/* File:      flrcompiler.P  -- The Flora Compiler
**
** Author(s): Guizhen Yang, Michael Kifer
**
** Contact:   see  CONTACTS.txt
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2023;
**      Coherent Knowledge Systems, LLC, 2014-2023;
**      and Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


/*
    TODO
        Many terms are compiled differently depending on whether they are
        in insert/delete or not. As a result,
        ?- insert{p(${foo})}.
        cannot be undone by
        ?- ?x ~ p(${foo}), delete{?x}.
        and
        ?- ?x ~ p(${foo}), insert{?x}.
        cannot be undone by
        ?- delete{p(${foo})}.

    Need to fix that.
*/

%% NOTE: MUST have flrregistry: and machine: prefixes here.
%% Otherwise XSB will think usermod!
:- if('NOWARN'(
       (flrregistry:flora_configuration(installdir,FlrDir),
        machine:slash(S),
        fmt_write_string(Opt,'%s%sopt%soptcompile.P',arg(FlrDir,S,S)),
        %% opt/opt.switch.off turns off the optimization
        fmt_write_string(OptOff,'%s%sopt%sopt.switch.off',arg(FlrDir,S,S)),
        \+file_exists(OptOff),
        file_exists(Opt)
       )
      )).
:- compiler_options([xpp_on(gpp,optcompile)]).
:- else.
:- compiler_options([xpp_on]).
:- endif.

#mode standard Prolog


%%#define SHOW_COMPILE_INPUT
%%#define SHOW_COMPILE_OUTPUT
%%#define SHOW_COMPILE_ADD_INPUT
%%#define SHOW_COMPILE_ADD_OUTPUT

#include "standard.h"
#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"
#include "flora_status_codes.flh"
#include "flora_characters.flh"
#include "flora_contexts.flh"

%% flrcompile_redefinitions
is_flstealthlit(FLSTEALTHLIT(Lit),Lit).
stealth_code(HeadCode,HeadCode1) :-
	generate_prolog_liblit(WRAP_STEALTHLIT,1,[HeadCode],HeadCode1).

#define NEWVAR	        	 newvar
#define NEWDONTCAREVAR	       	 newdontcarevar
#define NEWQUANTIFIEDVAR       	 newquantvar
#define NEWFLCONTEXTVAR	       	 newcontextvar
#define SKOLEMSYMVAR	       	 skolemsymvar
#define NEWUDFPREDVAR	         newudfpredvar
#define NEWPREDICATE_COUNTER   	 '_$$''''global_newpredicate_counter'
#define NEWPREDICATE_SYM       	 '_$$''''newpredicate'
#define NEWOID                   FL_NEWOID_SYM
#define NEWOID_GLOBAL            FL_NEWOID_GLOBAL_SYM
#define RULE_NUM                 rule_num
#define DEFAULT_RULE_ID          '_$$''''default_ruleid'
#define TMPDIRECT                tmpdirect
#define NEWOID_COUNT        	 FL_NEWOID_PREFIX
#define LIBOPTION	         liboption
#define PERMAOPTION	         permaoption
#define PERSISTENTOPTION	 persistentoption
#define COMPILATION_CONTEXT	 compcontext
#define DYNRULE_VARLIST          dynrule_varlist

#define BODYLITERAL         	 1
#define HEADLITERAL         	 2

#define SETARGATTRIBUTE          flrsetargattr
#define CONTEXTATTRIBUTE         flrcontextattr

%% used in an error message
#define ERRLINE_NO               ' on line '

%% ruleoid is used for numbered anonymous oid generation
:- dynamic ruleoid(_,_,_).
:- index(ruleoid/3,0).
:- dynamic LIBOPTION(_,_).
:- index(LIBOPTION/2,trie).
%% do NOT use trie indexing for PERMAOPTION. We rely on duplicates
:- dynamic PERMAOPTION(_), PERSISTENTOPTION(_).
:- index(PERSISTENTOPTION/1,trie).

%%:- dynamic TMPDIRECT(_).

:- dynamic COMPILATION_CONTEXT/1, COMPILATION_CONTEXT/2.
:- index(COMPILATION_CONTEXT/1,trie).

:- dynamic DYNRULE_VARLIST(_,_).
:- index(DYNRULE_VARLIST/2,0).

:- dynamic nowarn_symbol(_,_,_,_,_).
:- dynamic symbol_warnings_flag(_).


/****************************************************************************
  utilities
****************************************************************************/
is_flrule(FLRULE(Head,Body),Head,Body).
is_flfact(FLFACT(Head),Head).
is_flquery(FLQUERY(Body),Body).
%% latent queries
is_fllatent_query(FLLATENTQUERY(Body),Body).
is_fldirective(FLDIRECTIVE(DirectList,I),DirectList,I).
is_flannotated_construct(FLANNOTATEDCONSTRUCT(Descriptor,MainPartOfRule),Descriptor,MainPartOfRule).
is_fludfdef(FLUDF(Function,Body,ReturnValue),Function,Body,ReturnValue).
is_fludfdef_fact(FLUDFFACT(Function,Value),Function,Value).
%% udfdef_struct causes flrcoder.P to record UDF definitions in the registry
%% so that we could abolish all new_udf_predicate_XXX on reloading modules. This
%% is done in flora_cleanup_udf/1, which is called from flrutils:flora_flload/2
udfdef_struct(Name,N,UDFCode,PredName,PredCode,PRUDFDEFINITION(Name,N,UDFCode,PredName,PredCode)).
%% records that there was a useudf directive
useudf_struct(Fun/Arity/Idx,PRUSEUDF(Fun,Arity,File,Line)) :-
	code_line_and_file_by_index(Idx,Line,File).

is_fludfsymbol(FLUDFSYM(ParserTerm),ParserTerm).
is_flsensorsymbol(FLSENSORSYM(ParserTerm),ParserTerm).
is_flprlgsymbol(FLPRLGSYM(ParserTerm),ParserTerm).

is_fldescriptor(FLDESCRIPTOR(IdConstruct,Type,Index),IdConstruct,Type,Index).

is_flexport_list(FLEXPORT_LIST(Term),Term).
is_flexport(FLEXPORT(Term,Modules,IsUpdatable),Term,Modules,IsUpdatable).
is_flexport(FLEXPORT(DynamicModule,Term,Modules,IsUpdatable),DynamicModule,Term,Modules,IsUpdatable).

is_fldynrule(FLDYNRULE(Head,Body,DescriptorList),Head,Body,DescriptorList).

is_flopdef(FLOPDEF(P,A,O),P,A,O).
is_flprolog_directive(FLPROLOG(List,Idx),List,Idx).
is_flindex(FLINDEX(A,P),A,P).
is_fltabledirect(FLTABLE(List,Idx),List,Idx).
is_flnontabled_module(FLNONTABLEDMOD).
is_flnontabled_data_module(FLNONTABLEDDATAMOD).
is_flsensordirect(FLSENSOR(SensCall,DelayCond),SensCall,DelayCond).
is_flusesensordirect(FLUSESENSOR(List,Idx),List,Idx).
is_fluseudf_direct(FLUSEFUNCTION(List,Idx),List,Idx).
is_flsemantics(FLSEMANTICS(A),A).
is_flsetsemantics(FLSETSEMANTICS(A),A).
is_flsetruntime(FLSETRUNTIME(A),A).
is_flcmpopt(FLCMPOPT(OptList),OptList).

is_flstopdelay(FLSTOPDELAY(Vars,I),Vars,I).
is_flstopdelay(FLSTOPDELAY(I),I).

is_fldefeasible(FLDEFEASIBLE(Module),Module).

is_fldefeasible_rule_default(FLDEFEASIBLE_RULE_DEFAULT).
is_flstrict_rule_default(FLSTRICT_RULE_DEFAULT).

is_verbatim(FLVERBATIM(Instruction),Instruction).

is_encoding(FLENCODINGDIRECT(Encoding),Encoding).

is_new_global_oid_scope(FLNEW_GLOBAL_OIDSCOPE).
is_suppress_rulesigns(FLSUPPRESS_RULESIGNS).

%% Locality: global/local - whether the IRI prefix is local or global
is_flprefixdef(FLPREFIXDEF(PrefixName,Locality,PrefixStr),PrefixName,Locality,PrefixStr).

is_importmodule(FLIMPORTMOD(Module),Module).

is_flignoredep(FLIGNOREDEP(PredList),PredList).

is_flsymbolcontext(FLSYMBOLCONTEXT(PredList),PredList).

is_flconjunct(FLCONJUNCT(L,R),L,R).
is_fldisjunct(FLDISJUNCT(L,R),L,R).

is_flneg(FLNEG(Goal,Idx),Goal,Idx).
is_flplgnaf(FLPLGNAF(Goal),Goal).
is_flrulelognaf(FLRULELOGNAF(Goal),Goal).
is_default_negation(FLPLGNAF(Goal),Goal,FL_PLGNAF).
is_default_negation(FLRULELOGNAF(Goal),Goal,FL_RULELOGNAF).

is_fllogicquantifier(FLQUANTIFIER(Quant,VarNames,VarsCode,FormulaCode,Idx),
		     Quant,VarNames,VarsCode,FormulaCode,Idx).
is_fldelayquant(FLDELAYQUANTIFIER(Quant,Condition,Goal,Index),
		Quant,Condition,Goal,Index).


is_flhypothetical(FLHYPOTHETICAL(Op,Goal,Index),Op,Goal,Index).

is_flload(FLLOAD(LoadList),LoadList).
is_fladd(FLADD(LoadList),LoadList).
%% FLADDNEW - like FLADD, but file is not added to the module
%% if it was added before, EVEN if the module was modified.
%% This exists to work around the low time resolution in XSB for file modtimes.
%% Because the resolution is in seconds, it is possible that file mod time
%% and its add-time are the same even though the add happened later.
%% In such a case, FLADD will still re-add the file even though it should not
%% have done so. FLADDNEW will not re-add in such a situation.
is_fladdnew(FLADDNEW(LoadList),LoadList).

is_flconstraint(FLCONSTRAINT(ConstrBody),ConstrBody).

is_flemptyterm(FLEMPTYTERM(_Index)).

%% @module
is_flworkspace(FLWORKSPACE(P,WS),P,WS).
%% (dynrule)@module
is_flruleworkspace(FLRULEWORKSPACE(R,WS),R,WS).

detach_flworkspace(ParserTerm,ParserTermSansWS,WS) :-
	is_flworkspace(ParserTerm,ParserTermSansWS,WS),
	!.
detach_flworkspace(ParserTerm,ParserTermSansWS,WS) :-
	is_flruleworkspace(ParserTerm,ParserTermSansWS,WS),
	!.
detach_flworkspace(ParserTerm,ParserTerm,FL_THISMODULE).

%% P@\M - Flora system module
is_flfloralib(FLFLORALIB(P,M),P,M).
%% \M - the workspace by itself
is_flfloralib(FLFLORALIB(Mod), Mod).

%% @\prolog(M) and @\prolog
is_flplib(FLPLIB(P,M),P,M).
is_flplib(FLPLIB(P),P).
flplib_struct(Goal,FLPLIB(Goal)).       %% from the parser
%% @\prologall and @\prologall(module)
%% Make sure the coder writes P2H_PREDICATE/4 as prolog
is_flpliball(FLPLIBALL(P),P).
is_flpliball(FLPLIBALL(P,M),P,M).
/*
is_flpliball(FLPLIBALL(P),P) :- flora_define_prolog(P2H_PREDICATE,4).
is_flpliball(FLPLIBALL(P,M),P,M) :- flora_define_prolog(P2H_PREDICATE,4).
*/

is_flifthenelse(FLIFTHENELSE(Cond,Then,Else),Cond,Then,Else).
is_flifthen(FLIFTHEN(Cond,Then),Cond,Then).

%%is_flsetarg(FLSETARG(Term,Idx),Term,Idx).

%% Meta ~
is_fluniveqform(FLUNIVEQFORM(Left,Right),Left,Right).
%% Meta =..
is_flmetauniv(FLMETAUNIV(Left,Right),Left,Right).
%% -->>: Prolog ->
is_flprologifthen(FLPROLOGIFTHEN(Left,Right),Left,Right).

is_reifyop(FLREIFYOP(Formula),Formula).

%% Control constructs while-do, while-loop, loop-until, do-until,unless-do
is_flcontrolconstruct(FLWHILEDO(Cond,Action),FLLIBWHILEDO,Cond,Action).
is_flcontrolconstruct(FLWHILELOOP(Cond,Action),FLLIBWHILELOOP,Cond,Action).
is_flcontrolconstruct(FLDOUNTIL(Cond,Action),FLLIBDOUNTIL,Cond,Action).
is_flcontrolconstruct(FLLOOPUNTIL(Cond,Action),FLLIBLOOPUNTIL,Cond,Action).
is_flcontrolconstruct(FLUNLESSDO(Cond,Action),FLLIBUNLESSDO,Cond,Action).

is_flterm(FLTERM(Funct,Arity,Args),Funct,Arity,Args).
/*
%%  unused
is_flterm(FLTERM(Funct,Arity,Args),Funct,Arity,Args) :-
	\+is_fltransactionalatom(Funct,_),
	\+is_fltransactionalterm(Funct,_,_,_),
	\+is_fltransactionalpredspec(Funct,_).
*/
is_fltransactionalterm(FLTRANSACTIONALTERM(Func,N,Args),Func,N,Args).
/*
%%  unused
is_fltransactionalterm(FLTERM(Term,Arity,Args),Funct,Arity,Args) :-
	is_fltransactionalpredspec(Term,Funct),
	!.
is_fltransactionalterm(FLTERM(Term,Arity,Args),Term,Arity,Args) :-
	is_fltransactionalterm(Term,_,_,_),
	!.
is_fltransactionalterm(FLTERM(F,Arity,Args),F,Arity,Args) :-
	is_fltransactionalatom(F,_).
*/

is_flterm_or_flatom(Term,Funct,Arity,Args) :-
	is_flterm(Term,Funct,Arity,Args),
	!.
is_flterm_or_flatom(Atom,Atom,0,[]) :-
	is_flatom(Atom,_).

is_flarith(FLARITH(Expr),Expr).

is_flinsert(FLINSERT(Op,List,Cond),Op,List,Cond).
is_flinsert(FLINSERT(Op,List),Op,List).
is_fldelete(FLDELETE(Op,List,Cond),Op,List,Cond).
is_fldelete(FLDELETE(Op,List),Op,List).

is_fltablerefresh(FLREFRESH(List),List).

is_fltruthvalue(FLTRUTHVALUE(Formula,Op),Formula,Op).

is_fltag_primitive(FLTAGPRIMITIVE(Descriptor,HeadList),Descriptor,HeadList).
is_flprefixprimitive(FLPREFIXPRIMITIVE(Prefix,Expansion,Module),Prefix,Expansion,Module).

is_flclause(FLCLAUSE(Head,Body),Head,Body).
is_flclause(FLCLAUSE(Mode,Head,Body),Mode,Head,Body).
is_flannotated_clause_stmt(FLANNOTATEDCLAUSE(Descriptor,Head,Body),Descriptor,Head,Body).
is_flannotated_clause_stmt(FLANNOTATEDCLAUSE(Descriptor,Mode,Head,Body),Descriptor,Mode,Head,Body).
is_flcallmetafacts(FLCALLMETAFACTS(MF,Idx),MF,Idx).

is_flcatch(FLCATCH(Goal,Error,Handler),Goal,Error,Handler).
is_flthrow(FLTHROW(Error),Error).
is_flp2h(FLP2H(Prolog,Hilog),Prolog,Hilog).

is_flcallermodule(FLCALLERMODULE(Op,Var),Op,Var).
%% Op needed for newmodule/erasemodule only because of its position information 
is_flnewmodule(FLNEWMODULE(Op,Module),Op,Module).
is_flerasemodule(FLERASEMODULE(Op,Module),Op,Module).
is_flupdaterule(FLUPDATERULE(Op,RuleList),Op,RuleList).

is_flsimpleprimitive(FLSIMPLEPRIMITIVE(PrimName,Args),PrimName,Args).

is_flaggregate(FLAGGREGATE(Op,V,GV,Sort,Goal),Op,V,GV,Sort,Goal).

%% Binary relationship, like : or ::
is_flbirelate(FLBIRELATE(Obj1,RelType,Obj2),Obj1,RelType,Obj2).
%% Represents object reference: O.M, O!M. Type is NONINHERITABLE/INHERITABLE
is_flobjref(FLOBJREF(Obj,Att,Type),Obj,Att,Type).

is_flobjspec(FLOBJSPEC(Obj,Spec,Type),Obj,Spec,Type).

%% Arrow represents the arrow type: ->, =>, ...
is_flmvdattspec(FLMVDATTSPEC(Att,Arrow,Val,Type),Att,Arrow,Val,Type).
is_flsigattspec(FLSIGATTSPEC(Att,Arrow,Val,Type),Att,Arrow,Val,Type).
is_flsigattconspec(FLSIGATTCONSPEC(Att,Constr,Arrow,Val,Type),Att,Constr,Arrow,Val,Type).
is_flsigconstr(FLSIGCONSTR(Lower,Upper),Lower,Upper).
is_flincattspec(FLINCATTSPEC(Att,RefType,Val,Type),Att,RefType,Val,Type).
is_fltolistattspec(FLTOLISTATTSPEC(Att,Arrow,Val,Type),Att,Arrow,Val,Type).
is_flboolsig(FLBOOLSIG(Att,Arrow,Type),Att,Arrow,Type).
is_fltransig(FLTRANSIG(Att,Arrow,Type),Att,Arrow,Type).

/*
%%  unused
is_fltranspec(FLTRANSPEC(QN,Type),Tran,Type) :- 
	is_fltransactionalpredspec(QN,Tran),
	!.
*/
is_fltranspec(FLTRANSPEC(Tran,Type),Tran,Type).

/*
%%  unused
is_fltranspec(FLMETHSPEC(Meth,Type),Tran,Type) :-
	is_fltransactionalpredspec(Meth,Tran),
	!.
is_fltranspec(FLMETHSPEC(QN,Type),QN,Type) :- 
	is_fltransactionalatom(QN,_),
	!.
is_fltranspec(FLMETHSPEC(QN,Type),QN,Type) :- 
	is_fltransactionalterm(QN,_,_,_),
	!.
*/

is_flmethspec(FLMETHSPEC(Meth,Type),Meth,Type).
/*
is_flmethspec(FLMETHSPEC(Meth,Type),Meth,Type) :-
	\+is_fltransactionalterm(Meth,_,_,_),
	\+is_fltransactionalpredspec(Meth,_),
	\+is_fltransactionalatom(Meth,_).
*/

/*
%%  unused
is_fltransactionalpredspec(FLTRANSACTIONALPREDSPEC(QN),QN).
*/

is_flobjeql(FLOBJEQL(O1,O2),O1,O2).
is_flcut(FLCUT(I),I).

%% constructs like O[X=Y], O[X>Y], O[!], O[true], O[false], are compiled as
%% X=Y, !, true, etc.
is_flpassthru(FLPASSTRU(O),O).
is_flpassthru(O,Ostripped,Fun,Arg1,Arg2) :-
        is_flpassthru(O,Ostripped),
        is_flterm(Ostripped,Fun,2,[Arg1,Arg2]),
        !.
is_flpassthru(O,Ostripped,Fun,Arg1,Arg2) :-
        is_flpassthru(O,Ostripped),
        is_fldelayedliteral(Ostripped,Fun,ArgsFlList),
        !,
        is_fllist(ArgsFlList,[Arg1,Arg2],_,_).
is_flpassthru(O,Ostripped,_Fun,Arg1,Arg2) :-
        is_flpassthru(O,Ostripped),
        is_other_passthru_literal(Ostripped,Arg1,Arg2).

is_other_passthru_literal(Lit,Arg1,Arg2) :-
        is_flworkspace(Lit,RealLit,_),
        is_flobjeql(RealLit,Arg1,Arg2),
        !.
is_other_passthru_literal(Lit,Arg1,Arg2) :-
        is_fluniveqform(Lit,Arg1,Arg2),
        !.
is_other_passthru_literal(Lit,Arg1,Arg2) :-
        is_flplgnaf(Lit,PosLit),
        is_fluniveqform(PosLit,Arg1,Arg2),
        !.


%% TODO:
%% seems like a duplicate of flora_get_flatomvar_name/2 imported from flrparser.
get_flatom_name(Atom,Name) :- is_flatom(Atom,Name), !.
get_flatom_name(Atom,Name) :- is_flbuiltin_identifier(Atom,Name), !.
get_flatom_name(Atom,Atom) :- atom(Atom).

is_fltransactionalatom(FLTRANSACTIONALATOM(Atom,_I),Atom).
%% transactional numbers are used only in :- index %arity-argument
is_fltransactionalnumber(FLTRANSACTIONALNUMBER(Number,_I),Number).
is_fltransactionalstring(FLTRANSACTIONALSTRING(String,_I),String).
%% is_fltrans_atomnumberstring/1
is_fltrans_atomnumberstring(FLTRANSACTIONALATOM(_,_)).
is_fltrans_atomnumberstring(FLTRANSACTIONALNUMBER(_,_)).
is_fltrans_atomnumberstring(FLTRANSACTIONALSTRING(_,_)).

%% basic building blocks
is_flatom(FLATOM(Atom,_I),Atom).
is_flatom(FLATOM(Atom,Index),Atom,Index).
%%is_flatom(FLATOM(Atom,_I),Atom) :- \+ is_fltransactionalatom(Atom,_).
%%is_flatom(FLATOM(Atom,Index),Atom,Index) :- \+ is_fltransactionalatom(Atom,_).
is_flnumber(FLNUMBER(Number,_I),Number).
is_flnumber(FLNUMBER(Number,I),Number,I).
is_flstring(FLSTRING(String,I),String,I).
is_flstring(FlCode,Str) :- is_flstring(FlCode,Str,_).
is_flcharlist(FLCHARLIST(String,I),String,I).

is_flatomnumberstringbuiltin(FLATOM(_Atm,_)).
%%is_flatomnumberstringbuiltin(FLATOM(Atm,_)) :- \+is_fltransactionalatom(Atm,_).
is_flatomnumberstringbuiltin(FLNUMBER(_,_)).
is_flatomnumberstringbuiltin(FLSTRING(_,_)).
is_flatomnumberstringbuiltin(FLCHARLIST(_,_)).
is_flatomnumberstringbuiltin(FLBUILTIN_IDENTIFIER(_,_)).

is_fltoken(FLTOKEN(Token,I),Token,I).
%% this can be \#Number or \?Letter or \@!
is_fltoken(FLTOKEN(Token,Suffix,I),Token,Suffix,I).
%% is_fltoken/1
is_fltoken(FLTOKEN(_,_)).
is_fltoken(FLTOKEN(_,_,_)).

is_fldatatype(FLDATATYPE(Sort,Literal,Index),Sort,Literal,Index).
is_fltransactionaldatatype(FLTRANSACTIONALPREDSPEC(FLDATATYPE(Sort,Literal,Index)),Sort,Literal,Index).
is_fldatatypelist(DTListVal,List) :-
        nonvar(DTListVal),
        DTListVal = FLDATATYPELIST(List).


is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,_I),Builtin).
is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,I),Builtin,I).

is_flvariable(FLVAR(Name,Index),Name,Index).
is_anonymous_flvariable(FLVAR(FL_ANON_VAR,I),I).
is_fltransactionalvariable(FLTRANSACTIONALVAR(Name,Index),Name,Index).

is_silent_var_name(VarName) :- flratom_char_code(VarName,0,CH_ANON_VAR).

%% for speed
is_any_flvar(FLVAR(Name,Index),Name,Index).
is_any_flvar(FLTRANSACTIONALVAR(Name,Index),Name,Index).
is_any_prvar(PRVARIABLE(Name,Index),Name,Index).
is_any_prvar(PRTRANSACTIONALVARIABLE(Name,Index),Name,Index).
is_any_var(Var,Name,Index) :- is_any_flvar(Var,Name,Index), !.
is_any_var(Var,Name,Index) :- is_any_prvar(Var,Name,Index).

is_fllist(FLLIST(L,T,I),L,T,I).

is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args),Op,Args).
is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args,Mod),Op,Args,Mod).

is_isaspecop(FL_ISA).
is_subspecop(FL_SUB).
is_mvdspecop(FL_MVDARROW).


is_fltermdescriptor(FLTERMDESCRIPTOR(Funct,Arity),Funct,N) :-
	is_flnumber(Arity,N),
	!.
is_fltermdescriptor(FLTERMDESCRIPTOR(Funct,Arity),Funct,FL_STAR) :-
	is_anonymous_flvariable(Arity,_Idx),!.
is_fltransactionaltermdescriptor(FLTRANSACTIONALTERMDESCRIPTOR(Funct,Arity),Funct,N) :-
	is_flnumber(Arity,N),
	!.
is_fltransactionaltermdescriptor(FLTRANSACTIONALTERMDESCRIPTOR(Funct,Arity),Funct,FL_STAR) :-
	is_anonymous_flvariable(Arity,_Idx).
/****************************************************************************
  approx_flindex(+ParserTerm,-Index)

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_flindex(FLATOM(_Atom,I),II)              :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTRANSACTIONALATOM(_Atom,I),II) :- !,
	extract_real_token_number(I,II).
approx_flindex(FLBUILTIN_IDENTIFIER(_Id,I),II)  :- !,
	extract_real_token_number(I,II).
approx_flindex(FLDATATYPE(_Type,_Sort,I),II)    :- !,
	extract_real_token_number(I,II).
approx_flindex(FLNUMBER(_Number,I),II)          :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTRANSACTIONALNUMBER(_N,I),II)  :- !,
	extract_real_token_number(I,II).
approx_flindex(FLSTRING(_String,I),II)          :- !,
	extract_real_token_number(I,II).
approx_flindex(FLCHARLIST(_String,I),II)          :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTRANSACTIONALSTRING(_S,I),II)  :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTOKEN(_Token,I),II)            :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTOKEN(_Token,_Suffix,I),II)    :- !,
	extract_real_token_number(I,II).
approx_flindex(FLVAR(_Name,I),II)               :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTRANSACTIONALVAR(_Var,I),II)   :- !,
	extract_real_token_number(I,II).
approx_flindex(FLLIST(List,_T,I),J)  :- !,
	extract_real_token_number(I,II),
	(II>0 -> J=II; approx_flindex(List,J)).
approx_flindex(FLTERM(F,_,_),I)                :- !, approx_flindex(F,I).
approx_flindex(FLTRANSACTIONALTERM(F,_,_),I)   :- !, approx_flindex(F,I).

approx_flindex(FLBIRELATE(Obj1,_Rel,_O),I)  :- !, approx_flindex(Obj1,I).
approx_flindex(FLOBJREF(Obj,_Ref,_Att),I)   :- !, approx_flindex(Obj,I).
approx_flindex(FLOBJSPEC(Obj,_Spec,_T),I)      :- !, approx_flindex(Obj,I).
approx_flindex(FLMETHSPEC(Meth,_T),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLTRANSPEC(Meth,_T),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLBOOLSIG(Att,_,_T),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLTRANSIG(Att,_,_T),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLMVDATTSPEC(Att,_,_,_T),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTSPEC(Att,_,_,_T),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTCONSPEC(A,_,_,_,_T),I)  :- !, approx_flindex(A,I).
approx_flindex(FLINCATTSPEC(Att,_,_,_T),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLTOLISTATTSPEC(Att,_,_,_T),I)  :- !, approx_flindex(Att,I).
approx_flindex(FLOBJEQL(Obj,_),I)           :- !, approx_flindex(Obj,I).

approx_flindex([Obj|_],I)                   :- !, approx_flindex(Obj,I).

approx_flindex(FLIFTHEN(Cond,_Then),I)      :- !, approx_flindex(Cond,I).
approx_flindex(FLIFTHENELSE(Cond,_,_),I)    :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILEDO(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILELOOP(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLDOUNTIL(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLLOOPUNTIL(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLUNLESSDO(Cond,_),I)        :- !, approx_flindex(Cond,I).

approx_flindex(FLCONJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLDISJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLRULE(Head,_),I)            :- !, approx_flindex(Head,I).
approx_flindex(FLDYNRULE(Head,_,_),I)       :- !, approx_flindex(Head,I).
approx_flindex(FLUPDATERULE(Op,Rule),I)     :-
	!,
	(approx_flindex(Op,I), I>0 -> true
	; approx_flindex(Rule,I)
	).
approx_flindex(FLFACT(Head),I)              :- !, approx_flindex(Head,I).
approx_flindex(FLQUERY(Body),I)             :- !, approx_flindex(Body,I).
approx_flindex(FLDIRECTIVE(_Dir,I),II)       :- !,
	extract_real_token_number(I,II).
approx_flindex(FLTAGPRIMITIVE(Labl,_),I)    :- !, approx_flindex(Labl,I).

approx_flindex(FLANNOTATEDCLAUSE(_,_,H,_),I)   :- !, approx_flindex(H,I).
approx_flindex(FLANNOTATEDCLAUSE(_,H,_),I)     :- !, approx_flindex(H,I).
approx_flindex(FLCLAUSE(_,Head,_),I)        :- !, approx_flindex(Head,I).
approx_flindex(FLCLAUSE(Head,_),I)          :- !, approx_flindex(Head,I).
approx_flindex(FLUNIVEQFORM(Left,_),I)      :- !, approx_flindex(Left,I).
approx_flindex(FLMETAUNIV(Left,_),I)        :- !, approx_flindex(Left,I).
approx_flindex(FLAGGREGATE(Op,_,_,_),I)     :- !, approx_flindex(Op,I).
approx_flindex(FLCONSTRAINT(C),I)           :- !, approx_flindex(C,I).
approx_flindex(FLANNOTATEDCONSTRUCT(Descr,_),I)  :- !, approx_flindex(Descr,I).
approx_flindex(FLDESCRIPTOR(_,_,I),II)       :- !,
	extract_real_token_number(I,II).
approx_flindex(FLCALLMETAFACTS(_,I),II)      :- !,
	extract_real_token_number(I,II).

approx_flindex(FLREIFYOP(Form),I)             :- !, approx_flindex(Form,I).
approx_flindex(FLTRUTHVALUE(Form,_),I)        :- !, approx_flindex(Form,I).
approx_flindex(FLPLIB(P,_M),I)                :- !, approx_flindex(P,I).
approx_flindex(FLPLIB(P),I)                   :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P,_M),I)             :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P),I)                :- !, approx_flindex(P,I).
approx_flindex(FLFLORALIB(P,_M),I)            :- !, approx_flindex(P,I).
approx_flindex(FLWORKSPACE(P,_WS),I)          :- !, approx_flindex(P,I).
approx_flindex(FLRULEWORKSPACE(P,_WS),I)      :- !, approx_flindex(P,I).
approx_flindex(FLCONSTRAINT(C),I)             :- !, approx_flindex(C,I).

approx_flindex(FLLATENTQUERY(C),I)            :- !, approx_flindex(C,I).
approx_flindex(FLSETARG(_,I),II)              :- !,
	extract_real_token_number(I,II).

approx_flindex(FLUDF(Fun,_,_),I)              :- !, approx_flindex(Fun,I).
approx_flindex(FLUDFFACT(Fun,_),I)            :- !, approx_flindex(Fun,I).

approx_flindex(FLINSERT(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLINSERT(Op,_List),I)          :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List),I)          :- !, approx_flindex(Op,I).

approx_flindex(FLLOAD(List),I)                :- !, approx_flindex(List,I).

approx_flindex(FLDELAYEDLITERAL(Op,_),I)      :- !, approx_flindex(Op,I).
approx_flindex(FLDELAYEDLITERAL(Op,_,_),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLRULELOGNAF(G),I)             :- !, approx_flindex(G,I).
approx_flindex(FLPLGNAF(G),I)                 :- !, approx_flindex(G,I).
approx_flindex(FLNEG(_G,I),II)                :- !,
	extract_real_token_number(I,II).
approx_flindex(FLQUANTIFIER(_Quant,_,_,I),II) :- !,
	extract_real_token_number(I,II).
approx_flindex(_,NO_INDEX)  :- !.


/****************************************************************************
  approx_prindex(+ParserTerm,-Index)

  Same as approx_flindex, but for compiled code

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_prindex(PRATOM(_Atom,I),II)                  :- !,
	extract_real_token_number(I,II).
approx_prindex(PRATOMLIT(_Atom,I),II)               :- !,
	extract_real_token_number(I,II).
approx_prindex(PRTRANSACTIONALATOMLIT(_Atom,I),II)  :- !,
	extract_real_token_number(I,II).
approx_prindex(PRBUILTIN_IDENTIFIER(_Id,I),II)      :- !,
	extract_real_token_number(I,II).
approx_prindex(PRNUMBER(_Number,I),II)              :- !,
	extract_real_token_number(I,II).
approx_prindex(PRTRANSACTIONALNUMBER(_N,I),II)      :- !,
	extract_real_token_number(I,II).
approx_prindex(PRSTRING(_String,I),II)              :- !,
	extract_real_token_number(I,II).
approx_prindex(PRVARIABLE(_Name,I),II)              :- !,
	extract_real_token_number(I,II).
approx_prindex(PRTRANSACTIONALVARIABLE(_Var,I),II)  :- !,
	extract_real_token_number(I,II).
approx_prindex(PRLIST(List,_T,I),II)  :-
	!,
	(extract_real_token_number(I,J),J\=NO_INDEX -> II=J
	; approx_prindex(List,II)
	).
approx_prindex(PRNEWOID(_,I),II)                    :- !,
	extract_real_token_number(I,II).
approx_prindex(PRCUT(I),II)                         :- !,
	extract_real_token_number(I,II).
approx_prindex(PRMODULARIZEDATOM(_Form,I),II)       :- !,
	extract_real_token_number(I,II).
approx_prindex(PRMODULARIZEDATOM(_Form,_,I),II)     :- !,
	extract_real_token_number(I,II).

approx_prindex(PRDATATYPE(_Type,_Sort,I),II)        :- !,
	extract_real_token_number(I,II).
approx_prindex(PRDATATYPELIST(Lit),I)              :- !, approx_prindex(Lit,I).

approx_prindex(PRTERM(F,_,Args),J)                    :- !,
	approx_prindex(F,I),
	(I\=NO_INDEX-> I=J ; approx_prindex(Args,J)).
approx_prindex(PRTERMLIT(F,_,Args),J)                 :- !,
	approx_prindex(F,I),
	(I\=NO_INDEX-> I=J ; approx_prindex(Args,J)).
approx_prindex(PRTRANSACTIONALTERMLIT(F,_,Args),J)    :- !,
	approx_prindex(F,I),
	(I\=NO_INDEX-> I=J ; approx_prindex(Args,J)).

approx_prindex(PRISA(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PRSUB(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PREXISTS(Obj,_),I)             :- !, approx_prindex(Obj,I).
approx_prindex(PRMVD(Obj,_,_,_),I)            :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVD(Obj,_,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDDEF(Obj,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDDEF(Obj,_,_),I)          :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIG(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIG(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIGDEF(Obj,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIGDEF(Obj,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCON(Obj,_,_,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCON(Obj,_,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCONDEF(Obj,_,_,_,_,_),I)  :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCONDEF(Obj,_,_,_,_,_),I) :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDTOLIST(Obj,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDTOLIST(Obj,_,_,_),I)     :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDINC(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDINC(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMETH(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRIMETH(Meth,_,_),I)           :- !, approx_prindex(Meth,I).
approx_prindex(PRTRAN(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRBOOLSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRIBOOLSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PRTRANSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRITRANSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PROBJEQL(Obj,_,_),I)           :- !, approx_prindex(Obj,I).

approx_prindex([Obj|_],I)                     :- !, approx_prindex(Obj,I).

approx_prindex(PRAND(First,Second),I)         :- !,
	(approx_prindex(First,I), I \= NO_INDEX -> true
	; approx_prindex(Second,I)).
approx_prindex(PROR(First,Second),I)          :- !,
	(approx_prindex(First,I), I \= NO_INDEX -> true
	; approx_prindex(Second,I)).
approx_prindex(PRBAND(First,Second),I)         :- !,
	(approx_prindex(First,I), I \= NO_INDEX -> true
	; approx_prindex(Second,I)).
approx_prindex(PRRULE(Head,_),I)              :- !, approx_prindex(Head,I).
approx_prindex(PRFACT(Head),I)                :- !, approx_prindex(Head,I).
approx_prindex(PRREIFY(F),I)                  :- !, approx_prindex(F,I).
approx_prindex(PRQUERY(Body),I)               :- !, approx_prindex(Body,I).
approx_prindex(PRDIRECTIVE(Direct),I)         :- !, approx_prindex(Direct,I).
approx_prindex(PRCONSTRAINT(C),I)             :- !, approx_prindex(C,I).

approx_prindex(FLORASYSLIB(NO_INDEX,_,_,Args),I) :- !, approx_prindex(Args,I).
approx_prindex(FLORASYSLIB(I,_,_,_),II)       :- !,
	extract_real_token_number(I,II).

approx_prindex(PROLOGTERM(F,_,Args),I)           :-
        (approx_prindex(F,I), I \== NO_INDEX -> true
        ; approx_prindex(Args,I)
        ),
        !.
approx_prindex(PROLOGTERM(F,_,Args,_),I)      :-
        (approx_prindex(F,I), I \== NO_INDEX -> true
        ; approx_prindex(Args,I)
        ),
        !.
approx_prindex(PROLOGLIBLIT(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRFLORALIB(P),I)               :- !, approx_prindex(P,I).
approx_prindex(PRFDBSTORAGE(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACE(P,_WS),I)          :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACETERM(WS),I)         :- !, approx_prindex(WS,I).

approx_prindex(PRRULELOGNAF(G),I)             :- !, approx_prindex(G,I).
approx_prindex(PRPLGNAF(G),I)                 :- !, approx_prindex(G,I).
approx_prindex(PRNEG(G),I)                    :- !, approx_prindex(G,I).
approx_prindex(PRQUANTIFIER(Form,_,_),I)      :- !, approx_prindex(Form,I).

approx_prindex(_G,NO_INDEX)  :- !.


/****************************************************************************
  encoding utilities
****************************************************************************/
rule_struct(Head,Body,PRRULE(Head,Body)).
fact_struct(Head,PRFACT(Head)).
query_struct(Goal,PRQUERY(Goal)).
directive_struct(Direct,PRDIRECTIVE(Direct)).

reify_struct(Formula,PRREIFY(Formula)) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX).

%% We use this import directive support mechanism for @\prolog(module)
%%import_struct(F,N,M,PRIMPORT(F,N,M)).
cmpopt_struct(OptList,PRCMPOPT(OptList)).
ignoredep_struct(SpecList,PRIGNOREDEP(SpecList)).

%%empty module list, all modules allowed
export_struct(TermList,Code) :-
	florasyslib_struct(_Index,FLLIBEXPORT,_N,[TermList],Code).

%% :- importmodule foo.
importmodule_struct(Module,PRIMPORTMOD(Module)).

defeasible_struct(Module,PRDEFEASIBLE(Module)).

verbatim_struct(Instruction,PRVERBATIM(Instruction)).
table_directive_struct(SpecList,PRTABLE(SpecList)).


/****************************************************************************
  conjunct_struct(+Goal1,+Goal2,-Code)
  disjunct_struct(+Goal1,+Goal2,-Code)
  strong_conjunct_struct(+Goal1,+Goal2,-Code)
  naf_struct_prolog(+Goal,-Code)
  naf_struct_flora(+PRGoal,+FreeVars,-Code)
  neg_struct(+Goal,+Idx,-Code,-Status)
  head_neg_struct(+Goal,+Idx,-Code,-Status)
****************************************************************************/
conjunct_struct(Goal1,Goal2,Goal2) :-
	%% NULL and FL_TRUE are both dummy code that is ignored
	ignore_var_null_true(Goal1),
	!.
conjunct_struct(Goal1,Goal2,Goal1) :-
	ignore_var_null_true(Goal2),
	!.
conjunct_struct(Goal1,Goal2,Result) :-
        conjunct_struct_plain(Goal1,Goal2,Result).
conjunct_struct_plain(Goal1,Goal2,PRAND(Goal1,Goal2)).

disjunct_struct(Goal1,Goal2,Goal2) :-
	%% NULL and FL_FALSE are both dummy code that is ignored
	ignore_var_null_false(Goal1),
	!.
disjunct_struct(Goal1,Goal2,Goal1) :-
	ignore_var_null_false(Goal2),
	!.
disjunct_struct(Goal1,Goal2,PROR(Goal1,Goal2)).

%% strong_conjunct_struct/3 is like conjunct_struct/3, but the diff is
%% that NAF does not propagate through strong conjunction
strong_conjunct_struct(Goal1,Goal2,Goal2) :-
	%% NULL and FL_TRUE are both dummy code that is ignored
	ignore_var_null_true(Goal1),
	!.
strong_conjunct_struct(Goal1,Goal2,Goal1) :-
	ignore_var_null_true(Goal2),
	!.
%% NAF does not propagate through PRBAND
strong_conjunct_struct(Goal1,Goal2,PRBAND(Goal1,Goal2)).

%% Var also gets ignored by this
ignore_var_null_true(NULL) :- !.
ignore_var_null_true(FL_TRUE) :- !.

%% Var also gets ignored by this
ignore_var_null_false(NULL) :-!.
ignore_var_null_false(FL_FALSE).

quantifier_struct(QuantifierType,FormCode,QuantVarObjs,FreVarObjs,
		  PRQUANTIFIER(QuantifierType,FormCode,QuantVarObjs,FreVarObjs)).
is_existentialquant(FL_EXISTS)    :- !.
is_existentialquant(FL_EXIST)     :- !.
%%is_universalquant(FL_FORALL)    :- !.

%% \+
naf_struct_prolog(Goal,PRPLGNAF(Goal)).
%% naf
pure_naf_struct_flora(Goal,FreeVars,PRRULELOGNAF(WrappedGoal,FreeVars,Line,CurrFileName)) :-
	code_line_and_file_by_prterm(Goal,Line,CurrFileName),
	modularized_pratom_struct(FL_TABLED_NAF_CALL,NO_INDEX,FunCode),
	prologterm_struct(FunCode,1,[Goal],WrappedGoal).

%% We should optimize this: If FreeVars list is empty,don't delay!!
naf_struct_flora(Goal,FreeVars,Code) :-
	%% must stop delaying before applying NAF!
	(is_florasyslib_struct(Goal, Index,LibType,_N,Args),
	    (LibType == FLLIBMODLIT ; LibType == FLNEGLIBMODLIT)
	%% If it is compiled into a LIBMODLIT/3, replace with LIBMODOBJ
	->
	    convert_FLLIBMODLIT_to_FLLIBMODOBJ(LibType,Index,Args,GoalCode,LibModObjCode)
	;
	    LibModObjCode = NULL,
	    GoalCode = Goal
	),
	delay_checking_code_for_rulelog_naf(Goal,DelayCheckCode),
	conjunct_struct(GoalCode,DelayCheckCode,FullGoal),
	pure_naf_struct_flora(FullGoal,FreeVars,PureNAFcode),
	%% delay default negation
	delay_naf_struct(PureNAFcode,DelayCode),
	conjunct_struct(LibModObjCode,DelayCode,Code).

extract_goal_from_prrulelognaf(NafStruct,Goal) :-
	extract_goal_from_prrulelognaf(NafStruct,Goal,_,_,_,_).

%% the reversible version of extract_goal_from_prrulelognaf
extract_goal_from_prrulelognaf(NafStruct,Goal,FreeVars,DelayChecker,Line,File) :-
        is_delay_naf_struct(NafStruct,NafStructSansDelay),
	is_prrulelognaf(NafStructSansDelay,WrappedNafStruct,FreeVars,Line,File),
	modularized_pratom_struct(FL_TABLED_NAF_CALL,NO_INDEX,FunCode),
	is_prologterm(WrappedNafStruct,FunCode,1,[UnwrappedNafStruct]),
	is_prconjunct(UnwrappedNafStruct,Goal,DelayChecker).

is_delay_naf_struct(DelayStruct,NAFCode) :-
	is_prologterm(DelayStruct,FLLIBNAFDELAY,1,[NAFCode]).

%% delay struct
delay_struct(Index,DelayOp,Args,Code) :-
	code_line_and_file_by_index(Index,Line,CurrFileName),
	list_struct(Args,[],CodeList),
	(is_flvariable(Line,LineVarName,LineIdx) ->
	  varobj_struct(LineVarName,LineIdx,LineCode)
	; LineCode = Line
	),
	(is_flvariable(CurrFileName,CurrFileNameVarName,CurrFileNameIdx) ->
	  varobj_struct(CurrFileNameVarName,CurrFileNameIdx,CurrFileNameCode)
	; CurrFileNameCode = CurrFileName
	),
	%% this never gives out errors, so no need for file/nline args
	prologterm_struct(FLLIBDELAYEDLITERAL,4,
			  [DelayOp,CurrFileNameCode,LineCode,CodeList],
			  Code).

delay_defeat_struct(Index,DefeatCond,Headvars,HeadvarNames,DynHead,Code) :-
	code_line_and_file_by_index(Index,Line,CurrFileName),
	prologterm_struct(FLLIBDEFEATDELAY,6,
			  [CurrFileName,Line,
			   DefeatCond,DynHead,
			   Headvars,HeadvarNames],
			  Code).

delay_naf_struct(PureNAFcode,Code) :-
	prologterm_struct(FLLIBNAFDELAY,1,[PureNAFcode],Code).

%% propagate_rulelog_naf(+Goal,+FreeVars,-Code)
%% propagates NAF through connectives
%% These are mostly used because to_LT (in flrparser) currently does not 
%% propagate to if-then-else, while-do, structdb{...}, and some other primitives
propagate_rulelog_naf(PRAND(Goal1,Goal2),[],PROR(Code1,Code2)) :-
	!,
	%% if no free vars, can safely propagate
	propagate_rulelog_naf(Goal1,[],Code1),
	propagate_rulelog_naf(Goal2,[],Code2).
propagate_rulelog_naf(PRAND(Goal1,Goal2),FreeVars,Code) :-
	%% If Goal1,Goal2 have common free vars then don't propagate
        %% A similar precaution is taken in push_naf in the parser
	collect_prvars(Goal1,Goal1Vars),
	collect_prvars(Goal2,Goal2Vars),
	remove_prdontcare_and_FL_CONTEXT_vars(Goal1Vars,FreeGoal1Vars),
	vars_to_var_names(FreeGoal1Vars,FreeGoal1VarNames),
	remove_prdontcare_and_FL_CONTEXT_vars(Goal2Vars,FreeGoal2Vars),
	vars_to_var_names(FreeGoal2Vars,FreeGoal2VarNames),
	intersect(FreeGoal1VarNames,FreeGoal2VarNames,CommonFreeVarNames),
	CommonFreeVarNames \= [],
	!,
	is_prlist(FreeVars,FreeVarLst,_,_), %% FreeVars is a prlist/3
	subtract_varnames_from_vars(FreeVarLst,CommonFreeVarNames,RestFreeVars),
	list_struct(RestFreeVars,[],RestFreeVarsList),
	naf_struct_flora(PRAND(Goal1,Goal2),RestFreeVarsList,Code).
propagate_rulelog_naf(PRAND(Goal1,Goal2),FreeVars,PROR(Code1,Code2)) :-
	!,
	propagate_rulelog_naf(Goal1,FreeVars,Code1),
	propagate_rulelog_naf(Goal2,FreeVars,Code2).
propagate_rulelog_naf(PROR(Goal1,Goal2),FreeVars,PRAND(Code1,Code2)) :-
	!,
	propagate_rulelog_naf(Goal1,FreeVars,Code1),
	propagate_rulelog_naf(Goal2,FreeVars,Code2).
propagate_rulelog_naf(Goal,FreeVars,Code) :-
	is_florasyslib_struct(Goal,_Idx,FLLIBIFTHEN,_N,[_Mod,Cond,Then|_]),
	!,
	propagate_rulelog_naf(Then,FreeVars,ThenNaffed),
	conjunct_struct(Cond,ThenNaffed,Code).

propagate_rulelog_naf(Goal,FreeVars,Code) :-
	is_florasyslib_struct(Goal,_I,FLLIBIFTHENELSE,_,[_M,Cond,Then,Else|_]),
	!,
	propagate_rulelog_naf(Then,FreeVars,ThenNaffed),
	propagate_rulelog_naf(Else,FreeVars,ElseNaffed),
	conjunct_code([Cond,ThenNaffed,ElseNaffed],Code).

/*
%% The following propagations are done in the parser (to_LT/2)
propagate_rulelog_naf(Goal,_FreeVars,Code) :-
	is_delay_naf_struct(Goal,PRRuleLogNaf),
	!,
	extract_goal_from_prrulelognaf(PRRuleLogNaf,Code).

propagate_rulelog_naf(Goal,FreeVars,Code) :-
	is_prquantifier(Goal,Quantifier,Formula,_QuantVarLstObj,FreeVarListObj),
	!,
	(is_existentialquant(Quantifier) ->
	    naf_struct_flora(Goal,FreeVarListObj,Code)
	; propagate_rulelog_naf(Formula,FreeVars,Code)
	).
*/

%% catch-all: nothing left to propagate, including the case of PRBAND conjuncts
%% NAF does not propagate through strong conjunction PRBAND
propagate_rulelog_naf(Goal,FreeVars,Code) :-
	naf_struct_flora(Goal,FreeVars,Code).


%% neg_struct(+PRgoalIn,+Index,-PRgoalOut,-Status)
%% Propagation of neg inwards
neg_struct(PRAND(Goal1,Goal2),Idx,PRAND(Goal1,Struct2),Status) :-
	is_body_neg_passthrough_literal(Goal1),
	!,
	neg_struct(Goal2,Idx,Struct2,Status).
neg_struct(PRAND(Goal1,Goal2),Idx,PRAND(Struct1,Goal2),Status) :-
	is_body_neg_passthrough_literal(Goal2),
	!,
	neg_struct(Goal1,Idx,Struct1,Status).
%% unlike naf, neg can appear in the head
neg_struct(PRAND(Goal1,Goal2),Idx,PROR(Struct1,Struct2),Status) :-
	!,
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).

neg_struct(PRBAND(Goal1,Goal2),Idx,PRAND(Goal1,Struct2),Status) :-
	is_body_neg_passthrough_literal(Goal1),
	!,
	neg_struct(Goal2,Idx,Struct2,Status).
neg_struct(PRBAND(Goal1,Goal2),Idx,PRAND(Struct1,Goal2),Status) :-
	is_body_neg_passthrough_literal(Goal2),
	!,
	neg_struct(Goal1,Idx,Struct1,Status).
neg_struct(PRBAND(Goal1,Goal2),Idx,PROR(Struct1,Struct2),Status) :-
	!,
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).

neg_struct(PROR(Goal1,Goal2),Idx,PRAND(Struct1,Struct2),Status) :-
	!,
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).

neg_struct(Goal,Idx,Code,[]) :-
	is_prvariable(Goal),
	!,
	%% When variable is \neg-negated (inside a clause{...} etc)
	head_context_info_structure(FWContext),
	atomobj_struct(FL_INVALIDMODULE,Mod),
	florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,FWContext],Code).


/*
%% neg exists(Vars)^Goal -->  naf exists(Vars)^(naf neg Goal)
neg_struct(Goal,Idx,Code,Status) :-
	is_prquantifier(Goal,FL_EXISTS,FormCode,QuantVarObjs,FreeVars),
	!,
	is_prlist(QuantVarObjs,QuantVarL,_,ListIdx),
	is_prlist(FreeVars,FreeVarL,_,_),
	append(QuantVarL,FreeVarL,AllVars),
	list_struct(AllVars,[],ListIdx,AllVarsListObj),
	neg_struct(FormCode,Idx,NegFormCode,Status),
	(no_errors_found(Status) ->
	    propagate_rulelog_naf(NegFormCode,AllVarsListObj,Code1),
	    naf_struct_flora(Code1,FreeVars,Code)
	; true
	).

%% neg naf foo --> naf neg foo
neg_struct(Goal,Idx,OutGoal,Status) :-
	is_delay_naf_struct(Goal,PRRuleLogNaf),
	extract_goal_from_prrulelognaf(PRRuleLogNaf,PosGoal,_FreeVars,_DelayChecker,Line,File),
	(is_delay_naf_struct(PosGoal,PosGoalStripped),
	    extract_goal_from_prrulelognaf(PosGoalStripped,PosPosGoal,_,_,_,_)
	->  %% it is forall(...)^... translated as naf exists(...)^(naf ...)
	    %% so neg is pushed as just exists(...)^(neg ...)
	    %% (and exists is dropped)
	    neg_struct(PosPosGoal,Idx,OutGoal,Status)
	;   
	    %% this is just a naf goal, not a forall: push neg past naf
	    fail, %% don't allow to push neg past naf
	    %% The following code is unreachable; pushes NEG past NAF.
	    %% We DON'T want this as we want NEG FOO to always imply NAF FOO
	    neg_struct(PosGoal,Idx,NegPosGoal,Status),
	    %% applied in reverse: OutGoal1 is output
	    extract_goal_from_prrulelognaf(OutGoal1,NegPosGoal,_FreeVars,_DelayChecker,Line,File),
	    %% applied in reverse: OutGoal is output
	    is_delay_naf_struct(OutGoal,OutGoal1)
	),
	!.
*/

%% double negation
neg_struct(PRNEG(Goal),_Idx,Goal,[]) :- !.


/*
neg_struct(Goal,Idx,_,[Err]) :-
	is_unimplemented_neg_negatable_literal(Goal),
	!,
	compiling_error(Idx,UNIMPLEMENTED_NEG,Err).
*/
neg_struct(Goal,Idx,_,[Err]) :-
	\+is_body_neg_negatable_literal(Goal),
	!,
	approx_prindex(Goal,Idx2),
	(Idx2\==NO_INDEX -> RealIdx=Idx2
	; RealIdx=Idx
	),
	(workspace_struct(_,WS,Goal), floralib_struct(_,WS) ->
            compiling_error(RealIdx,ILLEGAL_NEGSYSLIB,Err)
	; compiling_error(RealIdx,ILLEGAL_NEGBODY,Err)
        ).

%% :- prolog predicate: workspaced and not
neg_struct(Goal,_Idx,Code,[]) :-
	(  workspace_struct(L,WS,Goal),
	    is_prologterm(L,Struct,Arity,Args),
	    is_modularized_pratom(Struct,Atom,Idx),
	    (is_pratom(WS,Mod,_) ; is_prbuiltin_identifier(WS,Mod,_))
	->
	    %% to check if this is a negatable prolog, reduce arity by 1:
	    %% modularized prolog has one extra FL_CONTEXT argument
	    Arity1 is Arity-1,
	    flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	    modularized_pratom_struct(NegAtm,Mod,Idx,FCode),
	    prologterm_struct(FCode,Arity,Args,Code)
	; is_prologterm(Goal,Struct,Arity,Args),
	    is_modularized_pratom(Struct,Atom,Idx)
	->
	    %% to check if this is a negatable prolog, reduce arity by 1:
	    %% modularized prolog has one extra FL_CONTEXT argument
	    Arity1 is Arity-1,
	    flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	    modularized_pratom_struct(NegAtm,Idx,FCode),
	    prologterm_struct(FCode,Arity,Args,Code)
	).

neg_struct(Goal,_Idx,Code,[]) :-
	(workspace_struct(PRNEG(L),WS,Goal)
	-> workspace_struct(L,WS,Code) % double negation
	;  workspace_struct(L,WS,Goal)
	-> workspace_struct(PRNEG(L),WS,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODLIT,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODOBJ,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODOBJ,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code)
	; is_prvariable(Goal,_VarName,Idx),
	    has_context(CONTEXT_COMPILER_GOAL_REIFICATION)
	-> % When variable is negated under ~, as in ?X ~ neg ?Y.
	    thismodule_struct(ThisModule),
	    body_context_info_structure(ThisModule,FWContext),
	    %% ...:-...,\neg ?X, is compiled into
	    %%    FLLIBMODLIT(neg_libmod_wrapper,X,FL_INVALIDMODULE,FWContext)
	    atomobj_struct(FL_INVALIDMODULE,Mod),
	    florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,FWContext],Code)
	;   Code = PRNEG(Goal)
	).

%% double negation
head_neg_struct(PRNEG(Goal),_Idx,Goal,NO_ERRORS) :- !.

head_neg_struct(Goal,Idx,Code,Status) :-
	%% Normally Goal is a single literal. It can also be a conjunction
	%% where the second conjunct is a cardinality constraint in a signature.
	%% In the latter case, the constraint is ignored.
	%% Any other conjunction is an error.
	is_prconjunct(Goal,Goal1,Goal2),
	ignorable_negated_head_conjunct(Goal2),
	!,
	head_neg_struct(Goal1,Idx,Code,Status).
	
head_neg_struct(Goal,Idx,Code,Status) :-
        is_prworkspace(Goal,L,WS),
	!,
	head_neg_struct(L,Idx,Code1,Status),
	( no_errors_found(Status) -> workspace_struct(Code1,WS,Code)
	;
	    true
	).

head_neg_struct(Goal,_Idx,NegGoal,[]) :-
	is_prologterm(Goal,Struct,Arity,Args),
	is_modularized_pratom(Struct,Atom,Idx),
	%% to check if this is a negatable prolog, reduce arity by 1:
	%% modularized prolog has one extra FL_CONTEXT argument
	Arity1 is Arity-1,
	flora_negatable_prlgdef(Atom,Arity1,NegAtom),
	modularized_pratom_struct(NegAtom,Idx,FCode),
	prologterm_struct(FCode,Arity,Args,NegGoal),
	!.

head_neg_struct(Goal,Idx,Code,[]) :-
	is_prvariable(Goal,_VarName,_Idx),
	!,
	%% When variable is \neg-negated (inside an update op)
	head_context_info_structure(FWContext),
	atomobj_struct(FL_INVALIDMODULE,Mod),
	florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,FWContext],Code).

head_neg_struct(Goal,_Idx,Code,[]) :-
	is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args),
	!,
	florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code).

%% normal case
head_neg_struct(Goal,_Idx,PRNEG(Goal),[]) :-
	is_head_neg_negatable_literal(Goal),
	!.

head_neg_struct(_Goal,Idx,_Code,[Err]) :-
	compiling_error(Idx,ILLEGAL_NEGHEAD,Err).


ignorable_negated_head_conjunct(Goal) :-
	%% PRMVDCONDEF and PRIMVDCONDEF occur only in rule heads
	(is_prmvdcondef(Goal) ; is_primvdcondef(Goal)),
	!.
ignorable_negated_head_conjunct(Goal) :-
	workspace_struct(L,_WS,Goal),
	ignorable_negated_head_conjunct(L).


/****************************************************************************
  conjunct_code(+GoalList,-Code)
  disjunct_code(+GoalList,-Code)

  Takes a list of goals and constructs a conjunct:
        prand(G1, prand(G2, G3))
     resp
        pror(G1, pror(G2, G3))
  Discards NULLs
  If all are NULLs, returns NULL.
****************************************************************************/
conjunct_code([],FL_TRUE) :- !.
conjunct_code([Goal],Goal) :- !.

conjunct_code([NULL|GList],ConjGoal) :- !, conjunct_code(GList,ConjGoal).
conjunct_code([FL_TRUE|GList],ConjGoal) :- !, conjunct_code(GList,ConjGoal).

conjunct_code([Goal|GList],ConjGoal) :-
	conjunct_code(GList,ConjGoalTail),
	!,
	( ConjGoalTail == NULL -> ConjGoal=Goal
	%% DON't include the case FL_TRUE here!
	;
	  conjunct_struct(Goal,ConjGoalTail,ConjGoal)
	).

/*
disjunct_code([],FL_FALSE) :- !.
disjunct_code([Goal],Goal) :- !.

disjunct_code([NULL|GList],ConjGoal) :- !, disjunct_code(GList,ConjGoal).
disjunct_code([FL_FALSE|GList],ConjGoal) :- !, disjunct_code(GList,ConjGoal).

disjunct_code([Goal|GList],ConjGoal) :-
	disjunct_code(GList,ConjGoalTail),
	!,
	( ConjGoalTail == NULL -> ConjGoal=Goal
	%% DON't include the case FL_FALSE here!
	;
	  disjunct_struct(Goal,ConjGoalTail,ConjGoal)
	).
*/


/****************************************************************************
  encoding routines

  Note: Only primitive structures (atoms, variables, numbers, strings, lists,
        newoids, and cuts) encode the index to the corresponding textual
        information. The compiler directives do not encode any textual
        information. However, not all primitive structures have a meaningful
        index, for instance, new variables that are generated for an oid
        reference. In this case, an index is approximated. In some other
        cases, an atom is generated to encode an internal structure. So there
        is no meaningful index. Then the macro NO_INDEX is encoded as a
        place holder. No textual information should be inferred from the
        NO_INDEX value.
****************************************************************************/
%% atomobj_struct/2
atomobj_struct(FLATOM(Atm,I),PRATOM(Atm,I)) :- !.
atomobj_struct(FLBUILTIN_IDENTIFIER(Atm,I),PRATOM(AtmReplacement,I)) :-
	flora_prlgdef_repl(Atm,0,AtmReplacement,usermod),
	!.
atomobj_struct(FLBUILTIN_IDENTIFIER(Atm,I),PRATOM(Atm,I)) :- !.
atomobj_struct(Atm,PRATOM(Atm,NO_INDEX)) :- atomic(Atm).
%% atomobj_struct/3
atomobj_struct(Atm,Index,PRATOM(Atm,Index)).

%% plgatomobj_struct/3: like atomobj_struct/2 but for Prolog terms with modules
plgatomobj_struct(FLATOM(Atm,I),Module,PRATOM(Atm,Module,I)).
plgatomobj_struct(FLBUILTIN_IDENTIFIER(Atm,I),Module,PRATOM(AtmReplacement,Module,I)) :-
	flora_prlgdef_repl(Atm,0,AtmReplacement,usermod),
	!.
plgatomobj_struct(FLBUILTIN_IDENTIFIER(Atm,I),Module,PRATOM(Atm,Module,I)) :- !.

%% A prolog atom that has FLORA-2 prefix and workspace in it.
%% This one is for THIS_WORKSPACE
%% modularized_pratom_struct/3
modularized_pratom_struct(Atom,Idx,PRMODULARIZEDATOM(PRDYNMODATOM(Atom),Idx)) :-
	has_context(CONTEXT_COMPILER_FOR_ADDITION),
	has_context(CONTEXT_COMPILER_HEADLITERAL),
	\+has_context(CONTEXT_COMPILER_UDF_DEFINITION),
	\+has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	!.
modularized_pratom_struct(Atom,Idx,PRMODULARIZEDATOM(Atom,Idx)).
%%  Mod is expected to be an atom
%% modularized_pratom_struct/4
modularized_pratom_struct(Atom,Mod,Idx,PRMODULARIZEDATOM(PRDYNMODATOM(Atom),Mod,Idx)) :-
	has_context(CONTEXT_COMPILER_FOR_ADDITION),
	has_context(CONTEXT_COMPILER_HEADLITERAL),
	\+has_context(CONTEXT_COMPILER_UDF_DEFINITION),
	\+has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	!.
modularized_pratom_struct(Atom,Mod,Idx,PRMODULARIZEDATOM(Atom,Mod,Idx)).

is_modularized_pratom(PRMODULARIZEDATOM(PRDYNMODATOM(Atom),Idx),Atom,Idx) :- !.
is_modularized_pratom(PRMODULARIZEDATOM(PRDYNMODATOM(Atom),_Mod,Idx),Atom,Idx) :- !.
is_modularized_pratom(PRMODULARIZEDATOM(Atom,Idx),Atom,Idx) :- !.
is_modularized_pratom(PRMODULARIZEDATOM(Atom,_Mod,Idx),Atom,Idx) :- !.

scrambled_atom_struct(Atom,Idx,Struct) :-
	flora_scramble_atom(Atom,ScrambledA),
	atomobj_struct(ScrambledA,Idx,Struct).

transactionalatomobj_struct(FLTRANSACTIONALATOM(Atom,I),PRATOM(Atom,I)) :- !.


atomlit_struct(_LitContext,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	atomobj_struct(Atom,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(LitContext,FLATOM(Atom,I),Code) :-
	flora_modular_prlgdef(Atom,0),
	!,
	splice_in_FL_CONTEXT_argument(LitContext,[],Args),
	modularized_pratom_struct(Atom,I,FunCode),
	prologterm_struct(FunCode,1,Args,Code).
atomlit_struct(_LitContext,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	atomobj_struct(Atom,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_LitContext,FLATOM(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	atomobj_struct(ReplacementAtm,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_LitContext,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(LitContext,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_modular_prlgdef(Atom,0),
	!,
	splice_in_FL_CONTEXT_argument(LitContext,[],Args),
	modularized_pratom_struct(Atom,I,FunCode),
	prologterm_struct(FunCode,1,Args,Code).
atomlit_struct(_LitContext,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_LitContext,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(ReplacementAtm,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(LitContext,FLATOM(Atom,I),PRATOMLIT([Atom,FWContext],I)) :-
	!,
	determine_context_info(LitContext,FWContext).
atomlit_struct(LitContext,FLBUILTIN_IDENTIFIER(Atom,I),PRATOMLIT([Atom,FWContext],I)) :-
	!,
	determine_context_info(LitContext,FWContext).
%% This is for the cases of an atomic literal like "abcd"^^foo
atomlit_struct(LitContext,Atomspec,PRATOMLIT([Atomspec,FWContext],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_context_info(LitContext,FWContext).

transactionalatomlit_struct(LitContext,FLTRANSACTIONALATOM(Atom,I),PRTRANSACTIONALATOMLIT([Atom,FWContext],I)) :-
	!,
	determine_context_info(LitContext,FWContext).
%% This is for the case of an atomic literal like %"abcd"^^foo
transactionalatomlit_struct(LitContext,Atomspec,PRTRANSACTIONALATOMLIT([Atomspec,FWContext],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_context_info(LitContext,FWContext).

numobj_struct(FLNUMBER(Number,I),PRNUMBER(Number,I)) :- !.
numobj_struct(Number,PRNUMBER(Number,NO_INDEX)) :- number(Number).
numobj_struct(Number,Idx,PRNUMBER(Number,Idx)) :- number(Number).

%% transactional numbers are used only in :- index %arity-argument
transactionalnumobj_struct(FLTRANSACTIONALNUMBER(Number,I),PRTRANSACTIONALNUMBER(Number,I)).

%% decompile prvar to flvar
prvar_to_flvar_struct(PRVARIABLE(Name,Index),FLVAR(Name,Index)).
%% decompile prvar list  to flvar list 
prvar_to_flvar_struct_list([], []) :- !.
prvar_to_flvar_struct_list([Var|Rest], [FlVar|FlRest]) :-
	prvar_to_flvar_struct(Var,FlVar),
	prvar_to_flvar_struct_list(Rest,FlRest).

flvar_struct_change_index(FLVAR(Name,_Index),FlIndex,FLVAR(Name,FlIndex)).

varobj_struct(FLVAR(FL_ANON_VAR,Index),VarObj) :-
        !,
        new_dontcare_prvariable(Index,VarObj).
varobj_struct(FLVAR(Name,Index),PRVARIABLE(Name,Index)) :- !.
varobj_struct(Name,VarObj) :- varobj_struct(Name,NO_INDEX,VarObj).
varobj_struct(FL_ANON_VAR,Index,VarObj) :-
        !,
        new_dontcare_prvariable(Index,VarObj).
varobj_struct(Name,Index,PRVARIABLE(Name,Index)).

transactionalvar_struct(Name,Index,PRTRANSACTIONALVARIABLE(Name,Index)).
transactionalstrobj_struct(FLTRANSACTIONALSTRING(String,I),PRSTRING(String,I)).

strobj_struct(FLSTRING(String,I),PRSTRING(String,I)).
strobj_struct(FLCHARLIST(String,I),PRSTRING(String,I)).

datatypeobj_struct(FLDATATYPE(Type,Lit,Idx),
		   Object,
		   VarBindingCode,
		   Status) :-
	!,
	compile_body_pathexp_top(Type,FL_THISMODULE,TypeCode,_,_,[],_),
	(
	/*
	%% Variable over a user-defined datatype
	%% UDTs are assumed to be classes, by convention: no special treatment
	; is_flvariable(Lit,VarName,VarIdx),
	    %% only the names that start with the udt prefix
	    is_pratom(TypeCode,TypeName,_),
	    flrprefixdef:FLLIBPREFIXPRIMITIVE(udt,UdtPrefix,_),
	    flora_match_substring(UdtPrefix,TypeName,0)
	->
	    add_underscore(VarName,InDataTypeVarName),
	    varobj_struct(InDataTypeVarName,VarIdx,LitCode),
	    Object = PRDATATYPE(TypeCode,LitCode,VarIdx),
	    VarBindingCode = NULL,
	    Status = NO_ERRORS
	*/
	%% Class-bound variable, date/time variable
	is_flvariable(Lit,VarName,VarIdx) ->
	  varobj_struct(VarName,VarIdx,DTVarCode),
	  Object = DTVarCode,
	  %% construct data type test: (NewVar,isa(NewVar,Class))
	  new_dontcare_prvariable(NO_INDEX,TestArgVar),
	  isaspec_struct(BODYLITERAL,TestArgVar,TypeCode,DTTesterCodePre),
	  conjunct_struct(TestArgVar,DTTesterCodePre,DTTesterCode),
	  %% put isa(_,Class) as the attr val of FL_DT_VAR
	  %% for the class variable
	  new_dontcare_prvariable(VarIdx,NewAttrVar),
	  attrvar_code(NewAttrVar,DTTesterCode,FL_DT_VAR,NewAttrVarCode),
	  %% construct DTVarCode=NewAttrVar
	  atomobj_struct(FL_UNIVEQ,UnivEQCode),
	  prologterm_struct(UnivEQCode,2,[DTVarCode,NewAttrVar],ConnectorLit),
	  %% VarBindingCode is the conjunction
	  %%     put_attr(NewAttrVar,FL_DT_VAR,is_list(_))
	  %%         /\ DTVarCode=NewAttrVar
	  conjunct_struct(NewAttrVarCode,ConnectorLit,VarBindingCode),
	  Status = NO_ERRORS
	%% list of data types
	; is_fldatatypelist(Lit,ListOfLits) ->
	  compile_datatype_list(ListOfLits,LitCode0,Status),
	  datatypelistobj_struct(LitCode0,LitCode),
	  VarBindingCode = NULL,
	  Object = PRDATATYPE(TypeCode,LitCode,Idx)
	; %% a non-variable, non-list data type
	  Object = PRDATATYPE(TypeCode,Lit,Idx),
	  VarBindingCode = NULL,
	  Status = NO_ERRORS
	).
datatypeobj_struct(FLTRANSACTIONALPREDSPEC(DTspec),Object,VarBindingCode,Status) :-
	!,
	datatypeobj_struct(DTspec,Object,VarBindingCode,Status).

datatypelistobj_struct(ListLit,PRDATATYPELIST(ListLit)).


builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Builtin,I),
			  PRBUILTIN_IDENTIFIER(Builtin,I)).

newoid_struct(Oid,Index,PRNEWOID(Oid,Index)).
cut_struct(Index,PRCUT(Index)).
special_variable_struct(Type,PRSPECIALVAR(Type)).

list_struct(List,Term,Index,PRLIST(List,Term,Index)).
list_struct(List,Term,PRLIST(List,Term,NO_INDEX)).

workspace_struct(P,WS,PRWORKSPACE(P,WS)).
thismodule_struct(PRTHISMODULE(PRTHISMODULE)).

workspaceterm_struct(WS,PRWORKSPACETERM(WSTerm)) :-
	compile_workspace_term(WS,WSTerm).

%% Compiles both user and system workspace terms
compile_workspace_term(FL_THISMODULE, CompiledWS) :-
	!,
	thismodule_struct(CompiledWS).
compile_workspace_term(WS, CompiledWS) :-
	(is_flatom(WS,_Atom,_I) -> atomobj_struct(WS,CompiledWS)
	; is_flvariable(WS,_Var,_I) -> varobj_struct(WS,CompiledWS)
	; is_fltoken(WS,FL_THISMODULE,_) -> thismodule_struct(CompiledWS)
	; is_flfloralib(WS,Mod) -> 
	    compile_workspace_term(Mod,WS1),
	    floralib_struct(WS1, CompiledWS) 
	; %% WS may come already compiled as a system workspace or as a var
	    (floralib_struct(_, WS) ; is_prvariable(WS))
	-> WS = CompiledWS
	; flora_error_line('[Compiler] BUG: Invalid workspace term, ~w', [WS]),
	    throw(FLORA_TOP_LEVEL)
	),
	!.

%% For dynamic rules - workspace of the rule: (rule)@WS
%% Otherwise - current module.
%% Used in rule BODIES
%% Used only in determine_context_info/2
%% FWContext: Flora-2 wrapper context. Used as the last arg of the wrappers.
%%            Represents this info: FL_CONTEXT(CallerMod,Id1,Id2)
%%            In the head: Id1=ThisRuleId, Id2=new context var.
%%            In the body: Id1= new context var, Id2=ThisRuleId.
body_context_info_structure(FWContext) :-
	has_context(dynruleworkspace(WSTerm)),
	!,
	body_context_info_structure(WSTerm,FWContext).
body_context_info_structure(FWContext) :-
	\+ has_context(CONTEXT_COMPILER_RULE_REIFICATION),
	(has_context(CONTEXT_COMPILER_GOAL_REIFICATION)
	%% 1) CONTEXT_COMPILER_STRING_COMMAND is set by
        %%    flora_string_command_line/4 in flrcallflora.P.
	%%    It is initialized in flora2.P.
	%%    Should NOT be initialized in initialize_compilation_contexts/0
        %% 2) It appears that commands compiled by flora_query MUST use
        %%    thismodule_struct(WSTerm), so we commented
        %%    CONTEXT_COMPILER_STRING_COMMAND below - was wrong to test
        %%    for CONTEXT_COMPILER_STRING_COMMAND before, as it would break
        %%    the test general_tests/justifier2_ergo.ergo (test3).
        %% 3) Comenting out CONTEXT_COMPILER_STRING_COMMAND seems to make
        %%    this context redundant.
	%%; has_context(CONTEXT_COMPILER_STRING_COMMAND)
	),
	!,
	%% With WSTerm = thismodule_struct instead of new_context_prvariable,
        %%    reification in the head doesn't unify with the body:
        %%    causes differences in callReified.flr, justifier_regwdemo.ergo
        %%    Need to find better differentiating tests.
	new_context_prvariable(NO_INDEX,WSTerm),
	%%thismodule_struct(WSTerm),  // see a comment above
	body_context_info_structure(WSTerm,FWContext).
body_context_info_structure(FWContext) :-
	thismodule_struct(WSTerm),
	!,
	body_context_info_structure(WSTerm,FWContext).

body_context_info_structure(CallerModule,FWContext) :-
	context_tracing_code(body,Id1,Id2),
	prologterm_struct(FL_CONTEXT,3,[CallerModule,Id1,Id2],FWContext).


%% FWContext: Flora-2 wrapper context. Used as the last arg of the wrappers.
%%            Represents this info: FL_CONTEXT(CallerMod,Id1,Id2)
%%            In the head: Id1=ThisRuleId, Id2=new context var.
%%            In the body: Id1= new context var, Id2=ThisRuleId.
head_context_info_structure(FWContext) :-
	%% In the head of dynamic rules
	has_context(CONTEXT_COMPILER_DYNRULE(_)),
	!,
	dyn_caller_module_var_struct(CallerModStruct),
	context_tracing_code(head,Id1,Id2),
	prologterm_struct(FL_CONTEXT,3,[CallerModStruct,Id1,Id2],FWContext).
%% In the HEAD of static rules
head_context_info_structure(FWContext) :-
	has_context(CONTEXT_COMPILER_FACTS),
	!,
	callermod_var_structure(CallerModStruct),
	context_tracing_code(head,Id1,Id2),
	prologterm_struct(FL_CONTEXT,3,[CallerModStruct,Id1,Id2],FWContextAttr),
	put_attr(FWContext,CONTEXTATTRIBUTE,FWContextAttr).
head_context_info_structure(FWContext) :-
	callermod_var_structure(CallerModStruct),
	context_tracing_code(head,Id1,Id2),
	prologterm_struct(FL_CONTEXT,3,[CallerModStruct,Id1,Id2],FWContext).

%% This is used when we want variables in the tracing part of FL_CONTEXT
var_context_info_structure(CallerModule,FWContext) :-
	context_tracing_code(vars,Id1,Id2),
	prologterm_struct(FL_CONTEXT,3,[CallerModule,Id1,Id2],FWContext).

callermod_var_structure(Struct) :-
	%% In the head of dynamic rules
	has_context(CONTEXT_COMPILER_DYNRULE(_)),
	!,
	dyn_caller_module_var_struct(Struct).
%% In the head of static rules
callermod_var_structure(Struct) :- caller_module_var_struct(Struct).

caller_module_var_struct(PRFLCONTEXTVAR(PRFLCONTEXTVAR)).
dyn_caller_module_var_struct(PRDYNFLCONTEXTVAR(PRDYNFLCONTEXTVAR)).
filename_in_ruleid_struct(PRFILENAMEINRULEIDVAR(PRFILENAMEINRULEIDVAR)).

%% LitContext =  head/body/vars
context_tracing_code(LitContext,Id1,Id2) :-
	(has_production_mode ->
	    %% Using constants (NULL) as Id1/Id2 saves choicepoint space somehow
	    %% (see the flora2-performance/wine_ontology/wine2.flr).
	    %% However, using new vars for Id1/Id2 makes it possible to mix
	    %% files compiled in production and development mode without
	    %% recompilation
	    %%atomobj_struct(NULL,Id1), Id2=Id1
	    new_context_prvariable(NO_INDEX,Id1),
	    new_context_prvariable(NO_INDEX,Id2)
	;
	    ( has_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)), LitContext\==vars,
		\+ has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
		\+ has_context(CONTEXT_COMPILER_UPDATE_LITERALS)
	    ; has_context(CONTEXT_COMPILER_RULE(DescrIdCode)), LitContext\==vars,
		\+ has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
		\+ has_context(CONTEXT_COMPILER_UPDATE_LITERALS)
	    ; %% LitContext = vars or isn't a rule, or is reification or update
		new_context_prvariable(NO_INDEX,DescrIdCode)
	    ),
	    !,
	    new_context_prvariable(NO_INDEX,CalledRuleVar),
	    (LitContext == body ->
		Id1 = CalledRuleVar, Id2 = DescrIdCode
	    ;
		Id1 = DescrIdCode, Id2 = CalledRuleVar
	    )
	).


thisstorage_struct(fdb,PRTHISFDBSTORAGE(PRTHISFDBSTORAGE)).
%% support for checking undefinedness
thisstorage_struct(fld,PRTHISFLDSTORAGE(PRTHISFLDSTORAGE)).

floralib_struct(WS,PRFLORALIB(WS)).
storage_struct(WS,PRFDBSTORAGE(WS)).

%% Construct FL_CONTEXT info for a literal.
%% Different caler info is created for body and head.
%% This form is used for cases when a literal can be both in the head and
%% in the body. In that case, LitContext is passed to tell which form to use.
%% When we know if we are in the head or in the body, we use
%% FWContext: Flora-2 wrapper context info: FL_CONTEXT(CallerMod,Id1,Id2),
%% where Id1, Id2 are tracing info rule Ids
%% body_context_info_structure/1 or head_context_info_structure/1 directly.
determine_context_info(BODYLITERAL,FWContext) :-
	!,
	body_context_info_structure(FWContext).
determine_context_info(HEADLITERAL,FWContext) :-
	!,
	head_context_info_structure(FWContext).
determine_context_info(LitContext,_FWContext) :-
	%% debug
	flora_error_line('[Compiler] BUG: No FL_CONTEXT can be constructed for this context, ~w', [LitContext]),
	throw(FLORA_TOP_LEVEL).

splice_in_FL_CONTEXT_argument(LitContext,Args,NewArgs) :-
	determine_context_info(LitContext,FWContext),
	%% TODO: see if we can get rid of flattening
	flatten([Args,FWContext],NewArgs).

%% special treatment of \overrides/2/4, \opposes/2/4, \cancel/1/2,
%% and stuff declared as :- prolog or :- table
termlit_struct(LitContext,FObj,N,ObjList,Code) :-
	(is_strict_pratom(FObj,AtomName,Idx)
	; is_prbuiltin_identifier(FObj,AtomName,Idx)
	),
	flora_modular_prlgdef(AtomName,N),
	!,
	splice_in_FL_CONTEXT_argument(LitContext,ObjList,Args),
	N1 is N+1,
	modularized_pratom_struct(AtomName,Idx,FunCode),
	prologterm_struct(FunCode,N1,Args,Code).

%% for things that have prolog name replacement
termlit_struct(_LitContext,FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	( has_permaoption(defsensor(AtomName,N)) ->
	    compile_sensor_literal(_,FObj,N,ObjList,Code)
	; has_permaoption(defsensor(AtomName,N,PrlgModName)) ->
	    compile_sensor_literal(PrlgModName,FObj,N,ObjList,Code)
	; has_permaoption(atomreplacement(AtomName,N,_)) ->
	    termlit_replacement(FObj,N,NewFObj),
	    prologterm_struct(NewFObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N) ->
	    %%termlit_replacement(FObj,N,NewFObj),
	    %%prologterm_struct(NewFObj,N,ObjList,Code)
	    prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	),
	!.
termlit_struct(_LitContext,FObj,N,ObjList,Code) :-
	is_strict_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(_LitContext,FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(LitContext,FObj,N,ObjList,PRTERMLIT(FObj,N1,Args)) :-
	splice_in_FL_CONTEXT_argument(LitContext,ObjList,Args),
	length(Args,N1),
	!,
	%% latent queries - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in termlit structure: Obj=~w, Arity=~w, Args=~w, LitContext=~w',
			   [FObj,N,ObjList,LitContext]),
	    throw(FLORA_TOP_LEVEL)
	).

transactionaltermlit_struct(LitContext,FObj,N,ObjList,PRTRANSACTIONALTERMLIT(FObj,N1,Args)) :-
	splice_in_FL_CONTEXT_argument(LitContext,ObjList,Args),
	length(Args,N1),
	!,
	%% latent queries - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in transactionaltermlit structure: Obj=~w, Arity=~w, Args=~w, LitContext=~w',
			   [FObj,N,ObjList,LitContext]),
	    throw(FLORA_TOP_LEVEL)
	).


caller_module_binding_code(Binding,Code) :-
	callermod_var_structure(CallerModVar),
	atomobj_struct(FL_SILENT_EQUAL,EqCode),
	prologterm_struct(EqCode,2,[CallerModVar,Binding],Code).


/*
is_prtermlit(PRTERMLIT(Obj,_,_),I) :- approx_prindex(Obj,I).
is_prtermlit(PRATOMLIT(_Obj,I),I).

is_prtransactionallit(PRTRANSACTIONALTERMLIT(O,_,_),I) :- approx_prindex(O,I).
is_prtransactionallit(PRTRANSACTIONALATOMLIT(_,I),I).
is_prtransactionallit(PRTRAN(_,Obj,_),I) :- approx_prindex(Obj,I).

has_prtransactionallit([],_) :- !, fail.
has_prtransactionallit([H|_],Idx) :-
	is_prtransactionallit(H,Idx),
	!.
has_prtransactionallit([_|Rest],Idx) :-
	has_prtransactionallit(Rest,Idx).
*/

has_prologlit([],_) :- !, fail.
has_prologlit([H|Rest],Idx) :-
	(is_prologterm(H,Atm,_) -> \+ is_modularized_pratom(Atm,_,_)
	; has_prologlit(Rest,Idx)
	),
	!.


/*
   attach_workspace(+InCode,+WS,-WSCode,-Status)

   Attaches workspace code to InCode. Takes into account various cases
   WSCode is where the final code is produced.
*/
attach_workspace(InCode,WS_in,WSCode,Status) :- 
	( compiling_flrshell_command, WS_in == FL_THISMODULE,
	    \+ has_context(CONTEXT_COMPILER_DESCRIPTORS(_)) ->
	    %% for the shell we want to check if :- prolog declarations were
	    %% imported, so we change WS so as WS == FL_THISMODULE will fail
	    is_flatom(WS,FLORA_DEFAULT_WORKSPACE,NO_INDEX)
	; WS = WS_in
	),
	(WS == FL_THISMODULE -> WSCode = InCode, Status = NO_ERRORS
	; is_modularizedprologterm(InCode) ->
	    workspacelit_struct(InCode,WS,WSCode,Status)
	;   is_prologterm(InCode,_,_) ->
	    %% If prolog term occurs under the scope of a FLORA-2 module, 
	    %% ignore the module
	    WSCode = InCode,
	    Status = NO_ERRORS
	; %% need to convert PRATOMLIT to modular prolog atom?
	    InCode = PRATOMLIT([Atom,FWContext],I),
	    is_flatom(WS,WSAtom,_),
	    flora_modular_prlgdef(Atom,0,WSAtom) ->
	    %% convert to modular prolog atom
	    modularized_pratom_struct(Atom,WSAtom,I,ModAtmCode),
	    prologterm_struct(ModAtmCode,1,[FWContext],WSCode),
	    Status = NO_ERRORS
	; %% need to convert PRTERMLIT to modular prolog term?
	    InCode = PRTERMLIT(FObj,Arity,Args),
	    is_flatom(WS,WSAtom,_),
	    (is_pratom(FObj,AtomName,Idx)
	    ; is_prbuiltin_identifier(FObj,AtomName,Idx)
	    ),
	    N is Arity-1,
	    flora_modular_prlgdef(AtomName,N,WSAtom) ->
	    %% convert to modular prolog term
	    modularized_pratom_struct(AtomName,WSAtom,Idx,FunCode),
	    prologterm_struct(FunCode,Arity,Args,WSCode),
	    Status = NO_ERRORS
	;
	    workspacelit_struct(InCode,WS,WSCode,Status)
	),
	!.

%% sometimes P might already be compiled and have a workspace.
%% Eg, if it came as head_neg_struct.
workspacelit_struct(P,_WS,Code,NO_ERRORS) :-
	is_prworkspace(P,_,_),
	!,
	Code = P.
workspacelit_struct(P,WS,Code,Status) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index)
	->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    body_context_info_structure(ThisModuleName,FWContext),
	    %% a call to a Flora user module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSVarCode,FWContext],Code),
	    Status = NO_ERRORS

	%% X@module or X@\module
        %% or %X@module or %X@\module
	; is_any_prvar(P,_,Index) ->
	    compile_workspace_term(WS,WSCode),
	    body_context_info_structure(ThisModuleName,FWContext),
	    %% a call to a module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSCode,FWContext],Code),
	    Status = NO_ERRORS

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Code),
	    Status = NO_ERRORS

	%%; (WS == FL_THISMODULE ; is_fltoken(WS,FL_THISMODULE,_)) ->
	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Code),
	    Status = NO_ERRORS
	;   %% Using ...@\?C 
	    %% This is currently unsupported. We need to pass OidCode out
	    %%  of this predicate, since this is what creates the code
	    %% to bind thecaller variable
	    is_fltoken(WS,FL_SPECIAL_VAR_TOKEN,FL_SPECIAL_CALLER_TOKEN,Idx) ->
	    %% CHANGE _OidCode/_Status to OidCode/Status once ...@\?C gets support
	    compile_pathexp_no_workspace(WS,WSCode,_OidCode,_,_,_Status),
	    body_context_info_structure(ThisModuleName,FWContext),
	    %% a call to a module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSCode,FWContext],Code),
	    %% temporary error until supported
	    compiling_error(Idx,ERROR_WSQUASI_VAR,Stat),
	    Status = [Stat]
	; is_prfloralib(WS,_,_) ->
	    %% a Flora system module
	    workspace_struct(P,WS,Code),
	    Status = NO_ERRORS
	;
	    (approx_flindex(WS,ErrIdx) ; approx_prindex(WS,ErrIdx)) ->
	    compiling_error(ErrIdx,ERROR_WSNAME,Stat),
	    Status = [Stat]
	),
	!.

%% This is used in situations where a workspace
%% term appears inside a predicate or a frame,
%% e.g., p(foo@?Mod) or a[b->foo@?Mod] or ?X = abc#cde@?Mod
%% or ?Pred@ws or ?Pred@?Mod
workspaceobj_struct(P,WS,Object,Code) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index) ->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    new_prvariable(Index,Object),
	    body_context_info_structure(ThisModuleName,FWContext),
	    %% code to construct the object for foo@X in arg position,
	    %% i.e., p(foo@X)
	    florasyslib_struct(Index,FLLIBMODOBJ,5,[FL_BODY,P,WSVarCode,FWContext,Object],Code)

	; is_prvariable(P,_,Index)
	->
	    compile_workspace_term(WS,WSCode),
	    new_prvariable(Index,Object),
	    body_context_info_structure(ThisModuleName,FWContext),
	    %% code to construct the object for X@... in arg position,
	    %% i.e., p(X@...)
	    florasyslib_struct(Index,FLLIBMODOBJ,5,[FL_BODY,P,WSCode,FWContext,Object],Code)

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL

	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL
	;
	  %% a Flora system module
	  Code=NULL,
	  workspace_struct(P,WS,Object)
	),
	!.

prologterm_struct(F,N,Args,PROLOGTERM(F,N,Args)).
%% This is used for prolog terms like goo(...)@\prolog(module)
%% when we encode them as module:goo. This is in addition to 
%% :- import goo from module. When XSB allows the notation foo:bar
%% in assert/retract, the :- module feature will be deprecated.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args)) :-
	var(Module),
	!.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args,ModuleCode)) :-
	atomobj_struct(Module,ModuleCode).

prologliblit_struct(PrologTerm,PROLOGLIBLIT(PrologTerm)).
is_prologliblit(PROLOGLIBLIT(PrologTerm),PrologTerm).

is_modularizedprologterm(Term) :-
	is_prologterm(Term,Fun,_N),
	is_modularized_pratom(Fun,_,_).

is_wsprologterm(Term) :-
        is_prworkspace(Term,BareTerm,_WS),
        is_prologterm(BareTerm,_,_).

prologterm_atom_arity(Term,Atom,Arity) :-
	is_prologterm(Term,Struct,Arity,_),
	is_modularized_pratom(Struct,Atom,_).
prologterm_atom_arity(Term,Atom,Arity) :- is_prologterm(Term,Atom,Arity).

flprologlib_atom_arity(ParserTerm,Atm,Arity) :-
	is_flplib(ParserTerm,FLterm),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
flprologlib_atom_arity_mod(ParserTerm,Atm,Arity,Mod) :-
	is_flplib(ParserTerm,FLterm,Mod),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
%% returns functor object, not its name
flprologlib_functor(ParserTerm,Funct) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)),
	!,
	is_flterm(FLterm,Funct,_,_).
flprologlib_call(ParserTerm,FLterm) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)),
	!.

%% Not all Flora system libraries encode textual information. Only
%% the ones for aggregates and DB updates
florasyslib_struct(F,N,Args,FLORASYSLIB(NO_INDEX,F,N,Args)) :-
	report_option(FLSYSLIB(F),NO_INDEX).
florasyslib_struct(Index,F,N,Args,FLORASYSLIB(Index,F,N,Args)) :-
	report_option(FLSYSLIB(F),Index).

is_florasyslib_struct(FLORASYSLIB(I,F,N,Args), I,F,N,Args).

termobj_struct(FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	(flora_prlgdef(AtomName,N)
	-> prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	),
	!.
termobj_struct(FObj,N,ObjList,Code) :-
	is_strict_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,PRTERM(FObj,N,ObjList)).

%% catch{...,...,...}
catch_struct(Goal,Error,Handler,Code) :-
	florasyslib_struct(FLLIBCATCH,3,[Goal,Error,Handler],Code).

%% throw{...}
throw_struct(Error,Code) :-
	florasyslib_struct(FLLIBTHROW,1,[Error],Code).

%% true{...}, false{...}, undefined{...}. Opname==FL_TRUE/FL_FALSE/FL_UNDEFINED
truthvalue_struct(Formula,Opname,Code) :-
	thismodule_struct(WS),
	%% Opname - first, for better indexing
	florasyslib_struct(FLLIBTRUTHVALUE,3,[Opname,WS,Formula],Code).

tagprimitive_struct(Descriptor,Module,Code) :-
	approx_prindex(Descriptor,Index),
	florasyslib_struct(Index,FLLIBTAGPRIMITIVE,2,[Descriptor,Module],Code).

prefixprimitive_struct(Prefix,Expansion,Module,Code) :-
	florasyslib_struct(FLLIBPREFIXPRIMITIVE,3,[Prefix,Expansion,Module],Code).

%% p2h{...}
p2h_struct(Prolog,Hilog,Code) :-
	atomobj_struct(P2H_PREDICATE,P2HCode),
	%%prologterm_struct(P2HCode,4,[Prolog,Hilog,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],Code).
	/* Previously we used P2H_DONOT_UNIFY_VARS here, but this meant that,
	   for example     ?- write(f(?X,?X))@\prologall.
           will print the two versions of ?X as different vars.
           Do not know why P2H_DONOT_UNIFY_VARS was used here before.
	*/
	prologterm_struct(P2HCode,4,[Prolog,Hilog,WRAP_HILOG,P2H_UNIFY_VARS],Code).

insert_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

insert_struct(Op,List,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

delete_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

delete_struct(Op,List,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

table_refresh_struct(List,Code) :-
	florasyslib_struct(FLLIBREFRESH,1,[List],Code).

clause_struct(Id,DescrVarTerm,MetaFacts,Mode,HeadList,Body,Code) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	florasyslib_struct(FLLIBCLAUSE,6,[Id,DescrVarTerm,MetaFacts,Mode,HeadList,Body],Code).

insert_rulesig_struct(HeadList,Body,H2BSig,PreBody,PostBody,DescrIdCode,DescrVarsTerm,DefeatCond,Code) :-
	thismodule_struct(WS),
	get_current_compile_file(File),
	(approx_prindex(DescrIdCode,Idx), Idx \== NO_INDEX -> true
	; approx_prindex(HeadList,Idx)
	),
	flora_token_rulenum(Idx,StmtNum), %% rulenum within file
	florasyslib_struct(FLLIBINSRULESIG,11,[DescrIdCode,File,DescrVarsTerm,WS,StmtNum,HeadList,Body,H2BSig,PreBody,PostBody,DefeatCond],Code).

insert_syslib(FL_INSERT,FLLIBINSERT) :- !.
insert_syslib(FL_INSERTALL,FLLIBINSERTALL) :- !.

insert_syslib(FL_BTINSERT,FLLIBBTINSERT) :- !.
insert_syslib(FL_BTINSERTALL,FLLIBBTINSERTALL) :- !.

delete_syslib(FL_DELETE,FLLIBDELETE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_DELETEALL,FLLIBDELETEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASE,FLLIBERASE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASEALL,FLLIBERASEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.

delete_syslib(FL_BTDELETE,FLLIBBTDELETE) :- !.
delete_syslib(FL_BTDELETEALL,FLLIBBTDELETEALL) :- !.
delete_syslib(FL_BTERASE,FLLIBBTERASE) :- !.
delete_syslib(FL_BTERASEALL,FLLIBBTERASEALL) :- !.

updaterule_syslib(FL_INSERTRULE,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_INSERTRULE_A,FLLIBINSERTRULE_A) :- 
        !.
updaterule_syslib(FL_INSERTRULE_Z,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_DELETERULE_A,FLLIBDELETERULE_A) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE_Z,FLLIBDELETERULE_Z) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE,FLLIBDELETERULE) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.

is_fldeleteruleop(FL_DELETERULE_A) :- !.
is_fldeleteruleop(FL_DELETERULE_Z) :- !.
is_fldeleteruleop(FL_DELETERULE) :- !.

aggregate_struct(Op,V,GV,SortOrUniq,B,Object,Code) :-
        %% case when no dupl control or sorting
	list_struct([],[],EmptyListCode), %% empty list
        SortOrUniq = EmptyListCode,
	is_flatom(Op,OpAtom,Index),
	aggregate_syslib(OpAtom,Lib),
	new_prvariable(Index,Object),
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
        florasyslib_struct(Index,Lib,5,[V,GV,SortOrUniq,B,Object],Code),
	!.
aggregate_struct(Op,V,GV,SortCode,B,Object,Code) :-
	is_flatom(Op,OpAtom,Index),
	(aggregate_syslib_sorted(OpAtom,Lib)
        ; aggregate_syslib_uniquified(OpAtom,Lib)
        ),
	new_prvariable(Index,Object),
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
        florasyslib_struct(Index,Lib,5,[V,GV,SortCode,B,Object],Code),
	!.

flora_aggregate_lib(X) :- aggregate_syslib(_,X), !.
flora_aggregate_lib(X) :- aggregate_syslib_sorted(_,X), !.
%% maps library (X) to function (Y)
flora_aggregate_lib(X,Y) :-
        aggregate_syslib(Y,X),
        !,
        Y \= FL_COLLECTSET, Y \= FL_COLLECTBAG.
flora_aggregate_lib(X,Y) :-
        aggregate_syslib_sorted(Y,X),
        !,
        Y \= FL_COLLECTSET, Y \= FL_COLLECTBAG.

aggregate_syslib(FL_MIN,FLLIBMIN) :- !.
aggregate_syslib(FL_MAX,FLLIBMAX) :- !.
aggregate_syslib(FL_SUM,FLLIBSUM) :- !.
aggregate_syslib(FL_AVG,FLLIBAVG) :- !.
aggregate_syslib(FL_COUNT,FLLIBCOUNT) :- !.
aggregate_syslib(FL_SUMDISTINCT,FLLIBSUMDISTINCT) :- !.
aggregate_syslib(FL_AVGDISTINCT,FLLIBAVGDISTINCT) :- !.
aggregate_syslib(FL_COUNTDISTINCT,FLLIBCOUNTDISTINCT) :- !.
aggregate_syslib(FL_SET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_BAG,FLLIBCOLLECTBAG) :- !.
%% deprecated; keep after FL_SET/FL_BAG
aggregate_syslib(FL_COLLECTSET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_COLLECTBAG,FLLIBCOLLECTBAG) :- !.

aggregate_syslib_uniquified(FL_SUM,FLLIBSUM) :- !.
aggregate_syslib_uniquified(FL_AVG,FLLIBAVG) :- !.
aggregate_syslib_uniquified(FL_COUNT,FLLIBCOUNT) :- !.

aggregate_syslib_sorted(FL_SET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_BAG,FLLIBBAGSORTBY) :- !.
%% deprecated; keep after FL_SET/FL_BAG
aggregate_syslib_sorted(FL_COLLECTSET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_COLLECTBAG,FLLIBBAGSORTBY) :- !.

hypothetical_struct(Op,Goal,Index,Code) :-
	hypothetical_syslib(Op,Lib), %% Op is a plain atom, not flatom
	florasyslib_struct(Index,Lib,2,[Op,Goal],Code).

flora_hypothetical_lib(X) :- hypothetical_syslib(_,X).
hypothetical_syslib(FL_POSSIBLE,FLLIBHYPOTHETICAL)      :- !.
hypothetical_syslib(FL_IMPOSSIBLE,FLLIBHYPOTHETICAL)    :- !.

objexists_struct(LitContext,Obj,PREXISTS(Obj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

birelate_struct(LiteralContext,Obj1,RelType,Obj2,Code) :-
	( is_isaspecop(RelType) ->
	    isaspec_struct(LiteralContext,Obj1,Obj2,Code)
	; is_subspecop(RelType) ->
	  subspec_struct(LiteralContext,Obj1,Obj2,Code)
        ),
	!.

isaspec_struct(LitContext,Obj1,Obj2,PRISA(Obj1,Obj2,FWContext)) :-
	determine_context_info(LitContext,FWContext).

subspec_struct(LitContext,Obj1,Obj2,PRSUB(Obj1,Obj2,FWContext)) :-
	determine_context_info(LitContext,FWContext).


sigattspec_struct(NONINHERITABLE,LiteralContext,Object,AttObj,ValObj,Code) :-
	!,
	mvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code).
sigattspec_struct(INHERITABLE,LiteralContext,Object,AttObj,ValObj,Code) :-
	imvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code).

%% cardinality constraint QUERY in the body. Not negatable with NEG
sigattconstr_struct(NONINHERITABLE,LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) :-
	!,
	mvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code).
sigattconstr_struct(INHERITABLE,LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) :-
	imvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code).


%% cardinality constraint definition in the head. Not negatable with NEG
sigattcondef_struct(NONINHERITABLE,LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) :-
	!,
	mvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code).
sigattcondef_struct(INHERITABLE,LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) :-
	imvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code).

mvdsigspec_struct(LitContext,Object,AttObj,ValObj,PRMVDSIG(Object,AttObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvdsigspec_struct(LitContext,Object,AttObj,ValObj,PRIMVDSIG(Object,AttObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

%% This is for cardinality constraints in the body
mvdcon_struct(LitContext,Object,AttObj,LowerObj,UpperObj,PRMVDCON(Object,AttObj,LowerObj,UpperObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvdcon_struct(LitContext,Object,AttObj,LowerObj,UpperObj,PRIMVDCON(Object,AttObj,LowerObj,UpperObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

%% This is for cardinality constraints in the head
mvdcondef_struct(LitContext,Object,AttObj,LowerObj,UpperObj,ValObj,PRMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvdcondef_struct(LitContext,Object,AttObj,LowerObj,UpperObj,ValObj,PRIMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

is_prmvdcondef(PRMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_FWContext)).
is_primvdcondef(PRIMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_FWContext)).

boolsig_struct(NONINHERITABLE,LitContext,Object,AttObj,PRBOOLSIG(Object,AttObj,FWContext)):-
	!,
	determine_context_info(LitContext,FWContext).
boolsig_struct(INHERITABLE,LitContext,Object,AttObj,PRIBOOLSIG(Object,AttObj,FWContext)):-
	determine_context_info(LitContext,FWContext).

transig_struct(NONINHERITABLE,LitContext,Object,AttObj,PRTRANSIG(Object,AttObj,FWContext)):-
	!,
	determine_context_info(LitContext,FWContext).
transig_struct(INHERITABLE,LitContext,Object,AttObj,PRITRANSIG(Object,AttObj,FWContext)):-
	determine_context_info(LitContext,FWContext).


%% This is for -> when the attribute is defined, but its value is empty set
mvdattdef_struct(NONINHERITABLE,LiteralContext,Object,AttObj,Code) :-
	!,
	mvddef_struct(LiteralContext,Object,AttObj,Code).
mvdattdef_struct(INHERITABLE,LiteralContext,Object,AttObj,Code) :-
	imvddef_struct(LiteralContext,Object,AttObj,Code).

%% This is for => when the attribute is defined, but its value is empty set
sigattdef_struct(NONINHERITABLE,LiteralContext,Object,AttObj,Code) :-
	!,
	mvdsigdef_struct(LiteralContext,Object,AttObj,Code).
sigattdef_struct(INHERITABLE,LiteralContext,Object,AttObj,Code) :-
	imvdsigdef_struct(LiteralContext,Object,AttObj,Code).


mvddef_struct(LitContext,Object,AttObj,PRMVDDEF(Object,AttObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvddef_struct(LitContext,Object,AttObj,PRIMVDDEF(Object,AttObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
mvdsigdef_struct(LitContext,Object,AttObj,PRMVDSIGDEF(Object,AttObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvdsigdef_struct(LitContext,Object,AttObj,PRIMVDSIGDEF(Object,AttObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

mvdattspec_struct(NONINHERITABLE,LiteralContext,Object,AttObj,ValObj,Code) :-
	!,
	mvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code).
mvdattspec_struct(INHERITABLE,LiteralContext,Object,AttObj,ValObj,Code) :-
	imvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code).

mvdspec_struct(LitContext,Object,AttObj,ValObj,PRMVD(Object,AttObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).
imvdspec_struct(LitContext,Object,AttObj,ValObj,PRIMVD(Object,AttObj,ValObj,FWContext)) :-
	determine_context_info(LitContext,FWContext).

%% for +>>
%% appears only in the rule body
incattspec_struct(NONINHERITABLE,Object,AttObj,ValObj,Code) :-
	!,
	mvdincspec_struct(Object,AttObj,ValObj,Code).
incattspec_struct(INHERITABLE,Object,AttObj,ValObj,Code) :-
	imvdincspec_struct(Object,AttObj,ValObj,Code).

%% +>>, inheritable and noninheritable
%% appears only in the rule body
mvdincspec_struct(Object,AttObj,ValObj,PRMVDINC(Object,AttObj,ValObj,FWContext)) :-
	thismodule_struct(ThisModule),
	body_context_info_structure(ThisModule,FWContext).
imvdincspec_struct(Object,AttObj,ValObj,PRIMVDINC(Object,AttObj,ValObj,FWContext)) :-
	thismodule_struct(ThisModule),
	body_context_info_structure(ThisModule,FWContext).

%% ->->, inheritable and noninheritable
%% appears only in the rule body
tolistattspec_struct(NONINHERITABLE,Object,AttObj,ValObj,Code) :-
	!,
	mvdtolistspec_struct(Object,AttObj,ValObj,Code).
tolistattspec_struct(INHERITABLE,Object,AttObj,ValObj,Code) :-
	imvdtolistspec_struct(Object,AttObj,ValObj,Code).

mvdtolistspec_struct(Object,AttObj,ValObj,PRMVDTOLIST(Object,AttObj,ValObj,FWContext)) :-
	thismodule_struct(ThisModule),
	body_context_info_structure(ThisModule,FWContext).
imvdtolistspec_struct(Object,AttObj,ValObj,PRIMVDTOLIST(Object,AttObj,ValObj,FWContext)) :-
	thismodule_struct(ThisModule),
	body_context_info_structure(ThisModule,FWContext).

%% This is called when someting like a.b[] is compiled.
body_objref_struct(NONINHERITABLE,Obj,Att,Index,Val,Code) :-
	!,
	%% Index is the approximate textual information
	%% for the new variable that represents an oid.
	%% Here we use quantified variables so that if we get something like
	%% naf bill.has(moo)[type->bar] then the var corresponding to
	%% bill.has(moo) will be treated as existential and so there will not be
	%% a delay because of its unboundedness.
	new_quantified_prvariable(Index,Val),
	mvdspec_struct(BODYLITERAL,Obj,Att,Val,Code).
body_objref_struct(INHERITABLE,Obj,Att,Index,Val,Code) :-
	new_quantified_prvariable(Index,Val),
	imvdspec_struct(BODYLITERAL,Obj,Att,Val,Code).


head_objref_struct(NONINHERITABLE,Obj,Att,Index,Val,Code) :-
	!,
	new_prvariable(Index,Val), 
	mvdspec_struct(HEADLITERAL,Obj,Att,Val,Code).
head_objref_struct(INHERITABLE,Obj,Att,Index,Val,Code) :-
	new_prvariable(Index,Val), 
	imvdspec_struct(HEADLITERAL,Obj,Att,Val,Code).
 	 

methspec_struct(NONINHERITABLE,LitContext,Obj,Meth,PRMETH(Obj,Meth,FWContext)) :-
	determine_context_info(LitContext,FWContext).
methspec_struct(INHERITABLE,LitContext,Obj,IMeth,PRIMETH(Obj,IMeth,FWContext)) :-
	determine_context_info(LitContext,FWContext).

%% presently inheritable and noninheritable transactional methods are the same
transpec_struct(NONINHERITABLE,LitContext,Obj,Tran,PRTRAN(Obj,Tran,FWContext)) :-
	!,
	determine_context_info(LitContext,FWContext).
%% presently inheritable and noninheritable transactional methods are the same,
%% i.e., we use PRTRAN: there is no PRITRAN yet
transpec_struct(INHERITABLE,LitContext,Obj,Tran,PRTRAN(Obj,Tran,FWContext)) :-
	determine_context_info(LitContext,FWContext).

objeql_struct(LitContext,O1,O2,PROBJEQL(O1,O2,FWContext)) :-
	determine_context_info(LitContext,FWContext).


ifthenelse_struct(Cond,Then,Else,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHENELSE,6,[ThisMod,Cond,Then,Else,Line,CurrFileName],Code).

ifthen_struct(Cond,Then,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHEN,5,[ThisMod,Cond,Then,Line,CurrFileName],Code).

%% encoding of control constructs
controlconstruct_struct(CondCode,ActionCode,Wrapper,Code) :-
	code_line_and_file_by_prterm(CondCode,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(Wrapper,5,[ThisMod,CondCode,ActionCode,Line,CurrFileName],Code).

univeqform_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBUNIVEQFORM,2,[Left,Right],Code).

%% This handles both ~.. and =..
%% These predicates are defined identically. The only difference is that
%% the LHS arg of ~.. is compiled as meta, while in =.. it is compiled as oid
metauniv_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBMETAUNIV,2,[Left,Right],Code).

constraint_struct(ConstrCode,PRCONSTRAINT(ConstrCode)).


/****************************************************************************
  reset_newpredicate/0
  new_predicate(-Name)
****************************************************************************/
%%reset_newpredicate :- flora_set_counter(NEWPREDICATE_COUNTER,1).

/*
new_predicate(Name) :-
	flora_increment_counter(NEWPREDICATE_COUNTER,1,OldVal,_NewVal),
	flora_concat_items([NEWPREDICATE_SYM,OldVal],Name).
*/

/****************************************************************************
  reset_default_ruleid/0
  current_default_ruleid(-Name)
****************************************************************************/
reset_default_ruleid :- flora_set_counter(DEFAULT_RULE_ID,1).

increment_default_ruleid :-
	flora_increment_counter(DEFAULT_RULE_ID,1,_,_).
%% static default rule Ids are even numbers
current_default_ruleid(RuleId) :-
	flora_get_counter(DEFAULT_RULE_ID,N),
	RuleId is 2*N.


/****************************************************************************
  flora_reset_newudfpredvar/0
  flora_newudfpredvar_obj(+VarPrefix,+Index,-CompiledVarObj)
****************************************************************************/
flora_reset_newudfpredvar :- flora_set_counter(NEWUDFPREDVAR,1).

flora_newudfpredvar_obj(Index,VarObj) :-
	flora_increment_counter(NEWUDFPREDVAR,1,OldVal,_NewVal),
	varobj_struct(OldVal,Index,VarObj).

/****************************************************************************
  flora_reset_newvar/0
  flora_new_varobj(+VarPrefix,+Index,-CompiledVarObj)
  new_prvariable(+Index,-CompiledVarObj)
****************************************************************************/
flora_reset_newvar :- flora_set_counter(NEWVAR,1).

%% This 3-argument version is provided for other parts of the compiler,
%% such as flrundefined.P, which need to generate vars.
%% VarPrefix makes sure that names don't clash.
flora_new_varobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	flora_concat_items([VarPrefix,OldVal],Name),
	varobj_struct(Name,Index,VarObj).

flora_new_transactionalvarobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	flora_concat_items([VarPrefix,OldVal],Name),
	transactionalvar_struct(Name,Index,VarObj).

new_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWVAR,Index,VarObj).
new_dontcare_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWDONTCAREVAR,Index,VarObj).
new_context_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWFLCONTEXTVAR,Index,VarObj).
new_quantified_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWQUANTIFIEDVAR ,Index,VarObj).
%% creates new transactional variable
new_dontcare_prtransactionalvar(Index,VarObj) :-
	flora_new_transactionalvarobj(NEWDONTCAREVAR,Index,VarObj).

prvariable_for_numbered_skolem(Index,SkolemNumber,VarObj) :-
	flora_concat_items([SKOLEMSYMVAR,SkolemNumber],Name),
	varobj_struct(Name,Index,VarObj).

%% new_flvariable/3: makes both new flvariable and a corresponding prvariable
new_flvariable(Index,FlVar,NewPrvar) :-
	new_prvariable(Index,NewPrvar),
	prvar_to_flvar_struct(NewPrvar,FlVar).


new_prvarlist(0,[]) :- !.
new_prvarlist(N,[VarObj|L]) :-
	new_prvariable(NO_INDEX,VarObj),
	M is N-1,
	new_prvarlist(M,L).

%% Scan arguments and construct a list of new prvariables.
%% prvars corresponding to the same argument must be the same.
new_prvarlist_from_args(VarNames,VarList) :-
        new_prvarlist_from_args(VarNames,VarList,[]).
new_prvarlist_from_args([],[],_) :- !.
new_prvarlist_from_args([Arg|Args],[Var|Vars],VarNamePairs) :-
        (is_any_prvar(Arg,Name,_) -> true
        ; Name = Arg
        ),
        (memberchk((Name,Var),VarNamePairs) -> VarNamePairs1=VarNamePairs
        ; new_prvariable(NO_INDEX,Var),
            VarNamePairs1 = [(Name,Var)|VarNamePairs]
        ),
        new_prvarlist_from_args(Args,Vars,VarNamePairs1).

/****************************************************************************
  reset_newoid/0
  new_oidobj(+Index,-OidObject)
****************************************************************************/
reset_newoid :- flora_set_counter(NEWOID_COUNT,1).
reset_newoid_global :- flora_set_counter(NEWOID_GLOBAL,1).

%% unnumbered Skolems
%% NOTE: Parser no longer generates unnumbered Skolems -- see the comment
%%       "Unnumbered" there. So, new_oidobj/2 below is DEAD CODE
new_oidobj(Index,OidObject) :-
	flora_increment_counter(NEWOID_COUNT,1,OldVal,_NewVal),
	flora_concat_items([NEWOID,OldVal],Name),
	newoid_struct(Name,Index,OidObject).

/*************************************************************************
  new_oidobj(+OidNumStr,+Index,-OidObject)
*************************************************************************/
%% numbered Skolems
new_oidobj(OidNumStr,Index,OidObject) :-
	( ruleoid(OidNumStr,_,Count)
	-> Count_new is Count+1,
	    %% TODO: see if we can replace assert/retract with conget/conset
	    retract(ruleoid(OidNumStr,_,Count)),
	    asserta(ruleoid(OidNumStr,Index,Count_new))
	;  asserta(ruleoid(OidNumStr,Index,1))
	), 
	!,
	flora_get_counter(RULE_NUM, StmtNum), 
        flora_concat_items([NEWOID,StmtNum,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).

%% numbered global oids
new_oidobj_global(OidNumStr,Index,OidObject) :-
	flora_get_counter(NEWOID_GLOBAL, GlobalScopeNum), 
        flora_concat_items([NEWOID_GLOBAL,GlobalScopeNum,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).

/*************************************************************************
  new_dynoidobj(+Index,-OidObject)
  new_dynoidobj(+OidNumStr,+Index,-OidObject)
  These generate dynamic new oids for use in the shell
*************************************************************************/
new_dynoidobj(Index,OidObject) :-
	gensym(FL_NEWOID_DYNSYM,Name),
	newoid_struct(Name,Index,OidObject).
new_dynoidobj(OidNumStr,Index,OidObject) :-
	flora_concat_atoms([FL_NEWOID_DYNSYM,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).
	


clear_ruleoid :- flora_retractall_substitute(ruleoid(_,_,_)).

/****************************************************************************
  reset_rulenum

****************************************************************************/
reset_rulenum :- flora_set_counter(RULE_NUM,1).
increment_rule_number :- flora_increment_counter(RULE_NUM,1,_,_).

/****************************************************************************
  collect_prvars(+CompilerTerm,-Vars)
  collect_prvars(+CompilerTerm,-Vars,-TailVars)
  collects all variables in a *compiled* term (or a list of terms).
  Returns a list Vars.

****************************************************************************/
collect_prvars(Term,Vars) :-
	collect_prvars(Term,Vs,[]),
	%%sort(Vs,Vars).
	Vs=Vars. %% sorting does nothing here

collect_prvars(Term,Vars,Vars) :-
	(var(Term); atomic(Term)),
	!.
%% this MUST be after the var-test above
collect_prvars([],Vars,Vars) :- !.
collect_prvars([H|L],Vars,TVars) :-
	!,
	collect_prvars(H,Vars,LVars),
	collect_prvars(L,LVars,TVars).
collect_prvars(Term,[Term|Vars],Vars) :-
	is_prvariable(Term),
	!.
collect_prvars(Term,[Head|Vars],Vars) :-
	is_prtransactionalvariable(Term,Name,Index),
	!,
        is_prvariable(Head,Name,Index).

collect_prvars(Term,Vars,Vars) :-
	is_pratomnumberstringbuiltin(Term,_),
	!.
collect_prvars(Term,Vars,Vars) :-
	is_prtransactionalnumber(Term,_,_),
	!.
collect_prvars(Term,NewVars,Vars) :-
	nonvar(Term),
	is_prdatatype(Term,_Sort,Lit,_),
	!,
	(is_prvariable(Lit,_Name,_Indx) -> NewVars = [Lit|Vars]
	; is_list(Lit) -> collect_prvars(Lit,NewVars,Vars)
	; is_prdatatypelist(Lit,LitList) -> collect_prvars(LitList,NewVars,Vars)
	; NewVars=Vars
	),
	!.
collect_prvars(Term,Vars,TVars) :-
	Term =.. [_F|L],
	collect_prvars(L,Vars,TVars).

collect_prvar_names(ParserTerm,VarNameList) :-
	collect_prvars(ParserTerm,VarList),
	vars_to_var_names(VarList,VarNameList).

/****************************************************************************
  error and warning messages
****************************************************************************/
compiling_error(Index,Mesg,error(RealIdx,ErrMsg)) :-
	is_list(Mesg),
	!,
	extract_real_token_number(Index,RealIdx),
	flora_concat_items(Mesg,ErrMsg).
compiling_error(Index,Mesg,error(RealIdx,Mesg)) :-
	extract_real_token_number(Index,RealIdx).

compiling_warning(Index,Mesg,warning(RealIdx,ErrMsg)) :-
	is_list(Mesg),
	!,
	extract_real_token_number(Index,RealIdx),
	flora_concat_atoms(Mesg,ErrMsg).
compiling_warning(Index,Mesg,warning(RealIdx,Mesg)) :-
	extract_real_token_number(Index,RealIdx).

extract_real_token_number(Index,RealIdx) :-
	var(Index),
	get_attr(Index,FLTOKENIDX,RealIdx),
	!.
extract_real_token_number(Index,Index) :-
	integer(Index),
	!.
extract_real_token_number(Index,Index).  %% think whether to issue an error here

flora_real_token_number(Idx,RealIds) :-
	extract_real_token_number(Idx,RealIds).


/****************************************************************************
  collect_flvars(+ParserTermOrList,-Vars)
  collects all occurrences of variables in a *parser* term (or a list of parser
  terms) into the list Vars.

  collect_flvars(+ParserTerm,-Vars,-TailVars,-ProtectedVars,-ProtectedTailVars)

  ProtectedVars are grouping and aggregate vars: we don't allow the
  user to have them outside
****************************************************************************/
collect_flvars(ParserTermOrList,Vars) :-
	collect_flvars(ParserTermOrList,Vars,[],_ProtectedVars,[]).
collect_flvars(ParserTermOrList,Vars,ProtectedVars) :-
	collect_flvars(ParserTermOrList,Vars,[],ProtectedVars,[]).

collect_flvars(ParserTerm,Vars,Vars,ProtectedVars,ProtectedVars) :-
	(var(ParserTerm) ; atomic(ParserTerm)),
	!.
%% this MUST be after the var-test above
collect_flvars([],Vars,Vars,ProtectedVars,ProtectedVars) :- !.
collect_flvars([H|L],Vars,TVars,ProtVars,TailProtVars) :-
	!,
	collect_flvars(H,Vars,LVars,ProtVars,LProtVars),
	collect_flvars(L,LVars,TVars,LProtVars,TailProtVars).

collect_flvars(ParserTerm,[ParserTerm|Vars],Vars,ProtVars,ProtVars) :-
	is_flvariable(ParserTerm,_Name,_Index),
	!.

collect_flvars(ParserTerm,[NewParserTerm|Vars],Vars,ProtVars,ProtVars) :-
	is_fltransactionalvariable(ParserTerm,Name,Index),
	!,
        is_flvariable(NewParserTerm,Name,Index).

collect_flvars(ParserTerm,Vars,Vars,ProtVars,ProtVars) :-
	is_flatomnumberstringbuiltin(ParserTerm),
	!.
collect_flvars(ParserTerm,Vars,Vars,ProtVars,ProtVars) :-
	is_fltrans_atomnumberstring(ParserTerm),
	!.
collect_flvars(ParserTerm,Vars,Vars,ProtVars,ProtVars) :-
	is_fltoken(ParserTerm),
	!.

collect_flvars(ParserTerm,NewVars,Vars,ProtVars,ProtVarsTail) :-
	is_fldatatype(ParserTerm,_Sort,Lit,_Index),
	!,
        (is_flvariable(Lit,_Name,_Indx) ->
	    NewVars = [Lit|Vars],
	    ProtVars=ProtVarsTail
	; is_list(Lit) -> collect_flvars(Lit,NewVars,Vars,ProtVars,ProtVarsTail)
	; is_fldatatypelist(Lit,ListLit) ->
	    collect_flvars(ListLit,NewVars,Vars,ProtVars,ProtVarsTail)
	;  NewVars=Vars,
	    ProtVars=ProtVarsTail
	),
	!.

collect_flvars(ParserTerm,Vars,TVars,ProtVars,TailProtVars) :-
	is_fllogicquantifier(ParserTerm,_,VarNames,_VarsCode,FormulaCode,_Idx),
	!,
	collect_flvars(FormulaCode,Vars1,TVars,ProtVars,TailProtVars),
	subtract_varnames_from_vars(Vars1,VarNames,Vars).

%% Note: Vars, ProtVars are always passed unbound.
collect_flvars(ParserTerm,Vars,TVars,ProtVars,TailProtVars) :-
	is_flaggregate(ParserTerm,_,AggrFlVar,GrpFlVars,SortSpec,FormulaCode),
	!,
	is_flvariable(AggrFlVar,AggrVarName,_),
	collect_flvars(FormulaCode,Vars1,TVars1,ProtVars,TailProtVars1),
        (SortSpec==NULL -> SortVars=[]
        ; collect_flvars(SortSpec,SortVars)
        ),
	%% append grouping&sort vars to avoid "singleton var" warning for them
        append(GrpFlVars,SortVars,GrpAndSortVars),
        %% TVars is a tail variable in the difflist TVars1
	append(GrpAndSortVars,TVars,TVars1),
	subtract_varnames_from_vars(Vars1,[AggrVarName],Vars),
	append(GrpFlVars,TailProtVars,TailProtVars1).

collect_flvars(ParserTerm,Vars,TVars,ProfVars,TailProtVars) :-
	ParserTerm =.. [_F|L],
	collect_flvars(L,Vars,TVars,ProfVars,TailProtVars).

collect_flvar_names(ParserTerm,VarNameList) :-
	collect_flvars(ParserTerm,VarList),
	vars_to_var_names(VarList,VarNameList).

delete_silent_var_names([],[]) :- !.
delete_silent_var_names([Name|List],Result) :-
        (is_silent_var_name(Name) -> delete_silent_var_names(List,Result)
        ; Result = [Name|RestResult],
            delete_silent_var_names(List,RestResult)
        ).


/****************************************************************************
  collect_prdatatypevars(+ParserTermOrList,-DTVarsCode)

  Collects all occurrences of datatype variable terms in a parser term 
  (or a list of parser terms) into the list Vars.
****************************************************************************/
collect_prdatatypevars(CompilerTermOrList,Vars) :-
	collect_prdatatypevars(CompilerTermOrList,Vars,[]).

collect_prdatatypevars(CompilerTermOrList,Vars,Vars) :-
	(var(CompilerTermOrList) ; atomic(CompilerTermOrList)),
	!.

collect_prdatatypevars([],Vars,Vars) :- !.

collect_prdatatypevars([H|L],Vars,TVars) :-
	!,
	(collect_prdatatypevars(H,Vars,LVars) -> true
	; LVars = Vars
	),
	collect_prdatatypevars(L,LVars,TVars).

%% If there is a variable in data type  ... ?Y^^type ... 
%% then create ?Y = FL_DATATYPE(Sort,?_Y) and collect all of these
collect_prdatatypevars(CompilerTermOrList,NewVars,Vars) :-
	nonvar(CompilerTermOrList),
	is_prdatatype(CompilerTermOrList,TypeCode,VarCode,_Index),
	!,
	%% TODO: get rid of the appends here!
        (is_prvariable(VarCode,VarName,VarIdx)
	-> strip_underscore(VarName,UsrGivenVarName),
	    %% create ?_Y =?__Y^^type
	    varobj_struct(UsrGivenVarName,VarIdx,UsrGivenVarCode),
	    is_prdatatype(DataTypeVarStruct,TypeCode,VarCode,NO_INDEX),
	    atomobj_struct(FL_UNIVEQ,UnivEQCode),
	    prologterm_struct(UnivEQCode,2,[UsrGivenVarCode,DataTypeVarStruct],
			      DatatypeVarCode),
	    NewVars = [DatatypeVarCode|Vars]
	; is_list(VarCode)
	-> collect_prdatatypevars(VarCode,AddlVars),
	    append(AddlVars,Vars,NewVars)
	; is_prdatatypelist(VarCode,ListOfLits)
	-> collect_prdatatypevars(ListOfLits,AddlVars),
	    append(AddlVars,Vars,NewVars)
	;  NewVars=Vars
	),
	!.


collect_prdatatypevars(CompilerTermOrList,Vars,TVars) :-
	nonvar(CompilerTermOrList),
	CompilerTermOrList =.. [_F|L],
	collect_prdatatypevars(L,Vars,TVars).


strip_underscore(Atom,NewAtom) :-
	substring(Atom,1,_,NewAtom).

/*
add_underscore(Atom,NewAtom) :-
	flora_concat_atoms(['_',Atom],NewAtom).
*/


/*******************************************************************************
  subtract_vars(+VarList1,+VarList2,-VarList)

  Subtracts VarList2 from VarList1.
  Both VarList1 and VarList2 must be of the same type: parser vars
  or compiler vars.

  subtract_varnames_from_vars(+VarList1,+VarNameList,-VarList2)

  VarList1 can be either prvars or flvars.
  VarNameList is a list of names of vars.
  The result is a list of variables whose names do not appear in VarsList2
  or VarNameList2.
  Anonymous variables are considered as distinct names and are not subtracted.
*******************************************************************************/
%% subtract_vars/3: subtract flvars from flvars or prvars from prvars
subtract_vars([],_,[]) :- !.
subtract_vars(L,[],L) :- !.

subtract_vars([H|T],L,Res) :-
	( %% construct X as H, but with variable index
	  is_flvariable(H,N,_) -> is_flvariable(X,N,_)
	; is_fltransactionalvariable(H,N,_) -> is_fltransactionalvariable(X,N,_)
	; is_prvariable(H,N,_) -> is_prvariable(X,N,_)
	; is_prtransactionalvariable(H,N,_) -> is_prtransactionalvariable(X,N,_)
	),
	!,
	subtract_vars(T,L,V),
	!,
	(N \== FL_ANON_VAR, memberchk(X,L) -> Res = V
	; Res = [H|V]
	),
	!.

%% subtract_varnames_from_vars/3: subtract var names from flvars or prvars
subtract_varnames_from_vars([],_,[]) :- !.
subtract_varnames_from_vars(L,[],L) :- !.

subtract_varnames_from_vars([H|T],L,Res) :-
	( is_any_flvar(H,N,_I)
	; is_any_prvar(H,N,_I)
	),
	!,
	(var(T) -> V = T
	; subtract_varnames_from_vars(T,L,V)
	),
	(N \== FL_ANON_VAR, memberchk(N,L) -> Res = V
	; Res = [H|V]
	),
	!.


/*****************************************************************************
     vars_contains(+VarList1,+VarList2)
     Checks if VarList1 contains VarList2 up to indices.
     VarList1,VarList2 are assumed to be sorted and of the same kind
*****************************************************************************/
vars_contains(_,[]) :- !.
vars_contains([H1|T1],[H2|T2]) :-
	( is_flvariable(H1,N,_), is_flvariable(H2,N,_)
	; is_fltransactionalvariable(H1,N,_), is_fltransactionalvariable(H2,N,_)
	; is_prvariable(H1,N,_), is_prvariable(H2,N,_)
	; is_prtransactionalvariable(H1,N,_), is_prtransactionalvariable(H2,N,_)
	),
	!,
	N \== FL_ANON_VAR,
	vars_contains(T1,T2).

%% one_var_left_memberchk(+Var,+VarL,-Var2)
%% check if Var occurs in VarL (with a different token index)
%% to the lexical left of Var. That is index(Var) > index(Var2) for some
%% Var2 in VarL
one_var_left_memberchk(Var,[Var2|_],Var2) :-
	is_any_var(Var,Name,Idx),
	is_any_var(Var2,Name,Idx2),
	extract_real_token_number(Idx,IdxN),
	extract_real_token_number(Idx2,Idx2N),
	Idx2N < IdxN,
	!.
one_var_left_memberchk(Var,[_|T],Var2) :- one_var_left_memberchk(Var,T,Var2).

%% varlist_left_membercheck(+VarL1,+VarL2,-Var2)
%% check if any Var1 in VarL1 occurs in VarL2 (with a different token index)
%% to the lexical left of Var1. That is index(Var1) > index(Var2) for some
%% Var2 in VarL2
varlist_left_membercheck([Var|_],VarList,Var2) :-
	one_var_left_memberchk(Var,VarList,Var2),
	!.
varlist_left_membercheck([_|Tail],VarList,Var2) :-
	varlist_left_membercheck(Tail,VarList,Var2).


/*****************************************************************************
             remove_FL_CONTEXT_prvars(+InList,-OutList)
             remove_prvars(+InList,-OutList)
      Removes all the do not care variables from InList.
      InList can be a list of parser or compiler vars.
*****************************************************************************/

remove_dontcare_flvars([],[]) :- !.
remove_dontcare_flvars([H|T1],T2) :-
	is_any_flvar(H,FL_ANON_VAR,_I),
	!,
	remove_dontcare_flvars(T1,T2).
remove_dontcare_flvars([H|T1],T2) :-
	is_any_flvar(H,VarName,_I),
	flora_match_substring(NEWDONTCAREVAR,VarName,0),
	!,
	remove_dontcare_flvars(T1,T2).
remove_dontcare_flvars([H|T1],[H|T2]) :-
	remove_dontcare_flvars(T1,T2).

remove_silent_flvars([],[]) :- !.
remove_silent_flvars([H|T1],T2) :-
	is_any_flvar(H,Name,_I),
        is_silent_var_name(Name),
	!,
	remove_silent_flvars(T1,T2).
remove_silent_flvars([H|T1],[H|T2]) :-
	remove_silent_flvars(T1,T2).

remove_FL_CONTEXT_flvars(InVars,OutVars) :-
	remove_flvars(NEWFLCONTEXTVAR,InVars,OutVars).

remove_prvars(_,[],[]) :- !.
remove_prvars(Prefix,[H|T1],T2) :-
	%% new vars are all prvar structures
	is_any_prvar(H,Var,_I),
	%% must be before the cut!!!
	flora_match_substring(Prefix,Var,0), %% starts with Prefix
	!,
	remove_prvars(Prefix,T1,T2).
remove_prvars(Prefix,[H|T1],[H|T2]) :-
	remove_prvars(Prefix,T1,T2).

remove_flvars(_,[],[]) :- !.
remove_flvars(Prefix,[H|T1],T2) :-
	%% new vars are all prvar structures
	is_any_flvar(H,Var,_I),
	%% must be before the cut!!!
	flora_match_substring(Prefix,Var,0), %% starts with Prefix
	!,
	remove_flvars(Prefix,T1,T2).
remove_flvars(Prefix,[H|T1],[H|T2]) :-
	remove_flvars(Prefix,T1,T2).

/*
remove_prdontcare_vars(InVars,OutVars) :-
	remove_prvars(NEWDONTCAREVAR,InVars,OutVars).
*/
remove_FL_CONTEXT_prvars(InVars,OutVars) :-
	remove_prvars(NEWFLCONTEXTVAR,InVars,OutVars).

remove_quantified_vars(InVars,OutVars) :-
	remove_prvars(NEWQUANTIFIEDVAR ,InVars,OutVars).

remove_prdontcare_and_FL_CONTEXT_vars(In,Out) :-
	remove_prvars(NEWDONTCAREVAR,In,Intermed),
	remove_prvars(NEWFLCONTEXTVAR,Intermed,Out).

%% remove all pr-vars that weren't given bu the user.
%% these are the vars that have index NO_INDEX
remove_nonuser_prvars([],[]) :- !.
remove_nonuser_prvars([H|T],Out) :-
        is_prvariable(H,_,NO_INDEX),
        !,
        remove_nonuser_prvars(T,Out).
remove_nonuser_prvars([H|T],[H|Out]) :-
        is_prvariable(H),
        remove_nonuser_prvars(T,Out).

/*
remove_nonuser_flvars([],[]) :- !.
remove_nonuser_flvars([H|T],Out) :-
        is_flvariable(H,_,NO_INDEX),
        !,
        remove_nonuser_flvars(T,Out).
remove_nonuser_flvars([H|T],[H|Out]) :-
        is_flvariable(H,_,_),
        remove_nonuser_flvars(T,Out).
*/


/****************************************************************************
  collect_name_var_pairs(+ParserTerm,-QueryVars)
  collects all the queryable variables (those that do not start with an
  underscore) in a parser term (or a list of parser terms) into a list
  of Name=Var constructs.

  indexvars(+SortedNameVars,-IndexVars)
  namevars(+SortedIndexVars,-QueryVars)
****************************************************************************/
collect_name_var_pairs(ParserTerm,QueryVars) :-
	collect_flvars(ParserTerm,NameVs),
	%% Sorting eliminated duplicate vars so that, for example,
	%% Name-Var code in compile_query will have 1 pair per var name.
	%% So, each var will be printed only once in the answers in the shell.
	sort(NameVs,SortedNameVs),
	indexvars(SortedNameVs,IndexVs),
	keysort(IndexVs,SortedIndexVs),
	namevars(SortedIndexVs,QueryVars).


%% creates a list of vars of the form [Idx-Name,Idx-Name,...]
indexvars([],[]) :- !.
indexvars([T|L],Vars) :-
	is_any_flvar(T,Name,I),
	!,
	( is_silent_var_name(Name) -> indexvars(L,Vars)
	;
          Vars=[I-Name|Vs],
	  remove_named_flvar_from_list_prefix(L,Name,VL),
	  indexvars(VL,Vs)
        ).


% an Index-VarName list and creates a list of items ?Name = Varobj.
%% This is used in queries to describe the variable bindings
namevars([],[]) :- !.
namevars([Index-Name|L],[NV|NVs]) :-
	varobj_struct(Name,Index,VCode),
	%% prepend '?' to var names in query answers
	flora_concat_atoms(['?',Name],NewName),
	atomobj_struct(NewName,Index,NCode),
	atomobj_struct(FL_UNIVEQ,FCode),
	prologterm_struct(FCode,2,[NCode,VCode],NV),
	namevars(L,NVs).


/****************************************************************************
  singleton_flvars(+SortedVarsList,-SingletonVars)
  collects all the singleton variables in SortedVarsList into SingletonVars.
  Singleton variables collected here exclude the anonymous var '_'.
  Silent vars, those beginning with an underscore are kept but
  singleton_warning/3 does not generate a warning for them.

  remove_named_flvar_from_list_prefix(+SortedVarsList,+VarName,-Vars)
  Remove variable named Name from the head SortedVarsList

  remove_dupflvars(+SortedVarsList,-Vars)
  Remove duplicates of variables in SortedVarsList

  get_quantification_info(+QuantGoal,-Quantifier,-Formula,-QuantVars,-FreeVars)
  QuantGoal is PR code of a (possibly) quantified formula
  Formula is the formula being quantified
  Vars free vars in Formula (which are not quantified in QuantGoal)
       It is a PR-list structure
****************************************************************************/
singleton_flvars([],[]) :- !.

singleton_flvars([V|L],[V|Vs]) :-
	is_any_flvar(V,FL_ANON_VAR,_I),
	!,
	singleton_flvars(L,Vs).

singleton_flvars([V],[V]) :- !.

singleton_flvars([V1,V2|L],Vars) :-
	( ( is_flvariable(V1,Name,_), is_flvariable(V2,Name,_)
	  ; is_fltransactionalvariable(V1,Name,_),
	      is_fltransactionalvariable(V2,Name,_)
	  )
	-> remove_named_flvar_from_list_prefix(L,Name,Vs),
	    singleton_flvars(Vs,Vars)
        ;
	  Vars=[V1|Vs],
	  singleton_flvars([V2|L],Vs)
        ),
	!.


%% Removes variables named Name from the head of a sorted list of vars.
%% The var to be removed can be either at the top or not appear at all
remove_named_flvar_from_list_prefix([V|L],Name,Vars) :-
	is_any_flvar(V,Name,_I),
	!,
	remove_named_flvar_from_list_prefix(L,Name,Vars).
remove_named_flvar_from_list_prefix(L,_Name,L).

%% real remove duplicate flvars
remove_dupflvars(Vars,VarsOut) :-
	sort(Vars,VarsS),
	remove_dupflvars_aux(VarsS,VarsOut).
remove_dupflvars_aux([],[]) :- !.
remove_dupflvars_aux([H|T],[H|TT]) :-
	is_any_flvar(H,Name,_I),
	!,
	remove_named_flvar_from_list_prefix(T,Name,Vars),
	remove_dupflvars_aux(Vars,TT).

%% QuantGoal is PR code
get_quantification_info(QuantGoal,Quantifier,Formula,QuantVarListObj,FreeVarListObj) :-
	(is_prquantifier(QuantGoal,Quantifier,Formula,QuantVarListObj,FreeVarListObj)
	-> true
	;  Formula = QuantGoal,
	    Quantifier = NULL,
	    %% if no quantifier, use all vars minus dontcare/contextvars
	    collect_prvars(QuantGoal,AllVars),
	    remove_prdontcare_and_FL_CONTEXT_vars(AllVars,FreeVarObjList1),
	    %% this is used if naf-exists is nested deep inside the code
	    remove_quantified_vars(FreeVarObjList1,FreeVarObjList),
	    list_struct(FreeVarObjList,[],FreeVarListObj),
	    list_struct([],[],QuantVarListObj)
	).

/****************************************************************************
  singleton_warning(+VarList,-WarnList,-WarnTail)
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
singleton_warning([],Warn,Warn).

singleton_warning([V|L],WarnList,WarnTail) :-
	is_any_flvar(V,Name,I),
	!,
	( is_silent_var_name(Name) -> singleton_warning(L,WarnList,WarnTail)
	;
	    compiling_warning(I,SINGLETON_VAR,W),
	    WarnList=[W|T],
	    singleton_warning(L,T,WarnTail)
        ),
	!.


/****************************************************************************
  unsafe_var_warning(+VarList,-WarnList,-WarnTail)
  unsafe_var_warning(+VarList,-WarnList,?WarnTail,+WarningMessage) :-
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
unsafe_var_warning(VarList,WarnList,WarnTail) :-
	unsafe_var_warning(VarList,WarnList,WarnTail,UNBOUND_VAR).

unsafe_var_warning([],WarnList,WarnList,_).

unsafe_var_warning([V|L],WarnList,WarnTail,WarningMessage) :-
	is_any_flvar(V,Name,I),
	!,
	( is_silent_var_name(Name) ->
	  unsafe_var_warning(L,WarnList,WarnTail,WarningMessage)
	;
	  compiling_warning(I,WarningMessage,W),
	  WarnList=[W|T],
	  unsafe_var_warning(L,T,WarnTail,WarningMessage)
        ),
	!.


/****************************************************************************
  check_rule_vars_for_safety(+HeadTermList,+BodyTerm,-Status)
****************************************************************************/
check_rule_vars_for_safety(HeadTermList,BodyTerm,Status) :-
	collect_flvars(HeadTermList,HeadVars),
	collect_flvars(BodyTerm,BodyVars,ProtectedVars),
	append(HeadVars,BodyVars,Vars),
	%% Singleton_flvars relies on sorting.
	%% Using parsort/4 does NOT eliminate duplicates so that singletons
	%% will be correctly reported in NL templates.
	%% For cases like ?X[a->b,c->d] we still can report duplicates
	%% since we are looking at flvars, not prvars, and in fl-code
	%% ?X[a->b,c->d] has just one occurrence of ?X. The
	%% problem with sort/2 is that it would erroneously report singletons
	%% in a template like this:  \(if ?X is a boy then ?X plays ball\).
	machine:parsort(Vars,asc,0,SortedVars),
        %% grouping vars in rule head are ok
	protected_vars_warning(BodyVars,ProtectedVars,Stat_vars),
	(no_errors_found(Stat_vars) ->
	    singleton_flvars(SortedVars,SingletonVars),
	    singleton_warning(SingletonVars,Status_pre,WarnTail),
            remove_silent_flvars(HeadVars,LoudHeadVars),
	    subtract_vars(LoudHeadVars,BodyVars,UnboundVars),
	    sort(UnboundVars,UnboundSortedVars),
            (UnboundSortedVars == [] -> WarnTail = []
            ; flora_ignore_unsafe_vars(HeadTermList) -> WarnTail = []
	    ; BodyTerm == [] ->
		unsafe_var_warning(UnboundSortedVars,WarnTail,[],UNBOUND_VAR_IN_FACT)
	    ; unsafe_var_warning(UnboundSortedVars,WarnTail,[])
	    ),
	    (var(WarnTail) -> WarnTail = Stat_vars, Status = Status_pre
	    ; append(Status_pre,Stat_vars,Status)
	    )
	; Status = Stat_vars
	),
	!.

%% Like check_latent_query_flvars_for_safety/3 but first arg is PRCode
check_latent_query_prvars_for_safety(PRCode,Body,Status) :-
        get_user_flvars_from_prcode(PRCode,CodeFLVars),
        check_latent_query_flvars_for_safety(CodeFLVars,Body,Status).
%% Arg1 - list of flvars
%% Check if CodeFLVars has any vars not in Body; issue unsafety warning
check_latent_query_flvars_for_safety(CodeFLVars,Body,Status) :-
	collect_flvars(Body,BodyFLvars,_),
        subtract_vars(CodeFLVars,BodyFLvars,UnboundVars),
        sort(UnboundVars,UnboundSortedVars),
        unsafe_var_warning(UnboundSortedVars,UnsafeWarn,[],UNBOUND_VAR_IN_LATENT_QUERY),
        (var(UnsafeWarn) -> UnsafeWarn = [], Status = []
        ; Status = UnsafeWarn
        ).

protected_vars_warning(Vars,ProtectedVars,Status) :-
	varlist_left_membercheck(ProtectedVars,Vars,Var),
	!,
	is_flvariable(Var,_,Idx),
	compiling_warning(Idx,GROUPING_LEFT_OF,Err),
	Status = [Err].
protected_vars_warning(_,_,NO_ERRORS).

%% used in the Ergo parser
flora_singleton_warnings(Formula,Warnings) :-
	collect_flvars(Formula,Varlist),
	sort(Varlist,SortedVars),
	singleton_flvars(SortedVars,SingletonVars),
	singleton_warning(SingletonVars,Warnings,[]).

get_user_flvars_from_prcode(PRCode,Vars) :-
        collect_prvars(PRCode,CodePRVars),
        remove_nonuser_prvars(CodePRVars,CodeUserPRVars),
	prvar_to_flvar_struct_list(CodeUserPRVars,Vars).

%% subtract flvars of Form2 from vars of Form1
flora_flvar_diff(Form1,Form2,Diff) :-
	collect_flvars(Form1,Form1vars),
	collect_flvars(Form2,Form2vars),
	subtract_vars(Form1vars,Form2vars,Diff).



/****************************************************************************
  check_udf_vars_for_safety(+Function,+Predicate,+ReturnValue,-Status)
****************************************************************************/
check_udf_vars_for_safety(Function,Predicate,ReturnValue,Status) :-
        collect_flvars([Function,ReturnValue],FuncVars),
        collect_flvars(Predicate,PredVars),
        append(FuncVars,PredVars,Vars),
        sort(Vars,SortedVars), %% singleton_flvars relies on sorting
        singleton_flvars(SortedVars,SingletonVars),
        singleton_warning(SingletonVars,Status,WarnTail),
        subtract_vars(FuncVars,PredVars,UnboundVars),
        %% Don't issue the unboundedness var warning for facts
	%% (facts can be defined using function definition)
        (Predicate == NULL ->
            ( var(Status) -> Status = NO_ERRORS
            ; true
            )
        ;
            unsafe_var_warning(UnboundVars,WarnTail,[],UNBOUND_UDF_VAR)
        ),
	(var(WarnTail) -> WarnTail=[]
	; true
	),
	!.



/****************************************************************************
    vars_to_var_names(+VarList,-NameList)

 Takes a list of vars from either the parser or compiler
 and returns a list of their names.
 Assumes that the list is indeed a list of vars.

****************************************************************************/
vars_to_var_names([],[]) :- !.
vars_to_var_names([V|VarList],[Name|NameList]) :-
	(is_any_flvar(V,Name,_)
	; is_any_prvar(V,Name,_)
	),
	!,
	vars_to_var_names(VarList,NameList).


/****************************************************************************
  clear_directive
  get_directive(-L)  
  report_directive(+Direct)
  clear_compilation_liboptions
  flora_get_compilation_liboptions(-L)
  report_option(+Option,+Index)
  clear_dynrule_varlist
  report_dynrule_varlist(+Var,+Val)
  get_dynrule_varlist(-L)
  get_dynrule_varlist(+CompileVarList,-L)
****************************************************************************/
/*
clear_directive :- retractall(TMPDIRECT(_)).
get_directive(L) :- findall(D,TMPDIRECT(D),L).
report_directive(Direct) :- assert(TMPDIRECT(Direct)).
*/

%%clear_compilation_liboptions :- flora_retractall_substitute(LIBOPTION(_,_)).
clear_compilation_liboptions :- retractall(LIBOPTION(_,_)).
flora_get_compilation_liboptions(L) :- findall((O,Idx),LIBOPTION(O,Idx),L).
report_option(Option,Idx) :- assert(LIBOPTION(Option,Idx)).

%% Do not(!) check for \+ PERMAOPTION(X) here!
%% So, do NOT use trie indexing!
%% We rely on duplicates if multiple declarations of argumentation theories
set_permaoption(X) :- asserta(PERMAOPTION(X)).
set_permaoptions([]) :- !.
set_permaoptions([X|Rest]) :-
	set_permaoption(X),
	set_permaoptions(Rest).
has_permaoption(X) :- PERMAOPTION(X).
flora_clear_compilation_permaoptions :- retractall(PERMAOPTION(_)).
clear_one_permaoption(X) :- (retract(PERMAOPTION(X)) ; true), !.
%% this is exported for others to use
has_compiler_permaoption(X) :- has_permaoption(X).

%% Unlike permaoptions, persistent options don't get reset by flrutils
%% when loading new files
set_persistentoption(X) :- asserta(PERSISTENTOPTION(X)).
set_persistentoption([]) :- !.
set_persistentoption([X|Rest]) :-
	set_persistentoption(X),
	set_persistentoption(Rest).
has_persistentoption(X) :- PERSISTENTOPTION(X).
clear_one_persistentoption(X) :- (retract(PERSISTENTOPTION(X)) ; true), !.
has_compiler_persistentoption(X) :- has_persistentoption(X).
flora_clear_compilation_persistentoptions :- retractall(PERSISTENTOPTION(_)).

set_context(X) :-
	atom(X),
	!,
	flora_set_counter(X,1).
set_context(X) :-
	compound(X),
	!,
	%% it is a trie - so no checking for duplicates
	%% replacing COMPILATION_CONTEXT/1 with interned tries and
	%% deleting tries instead of retractall does not help
	assert(COMPILATION_CONTEXT(X)).
	%%storage:storage_insert_fact(compiler_context,X,_).
set_context(X) :-
	abort(['[Compiler] bug: ', X, ': invalid compiler context']).

flora_set_compilation_context(X) :- set_context(X).

clear_context(X) :-
	(atom(X) -> flora_set_counter(X,0)
	; retract(COMPILATION_CONTEXT(X)) -> true
	    %%, storage:storage_delete_fact(compiler_context,X,_)
	; true
	).
clear_contextall(X) :- flora_retractall_substitute(COMPILATION_CONTEXT(X)).

flora_clear_compilation_context(X) :- clear_context(X).

/* all stackable contexts, like CONTEXT_COMPILER_BODY/1, must be initialized
    here. Initializing others is also a good practice.
*/
initialize_compilation_contexts :-
	flora_retractall_substitute(COMPILATION_CONTEXT(_)),
	flora_retractall_substitute(COMPILATION_CONTEXT(_,_)),
	flora_set_counter(CONTEXT_COMPILER_GOAL_REIFICATION,0),
	flora_set_counter(CONTEXT_COMPILER_TEXTIT,0),
	flora_set_counter(CONTEXT_COMPILER_TEXTIT_ARGS2_4,0),
	flora_set_counter(CONTEXT_COMPILING_METAUNIV,0),
	flora_set_counter(CONTEXT_COMPILER_RULE_REIFICATION,0),
	flora_set_counter(CONTEXT_COMPILER_UNIVEQFORM,0),
	flora_set_counter(CONTEXT_COMPILER_BODY_PATHEXP,0),
	flora_set_counter(CONTEXT_COMPILER_TERM_NAME,0),
	flora_set_counter(CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS,0),
	flora_set_counter(CONTEXT_COMPILER_SIMPLEPRIMITIVE_WITH_EXTRA_ARGS,0),
	flora_set_counter(CONTEXT_COMPILER_ARITHMETICS,0),
	flora_set_counter(CONTEXT_COMPILER_CONSTRAINT,0),
	flora_set_counter(CONTEXT_COMPILER_EXPORT_DIRECTIVE,0),
	flora_set_counter(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION,0),
	flora_set_counter(CONTEXT_COMPILER_FOR_ADDITION,0),
	flora_set_counter(CONTEXT_COMPILER_CLAUSE_PRIMITIVE,0),
	flora_set_counter(CONTEXT_COMPILER_UPDATE_LITERALS,0),
	flora_set_counter(CONTEXT_COMPILER_BODY_REIFY_4_DELETE,0),
	flora_set_counter(CONTEXT_COMPILER_DELETE_RULE,0),
	flora_set_counter(CONTEXT_COMPILER_FACTS,0),
	flora_set_counter(CONTEXT_COMPILER_DELETE,0),
	flora_set_counter(CONTEXT_COMPILER_UDF_DEFINITION,0),
	flora_set_counter(CONTEXT_COMPILER_WITH_VAR_MODULE,0),
	flora_set_counter(CONTEXT_COMPILER_IGNOREDEP,0),
	flora_set_counter(CONTEXT_COMPILER_HEADLITERAL,0),
	flora_set_counter(CONTEXT_COMPILER_DEFAULT_NEGATION,0),
	flora_set_counter(CONTEXT_COMPILING_PASSTHRU,0),
        %% CONTEXT_READ_PARSE_COMPILE is set/cleared in flrutils.P
	flora_set_counter(CONTEXT_READ_PARSE_COMPILE,0),
	%% stackable contexts below
	flora_set_counter(CONTEXT_COMPILER_NO_SYMBOL_CHECK,0),
	flora_set_counter(CONTEXT_COMPILER_BODY,0).
/*
clear_contextall(X) :-
	var(X),
	!,
	storage:storage_delete_all(compiler_context).
clear_contextall(X) :-
	( storage:storage_delete_fact(compiler_context,X,_), fail
	; true
	).
*/
/*
   Push context - requires a clear_context for initialization.
		  This is done in initialize_compilation_contexts/0, where
		  all pushable (and some other) contexts must be initialized.
*/
push_context(X) :-
	(atom(X) -> flora_increment_counter(X,1,_,_V)
	; compound(X) ->
	    functor(X,Fun,_),
	    flora_increment_counter(Fun,1,_,NewVal),
	    assert(COMPILATION_CONTEXT(NewVal,X))
	;
	    abort(['[Compiler] bug: ', X, ': invalid compiler stackable context'])
	).

pop_context(X) :-
	(atom(X) -> flora_increment_counter(X,-1,_,_V)
	; compound(X) ->
	    functor(X,Fun,_),
	    flora_increment_counter(Fun,-1,OldVal,_NV),
	    retract(COMPILATION_CONTEXT(OldVal,X))
	; true
	).

%%%%%%%%

has_context(X) :-
	(atom(X) ->
	    %%flora_get_counter(X,1).
	    flora_get_counter(X,V),
	    %% The following abort is for occasional debugging to find
	    %% uninitialized contexts.
	    %%(V>1000 -> abort(Debugging=X+V) ; true),
	    V > 0
	; compound(X),
	    (COMPILATION_CONTEXT(X) -> true
	    ; functor(X,Fun,_), flora_get_counter(Fun,Val),
		COMPILATION_CONTEXT(Val,X)
	    )
	).

%% this one is exported
flora_compilation_context(X) :- has_context(X).

clear_dynrule_varlist :- flora_retractall_substitute(DYNRULE_VARLIST(_,_)).
report_dynrule_varlist(AttrVar,Val) :-
	asserta(DYNRULE_VARLIST(AttrVar,Val)).
get_dynrule_varlist(L) :-
	(\+DYNRULE_VARLIST(_,_) -> L=[]
	; findall((Var,Val),DYNRULE_VARLIST(Var,Val),L)
	).
get_dynrule_varlist(VarList,L) :-
	(\+DYNRULE_VARLIST(_,_) -> L=[]
	; findall((Var,Val),(DYNRULE_VARLIST(Var,Val),memberchk(Var,VarList)),L)
	).

%% Report options specified in the :- setsemantics{...} directive
%% Since the argument is a parser list (sans the FLLIST wrapper), we need 
%% to extract the actual values of terms in the list in order to pass
%% to report_options/2.
report_semantic_options([]) :- !.
report_semantic_options([H|T]) :-
	is_flplib(H,FlTerm),
	is_flterm(FlTerm,Funct,_N,[Arg|_]),
	is_flatom(Funct,FunctVal,Index),
	is_flatom(Arg,ArgVal),
	Option =.. [FunctVal,ArgVal],
	report_option(Option,Index),
	report_semantic_options(T).


/****************************************************************************
  prepare_to_compile_rule/0
  Called each time we start parsing a new sentence
****************************************************************************/
prepare_to_compile_rule :-
	flora_reset_newvar,
	%%clear_directive,
	%%clear_compilation_liboptions,
	initialize_compilation_contexts,
        clear_dynrule_varlist.

/****************************************************************************
  flora_reset_compiler(+Purpose)

  Purpose: file/shell
  The compiler is reset usially once per file.
****************************************************************************/
flora_reset_compiler(Purpose) :-
	%%reset_newpredicate,
	(Purpose == file -> flora_reset_oid_related_counters
	; true
	),
	!,
	clear_compilation_liboptions,
	flora_clear_compiletime_uriprefixes,
        initialize_compilation_contexts,
	flora_clear_compilation_symbols.

flora_reset_oid_related_counters :-
	reset_rulenum,
	reset_default_ruleid,
	reset_newoid,
	reset_newoid_global.

/****************************************************************************
  flora_compile_add(+ParserTerm,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-StmtNum+StmtFileName,-Status)

  This is the top level predicate that is called to compile code for
  adding code to module.

  RuleDiffList is a difference list in the form of [...|R]-R. Diff lists
  are used for optimization of append.
  FactDiffList is the same for facts
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile_add([NULL],R-R,F-F,Q-Q,LQ-LQ,U-U,_,NO_ERRORS) :- !.

flora_compile_add(ParserTermList,RuleDiffList,FactDiffList,QueryDiffList,LatentQueryDiffList,UDFPredsDiffList,StmtNum+FileName,Status) :-
#ifdef SHOW_COMPILE_ADD_INPUT
	DBGOUTLN('------------result of parsing-----------------'),
	DBGOUTLN(ParserTermList),
	DBGOUTLN('----------------------------------------------'),
#endif
	prepare_to_compile_rule,
	increment_rule_number,
	ParserTermList = [ParserTerm|_],
	approx_flindex(ParserTerm,RuleIdx),
	get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
	get_current_compile_file(FileName),
	set_context(CONTEXT_COMPILER_FOR_ADDITION),
	compile_add_list_internal(ParserTermList,
				  RuleDiffList,FactDiffList,
				  QueryDiffList,LatentQueryDiffList,
				  UDFPredsDiffList,
				  Stat1),
	clear_context(CONTEXT_COMPILER_FOR_ADDITION),
	(ruleoid(_,_,1) -> referenced_once(Stat1,Status) ;  Status=Stat1),
	clear_ruleoid,
#ifdef SHOW_COMPILE_ADD_OUTPUT
	DBGOUTLN('------------result of compile_add-----------------'),
	DBGOUTLN(rules=RuleDiffList),
	DBGOUTLN(facts=FactDiffList),
	DBGOUTLN(queries=QueryDiffList),
	DBGOUTLN(latent_queries=LatentQueryDiffList),
	%%DBGOUTLN(udfs =UDFPredsDiffList),
	DBGOUTLN(status=Status),
	DBGOUTLN('--------------------------------------------------'),
#endif
	!.
	
%% This rule is for debugging.
flora_compile_add(ParserTerm,[],[],[],[],[],_,Status) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in flora_compile_add'],Err),
	Status = [Err].


/******************************************************************************
    compile_add_list_internal(+ParserTerm,-RuleDiffList,-FactDiffList,-QueryDiffList,-LatentQueryDiffList,-UDFPredsDiffList,-Status)
******************************************************************************/
compile_add_list_internal([],_R-_R,_F-_F,_Q-_Q,_LQ-_LQ,_U-_U,NO_ERRORS) :- !.

compile_add_list_internal([ParserTerm|ParserTermList],RuleDiffList-RuleTail,FactDiffList-FactTail,QueryList-QueryTail,LatentQueryList-LatentQueryTail,UDFPredsDiffList-UDFTail,Status) :-
	approx_flindex(ParserTerm,RuleIdx),
        compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_ADDRULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_),
	compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList-RuleTail1,FactDiffList-FactTail1,QueryList-QueryTail1,LatentQueryList-LatentQueryTail1,MetaFactDiffList,UDFPredsDiffList-UDFTail1,Stat1),
        !,
	(no_errors_found(Stat1) ->
	    compile_add_list_internal(ParserTermList,RuleDiffList2-RuleTail,FactDiffList2-FactTail,QueryList2-QueryTail,LatentQueryList2-LatentQueryTail,UDFPredsDiffList2-UDFTail,Stat2),
	    RuleTail1 = RuleDiffList2,
	    FactTail1 = FactDiffList2,
	    QueryTail1 = QueryList2,
	    LatentQueryTail1 = LatentQueryList2,
	    UDFTail1 = UDFPredsDiffList2,
	    append(Stat1,Stat2,Status)
	; Status = Stat1
	).

/******************************************************************************
    compile_add_internal(+ParserTerm,+DescriptorIdCode,+DescrVarsTerm,
                         -RuleDiffList,-FactDiffList,-QueryList,
			 -LatentQueryList,
			 ?MetaFactDiffList,-UDFPredsDiffList,-Status) :-

    MetaFactDiffList may be bound or unbound. In case this is called from
          compile_annotated_construct_add, it will be bound.
******************************************************************************/
compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flrule(ParserTerm,Head,Body),
        !,
	compile_rule_add(Head,Body,
			 DescriptorIdCode,DescrVarsTerm,
			 RuleDiffList,
			 FactDiffList,MetaFactDiffList,
			 Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ,
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flfact(ParserTerm,Head),
        !,
	compile_fact_add(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,MetaFactDiffList,Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ,
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,_MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flquery(ParserTerm,Body),
        !,
	compile_query(Body,QueryList,Status),
	RuleDiffList = _R-_R,
	LatentQueryList = _LQ-_LQ,
	FactDiffList = _Fact - _Fact,
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,DescriptorIdCode,_DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fllatent_query(ParserTerm,Body),
        !,
	%% Note: latent queries are always annotated.
	%% So, this must have been called from
	%% compile_annotated_construct_add.
	%% Therefore, MetaFactDiffList must be bound
	compile_latent_query(DescriptorIdCode,MetaFactDiffList,Body,FL_DESCRMODE_LATENT_ADDQUERY,LatentQueryList,Status),
	RuleDiffList = _R-_R,
	QueryList = _Q-_Q,
	FactDiffList = _Fact - _Fact,
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,_MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fldirective(ParserTerm,DirectList,DirctIdx),
        !,
	compile_directive_add(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ,
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,_MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flannotated_construct(ParserTerm,Descriptor,MainPartOfRule),
        !,
	compile_annotated_construct_add(Descriptor,MainPartOfRule,RuleDiffList,FactDiffList,QueryList,LatentQueryList,Status),
	UDFPreds=UDFPredsTail.

compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fludfdef(ParserTerm,Function,Body,ReturnValue),
        !,
        (var(DescriptorIdCode) ; is_prvariable(DescriptorIdCode) ->
	    %% MetaFactDiffList is nonvar, if compile_internal is called by
	    %% compile_annotated_construct (it is = []-[] then)
	    approx_flindex(ParserTerm,UDFIdx),
	    compile_descriptor_list([]-UDFIdx,FL_DESCRMODE_UDFRULE,DescriptorIdCodeUdf,DescrVarsTerm,MetaFactDiffListUdf,_)
	; DescriptorIdCodeUdf = DescriptorIdCode,
            MetaFactDiffListUdf = MetaFactDiffList
	),
	compile_udf_definition(Function,Body,DescriptorIdCodeUdf,DescrVarsTerm,ReturnValue,RuleDiffList,SigDiffList-Tail,FactDiffList,UDFPreds-UDFPredsTail,Status),
        make_code_for_inserting_metafacts(MetaFactDiffListUdf,InsertMetaCode),
	%%MetaFactDiffList = _M-_M,
	%%QueryList = _Q-_Q,
        QueryList = [InsertMetaCode|SigDiffList] - Tail,
	LatentQueryList = _LQ-_LQ.

compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fludfdef_fact(ParserTerm,Function,Value),
        !,
        (var(DescriptorIdCode) ; is_prvariable(DescriptorIdCode) ->
	    %% MetaFactDiffList is nonvar, if compile_internal is called by
	    %% compile_annotated_construct (it is = []-[] then)
	    approx_flindex(ParserTerm,UDFIdx),
	    compile_descriptor_list([]-UDFIdx,FL_DESCRMODE_UDFRULE,DescriptorIdCodeUdf,DescrVarsTerm,MetaFactDiffListUdf,_)
	; DescriptorIdCodeUdf = DescriptorIdCode,
            MetaFactDiffListUdf = MetaFactDiffList
	),
	compile_udf_definition(Function,NULL,DescriptorIdCodeUdf,DescrVarsTerm,Value,RuleDiffList,SigDiffList-Tail,FactDiffList,UDFPreds-UDFPredsTail,Status),
        make_code_for_inserting_metafacts(MetaFactDiffListUdf,InsertMetaCode),
	%%QueryList = _Q-_Q,
	%%MetaFactDiffList = _M-_M,
        QueryList = [InsertMetaCode|SigDiffList] - Tail,
	LatentQueryList = _LQ-_LQ.

/****************************************************************************
  compile_rule_add(+Head,+Body,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-FactDiffList,-MetaFactDiffList,-Status)

  DescriptorIdCode is code for a term/object
  FactDiffList is a NULL or a list of codes.

  RuleDiffList is a difference list in the form of [...|R]-R.
  FactDiffList is Facts-Facts == empty diff list
  MetaFactDiffList diff list of meta facts generated from annotations.
                    In this case, it is always empty.
  It is for the optimization of append.
****************************************************************************/
compile_rule_add(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleList-RuleTail,Facts-Facts,MetaFactDiffList,Status):-
	%% Note: DescriptorIdCode here is already compiled code for Id
	%% If FLDYNRULE(H,B,L) comes from the parser, then the
	%% descriptor has the form FLDESCRIPTOR(Id,Type,Index).
	compile_dynrule_main(FL_INSERTRULE_Z,Head,Body,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,RCode,Status),
        !,
	( no_errors_found(Status) -> 
	    list_struct([RCode],[],RListCode),
	    updaterule_syslib(FL_INSERTRULE_Z,UpdateruleLib),
	    approx_flindex(Head,Index),
	    florasyslib_struct(Index,UpdateruleLib,1,[RListCode],SysLibCode),
	    get_dynrule_varlist(L),
	    add_dynrule_attr_code(L,SysLibCode,InsertRuleCode),
	    query_struct(InsertRuleCode,Code),
	    RuleList = [Code|RuleTail]
	;
	    true
        ).

compile_directive_add([],_,R-R,F-F,NO_ERRORS) :- !.

%% Facts-Facts = empty diff list
compile_directive_add([D|L],DirIdx,RuleList-RuleTail,FactDiffList,Status) :-
	compile_direct_add(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive_add(L,DirIdx,T-RuleTail,FactDiffList,S2),
	    append(S2,S,Status)
	;
	  Status=S
        ),
	!.

compile_direct_add(DirectTerm,_DirIdx,[Code],S) :-
	is_flsetsemantics(DirectTerm,_OptionsList),
	!,
	compile_exec_directive([DirectTerm],NULL,Code1,S),
	query_struct(Code1,Code).

compile_direct_add(DirectTerm,DirIdx,DCodeList,S) :-
	compile_direct(DirectTerm,DirIdx,DCodeList,S).

/****************************************************************************
  compile_annotated_construct_add(+DescriptorList,+MainPartOfRule,-RuleDiffList,-FactDiffList,-QueryList,-LatentQueryList,-Status)

  DescriptorList - list of descriptors
  MainPartOfRule - rule without descriptors
  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used for append/3 optimization
  FactDiffList = the diff list of facts
  MetaFactDiffList - diff list of meta facts generated from annotations
****************************************************************************/
compile_annotated_construct_add(DescriptorList,MainPartOfRule,RuleDiffList,FactDiffList,QueryList,LatentQueryList,Status) :-
	approx_flindex(MainPartOfRule,RuleIdx),
	(is_fllatent_query(MainPartOfRule,_)-> Mode=FL_DESCRMODE_LATENT_ADDQUERY
        ; is_fludfdef(MainPartOfRule,_,_,_) -> Mode = FL_DESCRMODE_UDFRULE
        ; is_fludfdef_fact(MainPartOfRule,_,_) -> Mode = FL_DESCRMODE_UDFRULE
	; Mode = FL_DESCRMODE_ADDRULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTerm,MetaFactDiffList,Status1),
        !,
	( no_errors_found(Status1) -> 
	    %% this rule won't bring any new meta facts
	    compile_add_internal(MainPartOfRule,
				 DescrIdCode,DescrVarsTerm,
				 RuleDiffList,FactDiffList,QueryList,LatentQueryList,
				 MetaFactDiffList,
				 _UDFPreds,Status)
	;  Status = Status1
	),
	!.


/****************************************************************************
  flora_compile(+ParserTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryDiffList,-LatentQueryDiffList,-MetaFactDiffList,-UDFPredsDiffList,-StmtNum+StmtFileName,-Status)

  This is the top level procedure that is called to compile code.

  RuleDiffList is a rule difference list in the form of [...|R]-R.
                It is used in order to optimize append.
  SigDiffList - diff list of rule signatures
  FactDiffList is the same for facts
  MetaFactDiffList is a list of meta facts generated from annotations
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile([NULL],R-R,S-S,F-F,Q-Q,LQ-LQ,M-M,U-U,_,NO_ERRORS) :- !.

flora_compile(ParserTermList,RuleDiffList,SigDiffList,FactDiffList,QueryDiffList,LatentQueryDiffList,MetaFactDiffList,UDFPredsDiffList,StmtNum+FileName,Status) :-
#ifdef SHOW_COMPILE_INPUT
	DBGOUTLN('------------result of parsing-----------------'),
	DBGOUTLN(ParserTermList),
	DBGOUTLN('----------------------------------------------'),
#endif
	prepare_to_compile_rule,
	increment_rule_number,
	ParserTermList = [ParserTerm|_],
	approx_flindex(ParserTerm,RuleIdx),
	get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
	get_current_compile_file(FileName),
	compile_list_internal(ParserTermList,
			      RuleDiffList,SigDiffList,
			      FactDiffList,QueryDiffList,LatentQueryDiffList,
			      MetaFactDiffList,
			      UDFPredsDiffList,
			      Stat1),
	(ruleoid(_,_,1) -> referenced_once(Stat1,Status) ;  Status=Stat1),
	clear_ruleoid,
#ifdef SHOW_COMPILE_OUTPUT
	DBGOUTLN('------------result of compilation-----------------'),
	DBGOUTLN(rules=RuleDiffList),
	DBGOUTLN(signatures=SigDiffList),
	DBGOUTLN(facts=FactDiffList),
	DBGOUTLN(queries=QueryDiffList),
	DBGOUTLN(latent_queries=LatentQueryDiffList),
	DBGOUTLN(metafacts=MetaFactDiffList),
	%%DBGOUTLN(udfs =UDFPredsDiffList),
	DBGOUTLN(status=Status),
	DBGOUTLN('--------------------------------------------------'),
#endif
	!.
	
%% This rule is for debugging.
flora_compile([ParserTerm|_],[],[],[],[],[],[],[],_,Status) :-
	    approx_flindex(ParserTerm,ErrIdx),
	    compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in flora_compile'],Err),
	    Status = [Err].


/******************************************************************************
compile_list_internal(+ParserTermList,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,-MetaFactDiffList,-UDFPredsDiffList,-Status)
******************************************************************************/
compile_list_internal([],_R-_R,_S-_S,_F-_F,_Q-_Q,_LQ-_LQ,_M-_M,_U-_U,NO_ERRORS) :- !.

compile_list_internal([ParserTerm|ParserTermList],RuleDiffList-RuleTail,SigDiffList-SigTail,FactDiffList-FactTail,QueryList-QueryTail,LatentQueryList-LatentQueryTail,MetaFactDiffList-MetaTail,UDFPredsDiffList-UDFTail,Status) :-
	compile_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList-RuleTail1,SigDiffList-SigTail1,FactDiffList-FactTail1,QueryList-QueryTail1,LatentQueryList-LatentQueryTail1,MetaFactDiffList-MetaTail1,UDFPredsDiffList-UDFTail1,Stat1),
	(no_errors_found(Stat1) ->
	    compile_list_internal(ParserTermList,RuleDiffList2-RuleTail,SigDiffList2-SigTail,FactDiffList2-FactTail,QueryList2-QueryTail,LatentQueryList2-LatentQueryTail,MetaFactDiffList2-MetaTail,UDFPredsDiffList2-UDFTail,Stat2),
	    RuleTail1 = RuleDiffList2,
	    SigTail1 = SigDiffList2,
	    FactTail1 = FactDiffList2,
	    QueryTail1 = QueryList2,
	    LatentQueryTail1 = LatentQueryList2,
	    MetaTail1 = MetaFactDiffList2,
	    UDFTail1 = UDFPredsDiffList2,
	    append(Stat1,Stat2,Status)
	; Status = Stat1
	).



/******************************************************************************
    compile_internal(+ParserTerm,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,
                     -SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,
		     ?MetaFactDiffList,-UDFPreds,-Status)
     This does the main work
     DescriptorIdCode is either a code for an explicit Id or NULL
     DescrVarsTerm = code for vars(Variables of the descriptor list)
     MetaFactDiffList is bound if compile_internal/11 is called from within
            compile_annotated_construct/9 (in this case MetaFactDiffList=[]-[]).
            Otherwise MetaFactDiffList is unbound.
******************************************************************************/
compile_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flrule(ParserTerm,Head,Body),
        !,
	UDFPreds=UDFPredsTail,
	(var(DescriptorIdCode) ->
	    %% MetaFactDiffList is nonvar, if compile_internal is called by
	    %% compile_annotated_construct (it is = []-[] then)
	    approx_flindex(ParserTerm,RuleIdx),
	    compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_RULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_)
	; true
	),
	compile_rule(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ.

compile_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flfact(ParserTerm,Head),
        !,
	%% DefaultMetaFactDiffList is empty diff list Var-Var
	%% if Head is a real fact.
	%% If Head is compliled as a rule then it is the default metafact
	%% list (i.e., contains rule enabler, tag and type properties).
	%% We have to keep DefaultMetaFactDiffList as an argument to
	%% compile_fact because we don't know at this point if ParserTerm
	%% is going to turn into a rule and thus can't know if
	%% DefaultMetaFactDiffList will be empty or not.
	compile_fact(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,DefaultMetaFactDiffList,Status),
	%% currently MetaFactDiffList is always a Var1-Var2 here,
	%% since annotated facts are converted to rules by the parser.
	%% But in omni-heads DefaultMetaFactDiffList might be non-trivial
	%% Here we unify the MetaFactDiffList with DefaultMetaFactDiffList
	(var(DescriptorIdCode) -> MetaFactDiffList = DefaultMetaFactDiffList
	; MetaFactDiffList = Var1-Var2, var(Var1), var(Var2) ->
	    MetaFactDiffList = DefaultMetaFactDiffList
	; true
	),
	UDFPreds=UDFPredsTail,
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ.

compile_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flquery(ParserTerm,Body),
        !,
	UDFPreds=UDFPredsTail,
	compile_query(Body,QueryList,Status),
	RuleDiffList = _R-_R,
	LatentQueryList = _LQ-_LQ,
	SigDiffList = _S-_S,
	FactDiffList = _Fact - _Fact,
	MetaFactDiffList = _M-_M.

compile_internal(ParserTerm,DescriptorIdCode,_DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,_MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fllatent_query(ParserTerm,Body),
        !,
	UDFPreds=UDFPredsTail,
	%% Note: latent queries are always annotated.
	%% So, this must have been called from
	%% compile_annotated_construct/9.
	%% Therefore, MetaFactDiffList must be bound
	%% This is why we don't bind it further.
	%% However, we pass an empty diff list to
	%% compile_latent_query/6 because this is static compile,
	%% and the needed metafacts will be generated.
	%% So, FLLIBINSQUERYSIG/7 does not need to.
	%% Actually, compile_annotated_construct/9 passes []-[] to
	%% compile_internal/11 anyway.
	compile_latent_query(DescriptorIdCode,[]-[],Body,FL_DESCRMODE_LATENT_QUERY,LatentQueryList,Status),
	RuleDiffList = _R-_R,
	QueryList = _Q-_Q,
	SigDiffList = _S-_S,
	FactDiffList = _Fact - _Fact.

compile_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fldirective(ParserTerm,DirectList,DirctIdx),
        !,
	UDFPreds=UDFPredsTail,
	compile_directive(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ,
	SigDiffList = _S-_S,
	MetaFactDiffList = _M-_M.

compile_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_flannotated_construct(ParserTerm,DescriptorList,MainPartOfRule),
        !,
	compile_annotated_construct(DescriptorList,MainPartOfRule,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,Status),
	UDFPreds=UDFPredsTail.

compile_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fludfdef(ParserTerm,Function,Body,ReturnValue),
        !,
        (var(DescriptorIdCode) ->
	    %% MetaFactDiffList is nonvar, if compile_internal is called by
	    %% compile_annotated_construct (it is = []-[] then)
	    approx_flindex(ParserTerm,UDFIdx),
	    compile_descriptor_list([]-UDFIdx,FL_DESCRMODE_UDFRULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_)
	; true
	),
	compile_udf_definition(Function,Body,DescriptorIdCode,DescrVarsTerm,ReturnValue,RuleDiffList,SigDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ.

compile_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	is_fludfdef_fact(ParserTerm,Function,Value),
        !,
        (var(DescriptorIdCode) ->
	    %% MetaFactDiffList is nonvar, if compile_internal is called by
	    %% compile_annotated_construct (it is = []-[] then)
	    approx_flindex(ParserTerm,UDFIdx),
	    compile_descriptor_list([]-UDFIdx,FL_DESCRMODE_UDFRULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_)
	; true
	),
	compile_udf_definition(Function,NULL,DescriptorIdCode,DescrVarsTerm,Value,RuleDiffList,SigDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	%%SigDiffList = _S-_S,
	%%MetaFactDiffList = _M-_M,
	QueryList = _Q-_Q,
	LatentQueryList = _LQ-_LQ.

/***************************************************************************
  referenced_once(+Status_rf,-Status)
  finds singleton numbered Skolem oid and puts warning message in Status
***************************************************************************/
referenced_once(Status_rf,Status) :-
	%% we are looking for numbered oids mentioned once, but not those
	%% whose suffix starts with '_' or with 'omni*'.
	%% The later were generated from unumbered oids (\#) by the parser.
	findall(Index,
		(ruleoid(Oid,Index,1),
                    \+is_silent_var_name(Oid),
                    \+flora_match_substring(FL_OMNI_SKOLEM_PREFIX,Oid,0)
                ),
		IndexList),
	singleton_oid_warning(IndexList,WarnList,[]),
	append(Status_rf,WarnList,Status).


/*************************************************************************
singleton_oid_warning(+SingleOidList,-WarnList,-WarnTail)
***********************************************************************/
singleton_oid_warning([],WarnList,WarnList).

singleton_oid_warning([Index|L],WarnList,WarnTail) :-
	compiling_warning(Index,SINGLETON_OID,W),
	WarnList=[W|T],
	singleton_oid_warning(L,T,WarnTail).


/****************************************************************************
  compile_directive(+DirectList,+DirctIdx,-RuleDiffList,-FactDiffList,-Status)
  compile_direct(+DirectTerm,+DirctIdx,-RuleList,-Status)
****************************************************************************/
compile_directive([],_,R-R,F-F,NO_ERRORS) :- !.

%% Facts-Facts = empty diff list
compile_directive([D|L],DirIdx,RuleList-RuleTail,FactDiffList,Status) :-
	compile_direct(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive(L,DirIdx,T-RuleTail,FactDiffList,S2),
	    append(S,S2,Status)
	;
	  Status=S
        ),
	!.

%% TODO: optimize for preprocessor
compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flexport_list(DirectTerm,Term),
	compile_export(Term,Direct,Status),
	!,
	directive_struct(Direct,Code).

compile_direct(DirectTerm,DirIdx,[],NO_ERRORS) :-
	is_flindex(DirectTerm,A,P),
	!,
	report_option(FLINDEX(A,P),DirIdx).

compile_direct(DirectTerm,_DirIdx,[Code],NO_ERRORS) :-
	is_verbatim(DirectTerm,Instruction),
	!,
	atomobj_struct(Instruction,InstrCode),
	verbatim_struct(InstrCode,Direct),
	directive_struct(Direct,Code).

compile_direct(DirectTerm,_DirIdx,[],NO_ERRORS) :-
	is_suppress_rulesigns(DirectTerm),
	!,
	%% Right now this DOESN'T affect dynamic rules (neither _add
	%% nor insertrule{...}).
	%% But given this is intended for libraries, we don't need to extend
	%% this option to dynamic rules.
	set_permaoption(FLSUPPRESS_RULESIGNS_OPTION).

%% :- new_global_oid_scope.
compile_direct(DirectTerm,_DirIdx,[],NO_ERRORS) :-
	is_new_global_oid_scope(DirectTerm),
	!,
        flora_increment_counter(NEWOID_GLOBAL,1,_,_).
        

%% :- nontabled_module directive
compile_direct(DirectTerm,DirIdx,[],NO_ERRORS) :-
	is_flnontabled_module(DirectTerm),
	!,
	report_option(FLNONTABLEDMOD_OPT,DirIdx),
	report_option(FLNONTABLEDDATAMOD_OPT,DirIdx).

%% :- nontabled_data_module directive
%% (ie, data frames are not tabled; signatures are)
compile_direct(DirectTerm,DirIdx,[],NO_ERRORS) :-
	is_flnontabled_data_module(DirectTerm),
	!,
	report_option(FLNONTABLEDDATAMOD_OPT,DirIdx).

compile_direct(DirectTerm,DirIdx,[Code],NO_ERRORS) :-
	is_fldefeasible(DirectTerm,Module),
	!,
	is_flatom(Module,Name),
	set_permaoption(FLDEFEASIBLE(Name)),
	%% the next option is reported so that GCLP library would be included,
	%% if the default GCLP theory is used.
	(Name == FL_DEFAULT_DEFEASIBLE_THEORY
	->
	    report_option(FLSYSMOD(FL_DEFAULT_DEFEASIBLE_THEORY),DirIdx)
	; true
	),
	!,
	defeasible_struct(Name,Direct),
	directive_struct(Direct,Code).


compile_direct(DirectTerm,_DirIdx,[],NO_ERRORS) :-
	is_fldefeasible_rule_default(DirectTerm),
	!,
	set_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	
compile_direct(DirectTerm,_DirIdx,[],NO_ERRORS) :-
	is_flstrict_rule_default(DirectTerm),
	!,
	clear_one_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	

%% Operator definition. Must also induce executable op definition,
%% to execute in the shell (restricted to "main" module)
compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flopdef(DirectTerm,P,A,O),
	flora_define_operator(P,A,O),
	compile_exec_directive([FLOPDEF(P,A,O)],NULL,Code1,Status),
	query_struct(Code1,Code),
	!.

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flprolog_directive(DirectTerm,PairList,Idx),
	!,
	verify_symbol_context_pairlist(PairList,Idx, PROLOG_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PairList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,Code),
	set_permaoptions(PermaOptions).

%% Ergo; not reachable in Flora-2
compile_direct(DirectTerm,DirIdx,[Code],Status) :-
        is_flsimpleprimitive(DirectTerm,PrimName,Args),
        PrimName == FL_TEXTIT_PRIMITIVE,
	!,
        check_textit_arguments(DirIdx,Args,ErrorIssued,Stat1),
        (var(ErrorIssued) ->
            %% should have no oid code - oid code is ignored
            set_context(CONTEXT_COMPILER_TEXTIT),
            compile_simple_primitive(PrimName,Args,FL_THISMODULE,OidCode,PrimCode,Stat2),
            clear_context(CONTEXT_COMPILER_TEXTIT),
            clear_context(CONTEXT_COMPILER_TEXTIT_ARGS2_4),
            (OidCode==NULL -> Stat3 = Stat2
            ; 
		approx_flindex(Args,ArgIdx),
		compiling_error(ArgIdx,ERROR_TEXTIT_PATTERN,Err),
		Stat3 = [Err]
            ),
            query_struct(PrimCode,Code),
            append(Stat1,Stat3,Status)
        ; Status = Stat1
        ).



%% for sensor predicates, we do not define them as prolog here:
%% this is done by the sensor directive itself.
prolog_option((P,N,_Idx),_) :- 
	has_permaoption(defsensor(P,N)),
	!,
	fail.
prolog_option(P/N/_Idx,_) :- 
	has_permaoption(defsensor(P,N)),
	!,
	fail.
prolog_option((P,N,_Idx),prolog(P,N)) :- 
	!,
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).
prolog_option(P/N/_Idx,prolog(P,N)) :- 
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).

compile_direct(DirectTerm,_,[CodeTbl,CodePrlg],Status) :-
	is_fltabledirect(DirectTerm,PredSpecList,Idx),
	!,
	maplist(skip_sensor_spec(_,_),PredSpecList,PredSpecListSansSensors),
	verify_symbol_context_pairlist(PredSpecListSansSensors,Idx,PROLOG_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PredSpecList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,CodePrlg),
	set_permaoptions(PermaOptions),
	maplist(table_option(_,_),PredSpecList,TableSpecList),
	list2commalist(TableSpecList,TableSpec),
	table_directive_struct(TableSpec,Direct),
	directive_struct(Direct,CodeTbl).
%% for sensor predicates, the table directive works differently:
%% it creates a sensor predicate name and tables it with arity+2
table_option(P/N/_Idx,PMod/N2) :-
	has_permaoption(defsensor(P,N)),
	%% N+2 because the actual sensor predicate has 2 extra arguments, but
	%% :- table is using the declared # of args in the :- sensor directive
	N2 is N+2,
	!,
	scrambled_atom_struct(P,NO_INDEX,PMod).
table_option(P/N/_Idx,PMod/N1) :-
	N1 is N+1, %% because of the context argument
	flrprolog:flora_define_modular_tabled(P,N),
	modularized_pratom_struct(P,NO_INDEX,PMod).
skip_sensor_spec(P/N/_Idx,_) :-
	has_permaoption(defsensor(P,N)),
	!,
	fail.
skip_sensor_spec(P/N/Idx,P/N/Idx).

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flusesensordirect(DirectTerm,PairList,Idx),
	!,
	maplist(make_sensor_permaoption(_,_),PairList,PermaOptions),
	set_permaoptions(PermaOptions),
	verify_symbol_context_pairlist(PairList,Idx, USE_SENSOR_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(strip_pairlist_index(_,_),PairList,PairListSansIdx),
	verbatim_struct(PairListSansIdx,PairListCode),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code1),
	report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX),
	query_struct(Code1,Code).
%% used in converting usesensor pred list
make_sensor_permaoption(P/N/_Idx,usesensor(P,N)).
%% strip the index part from pred/arity/idx
strip_pairlist_index(P/N/_Idx,P/N) :- !.
strip_pairlist_index((P,N,_Idx),(P,N)).
%% not used
%%sensor_name_replacement(P/N/_Idx,SP/N) :- flora_scramble_atom(P,SP).


%% Compile-time :- useudf directive.
%% Does not generate any code - just sets options for compilation
compile_direct(DirectTerm,_,Code,Status) :-
	is_fluseudf_direct(DirectTerm,PairList,Idx),
	!,
        compile_useudf_directive(PairList,Idx,Status),
        maplist(useudf_struct(_,_),PairList,Code).

compile_direct(DirectTerm,_,[],NO_ERRORS) :-
        is_encoding(DirectTerm,Encoding),
        is_flatom(Encoding,EncAtm),
        !,
        seeing(InStream),
        file_io:file_set_character_set(InStream,EncAtm),
        telling(OutStream),
        file_io:file_set_character_set(OutStream,utf_8).
/*
compile_direct(DirectTerm,_,[Code1,Code2],NO_ERRORS) :-
        is_encoding(DirectTerm,Encoding),
        !,
        is_flatom(Encoding,EncAtm),
        set_prolog_flag(character_set,EncAtm),
        %% also set the current in/out streams to the right encoding
        flrencoding:flora_set_streams_character_set(EncAtm),
        compile_encoding_directive(Encoding,CodePre1,CodePre2),
        directive_struct(CodePre1,Code1),
        directive_struct(CodePre2,Code2).
*/

%% need to also construct a query so that sensor will be registered
%% during the compilation
compile_direct(DirectTerm,_,[Code],Status) :-
	is_flsensordirect(DirectTerm,SensCall,DelayCond),
	!,
	compile_defsensor_direct(SensCall,DelayCond,Direct,S1),
	query_struct(Direct,QueryCode),
	( no_errors_found(S1) -> 
	    flora_intern_code([QueryCode],NULL,PrologCode,S2),
	    ( no_errors_found(S2) -> call(PrologCode)
	    ; true
	    ),
	    directive_struct(Direct,Code),
	    append(S1,S2,Status)
	; Status = S1
	),
	!.

compile_direct(DirectTerm,_Idx,CodeList,NO_ERRORS) :-
	is_flsetsemantics(DirectTerm,OptionsList),
	!,
	is_fllist(OptionsList,L,_T,_I),
	report_semantic_options(L),
	CodeList = [],
	!.

%% prefix definition
compile_direct(DirectTerm,_Idx,Code,NO_ERRORS) :-
	is_flprefixdef(DirectTerm,PrefixName,Locality,PrefixExpansion),
	!,
	FLLIBPREFIXDEF(PrefixName,PrefixExpansion),
	thismodule_struct(ThisModule),
	(Locality == global
	->
	    florasyslib_struct(FLLIBPREFIXDEF,3,[ThisModule,PrefixName,PrefixExpansion],Code1),
	    query_struct(Code1,QCode),
	    Code = [QCode]
	%% prefix local to file, not inheritable
	; Code = []
	).

%% :- compiler_options
compile_direct(DirectTerm,_Idx,Code,Status) :-
	is_flcmpopt(DirectTerm,OptList),
	compile_compiler_options(OptList,Code,Status),
	!.
	
%% :- ignore_depchk
compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_flignoredep(DirectTerm,SpecList),
        set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
        set_context(CONTEXT_COMPILER_IGNOREDEP),
	compile_ignoredep_list(SpecList,SCode,Status),
        clear_context(CONTEXT_COMPILER_IGNOREDEP),
        clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
        !,
	( no_errors_found(Status) -> 
	    ignoredep_struct(SCode,LatentQueryode),
	    directive_struct(LatentQueryode,Code)
        ;   true
        ),
	!.

compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_importmodule(DirectTerm,Modspec) ->
	compile_body_pathexp_top(Modspec,FL_THISMODULE,Obj,_Oid,_Cd,[],Status),
	importmodule_struct(Obj,Code1),
	directive_struct(Code1,Code),
	!,
	(is_flbuiltin_identifier(Modspec,MName,Index),
	    flora_system_module(MName)
	-> report_option(FLSYSMOD(MName),Index)
	; true
	),
	!.

compile_direct(DirectTerm,_Idx,[],Status) :-
	is_flsymbolcontext(DirectTerm,SymbolList),
	compile_symbol_context_list(SymbolList,Status).

/****************************************************************************
  compile_ignoredep_list(+SpecList,-CodeList,-Status)
  compile a list of ignoredep sepcifications
****************************************************************************/
compile_ignoredep_list([],[],NO_ERRORS) :- !.
compile_ignoredep_list([H|L],[HCode|LCode],Status) :-
        compile_body(H,HCode,S),
	( no_errors_found(S) -> compile_ignoredep_list(L,LCode,Status)
        ;
            Status = S
        ),
	!.

/****************************************************************************
  Compile :- compiler_options(OptList) of FLORA (not XSB)
****************************************************************************/
compile_compiler_options([],[],NO_ERRORS) :- !.
compile_compiler_options([Opt|Rest],Code,Status) :-
	compile_compiler_option(Opt,OptCode,S1),
	(S1 == NO_ERRORS ->
	    compile_compiler_options(Rest,RestCode,Status),
	    (OptCode == [] -> Code = RestCode
	    ; Code = [OptCode|RestCode]
	    )
	; Status = S1
	).

compile_compiler_option(CmpOpt,OptCode,Status) :-
	is_flplib(CmpOpt,FltermOpt),
	is_flterm(FltermOpt,Funct,2,[OptionParserTerm,ValueParseTerm]),
	is_flatom(Funct,FL_UNIVEQ),
	!,
	is_flatom(OptionParserTerm,RealOption),
	( %% Prolog compiler options of the form prolog(opt,opt,...)
	    RealOption == FL_PROLOG ->
	    compile_body_pathexplist(ValueParseTerm,FL_THISMODULE,PlgOptListCode,_,_,[],Status),
	    cmpopt_struct(PlgOptListCode,PrCode),
	    directive_struct(PrCode,OptCode)
	%% expert=on/off, prduction=on/off modes
	; is_flatom(ValueParseTerm,Switch) ->
	    OptCode = [],
	    (RealOption == FL_PRODUCTION, Switch == on ->
		%% suppress trace info for better performance
		set_production_mode(on),
		Status = NO_ERRORS
	    ; RealOption == FL_PRODUCTION, Switch == off ->
		set_production_mode(off),
		Status = NO_ERRORS
	    ; RealOption == FL_EXPERT, Switch == on ->
		set_expert_mode(on),
		Status = NO_ERRORS
	    ; RealOption == FL_EXPERT, Switch == off ->
		set_expert_mode(off),
		Status = NO_ERRORS
	    ; RealOption == FL_OMNIFORM, Switch == on ->
		set_omniform_mode(on),
		Status = NO_ERRORS
	    ; RealOption == FL_OMNIFORM, Switch == off ->
		set_omniform_mode(off),
		Status = NO_ERRORS
            /*
	    ; RealOption == FL_QUANTTYPEDVARS, Switch == on ->
		set_quantified_typed_var_mode(on),
		Status = NO_ERRORS
	    ; RealOption == FL_QUANTTYPEDVARS, Switch == off ->
		set_quantified_typed_var_mode(off),
		Status = NO_ERRORS
            */
	    ;  approx_flindex(ValueParseTerm,Index),
		compiling_error(Index,ERROR_CMPOPT,Err),
		Status = [Err]
	    )
	;
	    approx_flindex(CmpOpt,Index),
	    compiling_error(Index,ERROR_CMPOPT,Err),
	    Status = [Err]
	).

compile_compiler_option(CmpOpt,_OptCode,Status) :-
	approx_flindex(CmpOpt,Index),
	compiling_error(Index,ERROR_CMPOPT,Err),
	Status = [Err].

%% If production mode is set in the shell then it persists across files.
%% Otherwise, it is local to files.
set_production_mode(X) :-
	var(X),
	!,
	(has_persistentoption(production_mode) -> X=on
        ; has_permaoption(production_mode) -> X=on
	; X=off
	).
set_production_mode(on)  :-
        (compiling_flrshell_command -> set_persistentoption(production_mode)
        ; set_permaoption(production_mode)
        ).
set_production_mode(off) :-
        (compiling_flrshell_command -> 
            clear_one_persistentoption(production_mode)
        ; clear_one_permaoption(production_mode)
        ).
has_production_mode :-
        (has_permaoption(production_mode)
        ;
            has_persistentoption(production_mode)
        ).

set_expert_mode(X) :-
	var(X),
	!,
	(has_persistentoption(FL_EXPERT) -> X=on
	; X=off
	).
set_expert_mode(on)    :- set_persistentoption(FL_EXPERT).
set_expert_mode(off)   :- clear_one_persistentoption(FL_EXPERT).
expert_mode_setting(X) :-
        (has_persistentoption(FL_EXPERT) -> X = on
        ; X = off
        ).

set_omniform_mode(X) :-
	var(X),
	!,
	(has_persistentoption(FL_OMNIFORM) -> X=on
	; X=off
	).
set_omniform_mode(on)    :- set_persistentoption(FL_OMNIFORM).
set_omniform_mode(off)   :- clear_one_persistentoption(FL_OMNIFORM).
omniform_mode_setting(X) :-
        (has_persistentoption(FL_OMNIFORM) -> X = on
        ; X = off
        ).

/*
set_quantified_typed_var_mode(X) :-
	var(X),
	!,
	(has_persistentoption(FL_QUANTTYPEDVARS) -> X=on
	; X=off
	).
set_quantified_typed_var_mode(on)    :- set_persistentoption(FL_QUANTTYPEDVARS).
set_quantified_typed_var_mode(off)   :- clear_one_persistentoption(FL_QUANTTYPEDVARS).
*/

/*
compile_encoding_directive(Encoding,CodePlgOpt,CodeFlrOpt) :-
        atomobj_struct(Encoding,EncodingCode),
        %% set character set flag
        generate_prolog_liblit(character_set,1,[EncodingCode],CodeOpt),
        cmpopt_struct([CodeOpt],CodePlgOpt),
        generate_prolog_liblit(set_prolog_flag,2,[character_set,EncodingCode],Code1),
        generate_prolog_liblit(flora_set_streams_character_set,1,[EncodingCode],flrencoding,Code2),
        conjunct_struct(Code1,Code2,CodeFlrOpt).
*/



/*****************************************************************************
** Some use_udf - related predicates
*****************************************************************************/
compile_useudf_directive(PairList,Idx,Status) :-
	verify_symbol_context_pairlist(PairList,Idx, USE_UDF_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status1),
        catch(maplist(useudf_option(_,_),PairList,PermaOptions),
              ErrorMsg,
              compiling_error(Idx,ErrorMsg,Err)),
	set_permaoptions(PermaOptions),
        (var(Err) -> Status = Status1
        ; Status = [Err|Status1]
        ).
        

useudf_option(FunName/Arity/_Idx,PermaOption) :-
	flatom_struct(FunName,NO_INDEX,Funct),
	new_udf_predicate(Funct,_FunCompiled,FunNameCode,UDFCode,Arity,_,_NewHead,NewHeadPredName,NewHeadPredArity,_NewReturnValue,NewHeadCode,Status),
	( \+no_errors_found(Status) ->
            flora_concat_atoms([ERROR_UDF,', ',FunName,'/',Arity],ErrorMsg),
            throw(ErrorMsg)
	; true),
	flora_modularize_atom(NewHeadPredName,FLORA_DEFAULT_WORKSPACE,
			      NewHeadPredNameModularized),
	NewHeadPredArity1 is NewHeadPredArity+1,
	(\+current_predicate(NewHeadPredNameModularized/NewHeadPredArity1),
	    compiling_flrshell_command
	->
            flora_concat_atoms([ERROR_UDF_WITHOUT_DEFINITION,', ',FunName,'/',Arity],
                               ErrorMsg),
            throw(ErrorMsg)
	; PermaOption = udf_option(FunNameCode,Arity,UDFCode,NewHeadCode),
	    asserta(flora_used_udf_registry(FunNameCode,Arity,UDFCode,NewHeadCode))
	).
	


/****************************************************************************
  compile_symbol_context_list(+SymbolsList,-Status)
  compile a list of symbols for which compiler does NOT check context usage
****************************************************************************/
compile_symbol_context_list([],NO_ERRORS) :- !.
compile_symbol_context_list([H|L],Status) :-
        compile_symbol_literal(H,S),
	( no_errors_found(S) -> compile_symbol_context_list(L,Status)
        ;
            Status = S
        ),
	!.

/****************************************************************************
  compile_symbol_literal(+ParserTerm,-Status)
  compile_symbol_literal(+ParserTerm,+SymContext,-Status)
  compile a symbol for which compiler does NOT check context usage
  SymContext here is FUNCTION_SYMBOL,PREDICATE_SYMBOL,UDF_SYMBOL,
            ANY_SYMBOL_CONTEXT, etc.
****************************************************************************/
compile_symbol_literal(ParserTerm,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,FL_THISMODULE,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status)
	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,FL_THISMODULE,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FL_THISMODULE,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flbuiltin_identifier(ParserTerm,Atom,Idx) ->
	    flatom_struct(Atom,Idx,ParserTerm1),
	    compile_symbol_term(ParserTerm1,0,NULL,FL_THISMODULE,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FL_THISMODULE,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionaltermdescriptor(ParserTerm,Funct,Arity) ->
	    compile_symbol_term(Funct,Arity,NULL,FL_THISMODULE,ANY_SYMBOL_CONTEXT,TRANSACTIONAL_SYMBOL,Status)
	; is_fltermdescriptor(ParserTerm,Funct,Arity) ->
	    compile_symbol_term(Funct,Arity,NULL,FL_THISMODULE,ANY_SYMBOL_CONTEXT,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fludfsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,UDF_SYMBOL,Status)
	; is_flsensorsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,SENSOR_SYMBOL,Status)
	; is_flprlgsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,PROLOG_SYMBOL,Status)
	; is_flworkspace(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	; is_flfloralib(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL_CONTEXT_DIR,Err),
	    Status = [Err]
	),
	!.

compile_symbol_literal(ParserTerm,WS,SymContext,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,WS,SymContext,TRANSACTIONAL_SYMBOL,Status)
	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,WS,SymContext,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,WS,SymContext,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flbuiltin_identifier(ParserTerm,Atom,Idx) ->
	    flatom_struct(Atom,Idx,ParserTerm1),
	    compile_symbol_term(ParserTerm1,0,NULL,WS,SymContext,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,WS,SymContext,TRANSACTIONAL_SYMBOL,Status)
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL_CONTEXT_DIR,Err),
	    Status = [Err]
	),
	!.

/****************************************************************************
  compile_symbol_term(+Funct,+N,+Args,+WS,+SymContext,+Transactional,-Status)
  SymContext here is FUNCTION_SYMBOL,PREDICATE_SYMBOL,UDF_SYMBOL,
            ANY_SYMBOL_CONTEXT, etc.
****************************************************************************/
compile_symbol_term(Funct,0,_Args,FL_THISMODULE,_SymContext,NONTRANSACTIONAL_SYMBOL,NO_ERRORS) :-
	flora_get_flatomvar_name(Funct,FLORA_WARNOFF),
	set_turnoff_symbol_warnings_flag(FLORA_WARNOFF),
	!.

compile_symbol_term(Funct,0,_Args,FL_THISMODULE,_SymContext,NONTRANSACTIONAL_SYMBOL,NO_ERRORS) :-
	flora_get_flatomvar_name(Funct,FLORA_CONSTOFF),
	set_turnoff_symbol_warnings_flag(FLORA_CONSTOFF),
	!.

compile_symbol_term(Funct,N,Args,WS,SymContext,Transactional,Status) :-
	flora_get_flatomvar_name(Funct,Name),
	(symbol_star_argument(Args) ->
		(N=:=1 ->
		    add_nowarn_symbol(Name,FL_STAR,WS,SymContext,Transactional),
		    Status = NO_ERRORS
		;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_SYMBOL_CONTEXT_STAR_ARG,Err),
		    Status = [Err]
		)
	;
		add_nowarn_symbol(Name,N,WS,SymContext,Transactional),
		Status = NO_ERRORS
	),
        !.

compile_symbol_term(Funct,_N,_Args,_WS,_SymContext,_Transactional,[Err]) :-
        approx_flindex(Funct,ErrIdx),
	compiling_error(ErrIdx,UNALLOWED_SPEC_IN_SYMBOL_CONTEXT,Err).


/****************************************************************************
  symbol_star_argument(+Args)
****************************************************************************/
symbol_star_argument([HArg]) :-
	flora_get_flatomvar_name(HArg,ArgName),
	ArgName==FL_STAR,
	!.

symbol_star_argument([HArg,_TArgs]) :-
	flora_get_flatomvar_name(HArg,ArgName),
	ArgName==FL_STAR,
	!.

symbol_star_argument([_HArg,TArgs]) :-
	symbol_star_argument(TArgs).

/****************************************************************************
  compile_atomvar(+T,-Code)

  T is a variable structure, or an atom structure, or a plain atomic.
****************************************************************************/
compile_atomvar(T,Code) :-
	( is_flvariable(T,TName,I) -> varobj_struct(TName,I,Code)
	; 
	    atomobj_struct(T,Code)
	),
	!.

/****************************************************************************
   compile_defsensor_direct(+SensCall,+DelayCond,-Direct,-Status)

   Compile a sensor directive.
****************************************************************************/
compile_defsensor_direct(SensCall,DelayCond,Code,Status) :-
	(flprologlib_atom_arity(SensCall,SensName,SensArity)
	%% sensor defined in a .flr file: declare it as prolog
	->
	    flora_scramble_atom(SensName,SensNameWithFloraPrefix),
	    set_permaoption(atomreplacement(SensName,SensArity,SensNameWithFloraPrefix)),
	    %% temporarily record as sensor
	    set_permaoption(defsensor(SensName,SensArity))
	; flprologlib_atom_arity_mod(SensCall,SensName,SensArity,ModName),
	    %% sensor defined in a prolog module
	    %%SensArity2 is SensArity+2,
	    set_permaoption(defsensor(SensName,SensArity,ModName))
	    %%flora_define_prolog(SensName,SensArity2,ModName)
	),
	set_context(CONTEXT_COMPILER_SENSOR_DIRECTIVE(SensName,SensArity)),
	%% flprologlib_call converts flplib into flterm.
	%% This is needed because atomreplacement takes place in
	%% termlit_struct, which takes flterm's.
	flprologlib_call(SensCall,SensFLtermCall),
	compile_body_literal_top(SensFLtermCall,FL_THISMODULE,OidCode,WSCode,[],S1),
	conjunct_struct(OidCode,WSCode,SensCode),
	(no_errors_found(S1) ->
	    detach_flworkspace(DelayCond,DelayCondSansWS,WS),
	    compile_body_literal_top(DelayCondSansWS,WS,DelayOidCode,DelayWSCode,[],S2),
	    conjunct_struct(DelayOidCode,DelayWSCode,DelayCheckCode)
	; S2 = S1
	),
	(no_errors_found(S2) ->
	    %% record symbol as sensor symbol, for error checking
	    flprologlib_functor(SensCall,SensFunct),
	    verify_symbol_context(SensFunct,SensArity,
				  SENSOR_SYMBOL,NONTRANSACTIONAL_SYMBOL,
				  Status)
	; Status = S2
	),
	!,
	report_option(FLSYSLIB(FLLIBSENSOR),NO_INDEX),
	prologterm_struct(FLLIBREGISTERSENSOR,2,[SensCode,DelayCheckCode],Code),
	clear_context(CONTEXT_COMPILER_SENSOR_DIRECTIVE(SensName,SensArity)).
	


/****************************************************************************
  compile_fact(+Head,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-MetaFactDiffList,-Status)
  compile_fact_add(+Head,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-MetaFactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used to optimize append
  SigDiffList list of insert rule signature commands.
               These are executed prior to loading
  FactDiffList is a difference list of facts

  Note: a fact containing a path expression might cause this
        fact to become a rule. However, we strip annotations from facts in
	the parser, so no need here to take rule tag/meta info into account.
****************************************************************************/
compile_fact(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,MetaFactDiffList,Status) :-
	set_context(CONTEXT_COMPILER_FACTS),
	compile_head_top(Head,_HeadNF,fact,HeadCode,H2BCodeFront,H2BCodeBack,HeadStat),
	!,
	( no_errors_found(HeadStat) ->
	    compile_factlist(HeadCode,DescriptorIdCode,DescrVarsTerm,H2BCodeFront,H2BCodeBack,RuleDiffList,SigDiffList,FactDiffList,MetaFactDiffList),
	    (has_context(CONTEXT_COMPILER_UDF_DEFINITION) -> S2 = NO_ERRORS
	    %% for UDFs, variables are checked separately
	    ; check_rule_vars_for_safety(Head,[],S2)
	    ),
	    append(HeadStat,S2,Status)
        ;
	  Status=HeadStat
	),
	!,
	clear_context(CONTEXT_COMPILER_FACTS).

compile_fact_add(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,MetaFactDiffList,Status) :-
	set_context(CONTEXT_COMPILER_FACTS), 
	compile_head_top(Head,_HeadNF,fact,HeadCode,H2BCodeFront,H2BCodeBack,HeadStat),
	!,
	( no_errors_found(HeadStat) ->
	    compile_factlist_add(HeadCode,DescriptorIdCode,DescrVarsTerm,H2BCodeFront,H2BCodeBack,RuleDiffList,FactDiffList,MetaFactDiffList),
	    (has_context(CONTEXT_COMPILER_UDF_DEFINITION) -> S2 = NO_ERRORS
	    %% for UDFs, variables are checked separately
	    ; check_rule_vars_for_safety(Head,[],S2)
	    ),
	    append(HeadStat,S2,Status)
        ;
	    Status=HeadStat
	),
	!,
	clear_context(CONTEXT_COMPILER_FACTS).


/****************************************************************************
  compile_factlist(+FactListCode,+DescriptorIdCode,+DescrVarsTerm,+H2BCodeFront,+H2BCodeBack,-RuleDifferenceList,-SigDiddList,-FactDifferenceList-MetaFactDiffList)

  This predicate takes a conjunction of atoms and splits into a
  difference list.

  If a fact is declared as a prolog term, it is put into the rule list,
  so it would be dumped as a normal Prolog fact rather than be put in a trie.
****************************************************************************/
compile_factlist([],_,_,_,_,RuleList-RuleList,SigList-SigList,FactList-FactList,MetaFactList-MetaFactList) :- !.
compile_factlist([F|FList],DescriptorIdCode,DescrVarsTerm,[H2BF|H2BCodeFront],[H2BB|H2BCodeBack],RuleList-RuleListTail,SigList-SigListTail,FactList-FactListTail,MetaFactList-MetaFactTail) :-
	!,
        %% MetaFactList is used here ONLY in order to indicate that there is
        %% meta-info available and so the .flm file will be loaded
        %% by flrutils.
	( H2BF == NULL, H2BB == NULL ->
	    compile_plain_fact(F,RuleList-RT,FactList-FT),
	    MetaFactList = MT,
	    SigList = ST
	;
	    (var(DescriptorIdCode) ->
		approx_prindex(F,FIdx),
		compile_descriptor_list([]-FIdx,FL_DESCRMODE_RULE,DescriptorIdCode,DescrVarsTerm,MetaFactList-MT,_)
	    ;
		MT = MetaFactList
	    ),
            %% The rule enabling meta info is generated directly
            %% from DescriptorIdCode, not from the MetaFactList.
            %% MetaFactList is used only to tell flrutils that meta-data exists
	    construct_rule_enabling_test(DescriptorIdCode,FL_DESCRMODE_RULE,RuleEnablerTest,_),
	    PreBody = RuleEnablerTest,
	    make_one_rule_and_signature(F,H2BF,H2BB,NULL,PreBody,NULL,NULL,DescriptorIdCode,DescrVarsTerm,RuleList-RT,SigList-ST),
	    FactList = FT
	),
	compile_factlist(FList,DescriptorIdCode,DescrVarsTerm,H2BCodeFront,H2BCodeBack,RT-RuleListTail,ST-SigListTail,FT-FactListTail,MT-MetaFactTail).

compile_factlist_add([],_,_,_,_,RuleL-RuleL,FactL-FactL,MetaL-MetaL) :- !.
compile_factlist_add([F|FList],DescrIdCode,DescrVarsTerm,[H2BF|H2BCodeFront],[H2BB|H2BCodeBack],RuleList-RuleListTail,FactList-FactListTail,MetaFactDiffList) :-
	!,
        %% The MetaFactDiffList here really contains just the rule-enabling code
	( H2BF == NULL, H2BB == NULL ->
	    compile_plain_fact(F,RuleList-RT,FactList-FT)
	; 
	    make_dynrule_from_fact(F,DescrIdCode,DescrVarsTerm,H2BF,H2BB,RuleList-RT,MetaFactDiffList),
	    FactList = FT
	),
	compile_factlist_add(FList,DescrIdCode,DescrVarsTerm,H2BCodeFront,H2BCodeBack,RT-RuleListTail,FT-FactListTail,MetaFactDiffList).

%% this is for fact-predicates that the compiler defines as prolog
%% using flora_define_prolog
compile_plain_fact(F,[FCode|ListTail]-ListTail,FL-FL) :-
	is_prologterm(F,_,_),
	!,
	(has_context(CONTEXT_COMPILER_FOR_ADDITION)
	->
	    generate_prolog_liblit(assert,1,[F],FCode1),
	    query_struct(FCode1,FCode)
	; fact_struct(F,FCode)
	),
	!.
%% these are just facts, possibly conjuncted (eg, as a result of compilation of
%% a:b[c->d])
compile_plain_fact(F,RulesList-RTail,FactList-FTail) :-
	is_prconjunct(F,F1,F2),
	!,
	compile_plain_fact(F1,RulesList-RuleTail,FactList-FactTail),
	compile_plain_fact(F2,RuleTail-RTail,FactTail-FTail).
compile_plain_fact(F,RL-RL,[FCode|ListTail]-ListTail) :-
	!,
	process_contextvars_in_prterm(F),
        collect_prvars(F,FVars),
        %% TODO: Why collect dynvars here??? The testsuite seems to run anyway.
        get_dynrule_varlist(FVars,DynVars),
	NDynVars = DynVars,
        ( NDynVars == [] -> fact_struct(F,FCode)
        ;
            add_fact_attr_code(NDynVars,F,AugmentedF),
            fact_struct(AugmentedF,FCode)
        ),
	!.


/*
%% simplified static rules from fact - unused
%% instead - use make_one_rule_and_signature
make_rule_from_fact(H,H2BF,H2BB,RulesList-RTail) :-
	is_prconjunct(H,H1,H2),
	!,
	make_rule_from_fact(H1,H2BF,H2BB,RulesList-RuleTail),
	make_rule_from_fact(H2,H2BF,H2BB,RuleTail-RTail).
make_rule_from_fact(H,H2BF,H2BB,[Rule|RT]-RT) :-
	conjunct_struct(H2BF,H2BB,FullBody),
	rule_struct(H,FullBody,Rule).
*/

make_dynrule_from_fact(H,DescrIdCode,DescrVarsTerm,H2BF,H2BB,RulesList-RTail,Meta) :-
	is_prconjunct(H,H1,H2),
	!,
	make_dynrule_from_fact(H1,DescrIdCode,DescrVarsTerm,H2BF,H2BB,RulesList-RuleTail,Meta),
	make_dynrule_from_fact(H2,DescrIdCode,DescrVarsTerm,H2BF,H2BB,RuleTail-RTail,Meta).
make_dynrule_from_fact(H,DescrIdCode,DescrVarsTerm,H2BF,H2BB,[Code|RT]-RT,MetafactsDiffList) :-
	approx_prindex(H,RuleIdx),
	/*
	(var(DescrIdCode) ->
	    compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_ADDRULE,DescrIdCode,DescrVarsTerm,_MetaFactDiffList,_)
	; true
	),
	*/
	get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
	%% Rule enabler for facts-turned-rules
	construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_ADDRULE,RuleEnablerTest,FileName),
	list_struct([H],[],HeadCodeList),
	list_struct([H2BF],[],H2BCodeFrontList),
	list_struct([H2BB],[],H2BCodeBackList),
	list_struct([FL_TRUE],[],PostBodyList), %% delay checker
        copy_term(MetafactsDiffList,MetafactsDiffListCopy),
	MetafactsDiffListCopy = MetafactsList - [],
	list_struct(MetafactsList,[],MetaFactCode),
	list_struct([],[],EmptyListCode), %% empty list
	HVL = EmptyListCode,
	HBL = EmptyListCode,
	PreBody = RuleEnablerTest,
	florasyslib_struct(FLSYSRULEUPDATE,15,
			   [DescrIdCode,FileName,DescrVarsTerm,
			    StmtNum,
			    MetaFactCode, %% Meta facts
			    HeadCodeList,
			    FL_TRUE, %% Body
			    HVL,HBL, %% HVL,HBL
			    FL_TRUE, %% DTvarscode
			    H2BCodeFrontList,
			    H2BCodeBackList,
			    PreBody,
			    PostBodyList, %% postbody, delay checker
			    FL_TRUE], %% defeat condition
			   RuleCode),
	list_struct([RuleCode],[],RuleCodeList),
	updaterule_syslib(FL_INSERTRULE_Z,UpdateruleLib),
	florasyslib_struct(RuleIdx,UpdateruleLib,1,[RuleCodeList],SysLibCode),
	query_struct(SysLibCode,Code).

add_dynrule_attr_code([],Code,Code) :- !.
add_dynrule_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code(Var,Val,FLDYNRULEVARCHECK,Code),
        add_dynrule_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

%% This is used when a rule appears in a fact (as a reified subterm).
%% In this case, we prepend a var_val(Var,Val) pair to the code.
%% In flrutils.P, flora_put_attr_and_insert_fact will execute
%% put_attr(Var,FLDYNRULEVARCHECK,Val) before asserting the fact.
%% If this rule is then ever inserted, its variables will be checked
%% for singletons and safety.
add_fact_attr_code([],Code,Code) :- !.
add_fact_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code_delayed(Var,Val,FLDYNRULEVARCHECK,Code),
        add_fact_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

attrvar_code(Var,Val,AttrName,Code) :-
	atomobj_struct(flora_put_attr,PutAttrFunct),
        atomobj_struct(AttrName,AttrCode),
        prologterm_struct(PutAttrFunct,3,[Var,AttrCode,Val],flrwhen,VCode),
        prologliblit_struct(VCode,Code).

%% This version creates record that will enable flrutils.P
%% flora_put_attr_and_insert_fact to create attributed variables
%% at insertion time
attrvar_code_delayed(Var,Val,AttrName,Code) :-
	atomobj_struct(var_val,VarValFunct), %% this is utilized in flrutils.P
        prologterm_struct(VarValFunct,3,[Var,AttrName,Val],Code).

/****************************************************************************
  compile_query(+Body,-QueryDiffList,-Status)

  QueryDiffList is a difference list in the form of [...|R]-R.
	It is used to optimize append/3
****************************************************************************/
compile_query(Body,_,[Err]) :-
	is_flterm(Body,Funct,2,_),
	is_flatom(Funct,FL_IMPLYOP,Idx),
	!,
	compiling_error(Idx,RULE_IN_PLACE_OF_QUERY,Err).
compile_query(Body,_,[Err]) :-
	is_flterm(Body,Funct,1,_),
	is_flatom(Funct,Sym,Idx),
	memberchk(Sym,[FL_IMPLYOP,FL_QUERYOP,FL_LATENT_QUERYOP]),
	!,
	compiling_error(Idx,SPURIOUS_SYMBOL,Err).
compile_query(Body,QueryList-QueryTail,Status) :-
	%% check for protected variables misuse
	collect_flvars(Body,BodyVars,ProtectedVars),
	protected_vars_warning(BodyVars,ProtectedVars,Stat_vars),
	(no_errors_found(Stat_vars) ->
	    compile_body_top(Body,BCode,Status_body),
            !,
	    ( no_errors_found(Status_body) -> 
		collect_prdatatypevars(BCode,DTVarsCodeList),
		conjunct_code(DTVarsCodeList,DTVarsCode),
		conjunct_struct(DTVarsCode,BCode,BodyCode),
		thismodule_struct(ThisMod),
		%% code to bind the CallerMod variable to the calling module
		caller_module_binding_code(ThisMod,CallerBindingCode),
		conjunct_struct(CallerBindingCode,BodyCode,AugmentedBodyCode),
		collect_name_var_pairs(Body,NV),
		list_struct(NV,[],NVCode),
		%% Note: we do not add delay-checker code FLORA_DELAY_CHECKER
		%% in queries, since it is explicit in FLLIBANSWER
		florasyslib_struct(FLLIBANSWER,2,[AugmentedBodyCode,NVCode],Goal),
		query_struct(Goal,QueryCode),
		QueryList = [QueryCode|QueryTail],
		append(Status_body,Stat_vars,Status)
	    ;
		Status = Status_body
	    )
	; Status = Stat_vars
	),
	!.

/******************************************************************************
    compile_latent_query(+DescrIdCode,+MetaFactDiffList,+Body,+Mode,-LatentQueryDiffList,-Status)
******************************************************************************/
compile_latent_query(DescrIdCode,MetaFactDiffList,Body,Mode,LatentQueryList-LatentQueryTail,Status) :-
	compile_body_top(Body,BCode,BodyStatus),
        !,
	( no_errors_found(BodyStatus) -> 
	    collect_prdatatypevars(BCode,DTVarsCodeList),
	    conjunct_code(DTVarsCodeList,DTVarsCode),
	    conjunct_struct(DTVarsCode,BCode,LatentQueryBodyCode),
	    thismodule_struct(ThisMod),
	    %% code to bind the CallerMod variable to the calling module
	    caller_module_binding_code(ThisMod,CallerBindingCode),
	    construct_rule_enabling_test(DescrIdCode,Mode,LatentQueryEnablerTest,_),
	    conjunct_struct(CallerBindingCode,LatentQueryEnablerTest,PreLatentQueryCode),
	    get_current_compile_file(File),
	    (approx_prindex(DescrIdCode,Idx), Idx \== NO_INDEX -> true
	    ; approx_flindex(Body,Idx)
	    ),
	    get_current_stmt_number_for_descriptor(Idx,StmtNum),
	    MetaFactDiffList = MetaFactList - [],
	    list_struct(MetaFactList,[],MetaFactCode),
	    %% Note: we do not add delay-checker code FLORA_DELAY_CHECKER
	    %% in constraints, since it is explicit in FLLIBANSWER
	    florasyslib_struct(FLLIBINSQUERYSIG,7,[DescrIdCode,File,ThisMod,StmtNum,MetaFactCode,PreLatentQueryCode,LatentQueryBodyCode],LatentQuerySigCodePre),
	    (has_context(CONTEXT_COMPILER_GOAL_REIFICATION) -> LatentQuerySigCode = LatentQuerySigCodePre
	    ; query_struct(LatentQuerySigCodePre,LatentQuerySigCode)
	    ),
	    LatentQueryList = [LatentQuerySigCode|LatentQueryTail]
	;
	  true
	),
        check_latent_query_prvars_for_safety((DescrIdCode,MetaFactDiffList),
                                             Body, VarStat),
        flatten([BodyStatus,VarStat],Status),
	!.


/****************************************************************************
  compile_annotated_construct(+DescriptorList,+MainPartOfRule,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,-MetaFactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used for append/3 optimization
  SigDiffList = diff list of rule signatures
  FactDiffList = the diff list of facts
		 FactList includes meta-facts
****************************************************************************/
compile_annotated_construct(DescriptorList,MainPartOfRule,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFacts-MetaFactsTail,Status) :-
	approx_flindex(MainPartOfRule,RuleIdx),
	(is_fllatent_query(MainPartOfRule,_) -> Mode = FL_DESCRMODE_LATENT_QUERY
        ; is_fludfdef(MainPartOfRule,_,_,_) -> Mode = FL_DESCRMODE_UDFRULE
        ; is_fludfdef_fact(MainPartOfRule,_,_) -> Mode = FL_DESCRMODE_UDFRULE
	; Mode = FL_DESCRMODE_RULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTerm,MetaFacts-MetaFactsTail,Status1),
        !,
	( no_errors_found(Status1) -> 
	    %% this rule won't bring any new meta facts
	    compile_internal(MainPartOfRule,DescrIdCode,DescrVarsTerm,
			     RuleDiffList,SigDiffList,
			     FactDiffList,QueryList,LatentQueryList,
			     []-[],
			     _UDFPreds,Status2),
            append(Status1,Status2,Status)
	;  Status = Status1
	),
	!.


/*
 compile_descriptor_list(+DescriptorList-RuleIdx,+Mode,-DescrIdCode,-DescrVarsTermOut,
                         -MetaFactDiffList,-Status)
 Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE.
        The FL_DESCRMODE_PLAIN_QUERY mode is used for the @!{...} queries.
        The FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
        FL_DESCRMODE_DYNRULE is for dynamic rules.
 DescrVarsTermOut normally is output as vars(VariablesInDescriptorList)
 If DescrVarsTermOut is bound then we assume that we are compiling
     for the clause{....} statement and so we pass a new unbound variable to
     compile_descriptor_list1, so MetaFacts will have unbound variable as arg 2.
     This is what we need for clause{....}
*/
compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTermOut,MetaFacts-MetaFactsTail,Status) :-
	flatten(DescriptorList,FlatDescrList),
	%% First, extract the code for the rule id
	findall(IdTerm-Idx,
		member(FLDESCRIPTOR(IdTerm,FLRULEID,Idx),FlatDescrList),
		IdParserTermList),
	!,
	push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	set_context(CONTEXT_COMPILER_DESCRIPTORS(Mode)),
	(length(IdParserTermList,Len), Len > 1
	-> IdParserTermList = [_,_-Idx|_],
	    compiling_error(Idx,MULTIPLE_RULE_IDS,Err),
	    IdStatus = [Err]
	; IdParserTermList == [] % no explicit rule id
	->
	    construct_default_ruleid_descriptor(Mode,RuleIdx,DescrIdCode),
	    RuleidFrameCode = _M - _M,
	    ExplicitModule = NULL,
	    IdStatus = NO_ERRORS
	; IdParserTermList = [[IdParserTerm|_] - Idx],
	    %% compile Id descriptor here
	    %% The compiler assumes that descriptor frames are passed as
	    %% an unbroken OBJSPEC. Parser ensures that.
	    compile_ruleid_descriptor(IdParserTerm,DescrIdCode,RuleidFrameCode,ExplicitModule,IdStatus)
	),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_UDFRULE])
	->
	    collect_flvars(FlatDescrList,DescrVars),
	    compile_var_list(DescrVars,DescrVarsCode),
	    length(DescrVarsCode,VarListLen),
	    %% construct the term containing all the vars in the descriptor
            %% Do not use prolog liblit here - use prolog term.
            %% Liblits may get usermod: attached to them, which may cause
            %% misunification between _$_$_ergo'descr_vars and
            %% usermod:_$_$_ergo'descr_vars
	    %%generate_prolog_liblit(FL_DESCRIPTOR_VARS_WRAPPER,VarListLen,DescrVarsCode,DescrVarsTermOut)
            (VarListLen==0 -> 
                %% For arity=0, use atomobj, which generates just an atom.
                %% generate_prolog_term(_,0,_,_) makes atom(), which crashes XSB
                atomobj_struct(FL_DESCRIPTOR_VARS_WRAPPER,DescrVarsTermOut)
            ;
                generate_prolog_term(FL_DESCRIPTOR_VARS_WRAPPER,VarListLen,DescrVarsCode,DescrVarsTermOut)
            )
	%% we are compiling clause{...} or a query
	%% Generate a var in this case
	;   new_prvariable(NO_INDEX,DescrVarsTermOut)
	),
	get_current_compile_file_for_descriptor(CurrFileName,Mode),
	get_descriptor_module(ExplicitModule,Mode,DescrModule),
	(IdStatus == NO_ERRORS
         %%, Mode \== FL_DESCRMODE_UDFRULE
	->
	    extract_features_from_descriptor_list(FlatDescrList,DescrFeatures),
	    determine_defeasibility(DescrFeatures,Mode,DescrIdCode,CurrFileName,DescrModule,DescrVarsTermOut,DefeatMetaFact,StatDefeat),
	    (no_errors_found(StatDefeat) ->
		compile_descriptor_list1(FlatDescrList,Mode,DescrIdCode,CurrFileName,DescrModule,RuleidFrameCode,DescrVarsTermOut,MetaFacts1-MetaFactsTail,StatDescr),
                append(StatDefeat,StatDescr,Status),
		construct_rule_enabling_fact(DescrIdCode,CurrFileName,Mode,RuleEnablerFact),
		%% make the rule id into its tag as well, if no explicit tag
		(memberchk(FLTAG_FEATURE,DescrFeatures) -> TagIdMetaFact = NULL
		; construct_tag_descriptor_fact_from_id(DescrIdCode,CurrFileName,DescrModule,Mode,DescrVarsTermOut,TagIdMetaFact)
		),
		%% mandatory facts that are always there
		construct_type_descriptor_fact(DescrIdCode,CurrFileName,DescrModule,Mode,DescrVarsTermOut,TypeMetaFact),
		MetaFacts_pre = [TypeMetaFact,TagIdMetaFact,RuleEnablerFact,DefeatMetaFact|MetaFacts1],
		remove_all(NULL,MetaFacts_pre,MetaFacts)
	    ; Status = StatDefeat
	    )
	%% either status of Id is bad or it is udfrule,
	%% so no metafacts are to be generated
	; Status = IdStatus,
	    MetaFacts = []
	),
	clear_context(CONTEXT_COMPILER_DESCRIPTORS(Mode)),
	pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK).



/*
    determine_defeasibility(+FlatDescrList,+Mode,+DescrIdCode,+CurrFileName,+DescrModule,+DescrVarsTerm,-DefeatMetaFact,-Status)

    If more than one defeasibility descriptor - error
    If exactly one defeasibility descriptor - noop.
          Note: tag+strict is allowed because one might turn
	        defeasibility on later
    If no defeasibility specified:
          If tag is specified, assume defeasible.
          Otherwise: assume strict.
*/
%% If Mode=FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY then don't produce defeasibility fact
determine_defeasibility(_Features,Mode,_DescrIdCode,_FileName,_Module,_DescrVarsTerm,NULL,NO_ERRORS) :-
	memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_PLAIN_QUERY,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_UDFRULE]),
	!.
determine_defeasibility(DescrFeatures,Mode,DescrIdCode,FileName,Module,DescrVarsTerm,DefeatMetaFact,Status) :-
	memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_ADDRULE]),
	!,
	(memberchk(FL_DEFEASIBLE,DescrFeatures),
	    memberchk(FL_STRICT,DescrFeatures)
	->
	    approx_prindex(DescrIdCode,ErrIdx),
	    compiling_error(ErrIdx,MULTIPLE_RULE_DEFEASIBILITY_INDICATORS,Err),
	    Status = [Err]
	; \+ has_permaoption(FLDEFEASIBLE(_ArgTheory)),
	    memberchk(FL_DEFEASIBLE,DescrFeatures)
	-> %% defeasible is specified but no :- use_argumentation_theory
	    approx_prindex(DescrIdCode,ErrIdx),
	    compiling_error(ErrIdx,DEFEASIBLE_RULE_BUT_NO_ARGUMENTATION_THEORY,Err),
	    Status = [Err]
	; (memberchk(FL_DEFEASIBLE,DescrFeatures) ; memberchk(FL_STRICT,DescrFeatures))
	-> DefeatMetaFact = NULL, %% already specified
	    Status = NO_ERRORS
	; (memberchk(FLTAG_FEATURE,DescrFeatures) ; has_permaoption(FLDEFEASIBLE_RULE_DEFAULT))
	->
            (\+ has_permaoption(FLDEFEASIBLE(_ArgTheory)) ->
                %% tag is specified but no :- use_argumentation_theory
                %% this one is a warning only
                approx_prindex(DescrIdCode,WarnIdx),
                compiling_warning(WarnIdx,TAGGED_RULE_BUT_NO_ARGUMENTATION_THEORY,Warning),
                StatWarn = [Warning]
	    ; StatWarn = []
            ),
            %% If TAG is given, assume rule is defeasible by default.
            %% If rules are defeasible by default, also assume this
            %% rule is defeasible
            flatom_struct(FL_DEFEASIBLE,NO_INDEX,DefeasibleDescr),
            construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,
                                            DescrVarsTerm, DefeasibleDescr,
                                            [DefeatMetaFact|Tail]-Tail,StatDsc),
            append(StatWarn,StatDsc,Status)
	;  %% otherwise, assume strict rule
	    flatom_struct(FL_STRICT,NO_INDEX,StrictDescr),
	    construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,StrictDescr,[DefeatMetaFact|Tail]-Tail,Status)
	).


%% extract a list of interesting features from FlatDescrList.
%% features include: tag, strict, defeasible
extract_features_from_descriptor_list(DescrList,Features) :-
	extract_features_from_descriptor_list1(DescrList,Features1),
	flatten(Features1,Features2),
	sort(Features2,Features).

extract_features_from_descriptor_list1([],[]) :- !.
extract_features_from_descriptor_list1([Descr|DescrList],[DFeatures|Features]) :-
	descriptor_feature(Descr,DFeatures),
	extract_features_from_descriptor_list1(DescrList,Features).

descriptor_feature(FLDESCRIPTOR(_,FLTAG,_), FLTAG_FEATURE) :- !.
descriptor_feature(FLDESCRIPTOR(FlAtom,FLBOOLDESCRIPTOR,_), Name) :-
	get_flatom_name(FlAtom,Name),
	(Name == FL_STRICT ; Name == FL_DEFEASIBLE),
	!.
descriptor_feature(FLDESCRIPTOR(List,FLRULEID,_), Features) :-
	!,
	extract_features_from_ruleid(List,Features).
%% this is unreachable for now
descriptor_feature(_Descriptor, []).

extract_features_from_ruleid([],[]) :- !.
extract_features_from_ruleid([First|Rest],[Features|RestFeatures]) :-
	detach_flworkspace(First,FirstSansWS,_),
	is_flobjspec(FirstSansWS,_,Spec,_),
	!,
	extract_features_from_objspec(Spec,Features),
	extract_features_from_ruleid(Rest,RestFeatures).
extract_features_from_ruleid([_|Rest],RestFeatures) :-
	extract_features_from_ruleid(Rest,RestFeatures).

extract_features_from_objspec(Spec,Features) :-
	is_flconjunct(Spec,Left,Right),
	!,
	extract_features_from_objspec(Left,F1),
	extract_features_from_objspec(Right,F2),
	(is_list(F2) -> Features = [F1|F2]
	; Features = [F1,F2]
	).
extract_features_from_objspec(Spec, FLTAG_FEATURE) :-
	detach_flworkspace(Spec,SpecSansWS,_),
	is_flmvdattspec(SpecSansWS,Att,ArrowType,_,_),
	is_mvdspecop(ArrowType), %% FL_MVDARROW, ->
	get_flatom_name(Att,FL_TAG_PROPERTY),
	!.
extract_features_from_objspec(Spec, Name) :-
	detach_flworkspace(Spec,SpecSansWS,_),
	is_flmethspec(SpecSansWS,BoolProp,_),
	get_flatom_name(BoolProp,Name),
	(Name == FL_STRICT ; Name == FL_DEFEASIBLE),
	!.
extract_features_from_objspec(_Spec, []).


/*
   compile_descriptor_list1(+DescriptorList,+Mode,+DescrIdCode,+CurrFileName,+DescrModule,+RuleidFrameCode,+DescrVarsTerm,-MetaFactDiffList,-Status)
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_CLAUSE is used for the clause{...} construct.
        FL_DESCRMODE_PLAIN_QUERY is for the @!{...} metainfo queries in bodies.
        FL_DESCRMODE_DYNRULE is for dynamic rules.
	etc.
*/
compile_descriptor_list1([],_Mode,_DescrIdCode,_FileName,_Module,_RuleidFrameCode,_DescrVarsTerm,M-M,NO_ERRORS) :- !.
compile_descriptor_list1([Descriptor|RestDescr],Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFacts-MetaTail,Status) :-
	compile_descriptor(Descriptor,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFacts-Tail,S1),
	(no_errors_found(S1)
	->  
	    compile_descriptor_list1(RestDescr,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,Tail-MetaTail,Status)
	; Status = S1
	).


/*
   compile_descriptor(+Descriptor,+Mode,+DescrIdCode,+DescrVarsTerm,-MetaFactDiffList,-Status)
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_RULE - rule descriptor in static rules
        FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
        FL_DESCRMODE_PLAIN_QUERY - for @!{...} queries in rule bodies
        FL_DESCRMODE_DYNRULE is for dynamic rules.
	etc.
*/
compile_descriptor(Descriptor,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFactDiffList,Status) :-
	is_fldescriptor(Descriptor,DescrContents,Type,_Index),
	(Type == FLTAG
	-> construct_tag_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,MetaFactDiffList,Status)
	; Type == FLBOOLDESCRIPTOR
	-> construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,MetaFactDiffList,Status)
	; Type == FLRULEID 
	-> 
	    construct_prop_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,RuleidFrameCode,MetaFactDiffList,Status)
	),
	!.
%% already compiled
compile_descriptor(Descriptor,_Mode,_DescrIdCode,_FileName,_Module,_RuleidFrameCode,_DescrVarsTerm,Descriptor,NO_ERRORS) :- !.

compile_ruleid_descriptor(IdDescriptorWithFrame,DescrIdCode,FrameCode,ExplicitModule,Status) :-
	compile_complex_descriptor(IdDescriptorWithFrame,
				   frames_ok,
				   DescrIdCode,FrameCode,ExplicitModule,Status).


/*
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_RULE - rule descriptor in static (loaded) rules
        FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
	       In that case, the default rule Id is just a new variable.
	       Same for FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY: these Ids are set at run time,
	            so here we just make the id into a variable.
        FL_DESCRMODE_PLAIN_QUERY is for @!{....} queries to metainfo in rule bodies
        FL_DESCRMODE_DYNRULE is for dynamic rules inserted at run time by insertrule.
        FL_DESCRMODE_ADDRULE is for dynamic rules inserted by _add.
        FL_DESCRMODE_LATENT_QUERY is for for static (loaded) latent queries
        FL_DESCRMODE_LATENT_ADDQUERY is for for latent queries inserted by _add.
        FL_DESCRMODE_LATENT_DYNQUERY is for for latent queries inserted by insert{}.
        FL_DESCRMODE_UDFRULE is for rules created as part of the UDF encoding

     Now we just use the rule number generated by the lexer as rule Id
     for static and UDF rules.
     This is because previously we used long atoms 20 chars and longer,
     and this takes a huge amount of space on the heap.
*/
construct_default_ruleid_descriptor(FL_DESCRMODE_RULE,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_LATENT_QUERY,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_UDFRULE,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_ADDRULE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_LATENT_ADDQUERY,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_LATENT_DYNQUERY,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_DYNRULE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_CLAUSE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_PLAIN_QUERY,Idx,RuleIdCode) :-
	new_prvariable(Idx,RuleIdCode).

%% construct_tag_descriptor_facts(+DescrIdCode,+FileName,+Module,+Mode,+DescrVarsTerm,+DescrContent,-MetaFactDiffList,-Stat)
%% construct_bool_descriptor_facts(+DescrIdCode,+File,+Module,+Mode,+DescrVarsTerm,+DescrContent,-MetaFactDiffList,-Stat)
construct_tag_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,[TagIdMetaFact|Tail]-Tail,Status) :-
	compile_simple_descriptor(DescrContents,DescrContentsCode,Status),
	construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,TagIdMetaFact).

%% Like construct_tag_descriptor_facts/7, but uses DescrContentsCode (pr-obj)
%% instead of %% DescrContents (fl-obj)
%% Also takes ExplicitModule
construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,TagIdMetaFact) :-
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,DescrContentsCode,DescrVarsTerm], TagIdMetaTerm),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_LATENT_QUERY]) ->
            fact_struct(TagIdMetaTerm,TagIdMetaFact)
        ; Mode == FL_DESCRMODE_UDFRULE, \+ has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
            fact_struct(TagIdMetaTerm,TagIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    TagIdMetaTerm = TagIdMetaFact
	).

construct_file_descriptor_query(DescrIdCode,Module,DescrVarsTerm,FileVal,MetaTerm,NO_ERRORS) :-
	has_context(CONTEXT_COMPILER_BODY(_)),
	!,
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	new_dontcare_prvariable(NO_INDEX,SomeTagVar),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileVal,Module,SomeTagVar,DescrVarsTerm], MetaTerm).
construct_file_descriptor_query(DescrIdCode,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_FILE_DESCRIPTOR_PROP,Err).

construct_module_descriptor_query(DescrIdCode,FileName,DescrVarsTerm,ModuleVal,MetaTerm,NO_ERRORS) :-
	has_context(CONTEXT_COMPILER_BODY(_)),
	!,
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	new_dontcare_prvariable(NO_INDEX,SomeTagVar),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,ModuleVal,SomeTagVar,DescrVarsTerm], MetaTerm).
construct_module_descriptor_query(DescrIdCode,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_MODULE_DESCRIPTOR_PROP,Err).

construct_type_descriptor_query(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact,NO_ERRORS) :-
	has_context(CONTEXT_COMPILER_BODY(_)),
	!,
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).
construct_type_descriptor_query(DescrIdCode,_,_,_,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_TYPE_DESCRIPTOR_PROP,Err).

%% constructs the meta fact for the type property @!{id[type->rule/query/udf]}
construct_type_descriptor_fact(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,MetaFact) :-
	has_context(CONTEXT_COMPILER_BODY(_)),
	!,
	atomobj_struct(FL_TYPE_PROPERTY,Prop),
	(memberchk(Mode,[FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_QUERY])
        ->
            atomobj_struct(FL_DESCRTYPE_QUERY,Val)
	; memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE])
        ->
            atomobj_struct(FL_DESCRTYPE_RULE,Val)
	; Mode==FL_DESCRMODE_UDFRULE -> atomobj_struct(FL_DESCRTYPE_UDF,Val)
	%% Mode = FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_CLAUSE
	; new_prvariable(NO_INDEX,Val)
	),
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).
construct_type_descriptor_fact(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,MetaFact) :-
	atomobj_struct(FL_TYPE_PROPERTY,Prop),
	(memberchk(Mode,[FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_QUERY]) -> atomobj_struct(FL_DESCRTYPE_QUERY,Val)
	; memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE]) -> atomobj_struct(FL_DESCRTYPE_RULE,Val)
	; memberchk(Mode,[FL_DESCRMODE_CLAUSE]) -> atomobj_struct(FL_DESCRTYPE_RULE,Val)
	; Mode==FL_DESCRMODE_UDFRULE -> atomobj_struct(FL_DESCRTYPE_UDF,Val)
	;  %% this should be unreachable
	    flora_abort(['Compiler bug!!! construct_type_descriptor_fact: unreachable statement'], FLORA_ABORT_NOTRACE)
	),
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).


construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,[BoolIdMetaFact|Tail]-Tail,Status) :-
	compile_simple_descriptor(DescrContents,DescrContentsCode,Status),
	construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,BoolIdMetaFact).
%% Like construct_tag_descriptor_facts, but uses DescrContentsCode (pr-obj)
%% instead of DescrContents (fl-obj)
%% Boolean descriptors are things like @!{abc[BoolDescr]}, where BoolDescr is
%% a Boolean property of the descriptor's frame.
construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,BoolIdMetaFact) :-
	PredCode = FL_BOOL_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,DescrContentsCode,DescrVarsTerm], BoolIdMetaTerm),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_LATENT_QUERY]) ->
            fact_struct(BoolIdMetaTerm,BoolIdMetaFact)
        ; Mode == FL_DESCRMODE_UDFRULE, \+ has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
            fact_struct(BoolIdMetaTerm,BoolIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    BoolIdMetaTerm = BoolIdMetaFact
	).

%% construct_prop_descriptor_facts/8
construct_prop_descriptor_facts(_,_,_,_,_,NULL,Meta-Meta,NO_ERRORS) :- !.
construct_prop_descriptor_facts(_,_,_,_,_,FL_TRUE,Meta-Meta,NO_ERRORS) :- !.

construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,RuleidFrameCode,LeftMeta-RightTail,Status) :-
	is_prconjunct(RuleidFrameCode,Left,Right),
	!,
	construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,Left,LeftMeta-LeftTail,S1),
	(S1 == NO_ERRORS ->
	    construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,Right,LeftTail-RightTail,Status)
	; Status =S1
	).
%% this should be unreachable due to the parser, but just in case
construct_prop_descriptor_facts(_,_,_,Mode,_,RuleidFrameCode,_,[Err]) :-
	is_prdisjunct(RuleidFrameCode,_,_),
	memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_UDFRULE]),
	!,
	approx_prindex(RuleidFrameCode,Idx),
	compiling_error(Idx,NO_DISJUNCTS_DESCRIPTOR_FRAME,Err).

construct_prop_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,RuleidFrameCode,Metafacts,Status) :-
	(is_prworkspace(RuleidFrameCode,RealCode,ExplicitModule) -> true
        ; %% in case explicit module is a variable: query: @!{?Id[..]@?Mod}
            is_florasyslib_struct(RuleidFrameCode,_,FLLIBMODLIT,_, [RealCode,ExplicitModule,_]) -> true
	; RealCode = RuleidFrameCode, ExplicitModule = Module
	),
	%% change module to ExplicitModule
	construct_attrval_descriptor_facts(DescrIdCode,FileName,ExplicitModule,Mode,DescrVarsTerm,RealCode,Metafacts,Status).


%% construct_attrval_descriptor_facts/8 for attr-val pairs
construct_attrval_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,PRMVD(DescrIdCode,Prop,Val,_),[MetaFact|Tail]-Tail,Status) :-
	!,
	%% if property=tag: construct a tag metafact; else - property metafact
	(is_pratom(Prop,FL_TAG_PROPERTY) -> 
	    construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Val,MetaFact),
	    Status = NO_ERRORS
	; is_pratom(Prop,FL_FILE_PROPERTY) ->
            %% this is used only in rule/query bodies
	    construct_file_descriptor_query(DescrIdCode,Module,DescrVarsTerm,Val,MetaFact,Status)
	; is_pratom(Prop,FL_MODULE_PROPERTY) ->
            %% this is used only in rule/query bodies
	    construct_module_descriptor_query(DescrIdCode,FileName,DescrVarsTerm,Val,MetaFact,Status)
	; is_pratom(Prop,FL_TYPE_PROPERTY) ->
            %% this is used only in rule/query bodies
	    construct_type_descriptor_query(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact,Status)
	;
	    construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact),
	    Status = NO_ERRORS
	).

%% construct_attrval_descriptor_facts/8 for Boolean properties
construct_attrval_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,PRMETH(DescrIdCode,Val,_),[MetaFact|Tail]-Tail,NO_ERRORS) :-
	!,
	construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Val,MetaFact).

%% construct_attrval_descriptor_facts/8 for empty frames: empty metafacts
construct_attrval_descriptor_facts(DescrIdCode,_,_,_,_,PREXISTS(DescrIdCode,_),Meta-Meta,NO_ERRORS) :-
	!.

%% construct_attrval_descriptor_facts/8
construct_attrval_descriptor_facts(_DescrIdCode,_FileName,_Module,_Mode,_DescrVarsTerm,RuleidFrameCode,_DiffList,[Err]) :-
	approx_prindex(RuleidFrameCode,Idx),
	compiling_error(Idx,NO_NESTED_DESCRIPTOR_FRAME,Err).

%% constructs meta facts for 1 attr-value pair
construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact) :-
	PredCode = FL_PROP_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,6,[DescrIdCode,FileName,Module,Prop,Val,DescrVarsTerm], MetaTerm),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_LATENT_QUERY]) ->
            fact_struct(MetaTerm,MetaFact)
        ; Mode == FL_DESCRMODE_UDFRULE, \+ has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
            fact_struct(MetaTerm,MetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    MetaTerm = MetaFact
	).


get_descriptor_module(ExplicitMod,Mode,OutModule) :-
	(ExplicitMod \== NULL -> OutModule = ExplicitMod
	; memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_DYNRULE]) ->
	    new_prvariable(NO_INDEX,OutModule)
	; Mode == FL_DESCRMODE_PLAIN_QUERY -> thismodule_struct(OutModule)
	; %% FL_DESCRMODE_RULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY
	    thismodule_struct(OutModule)
	).

%% descriptor without attached frames
compile_simple_descriptor(DescrContents,Object,Status) :-
	compile_complex_descriptor(DescrContents,no_frames,Object,_,_,Status).

%% When compiling tags or bool descriptors,
%% no frames are allowed: FramesOK == no_frames
%% When compiling rule ids, frames are allowed: FramesOK == frames_ok
%% Object here becomes the rule Id code.
compile_complex_descriptor(DescrContentsWS,FramesOK,Object,FrameCode,ExplicitModule,Status) :-
	(FramesOK == frames_ok -> true
	; FrameCode = NULL
	),
	%% If we are compiling descriptor as part of compiling a path
	%% expression (eg, reification in the rule body) then we need to
	%% make sure that the next compile_pathexp/7 won't clear the
	%% CONTEXT_COMPILER_BODY_PATHEXP context.
	detach_flworkspace(DescrContentsWS,DescrContents,WS),
	(has_context(CONTEXT_COMPILER_BODY_PATHEXP),
	    compile_body_pathexp_top(DescrContents,WS,Object,NULL,FrameCode,[],S1) 
	-> set_context(CONTEXT_COMPILER_BODY_PATHEXP)
	;
	    compile_body_pathexp_top(DescrContents,WS,Object,NULL,FrameCode,[],S1)
	-> true
	; approx_flindex(DescrContents,Idx),
	    compiling_error(Idx,SIMPLE_FRAMES_IN_RULE_DESCRIPTORS,Err),
	    S1 = [Err]
	),
	
	%% don't let the user define a posint rule Id explicitly to avoid
	%% clashes. The only exception is the \@! constant. In the latter case,
	%% the context is set to CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS
	(is_pratom(Object,NULL,RidIdx) ->
            compiling_error(RidIdx,NO_NULL_AS_RULEID,Err2),
	    Status = [Err2|S1]
        ; has_context(CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS) -> Status = S1
	; is_prnumber(Object,RuleId,RidIdx), integer(RuleId), RuleId > 0 ->
	    compiling_error(RidIdx,NO_INTEGERS_AS_RULEID,Err2),
	    Status = [Err2|S1]
	; Status = S1
	),
	clear_context(CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS),

	(var(FrameCode) -> ExplicitModule = NULL
	; is_prworkspace(FrameCode,_,ExplicitModule) -> true
	; (is_prconjunct(FrameCode,Left,_) ; is_prdisjunct(FrameCode,Left,_)),
            is_prworkspace(Left,_,ExplicitModule)
	-> true
        ; %% in case explicit module is a variable: query: @!{?Id[..]@?Mod}
            (is_prconjunct(FrameCode,Left,_) ; is_prdisjunct(FrameCode,Left,_)),
            is_florasyslib_struct(Left,_,FLLIBMODLIT,_,[_,ExplicitModule,_])
        -> true
	; ExplicitModule = NULL
	).
	
%% construct_rule_enabling_fact(+DescrIdCode,+Mode,-RuleEnablerMetaFact)
%% For clause{...} and the @!{...} query, don't construct the rule-enabling fact
construct_rule_enabling_fact(_DescrIdCode,_FileName,FL_DESCRMODE_CLAUSE,NULL) :- !.
construct_rule_enabling_fact(_DescrIdCode,_FileName,FL_DESCRMODE_PLAIN_QUERY,NULL) :- !.
construct_rule_enabling_fact(DescrIdCode,FileName,Mode,RuleEnablerMetaFact) :-
	construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm),
        %% UDF rules don't have enabling tests
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_LATENT_QUERY]) ->
            fact_struct(RuleEnablerMetaTerm,RuleEnablerMetaFact)
        ; Mode == FL_DESCRMODE_UDFRULE ->
             (\+ has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
                 fact_struct(RuleEnablerMetaTerm,RuleEnablerMetaFact)
             ; RuleEnablerMetaFact = RuleEnablerMetaTerm
             )
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    RuleEnablerMetaTerm = RuleEnablerMetaFact
	).

construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm) :-
	PredCode = FL_RULE_ENABLER,
	get_descriptor_module(NULL,Mode,Module),
	generate_prolog_liblit(PredCode,3,[DescrIdCode,FileName,Module],RuleEnablerMetaTerm).

%% like construct_rule_enabling_query/4 but generates file name for itself
%% used as the first subgoal in rules, queries, latent queries
construct_rule_enabling_test(_DescrIdCode,_Mode,FL_TRUE,_FileName) :-
	has_context(CONTEXT_COMPILER_UDF_DEFINITION),
	!.
construct_rule_enabling_test(DescrIdCode,Mode,RuleEnablerMetaTerm,FileName) :-
	get_current_compile_file_for_descriptor(FileName,Mode),
	construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm).

construct_tag_descriptor_fact_from_id(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,TagIdMetaFact) :-
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	(Mode == FL_DESCRMODE_DYNRULE -> Tag = DescrIdCode
	; Mode == FL_DESCRMODE_CLAUSE -> new_prvariable(NO_INDEX,Tag)
	; Mode == FL_DESCRMODE_PLAIN_QUERY -> new_prvariable(NO_INDEX,Tag)
        %% check if NULL is ok here
	; Mode == FL_DESCRMODE_UDFRULE -> atomobj_struct('_$_$invalid_tag',Tag)
	;
	    Tag = DescrIdCode
	),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,Tag,DescrVarsTerm],TagIdMetaTerm),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_LATENT_QUERY]) ->
            fact_struct(TagIdMetaTerm,TagIdMetaFact)
        ; Mode == FL_DESCRMODE_UDFRULE, \+ has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
            fact_struct(TagIdMetaTerm,TagIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    TagIdMetaFact = TagIdMetaTerm
	).


/***************************************************************************
  Compile the export directive
  The body can be a list of export terms, which are compiled individually.
***************************************************************************/
compile_export(BodyTerm,Code,Status) :-
	%% CONTEXT_COMPILER_EXPORT_DIRECTIVE context prevents recording the use
	%% of symbol context for symbols mentioned in the :- export directive
	set_context(CONTEXT_COMPILER_EXPORT_DIRECTIVE),
	compile_export_predicate_list(BodyTerm,BodyTermCode,Status),
	clear_context(CONTEXT_COMPILER_EXPORT_DIRECTIVE),
	list_struct(BodyTermCode,[],BodyTermCodeList),
	export_struct(BodyTermCodeList,Code).


/****************************************************************************
  compile_export_predicate_list(+List,-Code,-Status)
  To recursively compile a list of export predicates.
****************************************************************************/
compile_export_predicate_list([H|T],Code,Status) :-
	compile_export_predicate(H,HCode,S1),
	compile_export_predicate_list(T,TCode,S2),
	append(S1,S2,Status),
	Code = [HCode|TCode].
	
compile_export_predicate_list([],[],NO_ERRORS) :- !.


/****************************************************************************
  compile_export_predicate(+ExportTerm,-Code,-Status)
****************************************************************************/
compile_export_predicate(ExportTerm,Code,Status) :-
	( is_flexport(ExportTerm,BodyTerm,ModuleList,IsUpdatable),
	    WS = FL_THISMODULE
	;
	    %% Here WS is the dynamic module name. It is used only in
	    %% executable instruction like this:
	    %%    ?- (export pred(?)>>foo)@bar.
	    %% where dynamic module name = bar.
	    is_flexport(ExportTerm,WS,BodyTerm,ModuleList,IsUpdatable)
	),
	is_flfact(BodyTerm,ParseBodyTerm),
	!,
	%% compile_fact expects the argument to be a list, so
	%% ParseBodyTerm is put in a list.
	%% Uninitialized arguments are taken care of at run-time.
	compile_fact([ParseBodyTerm],_,_,_,_,ListBodyTermCode,_M-_M,StatusFact),
	compile_body_pathexp_top(ModuleList,FL_THISMODULE,ModuleListCode,_,_,[],_StatusModule),
	compile_body_pathexp_top(IsUpdatable,FL_THISMODULE,IsUpdatableCode,_,_,[],_StatusUpd),
	( WS == FL_THISMODULE -> StatusWS = NO_ERRORS
	;
	  compile_body_pathexp_top(WS,FL_THISMODULE,WSCode,_,_,[],StatusWS)
	),
	append(StatusFact,StatusWS,Status),
	%% It may be that the predicate itself is a comma separated list
	%% Convert ListBodyTermCode from a difference list to a normal list
	%% then wrap each element of the list in PREXPORT
	compile_export_list_convert(ListBodyTermCode,WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_list_convert(+Args,-Code)
   Args is a difference list of the form : [H|_V] -_V.
   Ground _V to [] and convert the diff list to a list
   Then processes the list with compile_export_extract_facts
****************************************************************************/
compile_export_list_convert(ListBodyTermCode - T, WSCode, ModuleListCode,IsUpdatableCode,Code) :-
	T = [],
	%% ListBodyTermCode is a list of facts; process them
	compile_export_extract_facts(ListBodyTermCode,[],WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_extract_facts(+Args,+InitialTerm,+WSCode,+ModuleListCode,+IsUpdatableCode,-Code)
  Encloses the individual predicates of the Args list in a PREXPORT struct. 
  Then the whole list is compiled as a list_struct.
****************************************************************************/
compile_export_extract_facts([H|T],InitTerm,WSCode,ModuleListCode,IsUpdatableCode,Code) :-
	is_prfact(H,HTermCode),
	!,
	construct_export_struct(HTermCode,WSCode,IsUpdatableCode,ModuleListCode,HCode),
	compile_export_extract_facts(T,[HCode|InitTerm],WSCode,ModuleListCode,IsUpdatableCode,Code).

compile_export_extract_facts([],InitTerm,_WSCode,_ModuleListCode,_IsUpdatableCode,Code) :-
	list_struct(InitTerm,[],Code).


/****************************************************************************
  construct_export_struct(+Term,+WSCode,+IsUpdatableCode,+ModuleListCode,-Code)
  Constructs an appropriate prexport struct.
  Here WSCode is the dynamic module name. It is used only in
  executable instruction like this:
  ?- (export pred(?)>>foo)@bar.
  where dynamic module name = bar.
****************************************************************************/
construct_export_struct(TermCode,WSCode,IsUpdatableCode,ModuleListCode,Code) :-
	thismodule_struct(ThisModule),
	atomobj_struct(FLEXPORT,FCode),
	( var(WSCode) ->
		prologterm_struct(FCode,4,[IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	;
		prologterm_struct(FCode,5,[WSCode,IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	).


%% UDFs are always compiled as STATIC rules, even the facts.
%% If a file is added to a module and the file has a definition for
%% the same function, the added UDFs are
%% represented by the same predicate, so the new definition overrides the old.
%%  To avoid this error-prone situation, in this case we issue an error.
%% When overriding a module, we abolish new_udf_predicates_FUN and
%% retractall flora_defined_udf_registry/6.
%% Structure of flora_defined_udf_registry/6 args:
%%
%%    Module,                 eg,     foobar
%%    UDF name,               eg,     fib          (say, for Fibonacci numbers)
%%    Arity of this UDF,              1
%%    UDF-term (user view)            fib(?_h2819)
%%    Name of the UDF predicate that defines this UDF,
%%                            eg,     FLORA_WORKSPACE(new_udf_predicate_fib)
%%    UDF Literal used to implement this UDF
%%       eg,    FLORA_WORKSPACE(new_udf_predicate_fib)(_h0,flapply(fib,_h1),_h2)
%%         
%% If overriding module FLORA_DEFAULT_WORKSPACE, we also
%% retractall flora_used_udf_registry/4.
%% Structure of flora_used_udf_registry/4 args:
%%
%%    UDF name,
%%    Arity of this UDF,
%%    UDF-term (user view)
%%    UDF Literal used to implement this UDF

/****************************************************************************
  compile_udf_definition(+Function,+Body,+DescrIdCode,+DescrVarsTerm,+ReturnValue,-RuleDiffList,-SigDiddList,-FactDiffList,-UDFPredsDiffList,-Status)

  Compile a UDF definition:
  udf Function := if Body.
  Creates a predicate representing the UDF and a rule for that predicate.

  Function - udf term
  Body - body of udf definition
  ReturnValue - return expression
  RuleDiffList - a difference list in the form of [...|T]-T. It is for
                  the optimization of append.
  FactDiffList - the same for facts
  UDFPredsDiffList -  the same for the list of tabled predicates
****************************************************************************/
compile_udf_definition(Function,Body,DescrIdCode,DescrVarsTerm,ReturnValue,CodeList-ListTail,SigDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status) :-
	set_context(CONTEXT_COMPILER_UDF_DEFINITION),
	( is_flterm_or_flatom(Function,Funct,N,Args)->
	    new_udf_predicate(Funct,FunctCompiled,FunctName,UDFCode,N,Args,NewHead,NewHeadPredName,NewHeadPredArity,NewReturnValue,NewHeadCode,FStatus),
	    ( no_errors_found(FStatus) -> 
		( \+ has_permaoption(udf_option(FunctName,N,UDFCode,NewHeadPredName,NewHeadCode)) ->
		    %% +1 for the FL_CONTEXT argument
		    NewHeadPredArity1 is NewHeadPredArity+1,
		    UDFPreds = [(NewHeadPredName,NewHeadPredArity1),UDFPredsTail],
		    set_permaoption(udf_option(FunctName,N,UDFCode,NewHeadPredName,NewHeadCode))
		;
		    UDFPreds = UDFPredsTail
		),
                %% DescrIdCode+DescrVarsTerm are now passed as params
		%%approx_flindex(Funct,FunctIndex),
		%%compile_descriptor_list([]-FunctIndex,FL_DESCRMODE_UDFRULE,DescrIdCode,DescrVarsTerm,_,_),
		( Body==NULL ->
		    %% UDFs are always compiled as rules: add a dummy body
		    flatom_struct(FL_TRUE,NO_INDEX,RealBodyPre),
		    flplib_struct(RealBodyPre,RealBody),
		    new_udfrule_body(RealBody,FunctIndex,
				     ReturnValue,NewReturnValue,NewBody),
		    %% empty descr list - just generate new rule id
		    compile_rule([NewHead],NewBody,
				 DescrIdCode, DescrVarsTerm,
				 RuleList-ListTail,
				 SigDiffList,
				 FactDiffList,S)
		;
		    new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody),
		    %% empty descr list - just generate new rule id
		    compile_rule([NewHead],NewBody,
				 DescrIdCode, DescrVarsTerm,
				 RuleList-ListTail,
				 SigDiffList,
				 FactDiffList,S)
		),
		CodeList=[UDFCodeList|RuleList],
		( no_errors_found(S) -> 
		    %% udfdef_struct causes flrcoder.P to record UDF
		    %% definitions in the registry so that we could abolish all
		    %% new_udf_predicate_XXX on reloading modules.
		    %% This is done in flora_cleanup_udf/1, which is called
		    %% from flrutils:flora_flload/2
		    udfdef_struct(FunctCompiled,N,UDFCode,NewHeadPredName,NewHeadCode,UDFCodeList),
		    %% is_flterm_or_flatom rather than is_flterm is important:
		    %% Otherwise, "udf foo := moo." won't work.
		    is_flterm_or_flatom(Function,FuncSym,FuncSymArity,_),
		    verify_symbol_context(FuncSym,FuncSymArity,UDF_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,
					  SymbolStatus),
		    check_udf_vars_for_safety(Function,Body,ReturnValue,VarStatus),
		    append(SymbolStatus,VarStatus,Status)
		;
		    Status=S
		)
	    ;
		Status = FStatus
	   )
	;
	    approx_flindex(Function,Index),
	    compiling_error(Index,ERROR_UDF,Err),
	    Status = [Err]
	),
	!,
	clear_context(CONTEXT_COMPILER_UDF_DEFINITION).


/*
       new_udf_predicate(+Funct,-FunctCompiled,-FunctName,-UDFCode,
                         +N,+FunctionArgs,-New_udf_predicate_FUNC,
			 -New_udf_predicate_name,-New_udf_predicate_arity,
			 -NewReturnValue,-New_udf_predicate_FUNC_code,-Status)
   Funct - UDF functor
   FunctCompiled - UDF functor compiled (pr-object)
   FunctName - the functor name (atom). Used only for symbol-context checks.
               If the UDF is hilog, then FunctName is set to HILOG_SYMBOL_NAME.
               This is a simplifying assumption for symbol context checking.
   UDFCode - the udf term compiled (pr-object)
   N - UDF arity
   FunctionArgs - the UDF arguments (fl-object, not compiled)
   New_udf_predicate_FUNC - new_udf_predicate_XXX term
                          (fl-obj, not compiled)
   New_udf_predicate_name - new_udf_predicate_XXX name
   New_udf_predicate_arity - new_udf_predicate_XXX arity
   NewReturnValue - a new variable generated for the return expression of udf
   New_udf_predicate_FUNC_code - new_udf_predicate_XXX term compiled
*/
new_udf_predicate(Funct,FunctCompiled,FunctName,UDFCode,N,FunctionArgs,New_udf_predicate_FUNC,New_udf_predicate_name,New_udf_predicate_arity,NewReturnValue,New_udf_predicate_FUNC_code,Status) :-
	new_udf_predicate_funct(Funct,FunctCompiled,N,NPFunct,NPFunctCompiled,New_udf_predicate_name,New_udf_predicate_arity,Stat1),
	( no_errors_found(Stat1) -> 
	    new_flvariable(NO_INDEX,NewReturnValue,NewReturnValueObj),
	    varobj_struct(FL_ANON_VAR,AnonVar),
	    (flora_get_flatom_name(Funct,FunctName) -> true
	    ;
		(  atomic(Funct) -> FunctName=Funct
		%% for HiLog UDF, the function name is HILOG_SYMBOL_NAME.
		%% This is used only for symbol context checking.
		; FunctName = HILOG_SYMBOL_NAME
		)
	    ),
	    flterm_struct(Funct,N,FunctionArgs,UDFTerm),
	    New_udf_pred_args_compiled = [NewReturnValueObj,UDFCode,AnonVar],
	    prologterm_struct(NPFunctCompiled,New_udf_predicate_arity,New_udf_pred_args_compiled,New_udf_predicate_FUNC_code),
	    New_udf_pred_flargs = [NewReturnValue,UDFTerm],
	    flterm_struct(NPFunct,New_udf_predicate_arity,New_udf_pred_flargs,New_udf_predicate_FUNC),
	    flora_define_modular_prolog(New_udf_predicate_name,New_udf_predicate_arity),
	    compile_body_pathexplist(FunctionArgs,FL_THISMODULE,FunctionArgsCompiled,_,_,[],Stat3),
	    ( no_errors_found(Stat3) -> 
		termobj_struct(FunctCompiled,N,FunctionArgsCompiled,UDFCode),
		Status = NO_ERRORS
	    ;
		Status = Stat3
	    )
	;
	    Status = Stat1
	).
	


/*
    new_udfrule_body(+Body,+FunctIndex,+ReturnValue,+NewReturnValue,-NewBody)

    Body - body of udf definition
    FunctIndex - lexer's index of udf functor
    ReturnValue - return expression of udf definition
    NewReturnValue - new variable generated for new_udf_predicate_XXX
                     which gets bound to return expression of udf
    NewBody - the actual body of the rule for new_udf_predicate_XXX
*/
new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody) :-
	%% Form body for the new rule.
	%% To avoid singleton variable warning variable in the head
	%%    and variable in the body of new rule must have different indexes
	flvar_struct_change_index(NewReturnValue,FunctIndex,NewReturnValueInBody), 
	flatom_struct(FL_UNIVEQ,NO_INDEX,ExprFunct),
	flterm_struct(ExprFunct,2,[NewReturnValueInBody,ReturnValue],ExprCode),
	flconjunct_struct(Body,ExprCode,NewBody).


/*
    new_udf_predicate_funct(+Funct,-FunctCompiled,+Arity,
                            -NewPredicateFunct,-NPFunctCompiled,-NewName,
			    -NPArity,-Status)
    Funct - UDF functor
    FunctCompiled - UDF functor compiled
    Arity - UDF arity 
    NewPredicateFunct - functor of new_udf_predicate_XXX
    NPFunctCompiled  - compiled functor of new_udf_predicate_XXX
    NewName - name (atom) of new_udf_predicate_XXX
    NPArity - new_udf_predicate_XXX arity
*/
new_udf_predicate_funct(Funct,FunctCompiled,Arity,
			NewPredicateFunct,NPFunctCompiled,NewName,NPArity,
			Status) :-
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_body_pathexp_top(Funct,FL_THISMODULE,FunctCompiled,_,_,[],Status), 
	clear_context(CONTEXT_COMPILER_TERM_NAME),
	encode_prterm(FunctCompiled,EncodedFunct),
	flora_concat_atoms([NEWUDFPREDICATENAME,EncodedFunct],NewName),
	flatom_struct(NewName,NO_INDEX,NewPredicateFunct),
	modularized_pratom_struct(NewName,NO_INDEX,NPFunctCompiled),
	NPArity is Arity+1.

/****************************************************************************
    encode_prterm(+Term,-EncodedBuildTerm)

    Encode a Term into a String to create a UDF Predicate Name
****************************************************************************/
encode_prterm(Term,EncodedBuildTerm):-
	collect_prvars(Term,VarList),
	flora_reset_newudfpredvar,
	encode_prvariables(VarList,Term,EncodedTerm,_NewVarList),
	encode_term_build(EncodedTerm,EncodedBuildTerm).

/***************************************************************************
    encode_prvariables(+VarNameList,+VarType,+OldFormula,-NewFormula,-NewVarList)
       Replaces each occurrence of each variable in VarNameList with
       a counter value
    rename_one_prvariable(+VarName,+NewVarObj,+Body,-NewBody),
       Replaces each occurrence of a a var object having VarName
       as the variable name with NewVarObj. Returns the newly created formula.
***************************************************************************/
encode_prvariables([],Body,Body,[]) :- !.

encode_prvariables([Var|VarNameList],Body,NewBody,[NewVarObj|NewVarList]) :-
        flora_newudfpredvar_obj(NO_INDEX,NewVarObj),
	(is_prvariable(Var,VarName,_VarIndex) ; VarName = Var),
        encode_one_prvariable(VarName,NewVarObj,Body,NewBody1),
        encode_prvariables(VarNameList,NewBody1,NewBody,NewVarList).

encode_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
        (
          atomic(Body) -> NewBody = Body
        ; var(Body) -> NewBody  = Body
        ; is_list(Body) ->
          encode_one_prvariable_in_list(VarName,NewVarObj,Body,NewBody)
        ; is_prvariable(Body,VarName,_Idx) -> NewBody = NewVarObj
        ; is_pratomnumberstringbuiltin(Body,_) ->  NewBody = Body
        ; is_prdatatype(Body,_,_,_) ->  NewBody = Body
        ; is_prdatatypelist(Body,_) ->  NewBody = Body
        ),
        !.

encode_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
        Body =.. [Wrapper|Args],
        encode_one_prvariable_in_list(VarName,NewVarObj,Args,NewArgs),
        NewBody =.. [Wrapper|NewArgs].

encode_one_prvariable_in_list(_,_,[],[]) :- !.
encode_one_prvariable_in_list(VarName,NewVarObj,[T|Terms],[NewT|NewTerms]) :-
        encode_one_prvariable(VarName,NewVarObj,T,NewT),
        encode_one_prvariable_in_list(VarName,NewVarObj,Terms,NewTerms).


/***************************************************************************
    encode_term_build(Term,BuildTerm)
    encode_term_build_list(Term,BuildTerm)
****************************************************************************/
encode_term_build(Term,BuildTerm):-
        is_prterm(Term,Funct,_Arity,Args),
	encode_term_build(Funct,BuildFunct),
	encode_term_build_list([Funct|Args],[_Comma,BuildFunct,_Comma|BuildArgs]),
	flora_concat_atoms([BuildFunct,'(',BuildArgs,')'],BuildTerm),
	!.	

encode_term_build(Term,BuildTerm):-
        ( atomic(Term) ->  BuildTerm = Term
        ; is_list(Term) -> encode_term_build_list(Term,BuildTerm)
        ; is_prvariable(Term,VarName,_Idx) -> flora_concat_atoms(['?',VarName],BuildTerm)
        ; is_pratomnumberstringbuiltin(Term,Val) ->  BuildTerm = Val
        ),
        !.

encode_term_build_list([],[]):-!.

encode_term_build_list([Term|TermList],[',',BuildTerm|BuildTermList]):-
	encode_term_build(Term,BuildTerm),
	encode_term_build_list(TermList,BuildTermList).




/****************************************************************************
  compile_rule(+Head,+Body,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-Status)

  DescriptorIdCode is either code for term/object or NULL

  RuleDiffList is a difference list in the form of [...|T]-T. It is for
  the optimization of append.
  FactDiffList = Facts-Facts: the empty diff list
****************************************************************************/
compile_rule(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleList-RuleTail,SigDiffList,Facts-Facts,Status) :-
	set_context(CONTEXT_COMPILER_RULE(DescriptorIdCode)),
	(has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
	    /* When compiling headlits of UDF rules, we should turn
	       off UDF conversion. For instance, for
		   \udf c(?x):=?y \if pred(?x,?y).
	       we create the rule:
	         new_udf_predicate_c(RetVal,flapply(c,x)) :- pred(X,Y),RetVal=Y.
	    */
	    set_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	    push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK)
	; true
	),
	compile_head_top(Head,HeadNF,rule,HeadCode,H2BCodeFront,H2BCodeBack,HeadStatus),
	(has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
	    %% done compiling UDF definition head
	    clear_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	    pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK)
	; true
	),
	( no_errors_found(HeadStatus) ->
	    compile_body_top(Body,BCode,BodyStatus),
	    ( no_errors_found(BodyStatus) ->
		make_datatype_vars_code(BCode,BodyDTvarscode),
		delay_literals_checking_code_list(HeadNF,Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,DelayCheckCodeList),
		construct_rule_enabling_test(DescriptorIdCode,FL_DESCRMODE_RULE,RuleEnablerTest,_),
		PreBody = RuleEnablerTest,
		PostBodyList = DelayCheckCodeList,
		make_rules_and_signatures(HeadCode,H2BCodeFront,H2BCodeBack,
					  BCode,PreBody,PostBodyList,
					  BodyDTvarscode,
					  DescriptorIdCode,DescrVarsTerm,
					  RuleList-RuleTail,
					  SigDiffList,
					  FinalStatus),
		( no_errors_found(FinalStatus),
		    %% for UDFS checking of variables is done separately
		    \+ has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
		    check_rule_vars_for_safety(Head,Body,VarStat),
		    flatten([HeadStatus,BodyStatus,FinalStatus,VarStat],Status)
		; Status = FinalStatus
		)
	    ;
		Status=BodyStatus
	    )
	;
	    Status=HeadStatus
        ),
	clear_context(CONTEXT_COMPILER_RULE(DescriptorIdCode)),
	!.

/****************************************************************************
  make_rules_and_signatures(+HeadCodeList,+H2BFrontList,+H2BBackList,+BodyCode,+PreBody,+PostBodyList,+BodyDTvarscode,+DescriptorIdCode,+DescrVarsTerm,RuleDiffList,SigDiffList,Status)

  HeadCodeList is a list of atoms in the rule head. BodyCode is the formula
  in the rule body. This procedure splits the list of atoms in the rule
  head and generates a difference list.

  DescriptorIdCode is a term code
  DescrVarsTerm is code for vars(variables in the descriptor list)

  Note: delay checker is NOT added to the body in signatures
****************************************************************************/
make_rules_and_signatures([],_H2BFront,_H2BBack,_BodyCode,_PreBody,_PostBody,_BodyDTvarscode,_DescriptorIdCode,_DescrVarsTerm,Rule-Rule,Sig-Sig,NO_ERRORS) :- !.
make_rules_and_signatures([H|HList],[H2BF|H2BFrontL],[H2BB|H2BBackL],BodyCode,PreBody,[PostBody|PostBodyList],BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RulesHead-RTail,SigHead-STail,Status) :-
	make_one_rule_and_signature(H,H2BF,H2BB,BodyCode,PreBody,PostBody,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RulesHead-RulesTail,SigHead-SigTail),
	make_rules_and_signatures(HList,H2BFrontL,H2BBackL,BodyCode,PreBody,PostBodyList,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RulesTail-RTail,SigTail-STail,Status).

/*
  make_one_rule_and_signature/11 can expect single-literal heads
  or conjunctions of single literals. These cnjunctions are closely related.
  For instance, they might come from ?X[?P=>?O] :- ...
  which involves a conjunction of (mvdsig(....),mvdcondef(.....)) wrappers.

  This is diff from make_rules_and_signatures/11, which takes lists of heads.
*/
make_one_rule_and_signature(H,H2BF,H2BB,BodyCode,PreBody,PostBody,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RuleList-RTail,SigCode-STail) :-
	is_prconjunct(H,H1,H2),
	!,
	make_one_rule_and_signature(H1,H2BF,H2BB,BodyCode,PreBody,PostBody,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RuleList-RuleTail,SigCode-SigTail),
	make_one_rule_and_signature(H2,H2BF,H2BB,BodyCode,PreBody,PostBody,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,RuleTail-RTail,SigTail-STail).
make_one_rule_and_signature(H,H2BF,H2BB,BodyCode,PreBody,PostBody,BodyDTvarscode,DescriptorIdCode,DescrVarsTerm,[Rule|RTail]-RTail,[Sig|STail]-STail) :-
	make_datatype_vars_code(H,HeadDTvarscode),
	conjunct_struct(HeadDTvarscode,BodyDTvarscode,DTvarscode),
	construct_static_defeasible_condition(H,DescriptorIdCode,DescrVarsTerm,DefeatCond),
	conjunct_code([DTvarscode,BodyCode],BodyForSig),
	conjunct_code([PreBody,DTvarscode,H2BF,BodyCode,H2BB,DefeatCond,PostBody],FullBody),
	%% H2BSig goes into the rule signature
	conjunct_struct(H2BF,H2BB,H2BSig),
	rule_struct(H,FullBody,Rule),
	make_insert_rulesig_code(H,BodyForSig,H2BSig,PreBody,PostBody,DescriptorIdCode,DescrVarsTerm,Sig).


/*
   For static rules only. Creates the query
   ?- FLLIBINSRULESIG(....).
   which is added to the compiled file. When the file is loaded,
   the signature for that static rule is added to the rule registry.
   Body: includes H2BFront and H2BBack
*/
make_insert_rulesig_code(_HeadCode,_Body,_,_PreBody,_PostBody,_,_,NULL) :-
        /*
        %% we need UDF signatures now
	(has_context(CONTEXT_COMPILER_UDF_DEFINITION)
	; has_permaoption(FLSUPPRESS_RULESIGNS_OPTION)
	),
        */
	has_permaoption(FLSUPPRESS_RULESIGNS_OPTION),
	!.
make_insert_rulesig_code(HeadCode,Body,H2BSig,PreBody,PostBody,DescrIdCode,DescrVarsTerm,Code) :-
	construct_defeasible_condition_for_signature_or_dynrule(HeadCode,DescrIdCode,DescrVarsTerm,DefeatCond),
        insert_rulesig_struct(HeadCode,Body,H2BSig,PreBody,PostBody,DescrIdCode,DescrVarsTerm,DefeatCond,CCode),
        query_struct(CCode,Code).

make_datatype_vars_code(PRCode,Code) :-
	collect_prdatatypevars(PRCode,VarsCodeList),
	conjunct_code(VarsCodeList,Code).

%% DefeatCondCode = FL_UNDEFEATED(DescrIdCode,FileName,VarsCode,NewVar,ThisModule)
%% FL_UNDEFEATED is a modularized Prolog predicate
%% NewVar is used because this type of defeasible condition is used in rule
%% signatures and dynamic rules; NewVar is bound to the head at run time.
construct_defeasible_condition_for_signature_or_dynrule(HeadCode,DescrIdCode,DescrVarsTerm,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)),
	    \+ has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
	    %% DummyVarObj4Head is unified with Head in
	    %% flora_record_rule_signature in flrcanon.P and flrdynrule.P
	    %% This is because the rule head can be a variable bound at runtime.
	    %% Eg, ?X=${p(?Y)}, insertrule{?X :- ...}.
	    %% So, we cannot determine the rule head statically here.
	    new_prvariable(NO_INDEX,DummyVarObj4Head),
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(DescrIdCode,FileName,DescrVarsTerm,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into a modularized Prolog predicate
	    %% It is faster, saves table space
	    modularized_pratom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,UnDefeatFunCode),
	    var_context_info_structure(ThisModule,FWContext),
	    get_current_compile_file_for_descriptor(FileName,FL_DESCRMODE_DYNRULE),
	    prologterm_struct(UnDefeatFunCode,6,
			      [DescrIdCode,FileName,DescrVarsTerm,
			       DummyVarObj4Head,ThisModule,FWContext],
			      DefeatCondCode),
	    %% wrap up for delaying the defeasible condition
	    list_struct([],[],EmptyListObj), %% empty list
	    ( approx_prindex(HeadCode,HeadIdx), HeadIdx \== NO_INDEX -> true
	    ; HeadIdx=NO_INDEX
	    ),
	    delay_defeat_struct(HeadIdx,DefeatCondCode,
				EmptyListObj,EmptyListObj, %% no headvars
				DummyVarObj4Head,  %% will be bound to head
				DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = true
	),
	!.

%% DefeatCondCode = FL_UNDEFEATED(DescrIdCode,FileName,DescrVarsTerm,HeadCode,ThisModule)
%%                  or true.
%% FL_UNDEFEATED is a modularized Prolog predicate
%% The difference is that instead of NewVar we insert head code at compile time.
construct_static_defeasible_condition(HeadCode,DescrIdCode,DescrVarsTerm,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)),
	    \+ has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
	    %% create FL_UNDEFEATED(DescrIdCode,NewVar,ThisModule)
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(DescrIdCode,FileName,DescrVarsTerm,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into a modularized Prolog predicate
	    %% It is faster, saves table space
	    modularized_pratom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,UnDefeatFunCode),
	    var_context_info_structure(ThisModule,FWContext),
	    get_current_compile_file(FileName),
	    prologterm_struct(UnDefeatFunCode,6,
			      [DescrIdCode,FileName,DescrVarsTerm,
			       HeadCode,ThisModule,FWContext],
			      DefeatCondCode),
	    %% wrap up for delaying the defeasible condition
	    collect_prvars(HeadCode,HeadCodeVars1),
	    remove_FL_CONTEXT_prvars(HeadCodeVars1,HeadCodeVars),
	    vars_to_var_names(HeadCodeVars,HeadCodeVarNames),
	    list_struct(HeadCodeVars,[],HeadCodeVarsStruct),
	    list_struct(HeadCodeVarNames,[],HeadCodeVarNamesStruct),
	    ( approx_prindex(HeadCode,HeadIdx), HeadIdx\==NO_INDEX -> true
	    ; HeadIdx=NO_INDEX
	    ),
	    delay_defeat_struct(HeadIdx,DefeatCondCode,
				HeadCodeVarsStruct,HeadCodeVarNamesStruct,
				NULL, %% no dynamic head code
				DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = true
	),
	!.


/****************************************************************************
  prconjunct2list(+ConjunctCode,-CodeList)
  prconjunct2list(+ConjunctCode,-CodeList,-ListTail)

  ConjunctCode may contain NULL.
****************************************************************************/
prconjunct2list(ConjunctCode,CodeList) :-
	prconjunct2list(ConjunctCode,CodeList,[]).

prconjunct2list(NULL,CodeList,CodeList) :- !.

prconjunct2list(ConjunctCode,CodeList,ListTail) :-
	is_prconjunct(ConjunctCode,C1,C2),
	!,
	prconjunct2list(C1,CodeList,T1),
	prconjunct2list(C2,T1,ListTail).

prconjunct2list(Code,[Code|ListTail],ListTail) :- !.


/****************************************************************************
  compile_head_top(+ParsTermL,-ParsTermLNF,+Context,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
      compile_head(+ParsTermL,         -Code,-H2BCodeFront,-H2BCodeBack,-Status)

  Context: rule or fact
  ParsTermLNF  - a transformed version of ParsTermL. Used in some ergoisms
  H2BCodeFront - code passed from head to body, which is supposed to be
                 prepended to the code of the body
  H2BCodeBack - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/

:- import to_Cranial_list/4 from flrparser.

compile_head_top(ParserTerm,ParsedHeadList,Context,Code,H2BCodeFront,H2BCodeBackCombined,Status) :-
	(Context==fact -> true
	; collect_flvars(ParserTerm,FlVars),
	    %% TODO: pass FlVars to compile_head as a parameter
	    %%       Then pass it also to compile_body_top, compile_body,
	    %%       compile_stop_delay
	    set_context(compiling_head(FlVars))
	),
	%% cranial returns diff lists, so terminate them with the []
	to_Cranial_list(ParserTerm,ParsedHeadList-[],ParsedCranialBodyL-[],S0),
	!, %% to prevent backtracking if compile_head/5 fails
	(no_errors_found(S0) ->
	    compile_cranial_body_list(ParsedCranialBodyL,CranialBodyCodeL,S1),
	    (no_errors_found(S1) ->
		compile_head(ParsedHeadList,Code,H2BCodeFront,H2BCodeBack,S2),
		maplist_conjunct(H2BCodeBack,CranialBodyCodeL,H2BCodeBackCombined),
		append(S1,S2,Status)
	    ; Status = S1
	    )
	; Status = S0
	),
	(Context==fact -> true
	; clear_context(compiling_head(FlVars))
	),
	!.

compile_cranial_body_list([],[],NO_ERRORS) :- !.
compile_cranial_body_list([B|RestB],[BCode|RestBCode],Status) :-
	(B==NULL -> BCode=B, S1=NO_ERRORS
	; compile_body_top(B,BCode,S1)
	),
	(no_errors_found(S1) ->
	    compile_cranial_body_list(RestB,RestBCode,S2),
	    append(S1,S2,Status)
	; Status = S1
	).

maplist_conjunct([],[],[]) :- !.
%% Next two not used because in our case the lists have the same length
%%maplist_conjunct([],L2,L2) :- !.
%%maplist_conjunct(L1,[],L1) :- !.
maplist_conjunct([E1|R1],[E2|R2],[C|R]) :-
	conjunct_struct(E1,E2,C),
	maplist_conjunct(R1,R2,R).

compile_head([],[],[],[],NO_ERRORS) :- !.

compile_head([ParserTerm|ParserTermList],Code,H2BCodeFront,H2BCodeBack,Status) :-
	detach_flworkspace(ParserTerm,P,WS),
	compile_head_literal_top(P,WS,PCode,PH2BCodeFront,PH2BCodeBack,S),
	( no_errors_found(S) ->
	    compile_head(ParserTermList,PLCode,PLH2BCodeFront,PLH2BCodeBack,S2),
	    ( no_errors_found(S2) ->
		Code = [PCode|PLCode],
		H2BCodeFront = [PH2BCodeFront|PLH2BCodeFront],
		H2BCodeBack = [PH2BCodeBack|PLH2BCodeBack],
		append(S,S2,Status)
	     ;
		Status=S2
	    )
	;
	  Status=S
        ),
	!.
compile_head([ParserTerm|_],_,_,_,Status) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head'],Err),
	Status = [Err].


/****************************************************************************
  compile_body_top(+ParserTerm,-Code,-Status)
  compile_body(+ParserTerm,-Code,-Status)
****************************************************************************/
%% this is a top-level entry into the body compile. Called by compile_query/rule
compile_body_top(ParserTerm,Code,Status) :-
	collect_flvars(ParserTerm,FlVars),
	%% TODO: pass FlVars to compile_body as a parameter
	%%       Then pass it to compile_body_literal_top, compile_stop_delay
	push_context(CONTEXT_COMPILER_BODY(FlVars)),
	compile_body(ParserTerm,Code,Status),
	pop_context(CONTEXT_COMPILER_BODY(FlVars)),
	!.


compile_body(ParserTerm,Code,Status) :-
	is_flconjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		conjunct_struct(LCode,RCode,Code),
		append(S,S2,Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ).

compile_body(ParserTerm,Code,Status) :-
	is_fldisjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		disjunct_struct(LCode,RCode,Code),
		append(S,S2,Status)
	    ; Status=S2)
	;
	  Status=S
        ).


compile_body(ParserTerm,Code,Status) :-
	is_flneg(ParserTerm,G,Idx),
	!,
	compile_body(G,GCode,Status1),
	( no_errors_found(Status1) ->
	   neg_struct(GCode,Idx,Code,Status2),
	   append(Status1,Status2,Status)
	; Status = Status1
	).

compile_body(ParserTerm,Code,Status) :-
	is_flplgnaf(ParserTerm,G),
	!,
	set_context(CONTEXT_COMPILER_DEFAULT_NEGATION),
	compile_body(G,GCode,Status),
	( no_errors_found(Status) ->
	    get_quantification_info(GCode,_Quantifier,FormCode,_QuantVars,_FreeVars),
	    naf_struct_prolog(FormCode,Code)
	; true
	),
	clear_context(CONTEXT_COMPILER_DEFAULT_NEGATION).

compile_body(ParserTerm,Code,Status) :-
	is_flrulelognaf(ParserTerm,G),
	!,
	set_context(CONTEXT_COMPILER_DEFAULT_NEGATION),
	compile_body(G,GCode,Status),
	( no_errors_found(Status) ->
	    get_quantification_info(GCode,Quantifier,FormCode,_QuantVars,FreeVarObjs),
	    (is_existentialquant(Quantifier) ->
		naf_struct_flora(FormCode,FreeVarObjs,Code)
	    ; %% naked NAF, without quantification
		propagate_rulelog_naf(FormCode,FreeVarObjs,Code)
	    )
	; true
	),
	clear_context(CONTEXT_COMPILER_DEFAULT_NEGATION).

compile_body(ParserTerm,Code,Status) :-
	is_fllogicquantifier(ParserTerm,QuantType,QuantVarNames,VarsCode,Formula,Idx),
	!,
	%% no quantified don't care vars (?,?_) allowed
	(memberchk(FL_ANON_VAR,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = NO_ERRORS
	),

	compile_body(Formula,FormCode,S2),
	(S1==NO_ERRORS -> S3=S2
	; S3 = [Err1|S2]
	),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars(FormCode,FormVarList),
	vars_to_var_names(FormVarList,FormVarNames),
	(no_errors_found(S3) ->
	    (QuantVarNames == FL_STAR -> Stat4 = NO_ERRORS %% all vars exist'l
	    %% quantified vars must occur in Formula
	    ; subset(QuantVarNames,FormVarNames) -> Stat4 = NO_ERRORS
	    ; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err4),
		Stat4 = [Err4]
	    ),
	    (QuantVarNames == FL_STAR -> FreeVarObjs_aux = []
	    ; subtract_varnames_from_vars(FormVarList,QuantVarNames,FreeVarObjs_aux)
	    ),
	    remove_prdontcare_and_FL_CONTEXT_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	    %% this is used if naf-exists is nested deep inside the code
	    remove_quantified_vars(FreeVarObjs_aux2,FreeVarObjs),

	    (QuantVarNames == FL_STAR ->
                RenamedFormCode = FormCode,
                Status = Stat4
	    ;
                compile_datatype_objects(VarsCode,PRVarsCode,StatVarsCode),
                rename_prvariables(QuantVarNames,NEWQUANTIFIEDVAR,
                                 (PRVarsCode,FormCode),
				 (RenamedPRVarsCode,RenamedFormCode),
                                 RenamedQuantVars),
                append(StatVarsCode,Stat4,Status)
	    )
	; Status = S3
	),
	!,
	( no_errors_found(Status) ->
	    %% Create code for compiled quantification.
	    list_struct(RenamedQuantVars,[],RenamedQuantVarsListObj),
	    (QuantType==FL_EXISTS ->
		list_struct(FreeVarObjs,[],FreeVarListObj),
                %% push typed var binding code (RenamedPRVarsCode) past nearest
                %% \naf, if any.
                (extract_goal_from_prrulelognaf(RenamedFormCode,ExtractedGoal,
                                                FreeFormVars,FormDelayChecker,
                                                FLine,FFile)
                ->
                    conjunct_struct(RenamedPRVarsCode,ExtractedGoal,ExtractedVarsCode),
                    extract_goal_from_prrulelognaf(CombinedCode,ExtractedVarsCode,
                                                   FreeFormVars,FormDelayChecker,
                                                   FLine,FFile)
                ;
                    conjunct_struct(RenamedPRVarsCode,RenamedFormCode,CombinedCode)
                ),
		quantifier_struct(QuantType,CombinedCode,RenamedQuantVarsListObj,FreeVarListObj,Code)
	    ;
		%% QuantType==FL_FORALL: compile as naf exists naf
		append(RenamedQuantVars,FreeVarObjs,AllVars_pre),
		remove_prdontcare_and_FL_CONTEXT_vars(AllVars_pre,AllVars),
		list_struct(AllVars,[],AllVarsListObj),
		propagate_rulelog_naf(RenamedFormCode,AllVarsListObj,Code1),
		list_struct(FreeVarObjs,[],FreeVarListObj),
                conjunct_struct(RenamedPRVarsCode,Code1,CombinedCode),
		naf_struct_flora(CombinedCode,FreeVarListObj,Code)
	    )
	;
	    true
	).


compile_body(ParserTerm,Code,Status) :-
	is_flhypothetical(ParserTerm,Op,Goal,Index),
	!,
	compile_body(Goal,GCode,Status),
	( no_errors_found(Status) ->
		hypothetical_struct(Op,GCode,Index,Code)
	;
	    true
	).

%% this is used when we reify latent queries
compile_body(ParserTerm,Code,Status) :-
	is_flannotated_construct(ParserTerm,Descriptor,Statement),
	is_fllatent_query(Statement,Body),
	!,
	approx_flindex(Statement,RuleIdx),
	compile_descriptor_list(Descriptor-RuleIdx,FL_DESCRMODE_LATENT_ADDQUERY,DescrIdCode,_DescrVarsTerm,MetaFacts,Status1),
	(no_errors_found(Status1) ->
	    compile_latent_query(DescrIdCode,MetaFacts,Body,FL_DESCRMODE_LATENT_ADDQUERY,CodeList-[],Status),
	    conjunct_code(CodeList,Code)
	; Status = Status1
	).


%% a descriptor query in rule/query body like ... :- ..., @!{...}
compile_body(ParserTerm,Code,Status) :-
	is_fldescriptor(ParserTerm,_,FLRULEID,_),
	!,
	approx_flindex(ParserTerm,QueryIdx),
	compile_descriptor_list([ParserTerm]-QueryIdx,FL_DESCRMODE_PLAIN_QUERY,_,_,CodeList-[],Status),
	conjunct_code(CodeList,Code).

compile_body(ParserTerm,Code,Status) :-
	detach_flworkspace(ParserTerm,P,WS),
	compile_body_literal_top(P,WS,OidCode,SpecCode,BodyFrontList,Status),
	conjunct_code(BodyFrontList,BodyFrontCode),
	%% generaly we should use strong conjunction for OidCode+SpecCode
	%% coming out of compile_body_literal_top/6, if this code can appear
	%% under NAF. This is because OidCode+SpecCode usually share variables.
	strong_conjunct_struct(OidCode,SpecCode,BodyLitCode),
	conjunct_struct(BodyFrontCode,BodyLitCode,Code).

compile_body_literal_list([],[],[],[],NO_ERRORS) :- !.
compile_body_literal_list([HWS|T],[HOidCode|TOidCode],[HSpecCode|TSpecCode],FrontListCode,Status) :-
	detach_flworkspace(HWS,H,WS),
        compile_body_literal_top(H,WS,HOidCode,HSpecCode,HLitFrontListCode,HStat),
        ( no_errors_found(HStat) -> 
            compile_body_literal_list(T,TOidCode,TSpecCode,TLitFrontListCode,TStat),
            append(HLitFrontListCode,TLitFrontListCode,FrontListCode),
            append(HStat,TStat,Status)
        ; Status = HStat
        ).


/****************************************************************************
  compile_ifthenelse(+Cond,+Then,+Else,-Code,-Status)
****************************************************************************/
compile_ifthenelse(Cond,Then,Else,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	compile_body(Then,ThenCode,S2),
	append(S1,S2,CondThenStatus),
	( no_errors_found(CondThenStatus) ->
	    compile_body(Else,ElseCode,Status),
	    ( no_errors_found(Status) ->
	       ifthenelse_struct(CondCode,ThenCode,ElseCode,Code)
	    ;
		true
	    )
	;
	    Status=CondThenStatus
	).


/****************************************************************************
  compile_ifthen(+Cond,+Then,-Code,-Status)
****************************************************************************/
compile_ifthen(Cond,Then,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Then,ThenCode,Status),
	    ( no_errors_found(Status) ->
	       ifthen_struct(CondCode,ThenCode,Code)
	    ;
		true
	    )
	;
	  Status=S1
	).

/****************************************************************************
  compile_univeqform(+Left,+Right,-Code,-Status)

  Compiling ~
  This produces only spec code -- no oid code, because each argument
  is treated as Meta, so no oid is passed utside of this term
****************************************************************************/
compile_univeqform(Left,Right,Code,Status) :-
        push_context(CONTEXT_COMPILER_GOAL_REIFICATION),
        set_context(CONTEXT_COMPILER_UNIVEQFORM),
	compile_body(Left,LeftCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Right,RightCode,Status),
	    ( no_errors_found(Status) ->
		univeqform_struct(LeftCode,RightCode,Code)
	    ;
		true
	    )
	;
	  Status=S1
	),
        clear_context(CONTEXT_COMPILER_UNIVEQFORM),
        pop_context(CONTEXT_COMPILER_GOAL_REIFICATION).


/****************************************************************************
  compile_metauniv(+Left,+Right,-OidCode,-Code,-Status)
  Compiling =..
****************************************************************************/
compile_metauniv(Left,Right,OidCode,Code,Status) :-
	%% Use pathexp translation instead of body translation, because we
	%% don't want module name to be tacked on unless requested
	%% LeftCode becomes bound to the OID code of Left
	%% ObjCode is later conjuncted with the result
        set_context(CONTEXT_COMPILING_METAUNIV),
	compile_body_pathexp_top(Left,FL_THISMODULE,LeftCode,OidCodeLeft,LeftObjCode,[],S1),
	( no_errors_found(S1) ->
	    push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	    compile_body_pathexp_top(Right,FL_THISMODULE,RightCode,OidCodeRight,RightObjCode,[],Status),
	    pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	    ( no_errors_found(Status) ->
                %% LeftCode - what goes in place of this Left pathexpr:
                %%            Left =.. Right
		%% OidCodeLeft - code that is called prior to =.. to instantiate
                %%               LeftCode
		%% LeftObjCode - actual formula that corresponds to
                %%               Left pathexpr. Usually NULL.
                (is_flaggregate(Left,_,_,_,_,_) ->
                    RealLeftCode = OidCodeLeft,
                    RealOidCodeLeft = NULL
                ;   RealLeftCode = LeftCode,
                    RealOidCodeLeft = OidCodeLeft
                ),
		metauniv_struct(RealLeftCode,RightCode,UnivCode),
		conjunct_code([RealOidCodeLeft,UnivCode,LeftObjCode,RightObjCode],Code),
		%%conjunct_struct(OidCodeLeft,OidCodeRight,OidCode)
		OidCode = OidCodeRight
	    ; true
	    )
	;
	    Status=S1
	),
        clear_context(CONTEXT_COMPILING_METAUNIV).

/****************************************************************************
  compile_prologifthen(+Left,+Right,-Code,-Status)
  Compiling -->>
****************************************************************************/
compile_prologifthen(Left,Right,Code,Status) :-
	/* Do not push CONTEXT_COMPILER_GOAL_REIFICATION. Otherwise,
	   Left,Right will get reified and their context arguments will
	   be zapped. Then, in encapsulated Flora-2 modules this will cause
	   errors. For instance, calling (foo(?X) -->> bar(?X) ; ...) will
	   not pass the module context to foo and bar.
	   This will cause the "calling unexported method" error.
	*/
        %%push_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	compile_body(Left,LeftCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Right,RightCode,Status),
	    ( no_errors_found(Status) ->
		atomobj_struct(('->'),ArrowObj),
		prologterm_struct(ArrowObj,2,[LeftCode,RightCode],Code)
	    ;
		true
	    )
	;
	  Status=S1
	),
        %%pop_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	true.


/****************************************************************************
  compile_controlconstruct(+Cond,+Action,+Wrapper,-Code,-Status)

  Handle control stmts while-do,do-until,while-loop,loop-until,unless-do
****************************************************************************/
compile_controlconstruct(Cond,Action,Wrapper,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Action,ActionCode,Status),
	    ( no_errors_found(Status) -> 
	       controlconstruct_struct(CondCode,ActionCode,Wrapper,Code)
	    ; true
	    )
	; Status = S1
	).


/***************************************************************************
   compile_datatype_objects(+ParserTerm,-VarBindingCode,-Status)
   Used to compile vatiable typing code from quantifiers.
   Eg, forall(?X^^foo)^... exist(?X^^foo,?Y^^bar)^....
****************************************************************************/
compile_datatype_objects(NULL,true,NO_ERRORS) :- !.
compile_datatype_objects(ParserTerm,VarBindingCode,Status) :-
        is_fldatatype(ParserTerm,_Sort,_Lit,_Index),
        !,
        datatypeobj_struct(ParserTerm,_Object,VarBindingCode,Status).
compile_datatype_objects(ParserTerm,VarBindingCode,Status) :-
	is_flconjunct(ParserTerm,L,R),
        !,
        compile_datatype_objects(L,VarBindingCodeL,StatL),
        (no_errors_found(StatL) ->
            compile_datatype_objects(R,VarBindingCodeR,Status),
            conjunct_struct(VarBindingCodeL,VarBindingCodeR,VarBindingCode)
        ; true
        ).


/****************************************************************************
verify_symbol_context(+Funct,+Arity,+SymbolContext,+Transactional,-SymbolContextStatus)
verify_symbol_context(+Funct,+Arity,+WS,+SymbolContext,+Transactional,-SymbolContextStatus)

  The context CONTEXT_COMPILER_TERM_NAME is set in rule body responsible
  for compiling a term (e.g. compile_body_termlit).
  It is cleared before compiling arguments of the term.
  It is needed to distinguish between compiling an atom as a term
  name and atom by itself

****************************************************************************/
verify_symbol_context(Funct,Arity,SymbolContext,Transactional,Status) :-
	verify_symbol_context(Funct,Arity,FL_THISMODULE,SymbolContext,Transactional,Status).

%% If term name is a variable, do not check 
/*
verify_symbol_context(Funct,_Arity,_WS,_SymbolContext,_Transactional,NO_ERRORS):-
	is_flvariable(Funct,_Name,_Index),
	!.
*/

%% If this is a HiLog term (Funct is a var or a complex term),
%% record the symbol context
verify_symbol_context(Funct,Arity,WS,SymbolContext,Transactional,Status):-
	(is_flvariable(Funct,_Name,Index) ; is_flterm(Funct,_FFunct,_FArity,_FArgs)),
	%% for hilog udfs, we record only a generic name, HILOG_SYMBOL_NAME.
	flatom_struct(HILOG_SYMBOL_NAME,Index,VarFunct),
	verify_symbol_context(VarFunct,Arity,WS,SymbolContext,Transactional,Status),
	!.

%% Already checked symbol: do not check again and do not record duplicates(!)
verify_symbol_context(Funct,Arity,_WS,SymbolContext,Transactional,NO_ERRORS):-
	SymbolContext \== SENSOR_SYMBOL,
	SymbolContext \== UDF_SYMBOL,
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,SymbolContext,Transactional),
	!.

verify_symbol_context(Funct,Arity,_WS,_SymbolContext,_Transactional,NO_ERRORS):-
	(is_flbuiltin_identifier(Funct,Name) -> true
	; is_flatom(Funct,Name)
	),
	flora_reserved_builtin(Name,Arity),
	!.

verify_symbol_context(Funct,Arity,_WS,UDF_SYMBOL,Transactional,NO_ERRORS):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,USE_UDF_SYMBOL,Transactional)
	-> true
	; has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,UDF_SYMBOL,Transactional)
	),
	!.

verify_symbol_context(Funct,Arity,_WS,SENSOR_SYMBOL,Transactional,NO_ERRORS):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,USE_SENSOR_SYMBOL,Transactional)
	; has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,SENSOR_SYMBOL,Transactional)
	),
	!.

verify_symbol_context(_Funct,_Arity,_WS,_SymbolContext,_Transactional,NO_ERRORS):-
	(has_context(CONTEXT_COMPILER_TERM_NAME)
        ; has_context(CONTEXT_COMPILER_EXPORT_DIRECTIVE)
        ; has_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK)
        ; has_context(CONTEXT_COMPILER_IGNOREDEP)
        ),
	!.

verify_symbol_context(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,NO_ERRORS):-
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,_SFile,PROLOG_SYMBOL,_Transactional),
	!.

verify_symbol_context(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,NO_ERRORS):-
	flora_get_flatomvar_name(Funct,Name),
	(has_context(CONTEXT_COMPILER_SENSOR_DIRECTIVE(Name,Arity))
	;
	    has_permaoption(defsensor(Name,Arity))
	),
	!.


verify_symbol_context(Funct,Arity,WS,SymbolContext,Transactional,SymbolContextStatus):-
	flora_get_flatomvar_name(Funct,Name),
	!,
  	approx_flindex(Funct,Index),
	get_current_compile_file(CurFile),
        %% Check if symbol was used before in a different context
	(Arity==0, SymbolContext==FUNCTION_SYMBOL,
            symbol_warnings_flag(FLORA_CONSTOFF)
        ->
            SymbolContextStatus = NO_ERRORS
        ; has_symbol(Name,SArity,_,_SIndex,SLine,SFile,SContext,STransactional),
	    Name \= HILOG_SYMBOL_NAME,
	    %% Index > 0 ensures that symbols introduced by the compiler
	    %% are not checked
	    integer(Index),
	    Index > 0,
	    (SFile == CurFile -> SymFileMsg = ' in the same file '
	    ; flora_concat_atoms([' in file ',SFile,' '],SymFileMsg)
	    ),
	    make_symbol_context_status(SContext,SLine,SymFileMsg,
				       STransactional,
				       SArity,Name,Arity,WS,
				       Index,SymbolContext,Transactional,
				       SymbolContextStatus),
	    SymbolContextStatus \== NO_ERRORS,
	    %% note: we need to backtrack through enough of symbols to
	    %% get a warning
	    !
	 ;
	    SymbolContextStatus = NO_ERRORS
         ),
	!,
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,CurFile,SymbolContext,Transactional).

verify_symbol_context(_Funct,_Arity,_WS,_SymbolContext,_Transactional,NO_ERRORS).

/****************************************************************************
suppress_symbol_warning(+Name,+Arity,+WS,+SymbolContext,+Transactional)
****************************************************************************/
%% do not check workspace for function symbols
suppress_symbol_warning(Name,Arity,_WS,FUNCTION_SYMBOL,Transactional):-
	(has_nowarn_any_symbol(Name,Arity,_,FUNCTION_SYMBOL,Transactional)
        ;
            has_nowarn_any_symbol(Name,FL_STAR,_,FUNCTION_SYMBOL,Transactional)
        ),
	!.

suppress_symbol_warning(Name,Arity,_WS,SymbolContext,Transactional):-
	(has_nowarn_any_symbol(Name,Arity,StoredWS,SymbolContext,Transactional)
        ;
            has_nowarn_any_symbol(Name,FL_STAR,StoredWS,SymbolContext,Transactional)
        ),
	%% If StoredWS is an anonymous variable - then ignore warnings
	is_flvariable(StoredWS,VarName,_VarIndex),
	VarName == FL_ANON_VAR,
	!.

/*
%% Is this redundant in view of the next clause?? WS can't be NULL any more
suppress_symbol_warning(Name,Arity,NULL,SymbolContext,Transactional):-
	%% if workspace for symbol is NULL then ignore warnings
	%% only if StoredWS is current module or NULL
	(has_nowarn_any_symbol(Name,Arity,NULL,SymbolContext,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,NULL,SymbolContext,Transactional)),
	!.
*/

suppress_symbol_warning(Name,Arity,FL_THISMODULE,SymbolContext,Transactional):-
	%% if workspace for symbol is FL_THISMODULE then ignore warnings
	(has_nowarn_any_symbol(Name,Arity,FL_THISMODULE,SymbolContext,Transactional)
        ;
            has_nowarn_any_symbol(Name,FL_STAR,FL_THISMODULE,SymbolContext,Transactional)
        ),
	!.

suppress_symbol_warning(Name,Arity,WS,SymbolContext,Transactional):-
	%% if workspace for symbol is not NULL then we ignore warnings
	%% only if StoredWS has the same name as WS
	%%WS \= NULL,
	WS \= FL_THISMODULE,
	flora_get_flatomvar_name(WS,WSName),
	(has_nowarn_any_symbol(Name,Arity,WSName,SymbolContext,Transactional)
        ;
            has_nowarn_any_symbol(Name,FL_STAR,WSName,SymbolContext,Transactional)
        ),
	!.

/****************************************************************************
compiling_symbol_warning(+Name,+Arity,+WS,+SymbolContext,+Transactional,+Index,+Mesg,-Status)
****************************************************************************/
compiling_symbol_warning(_Name,_Arity,_WS,_SymbolContext,_Transactional,_Index,_Mesg,NO_ERRORS):-
	symbol_warnings_flag(FLORA_WARNOFF),
	!.

compiling_symbol_warning(Name,Arity,WS,SymbolContext,Transactional,_Index,_Mesg,NO_ERRORS):-
	suppress_symbol_warning(Name,Arity,WS,SymbolContext,Transactional),
	!.

compiling_symbol_warning(Funct,_Arity,_WS,_SymbolContext,_Transactional,Index,MesgIn,[Warning]):-
	extract_real_token_number(Index,RealIndex),
	flora_nth_token(RealIndex,Token),
	flora_token_text(Token,TextStr,_BLN,_BCN,_ELN,_ECN),
	atom_codes(TextAtom,TextStr),
	(is_list(MesgIn) -> append(MesgIn,[WARN_SUPPRESS_SYMBOL],Mesg)
	; flora_concat_atoms([MesgIn,WARN_SUPPRESS_SYMBOL],Mesg)
	),
	( TextAtom=Funct -> compiling_warning(Index,Mesg,Warning)
	; flora_op_synonym(TextAtom,Funct) ->
	    compiling_warning(Index,Mesg,Warning)
	%% TextAtom is a transactional variant of Funct: don't show Funct twice
	; TextStr = [CH_PERCENT|TextStr1], atom_codes(Funct,TextStr1) ->
	    compiling_warning(Index,Mesg,Warning)
	; compiling_warning(Index,[Funct,': '|Mesg],Warning)
	).

/****************************************************************************
make_symbol_context_status(+UsedSymContext,+UsedLine,+UsedFileMsg,+UsedTransactional,+UsedArity,+SymbolName,+SymbolArity,+SymbolWS,+SymbolIndex,+SymbolContext,+SymbolTransactional,-Status)
****************************************************************************/
make_symbol_context_status(_UsedSymContext,UsedLine,UsedFileMsg,UsedTransactional,_UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SymbolContext,SymbolTransactional,SymContextStatus) :-
	UsedTransactional\=SymbolTransactional,
	!,
	(SymbolTransactional==TRANSACTIONAL_SYMBOL
	-> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional,SymbolIndex,
				    [WARN_TRANSACTIONAL_SYMBOL,ERRLINE_NO,
				     UsedLine,UsedFileMsg],
				    SymContextStatus)
	; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional,SymbolIndex,
				   [WARN_NONTRANSACTIONAL_SYMBOL,ERRLINE_NO,
				    UsedLine,UsedFileMsg],
				   SymContextStatus)
	).

make_symbol_context_status(UsedSymContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,FUNCTION_SYMBOL,SymbolTransactional,SymContextStatus) :-
	( UsedSymContext==UDF_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_FUNC_UDF_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==FUNCTION_SYMBOL,
	    UsedArity\=SymbolArity,
	    %%_UsedTransactional = SymbolTransactional,
	    %% This prevents things like a+b and X = +1 from causing a warning
	    %% Ditto with a-b, X=-2.
	    ((SymbolName \== FL_MINUS, SymbolName \== FL_PLUS)
	    ; (UsedArity =\= 1, UsedArity =\= 2)
	    ; (SymbolArity =\= 1, SymbolArity =\= 2)
	    )
	    ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_FUNC_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	;   %% for the following, we warn only if there was prior use as
	    %% hilog predicate, modular prolog predicate, or sensor
	    %% with the ***same*** number of arguments
	    UsedSymContext==PREDICATE_SYMBOL, UsedArity==SymbolArity,
	    (\+memberchk(SymbolName,[FL_FALSE,FL_TRUE]) ; UsedArity =\= 0)
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_FUNC_PREDICATE_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_FUNC_PROLOG_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_FUNC_SENS_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
/*
	; UsedSymContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_SYMBOL], SymContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_ARITY_SYMBOL], SymContextStatus)
	    )
*/
	;
	    SymContextStatus = NO_ERRORS
        ),
	!.

make_symbol_context_status(UsedSymContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional,SymContextStatus) :-
	( UsedSymContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_PREDICATE_UDF_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==FUNCTION_SYMBOL, UsedArity==SymbolArity,
	    (\+memberchk(SymbolName,[FL_FALSE,FL_TRUE]) ; UsedArity =\= 0)
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_PREDICATE_FUNC_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PREDICATE_SYMBOL,
	    %%_UsedTransactional = SymbolTransactional,
	    UsedArity\=SymbolArity
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_PREDICATE_PROLOG_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==SENSOR_SYMBOL, UsedArity==SymbolArity,
	    \+compiling_flrshell_command ->
	    compiling_error(SymbolIndex,
			    [ERROR_PREDICATE_SENS_SYMBOL,ERRLINE_NO,
			     UsedLine,UsedFileMsg],
			    Err),
	    SymContextStatus = [Err]
	; UsedSymContext==SENSOR_SYMBOL, \+compiling_flrshell_command ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
				     [ERROR_PREDICATE_SENS_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	;
	    SymContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedSymContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,UDF_SYMBOL,SymbolTransactional,SymContextStatus) :-
	( UsedSymContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_UDF_PROLOG_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==FUNCTION_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,
			       [ERROR_UDF_SYMBOL, %%WARN_UDF_FUNC_SYMBOL,
				ERRLINE_NO, UsedLine,UsedFileMsg],
			       Err),
		SymContextStatus = [Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				       [WARN_UDF_FUNC_ARITY_SYMBOL,ERRLINE_NO,
					UsedLine,UsedFileMsg],
				       SymContextStatus)
	    )
	; UsedSymContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
					[WARN_UDF_PREDICATE_SYMBOL,ERRLINE_NO,
					 UsedLine,UsedFileMsg],
					SymContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				       [WARN_UDF_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
					UsedLine,UsedFileMsg],
				       SymContextStatus)
	    )
	; UsedSymContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_UDF_SENSOR_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_SYMBOL], SymContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_ARITY_SYMBOL], SymContextStatus)
	    )
	;
	    SymContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedSymContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SENSOR_SYMBOL,SymbolTransactional,SymContextStatus) :-
	( UsedSymContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_SENSOR_UDF_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_SENSOR_FUNC_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PREDICATE_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				     [ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PREDICATE_SYMBOL, UsedArity==SymbolArity ->
	    (\+compiling_flrshell_command ->
		compiling_error(SymbolIndex,
				[ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				Err),
		SymContextStatus = [Err]
	    %% in the FLORA-2 shell just give a warning
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				       [ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
					UsedLine,UsedFileMsg],
				       SymContextStatus)
	    )
	; UsedSymContext==SENSOR_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_SENSOR_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==PROLOG_SYMBOL,
	    %% prolog symbol that comes from a sensor has 2 more args: file+line
	    (UsedArity=\=SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
					[ERROR_SENSOR_PROLOG_SYMBOL,ERRLINE_NO,
					 UsedLine,UsedFileMsg],
					SymContextStatus)
	    ; compiling_error(SymbolIndex,
			      [ERROR_SENSOR_PROLOG_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      Err),
	    	SymContextStatus=[Err]
	    )
	; UsedSymContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex, WARN_BUILTIN_SYMBOL, Err),
	    	SymContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_ARITY_SYMBOL], SymContextStatus)
	    )
	;
	    SymContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedSymContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,PROLOG_SYMBOL,SymbolTransactional,SymContextStatus) :-
	%% MK: can this happen in the FLORA-2 shell?
	( UsedSymContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_error(SymbolIndex,
			    [ERROR_PROLOG_UDF_SYMBOL,ERRLINE_NO,
			     UsedLine,UsedFileMsg],
			    Err),
		SymContextStatus=[Err]
	; UsedSymContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex,
				     [WARN_PROLOG_ARITY_SYMBOL,ERRLINE_NO,
				      UsedLine,UsedFileMsg],
				     SymContextStatus)
	; UsedSymContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
		compiling_error(SymbolIndex,
				[ERROR_PROLOG_FUNC_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				Err),
		SymContextStatus=[Err]
	; UsedSymContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,
			       [ERROR_PROLOG_PREDICATE_SYMBOL,ERRLINE_NO,
				UsedLine,UsedFileMsg],
			       Err),
	    	SymContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex,
				       [WARN_PROLOG_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
					UsedLine,UsedFileMsg],
				       SymContextStatus)
	    )
	; UsedSymContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex, WARN_BUILTIN_SYMBOL, Err),
		    SymContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex, [WARN_BUILTIN_ARITY_SYMBOL], SymContextStatus)
	    )
	;
	    SymContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(_,_,_,_,_,_,_,_,_,_,_,NO_ERRORS).


/****************************************************************************
  compile_load(+LoadList,+Mode,-Code,-Status)
  Mode: FL_LOAD/FL_ADD
****************************************************************************/
compile_load(LoadList,Mode,Code,Status) :-
	is_fllist(LoadList,L,T,I),
	%% since complex terms aren't allowed in load lists, we ignore OidCode
	compile_body_list_obj(L,T,I,FL_THISMODULE,ObjList,_OidCode,OCode,[],Status),
	( no_errors_found(Status) ->
	    thismodule_struct(Mod),
	    %% This is the file being compiled
	    (flora_compiler_environment(file,ProgramFile), !
	    ; ProgramFile=FL_SHELL_FICTITIOUS_FILENAME
	    ),
	    %% "I" is a token index
	    extract_real_token_number(I,RealI),
	    flora_nth_token(RealI,Token),
	    flora_token_text(Token,_TextStr,BLN,BCN,_ELN,_ECN),
	    %% Encode location of the literal [file>>mod]
	    %% Location is used for error checking in flrload.P to make sure
	    %% that loading of a file doesn't override the program
	    %% in which the loading statement occurs
	    list_struct([BLN,BCN],[],PositionCode),
	    (Mode == FL_LOAD -> Library = FLLIBLOAD
            ; Mode == FL_ADDNEW -> Library = FLLIBADDNEW
	    ; Library = FLLIBADD
	    ),
	    florasyslib_struct(I,Library,
			       4,
			       [ObjList,ProgramFile,Mod,PositionCode],LCode),
	    conjunct_struct(OCode,LCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_var(+Name,+Index,-VarObject)
****************************************************************************/
compile_var(FL_ANON_VAR,Index,VarObject) :-
	!,
	new_dontcare_prvariable(Index,VarObject).
compile_var(Name,Index,VarObject) :-
	varobj_struct(Name,Index,VarObject).

compile_transactionalvar_without_trans(FL_ANON_VAR,Index,VarObject) :-
	!,
	new_dontcare_prvariable(Index,VarObject).
compile_transactionalvar_without_trans(Name,Index,VarObject) :-
	varobj_struct(Name,Index,VarObject).

compile_transactionalvar(FL_ANON_VAR,Index,VarObject) :-
	!,
	new_dontcare_prtransactionalvar(Index,VarObject).
compile_transactionalvar(Name,Index,VarObject) :-
	transactionalvar_struct(Name,Index,VarObject).

%% takes list of flvars
compile_var_list([],[]) :- !.
compile_var_list([Var|Rest],[PrVar|PrRest]) :-
	is_flvariable(Var,Name,Index),
	compile_var(Name,Index,PrVar),
	compile_var_list(Rest,PrRest).

/****************************************************************************
  compile_atomobj(+ParserTerm,-Object,?BodyFrontList,-Status)

  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to empty ([])
		  ignores user defined functions
****************************************************************************/
compile_atomobj(ParserTerm,Object,BodyFrontList,Status):-
	var(BodyFrontList),
	%% NO cut here!
	udf_expansion_test(ParserTerm,0),
	has_UDF(ParserTerm,0,[],Predicate,Object /* return value */,_,_),
	!,
	verify_symbol_context(ParserTerm,0,UDF_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymStatus),
	compile_udf_body_literal(ParserTerm,Predicate,PCode,PBodyFrontList,S),
	( no_errors_found(S) -> 
	    %%BodyFrontList = [PCode|PBodyFrontList],
	    append(PBodyFrontList,[PCode],BodyFrontList),
	    append(S,SymStatus,Status)
	;
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,ERROR_UDF_COMPILE,Err),
	    Status = [Err|S]
	).

compile_atomobj(ParserTerm,Object,[],Status):-
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,Status),
	atomobj_struct(ParserTerm,Object).


/****************************************************************************
  compile_udf_body_literal(+Funct,+Predicate,-PCode,-PBodyFrontList,-Status)

  Compile a UDF literal in the body.

  PBodyFrontList contains the UDFHILOGPREDICATENAME/4 predicates that have
  to be fronted before the predicate being translated. For instance,
  if foo/1, bar/1 are UDFs and we are translating mypred(foo(?X),bar(?X))
  then we get:

        UDFHILOGPREDICATENAME(foo(X),1,\@,Newvar1),
        UDFHILOGPREDICATENAME(bar(X),1,\@,Newvar2),
	mypred(Newvar1,Newvar2).
   
  Here the UDFHILOGPREDICATENAME part goes into PBodyFrontList. Note that there
  is redundancy in the above translation, if foo(X) and bar(X) can be rewritten
  in myltiple ways. This would result in unnecessary backtracking. An example
  is givein in flora2-testsuite/functions/test_func_eq.flr
****************************************************************************/
compile_udf_body_literal(Funct,Predicate,PCode,PBodyFrontList,Status) :-
	%% If we set CONTEXT_COMPILER_NO_SYMBOL_CHECK here then clear it out
	%% at the end. If inherited CONTEXT_COMPILER_NO_SYMBOL_CHECK from
	%% the caller - do not clear out the context
	push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	set_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	compile_body_literal_top(Predicate,FL_THISMODULE,OidCode,SpecCode,PBodyFrontList,Status),
	%% generaly we should use strong conjunction for OidCode+SpecCode
	%% coming out of compile_body_literal_top/6, if this code can appear
	%% under NAF. This is because OidCode+SpecCode usually share variables.
	%% Here using strong_conjunct_struct/3 is probably an overkill,
	%% but this has no performance penalty.
	strong_conjunct_struct(OidCode,SpecCode,PCode),
	clear_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK).


/****************************************************************************
  find_UDF(+BaseName,+N,-UDFCode,-Predicate) 

  Indicate if there is an active UDF
****************************************************************************/
find_UDF(BaseName,N,UDFCode,Predicate) :-
	has_permaoption(udf_option(BaseName,N,UDFCode,_PredName,Predicate)),
	!.
find_UDF(BaseName,N,UDFCode,Predicate) :-
	flora_used_udf_registry(BaseName,N,UDFCode,Predicate),
	!.

/****************************************************************************
  has_UDF(+Funct,+N,-Predicate,-ReturnValue,-BodyFrontList,-Status) 

  Tells if there is an active UDF with this Funct/N

  Funct - Functor of UDF
  N - Arity of UDF
  Predicate - the new_udf_predicate_XXX that computes this UDF
  ReturnValue - the variable representing the return value of this UDF;
                it appears in Predicate as Arg 1.
  BodyFrontList - a list of literals to be added to rule body where udf appears
                 (again for cases when udf functor is a term)
  Example:
     head :- q(?x(a,b)(?x))
     head :- udf_hilog_predicate(?x(a,b),?var2),
	     udf_hilog_predicate(?var2(?x)),?var1),
             q(?var1) 
****************************************************************************/
%% TODO: Status seems to be always [] - remove?
has_UDF(Funct,N,Args,Predicate,ReturnValue,[],NO_ERRORS) :-
	\+ has_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	\+ has_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	\+ get_flatom_name(Funct,UDFHILOGPREDICATENAME),
	flora_get_flatom_name(Funct,Name),
	(flora_op_synonym(Name,BaseName)
	; BaseName = Name
	),
	find_UDF(BaseName,N,_UDFCode,_PredicateCode),
	make_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue),
	!.

has_UDF(Funct,N,Args,Predicate,ReturnValue,[],NO_ERRORS) :-
	\+ has_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	N\=0,
	Args\=[],
	Args\=null,
	is_flvariable(Funct,_VarName,_Idx),
	!,
	\+ has_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	find_UDF(_BaseName,N,_UDFCode,_PredicateCode),
	make_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).


has_UDF(Funct,N,Args,Predicate,ReturnValue,[],NO_ERRORS) :-
	\+ has_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	N\=0,
	Args\=[],
	Args\=null,
	is_flterm(Funct,_FFunct,_FunctN,_FunctArgs),
	!,
	\+ has_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	find_UDF(_BaseName,N,_UDFCode,_Predicate),
	make_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).

has_UDF(Funct,N,Args,Predicate,ReturnValue,[],NO_ERRORS) :-
	\+ has_context(CONTEXT_COMPILER_BLOCK_UDF_EXPANSION),
	\+ has_context(CONTEXT_COMPILER_UDF_HILOG(Funct)),
	N\=0,
	Args\=[],
	Args\=null,
	find_UDF(HILOG_SYMBOL_NAME,N,_UDFCode,_PredicateCode),
	make_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).

/****************************************************************************
  make_udf_hilog_predicate(+Funct,+N,+Args,+ReturnOrigPred,-Predicate,-ReturnValue) 

  makes the predicate for UDF with term names (hilog).

  Funct - UDF functor
  N - UDF arity
  Args - UDF arguments
  Predicate - UDFHILOGPREDICATENAME code
  ReturnValue - code for the return variable which represents the return value
                of udf_hilog_predicate. This variable appears as argument 5 in
		UDFHILOGPREDICATENAME.
****************************************************************************/
make_udf_hilog_predicate(Funct,N,Args,NewHeadCode,NewReturnValueObj):-
	get_udf_hilog_predicate_funct(NPFunct),
	%%set_context(CONTEXT_COMPILER_UDF_HILOG(NPFunct)),
	new_flvariable(NO_INDEX,NewReturnValue,NewReturnValueObj),
	flterm_struct(Funct,N,Args,OrigPredicateCode),
	flthismodule_struct(Module),
	flterm_struct(NPFunct,4,[OrigPredicateCode,N,Module,NewReturnValue],NewHeadCodePre),
	flplib_struct(NewHeadCodePre,NewHeadCode).

/*
   Convert a UDFHILOGPREDICATENAME(UDF,_,_,Result) to
   Result = UDF.
   This is needed when compiling UDFs under clause{...}. In this case,
   UDFs get injected into the clause by the code executed before clause{...}
*/
convert_udf_hilog_predlist([],[]) :- !.
convert_udf_hilog_predlist([H|T],[HOut|TOut]) :-
        convert_one_udf_hilog_pred(H,HOut),
        convert_udf_hilog_predlist(T,TOut).
convert_udf_hilog_predlist([H|T],[H|TOut]) :-
        convert_udf_hilog_predlist(T,TOut).

convert_one_udf_hilog_pred(H, HOut) :-
        is_prologliblit(H,H1),
        get_udf_hilog_predicate_prfunct(Funct),
	is_prologterm(H1,Funct,4,[Fun,_,_,RetVal]),
        !,
        atomobj_struct(FL_UNIVEQ,UnivEQCode),
	prologterm_struct(UnivEQCode,2,[RetVal,Fun],H2),
        prologliblit_struct(H2,HOut).
%% NAF doesn't propagate through PRBAND.
%% Here _Aux represents delay code (eg, from ?X^^type) and the like
convert_one_udf_hilog_pred(PRBAND(_Aux,H), HOut) :-
        convert_one_udf_hilog_pred(H, HOut).


/****************************************************************************
  get_udf_hilog_predicate_funct(-Funct) 

  form predicate functor for UDF with term names (hilog).
****************************************************************************/
get_udf_hilog_predicate_funct(Funct):-
	flatom_struct(UDFHILOGPREDICATENAME,NO_INDEX,Funct).
get_udf_hilog_predicate_prfunct(Funct):-
	atomobj_struct(UDFHILOGPREDICATENAME,Funct).



/****************************************************************************
  compile_delayquant(+Quant,+Condition,+Goal,+Index,-SpecCode,-BodyFrontList,-Status)
****************************************************************************/
compile_delayquant(Quant,ConditionWS,Goal,Index,SpecCode,BodyFrontList,Status):-
	collect_flvar_names(ConditionWS,CondVarNames),
	collect_flvar_names(Goal,GoalVarNames),
	detach_flworkspace(ConditionWS,Condition,WS),
	compile_body_literal_top(Condition,WS,OidCode,WSCode,BodyFrontList,S1),
	%% generaly we should use strong conjunction for OidCode+WSCode
	%% coming out of compile_body_literal_top/6, if this code can appear
	%% under NAF. This is because OidCode+WSCode usually share variables.
	%% Here using strong_conjunct_struct/2 for delay conditions is probably
	%% an overkill, but there is no performance penalty.
	strong_conjunct_struct(OidCode,WSCode,ConditionCode),
	(subset(CondVarNames,GoalVarNames) ->
	    ( no_errors_found(S1) ->
		compile_body(Goal,GoalCode,S2),
		( no_errors_found(S2) ->
		    append(S1,S2,Status),
		    delay_struct(Index,FL_DELAYQUANT,
				 [Quant,ConditionCode,GoalCode],
				 SpecCode)
		;
		    Status = S2
		)
	    ;
		Status = S1
	    )
	;
	    approx_flindex(Condition,Idx),
	    compiling_error(Idx,DELAY_QUANT_VARS_NOT_IN_GOAL,Err),
	    Status = [Err]
	).


/****************************************************************************
 compile_aggregate(+Op,+AggVar,+GVars,+SortSpec,+BodyTerm,-Object,-Code,-Status)
 SortSpec can be a list of vars used for duplicate control in sum, avg, count
 Or it is a more complex sort spec used by setof and bagof
****************************************************************************/
compile_aggregate(Op,AggVar,GVars,SortSpec,BodyTerm,Object,Code,Status) :-
	compile_body(BodyTerm,BodyPureCode,S),
	delay_literals_checking_code([],BodyTerm,[],[],FL_DESCRIPTOR_VARS_WRAPPER,DelayCheckCode),
	PostBody = DelayCheckCode,
	(is_prvariable(PostBody) -> BCode = BodyPureCode
	; conjunct_struct(BodyPureCode,PostBody,BCode)
	),
	( no_errors_found(S) -> 
	    check_aggregate(AggVar,GVars,SortSpec,BodyTerm,S1),
	    ( no_errors_found(S1) -> 
		compile_body_pathexplist([AggVar|GVars],FL_THISMODULE,[_AggVarCode|GVarsCode],NULL,NULL,[],NO_ERRORS),
		%% Note: grouping vars are global, NOT renamed
		list_struct(GVarsCode,[],GVarsListCode),
		is_flvariable(AggVar,AggVarName,_),
		%% make agg var unique so it won't get bound from the outside
		rename_prvariables([AggVarName],NEWDONTCAREVAR,BCode,NewBCode,[NewAggVarCode]),
		(SortSpec==NULL ->
                    list_struct([],[],SpecCode),  %% empty list
                    aggregate_struct(Op,NewAggVarCode,GVarsListCode,SpecCode,NewBCode,Object,Code),
		    Status = NO_ERRORS
                ; is_list(SortSpec) -> %% duplicate control in sum/count/avg
                    compile_var_list(SortSpec,SpecCodePre),
                    list_struct(SpecCodePre,[],SpecCode),
                    aggregate_struct(Op,NewAggVarCode,GVarsListCode,SpecCode,NewBCode,Object,Code),
                    Status = NO_ERRORS
		;
		    is_flterm(SortSpec,Funct,N,Args),
		    (is_fltransactionalatom(Funct,_)
		    -> Transactionality = TRANSACTIONAL_SYMBOL
		    ; Transactionality = NONTRANSACTIONAL_SYMBOL
		    ),
		    compile_body_termobj(Funct,N,Args,FL_THISMODULE,SpecCode,_,_,[],Transactionality,Status),
		    ( no_errors_found(Status) -> 
			aggregate_struct(Op,NewAggVarCode,GVarsListCode,SpecCode,NewBCode,Object,Code)
		    ;   true
		    )
		)
	    ;
	      Status = S1
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  check_aggregate(+AggVar,+GroupVars,+SortSpec,+BodyTerm,-Status)
     SortSpec is used only if it is a list of uniquification vars
     for count, sum, avg.
  check_repeatedvar(+Vars,-Status,-TailStatus)
  allgvar_notin(+SortedVars,-Status,-TailStatus)
  Checks for any abnormalities with grouping and aggregate variables.
****************************************************************************/
check_aggregate(AggVar,GVars,SortSpec,BodyTerm,Status) :-
	is_flvariable(AggVar,AggVarName,AggVarIndex),
	%% Check if the aggregate variable is anonymous.
	( AggVarName == FL_ANON_VAR ->
	    compiling_error(AggVarIndex,ERROR_AVAR,M1),
	    Status=[M1|S1]
	;
	  Status=S1
        ),
	%% Check if any grouping variable is anonymous.
	check_gvar(GVars,S1,S2),
	%% Check if the aggregate variable is also used for grouping.
	( AggVarName \= FL_ANON_VAR, is_flvariable(U,AggVarName,_Iu),
	    memberchk(U,GVars) ->
	    compiling_error(AggVarIndex,AVAR_ASGVAR,M2),
	    S2=[M2|S3]
	; S3=S2
        ),
	%% Check if there are any repeated grouping variables.
	sort(GVars,SVars),
	check_repeatedvar(SVars,S3,S4),
	collect_flvars(BodyTerm,BVars),
	%% Check if aggregate variable is used in the aggregate body.
	( (AggVarName == FL_ANON_VAR; is_flvariable(W,AggVarName,_Iw), memberchk(W,BVars)) ->
	    S5=S4
        ;
	  compiling_error(AggVarIndex,AVAR_NOTIN,M5),
	  S4=[M5|S5]
        ),
	%% Check if all grouping variables are used in the aggregate body.
	( subtract_vars(GVars,BVars,L), L \== [] ->
	    sort(L,SL),
	    allgvar_notin(SL,S5,S6)
	;
	  S6 = S5
        ),
	%% Check if all SortVars (if it is a list of uniquification vars
        %% for sum, count, avg) are used in the aggregate body.
	( subtract_vars(SortSpec,BVars,L), L \== [] ->
            approx_flindex(L,Index),
            compiling_error(Index,UNIQVAR_NOTIN,Msg),
            S6 = [Msg]
	;
	  S6 = NO_ERRORS
        ),
	!.


check_gvar([],S,S) :- !.

check_gvar([H|L],Status,TS) :-
	( is_flvariable(H,FL_ANON_VAR,HIndex) ->
	    compiling_error(HIndex,ERROR_GVAR,M),
	    Status=[M|S],
	    check_gvar(L,S,TS)
	;
	  check_gvar(L,Status,TS)
        ).


check_repeatedvar([],S,S) :- !.

check_repeatedvar([H|L],Status,TS) :-
	is_flvariable(H,FL_ANON_VAR,_I),
	!,
	check_repeatedvar(L,Status,TS).

check_repeatedvar([_H],S,S) :- !.

check_repeatedvar([H1,H2|T],Status,TS) :-
	( is_flvariable(H1,Name,_I1), is_flvariable(H2,Name,I2) ->
	    compiling_error(I2,REPEATED_GVAR,Msg),
	    Status=[Msg|S],
	    check_repeatedvar([H1|T],S,TS)
	;
	  check_repeatedvar([H2|T],Status,TS)
        ).


allgvar_notin([],S,S) :- !.

allgvar_notin([H|L],Status,TS) :-
	is_flvariable(H,FL_ANON_VAR,_I),
	!,
	allgvar_notin(L,Status,TS).

allgvar_notin([H|T],[Msg|S],TS) :-
	is_flvariable(H,Name,Index),
	compiling_error(Index,GVAR_NOTIN,Msg),
	remove_named_flvar_from_list_prefix(T,Name,L),
	allgvar_notin(L,S,TS).


/****************************************************************************
  compile_head_fltoken(+Token,+Index,-Object)

  Handles \#, \#123, \@, atoms
****************************************************************************/
compile_head_fltoken(FL_THISMODULE,_Index,Object) :-
	!,
	thismodule_struct(Object).
compile_head_fltoken(FL_NEWOID,Index,Object) :-
	!,
	%% DEAD CODE: The parser no longer generates unnumbered skolems, so
	%% new_oidobj/2 is actually never used
	new_oidobj(Index,Object).
compile_head_fltoken(Token,Index,Object) :-
        atomobj_struct(Token,Index,Object).

/****************************************************************************
  compile_head_fltoken(+Token,+Num,+Index,-Object,-Status)
****************************************************************************/
compile_head_fltoken(FL_NEWOID,Suffix,Index,Object,NO_ERRORS) :-
	!,
	new_oidobj(Suffix,Index,Object).
compile_head_fltoken(FL_NEWOID_GLOBAL,Suffix,Index,Object,NO_ERRORS) :-
	!,
	new_oidobj_global(Suffix,Index,Object).
compile_head_fltoken(FLSPECIALSKOLEM,Suffix,Index,Object,NO_ERRORS) :-
	!,
        %% Like FL_NEWOID, but is a Skolem both in the body and in the head
        %% Generated by skolemization during the omni transform
	new_oidobj(Suffix,Index,Object).
compile_head_fltoken(Token,Suffix,Index,Object,Status) :-
        (%% \@F
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_SPECIAL_FILE_TOKEN ->
	    get_current_compile_file(FileName),
            (has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
                generate_prolog_term(FL_DYNRULE_FICTITIOUS_FILENAME,1,[FileName],Object)
            ; atomobj_struct(FileName,Index,Object)
            ),
	    Status = NO_ERRORS
	; %% \@L
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_SPECIAL_LINE_TOKEN ->
	    flora_token_index_to_line(Index,Line),
	    numobj_struct(Line,Index,Object),
	    Status = NO_ERRORS
	;  %% \@!, the rule id
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_RULEID_SYM ->
	    ( has_context(CONTEXT_COMPILER_DESCRIPTORS(Mode))
	    -> construct_default_ruleid_descriptor(Mode,Index,DescrIdCode),
		%% the CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS context is
		%% cleared out in compile_complex_descriptor/6
		set_context(CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS),
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ; (has_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)) -> true
	      ; has_context(CONTEXT_COMPILER_RULE(DescrIdCode))
	      )
	    -> 
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ;
		compiling_error(Index,RULEID_TOKEN_NOT_IN_RULE,Err),
		Status = [Err]
	    )
        ; %% \@? - the null value
            Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_NULL_QUASI_SYM ->
            compile_null_value(Object,Status)
        ;
	    atomobj_struct(Token,Index,Object),
	    Status = NO_ERRORS
        ).


/*****************************************************************************
%% compile_head_setarg_list(+Setarg,+WS,-SetList,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
%% set expression {a1,a2,a3}
%%
%% SetList - the list [Elt1, Elt2, ...], where Elt1,Elt2, etc., are the
%%                  compiled object parts in the set expression
%% BodyFrontList -  the code resulting from stuff attached
%%                  to the elements of the set, e.g., elt[foo->bar]
%%                  OidCode, code to produce elements of the set
%%                  goes into BodyFrontList
******************************************************************************/
/*
%% Head setarg expansion is now done in the parser
compile_head_setarg_list([],_WS,[],_,NULL,NULL,NO_ERRORS) :- !.
compile_head_setarg_list([Elt|Rest],WS,SetList,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexp(Elt,WS,EltObj,EltFrameStuff,EltH2BCodeFront,EltH2BCodeBack,S),
	( no_errors_found(S) -> 
	    compile_head_setarg_list(Rest,WS,RestSetList,RestCode,RestH2BCodeFront,RestH2BCodeBack,S2),
	    ( no_errors_found(S2) -> 
		SetList = [EltObj|RestSetList],
		conjunct_struct(EltFrameStuff,RestCode,Code),
		conjunct_struct(EltH2BCodeFront,RestH2BCodeFront,H2BCodeFront),
		conjunct_struct(EltH2BCodeBack,RestH2BCodeBack,H2BCodeBack),
		append(S,S2,Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ).
*/


/****************************************************************************
  compile_floraliblit(+ParserTerm,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)

  This procedure compiles a literal that is associated with a Flora system
  module specification.
 ?BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
****************************************************************************/
compile_floraliblit(ParserTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_body_literal_top(ParserTerm,WSCode,OidCode,Code,
				 BodyFrontList,Status).


/****************************************************************************
  compile_body_literal_top(+ParserTerm,+Workspace,-OidCode,-BodyLitCode,?BodyFrontList,-Status)
  BodyLitCode is the main code for the literal. It may be multiplied if
              it contains set arguments. Eg, p({a,b}) becomes p(a),p(b).
              This is done by replacing {a,b} with an attributed variable X
	      that has member(X,[a,b]) as an attribute. At the end of
	      compile_body_literal_top/6, we do
	      findall(WSCode,member(X,[a,b]),BodyLitCode), which does
	      the multiplication trick.
  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
****************************************************************************/
compile_body_literal_top(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	%%compile_body_literal(ParserTerm,WS,OidCode,BodyLitCodePre,BodyFrontList,Status),
        %% OBSOLETE - expansion is now in the parser
	%% multiply the literal, if it has set arguments inside
	%%multiply_setarg_code(BodyLitCodePre,BodyLitCode).
	compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status).


%% TODO: no need for separate OidCode+WSCode. This is used only in
%% compile_floraliblit, but compile_floraliblit does not need it either!!!
compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_fltransactionalterm(ParserTerm,Funct,N,Args),
	!,
	compile_body_transactional_termlit(Funct,N,Args,WS,OidCode,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flterm(ParserTerm,Funct,N,Args),
	!,
	compile_body_termlit(Funct,N,Args,WS,OidCode,BodyLitCode,BodyFrontList,Status).

%% Literal variable without @module
compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],NO_ERRORS) :-
	is_flvariable(ParserTerm,VName,VIndex),
	WS == FL_THISMODULE,
	!,
	compile_var(VName,VIndex,V),
	( ( has_context(CONTEXT_COMPILER_WITH_VAR_MODULE)
	  ; has_context(CONTEXT_COMPILER_GOAL_REIFICATION)
	  ; has_context(CONTEXT_COMPILER_DELETE)
	  )
	-> BodyLitCode = V
	;
	  %% Not to promote term to predicate, but to bind caller module
	  %% Needed only for calls when a variable occurs by itself in
	  %% the rule body:  ... :- ..., X, ,,,
	  thismodule_struct(ThisModule),
	  %% doesn't matter??
	  body_context_info_structure(ThisModule,FWContext),
	  %% ...:-...,X, is compiled into
	  %%    FLLIBMODLIT(libmod_wrapper,X,FL_INVALIDMODULE,FWContext)
	  atomobj_struct(FL_INVALIDMODULE,Module),
	  florasyslib_struct(VIndex,FLLIBMODLIT,3,[V,Module,FWContext],BodyLitCode)
	).

%% Variable with @module, where module != \@.  E.g., ?- ?X=p, ?X@qr.
compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_flvariable(ParserTerm,VarName,Index),
	!,
	compile_var(VarName,Index,VarCode),
	attach_workspace(VarCode,WS,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,BodyFrontList,Status) :-
	is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx),
	!,
	compile_delayquant(Quant,Condition,Goal,Idx,BodyLitCode,BodyFrontList,Status).

%% %?X@module. E.g., ?- ?X = p, %?X@pp.
%% Note: ?- %?X is impossible: parser catches it.
compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_fltransactionalvariable(ParserTerm,VarName,Index),
	!,
	compile_transactionalvar(VarName,Index,VarCode),
	attach_workspace(VarCode,WS,BodyLitCode,Status).

compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,[],Status) :-
	is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2),
	!,
	compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,_Obj,OidCode,BodyLitCode,Status).

compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flobjspec(ParserTerm,ObjTerm,Spec,_),
	!,
	compile_body_objspec(Spec,ObjTerm,WS,_Obj,OidCode,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flobjeql(ParserTerm,O1,O2),
	!,
	compile_body_objeql(O1,O2,WS,OidCode,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_fldirective(ParserTerm,DirectList,_Idx),
	!,
	compile_exec_directive(DirectList,WS,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flload(ParserTerm,LoadList),
	!,
	compile_load(LoadList,FL_LOAD,BodyLitCode,Status).

%% FLADDNEW - like FLADD, but file is not added to the module
%% if it was added before, EVEN if the module was modified.
%% This exists to work around the low time resolution in XSB for file modtimes.
%% Because the resolution is in seconds, it is possible that file mod time
%% and its add-time are the same even though the add happened later.
%% In such a case, FLADD will still re-add the file even though it should not
%% have done so. FLADDNEW will not re-add in such a situation.
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fladdnew(ParserTerm,LoadList),
	!,
	compile_load(LoadList,FL_ADDNEW,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fladd(ParserTerm,LoadList),
	!,
	compile_load(LoadList,FL_ADD,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flconstraint(ParserTerm,ConstrBody),
	!,
	push_context(CONTEXT_COMPILER_ARITHMETICS),
	set_context(CONTEXT_COMPILER_CONSTRAINT),
	compile_body(ConstrBody,ConstrBodyCode,Status),
	clear_context(CONTEXT_COMPILER_CONSTRAINT),
	pop_context(CONTEXT_COMPILER_ARITHMETICS),
	constraint_struct(ConstrBodyCode,BodyLitCode).

%% prolog call withOUT prolog module
compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flplib(ParserTerm,P),
	!,
	compile_prologliblit(P,OidCode,BodyLitCode,BodyFrontList,Status).

%% prolog call WITH prolog module
compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flplib(ParserTerm,P,Module),
	!,
	compile_prologliblit(P,Module,OidCode,BodyLitCode,BodyFrontList,Status).

%% prologALL call withOUT prolog module
compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flpliball(ParserTerm,P),
	!,
	compile_prologallliblit(P,OidCode,BodyLitCode,BodyFrontList,Status).

%% prologALL call WITH prolog module
compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flpliball(ParserTerm,P,Module),
	!,
	compile_prologallliblit(P,Module,OidCode,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_flfloralib(ParserTerm,P,Module),
	!,
	compile_floraliblit(P,Module,OidCode,BodyLitCode,BodyFrontList,Status).

%% Not attaching workspace: it is propagated inwards by the parser
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flinsert(ParserTerm,Op,List,Cond),
	!,
	compile_insert(Op,List,Cond,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flinsert(ParserTerm,Op,List),
	!,
	compile_insert(Op,List,BodyLitCode,Status).

%% Not attaching workspace: it is propagated inwards by the parser
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fldelete(ParserTerm,Op,List,Cond),
	!,
	compile_delete(Op,List,Cond,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fldelete(ParserTerm,Op,List),
	!,
	compile_delete(Op,List,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flneg(ParserTerm,_,_),
	!,
	compile_body(ParserTerm,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_fldelayedliteral(ParserTerm,Op,Args),
	!,
	compile_delayed_literal(Op,Args,BodyLitCode,OidCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,BodyFrontList,Status) :-
	is_fldelayedliteral(ParserTerm,Op,Args,Mod),
	!,
	compile_delayed_literal(Op,Args,Mod,BodyLitCode,OidCode,BodyFrontList,Status).

%% Rule: can occur only inside reify_op as a top-level literal
compile_body_literal([ReifiedRule|Rest],_WS,OidCode,BodyLitCode,[],Status) :-
	(is_fldynrule(ReifiedRule,_H,_B,_Descr)
	; is_flruleworkspace(ReifiedRule,_RealRule,_WS2)
	),
	!,
	compile_reifyop([ReifiedRule|Rest],BodyLitCode,OidCode,Status).

compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,[],Status) :-
	is_reifyop(ParserTerm,Formula),
	!,
	compile_reifyop(Formula,BodyLitCode,OidCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fltablerefresh(ParserTerm,List),
	!,
	compile_refresh(List,BodyLitCode,Status).

%% !!{Vars}
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flstopdelay(ParserTerm,VarList,Idx),
	!,
        %% here VarList consists of flvars
	compile_stop_delay(VarList,Idx,BodyLitCode,Status).

%% !! without the vars
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flstopdelay(ParserTerm,Idx),
	!,
	compile_stop_delay(_,Idx,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fltruthvalue(ParserTerm,Formula,Atom),
	!,
	compile_truthvalue(Formula,Atom,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fltag_primitive(ParserTerm,Descriptor,HeadList),
	!,
	compile_tag_primitive(Descriptor,HeadList,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flprefixprimitive(ParserTerm,Prefix,Expansion,Module),
	!,
	compile_prefixprimitive(Prefix,Expansion,Module,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flcatch(ParserTerm,Goal,Error,Handler),
	!,
	compile_catch(Goal,Error,Handler,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flthrow(ParserTerm,Error),
	!,
	compile_throw(Error,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flp2h(ParserTerm,Prolog,Hilog),
	!,
	compile_p2h(Prolog,Hilog,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],NO_ERRORS) :-
	is_flnewmodule(ParserTerm,Op,Module),
	!,
	is_flatom(Op,_OpAtom,Index),
	compile_atomvar(Module,ModCode),
	thismodule_struct(ThisModuleName),
	florasyslib_struct(Index,FLLIBNEWMODULE,2,[ThisModuleName,ModCode],BodyLitCode).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],NO_ERRORS) :-
	is_flerasemodule(ParserTerm,Op,Module),
	!,
	is_flatom(Op,_OpAtom,Index),
	compile_atomvar(Module,ModCode),
	thismodule_struct(ThisModuleName),
	florasyslib_struct(Index,FLLIBERASEMODULE,2,[ThisModuleName,ModCode],BodyLitCode).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],NO_ERRORS) :-
	is_flcallermodule(ParserTerm,Op,Module),
	!,
	is_flatom(Op,_OpAtom,_Index),
	compile_atomvar(Module,ModCode),
	caller_module_binding_code(ModCode,BodyLitCode).

compile_body_literal(ParserTerm,WS,OidCode,BodyLitCode,[],Status) :-
	is_flsimpleprimitive(ParserTerm,PrimName,Args),
	!,
        compile_simple_primitive(PrimName,Args,WS,OidCode,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flupdaterule(ParserTerm,Op,List),
	!,
	compile_updaterule(Op,List,BodyLitCode,Status).
		
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,BodyFrontList,Status) :-
        is_flclause(ParserTerm,Head,Body),
	!,
	compile_clause([],NULL,Head,Body,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,BodyFrontList,Status) :-
        is_flclause(ParserTerm,Mode,Head,Body),
	!,
	compile_clause([],Mode,Head,Body,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,BodyFrontList,Status) :-
        is_flannotated_clause_stmt(ParserTerm,Descriptor,Mode,Head,Body),
	!,
	compile_clause(Descriptor,Mode,Head,Body,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,BodyFrontList,Status) :-
	is_flannotated_clause_stmt(ParserTerm,Descriptor,Head,Body),
	!,
	compile_clause(Descriptor,NULL,Head,Body,BodyLitCode,BodyFrontList,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flcallmetafacts(ParserTerm,MetaFacts,_),
	!,
	compile_callmetafacts(MetaFacts,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flifthenelse(ParserTerm,Cond,Then,Else),
	!,
	compile_ifthenelse(Cond,Then,Else,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flifthen(ParserTerm,Cond,Then),
	!,
	compile_ifthen(Cond,Then,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fluniveqform(ParserTerm,Left,Right),
	!,
	compile_univeqform(Left,Right,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,OidCode,BodyLitCode,[],Status) :-
	is_flmetauniv(ParserTerm,Left,Right),
	!,
	compile_metauniv(Left,Right,OidCode,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flprologifthen(ParserTerm,Left,Right),
	!,
	compile_prologifthen(Left,Right,BodyLitCode,Status).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_flcontrolconstruct(ParserTerm,Wrapper,Cond,Action),
	!,
	compile_controlconstruct(Cond,Action,Wrapper,BodyLitCode,Status).
	
compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],NO_ERRORS) :-
	is_flcut(ParserTerm,I),
	!,
	cut_struct(I,BodyLitCode).

compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_flatom(ParserTerm,_A),
	!,
	atomlit_struct(BODYLITERAL,ParserTerm,Code),
	attach_workspace(Code,WS,BodyLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; Status = WSStatus
	).

compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_flbuiltin_identifier(ParserTerm,_A),
	!,
	atomlit_struct(BODYLITERAL,ParserTerm,Code),
	attach_workspace(Code,WS,BodyLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; Status = WSStatus
	).

compile_body_literal(ParserTerm,WS,NULL,BodyLitCode,[],Status) :-
	is_fltransactionalatom(ParserTerm,_A),
	!,
	transactionalatomlit_struct(BODYLITERAL,ParserTerm,Code),
	attach_workspace(Code,WS,BodyLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; Status = WSStatus
	).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fldatatype(ParserTerm,_Sort,_Lit,_Index),
	!,
	datatypeobj_struct(ParserTerm,Code1,_VarBindingCode,Status),
	(is_prvariable(Code1,_,VIndex) ->
	    %% Not to promote term to predicate, but to bind caller module
	    %% Needed only for calls when a variable occurs by itself in
	    %% the rule body:  ... :- ..., X, ,,,
	    thismodule_struct(ThisModule),
	    %% doesn't matter??
	    body_context_info_structure(ThisModule,FWContext),
	    %% ...:-...,X, is compiled into
	    %%    FLLIBMODLIT(libmod_wrapper,X,FL_INVALIDMODULE,FWContext)
	    atomobj_struct(FL_INVALIDMODULE,Module),
	    florasyslib_struct(VIndex,FLLIBMODLIT,3,[Code1,Module,FWContext],BodyLitCode)
	; atomlit_struct(BODYLITERAL,Code1,BodyLitCode)
	).

compile_body_literal(ParserTerm,_WS,NULL,BodyLitCode,[],Status) :-
	is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index),
	!,
	datatypeobj_struct(ParserTerm,Code1,_VarBindingCode,Status),
	transactionalatomlit_struct(BODYLITERAL,Code1,BodyLitCode).

compile_body_literal(ParserTerm,_WS,_OidCode,_BodyLitCode,_BodyFrontL,[Err]) :-
        is_fllist(ParserTerm,_,_,Idx),
        !,
        compiling_error(Idx, ERROR_BDLITERAL,Err).
        
compile_body_literal(ParserTerm,_WS,_OidCode,_BodyLitCode,_BodyFrontL,[Err]) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_body_literal'],Err).


/****************************************************************************
  compile_floralibobj(+ParserTerm,+Workspace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_floralibobj(ParserTerm,WS,Object,OidCode,Code,Status) :-
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_body_pathexp_top(ParserTerm,WSCode,Object,OidCode,Code,[],Status).


/****************************************************************************
  compile_body_pathexplist(+ParserTermList,+Workspace,-ObjectList,-OidCode,-Code,?BodyFrontList,-Status)
  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is normally an output parameter, but if bound to []
		  then ignores user defined functions
****************************************************************************/
compile_body_pathexplist([],_WS,[],NULL,NULL,[],NO_ERRORS) :- !.

compile_body_pathexplist([T|L],WS,[TObj|LObj],OidCode,Code,BodyFrontList,Status) :-
	(var(BodyFrontList) -> true ; BodyFrontList1=[],BodyFrontList2=[]),
	compile_body_pathexp_top(T,WS,TObj,OidCodeFront,TCode,BodyFrontList1,S),
        (has_context(CONTEXT_COMPILER_TEXTIT) ->
            %% textit args 2-4 compile in CONTEXT_COMPILER_TEXTIT_ARGS2_4 mode
            %% in that mode, filename/linenumbers are added to delayed
            %% predicates even if they are reified so that if an error occurs
            %% during explanation it will refer to a specific textit statement
            set_context(CONTEXT_COMPILER_TEXTIT_ARGS2_4)
        ; true
        ),
	(var(TCode) -> TCode = NULL ; true),
	clear_context(CONTEXT_COMPILER_TERM_NAME),
	( no_errors_found(S) -> 
	    compile_body_pathexplist(L,WS,LObj,OidCodeBack,LCode,BodyFrontList2,S2),
	    (var(LCode) -> LCode = NULL ; true),
	    ( var(BodyFrontList) ->
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	    ; true
	    ),
	    ( no_errors_found(S2) -> 
		conjunct_struct(TCode,LCode,Code),
		conjunct_struct(OidCodeFront,OidCodeBack,OidCode),
		append(S,S2,Status)
	    ; Status=S2
	    )
	; Status=S
        ),
	!.


/****************************************************************************
  compile_body_pathexp_top(+ParserTerm,+Workspace,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Handles pathexps that are atoms, numbers, special tokens, like \#, \#123, \@,
  vars, strings

  Object  - the term that goes in place of this path expression.
  OidCode - conjunction of the code for computing the arguments of
            the pathexp such as a.b[c.d->e.f]
	    Eg, AND(a[b->?X],c[d-?Y],e[f->?Z]) - the code for computing the
	        objects that go in place of a.b, c.d, e.f. These objects are
		?X, ?Y, ?Z, respectively.
            OidCode comes before the code for the frame or predicate
	    where the path expression occurs. For instance, in the above,
	    we'll have:
	      AND(a[b->?X],c[d-?Y],e[f->?Z]), <<--- OidCode for path expressions
		?X[?Y->?Z],                   <<--- the actual frame.
                                                    ?X,?Y,?Z are Object(s)
						    for path expressions
		   Code(for a.b,c.d,e.f)      <<--- Code for path expressions
  Code    - code for the actual Boolean expression that corresponds to
            a.b[c.d->e.f], ie, ?X[?Y->?Z].
            Note: Code is conjoined from the right. For instance,
	          in obj[attr->c.d], the Code for c.d appears after the code
		  for obj[attr->...]. Namely, the overall code will be:
		    OidCode(for_c.d,Object(for_c.d)),
		      obj[attr->Object(for_c.d)],
		        Code(for_c.d)
  BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([])
		 ignores user defined functions
****************************************************************************/
%% ParserTerm is a primitive object -- no oid code and no spec code results
compile_body_pathexp_top(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	set_context(CONTEXT_COMPILER_BODY_PATHEXP),
	compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status),
	clear_context(CONTEXT_COMPILER_BODY_PATHEXP).


compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,[],Status) :-
	is_flobjref(ParserTerm,ObjTerm,AttTerm,SpecType),
	!,
	compile_body_objref(ObjTerm,SpecType,AttTerm,WS,Object,OidCode,Code,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flobjspec(ParserTerm,ObjTerm,Spec,_),
	!,
	compile_body_objspec(Spec,ObjTerm,WS,Object,OidCode,Code,BodyFrontList,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,[],Status) :-
	is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2),
	!,
	compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Object,OidCode,Code,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_fltransactionalterm(ParserTerm,Funct,N,Args),
	!,
	compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,BodyFrontList,TRANSACTIONAL_SYMBOL,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flterm(ParserTerm,Funct,N,Args),
	!,
	compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,BodyFrontList,NONTRANSACTIONAL_SYMBOL,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flarith(ParserTerm,StrippedParseTerm),
	!,
	push_context(CONTEXT_COMPILER_ARITHMETICS),
	compile_body_pathexp_top(StrippedParseTerm,WS,Object,OidCode,Code,BodyFrontList,Status),
	pop_context(CONTEXT_COMPILER_ARITHMETICS).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
        is_flpassthru(ParserTerm,ParserTermStripped,_,Arg1,_Arg2),
        !,
        push_context(CONTEXT_COMPILING_PASSTHRU),
        compile_body_pathexp_top(Arg1,WS,Object,OidCode1,Code1,BodyFrontList1,S1),
        (no_errors_found(S1) ->
            compile_body_pathexp_top(ParserTermStripped,WS,Object2,OidCode2,Code2,BodyFrontList2,S2),
            append(BodyFrontList1,BodyFrontList2,BodyFrontList),
            conjunct_struct(OidCode1,OidCode2,OidCode),
            conjunct_code([Code1,Code2,Object2],Code),
            append(S1,S2,Status)
        ; Status = S1
        ),
        pop_context(CONTEXT_COMPILING_PASSTHRU).

compile_body_pathexp(ParserTerm,_WS,_Object,OidCode,Code,BodyFrontList,Status) :-
        has_context(CONTEXT_COMPILING_PASSTHRU),
	is_fldelayedliteral(ParserTerm,Op,Args),
	!,
	compile_delayed_literal(Op,Args,Code,OidCode,BodyFrontList,Status).

compile_body_pathexp(ParserTerm,WS,_Object,OidCode,Code,BodyFrontList,Status) :-
        has_context(CONTEXT_COMPILING_PASSTHRU),
	is_flobjeql(ParserTerm,O1,O2),
	!,
	compile_body_objeql(O1,O2,WS,OidCode,Code,BodyFrontList,Status).

compile_body_pathexp(ParserTerm,_WS,_Object,NULL,Code,[],Status) :-
        has_context(CONTEXT_COMPILING_PASSTHRU),
	is_fluniveqform(ParserTerm,Left,Right),
	!,
	compile_univeqform(Left,Right,Code,Status).
compile_body_pathexp(ParserTerm,_WS,_Object,NULL,Code,[],Status) :-
        has_context(CONTEXT_COMPILING_PASSTHRU),
        is_flplgnaf(ParserTerm,G),
	is_fluniveqform(G,Left,Right),
	!,
	compile_univeqform(Left,Right,Code_pre,Status),
        (Status==NO_ERRORS -> naf_struct_prolog(Code_pre,Code)
        ; true
        ).


%% compile body eval
is_flevalexp(FLEVALEXP(Expr),Expr).

%% expression like =Expr as an argument in rule body
compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flevalexp(ParserTerm,StrippedParseTerm),
	!,
	push_context(compiling_arithmetics),
	compile_body_pathexp_top(StrippedParseTerm,WS,ExprCode,ExprOidCode,ArgCode,BodyFrontList,Status),
	new_quantified_prvariable(NO_INDEX,Object),
	code_line_and_file_by_prterm(ExprCode,Line,CurrFileName),
	prologterm_struct(flora_arith_IS_builtin,4,[CurrFileName,Line,Object,ExprCode],FLDELAYSUPPORTMOD,EvalExprCode),
	%% this order is important here and it should go into OidCode.
	%% Otherwise, something like q(=sum{?V|p(?V)}) would not work.
	%% Here we want FLLIBSUM to go first, the code for
	%% flora_arith_IS_builtin next and only then the code for q/1.
	conjunct_code([ExprOidCode,ArgCode,EvalExprCode],OidCode),
	Code = NULL,
	pop_context(compiling_arithmetics).
%% end compile body eval

%% compile text template
%% similar to verbatim, but verbatim is used to copy atoms over to .pl
%% while FLLITERATIM is used internally (no directive) to display ErgoText
%% phrases.
is_literatim(FLLITERATIM(Code),Code).

is_flload_textgen(FL_LOADTEXTGEN(TemplName,Module,Idx),TemplName,Module,Idx).
is_flload_template(FL_LOADTEMPLATE(TemplName,Module,Idx),TemplName,Module,Idx).

compile_body_pathexp(ParserTerm,_WS,Object,NULL,NULL,[],NO_ERRORS) :-
	is_literatim(ParserTerm,Term),
	!,
	verbatim_struct(Term,Object).

compile_direct(DirectTerm,_,[Code],NO_ERRORS) :-
	is_flload_textgen(DirectTerm,Template,Module,_Idx),
	!,
        compile_workspace_term(Module,ModuleCode),
	generate_prolog_liblit(flora_load_textgen_template,2,
			       [Template,ModuleCode],
			       flrutils,PreCode),
	query_struct(PreCode,Code).


%% generates ?- flora_load_ergotext_template(Templ,Module).
compile_direct(DirectTerm,_,[Code],NO_ERRORS) :-
	is_flload_template(DirectTerm,Template,Module,_Idx),
	!,
        compile_workspace_term(Module,ModuleCode),
	generate_prolog_liblit(flora_load_ergotext_template,2,
			       [Template,ModuleCode],
			       flrutils,PreCode),
	query_struct(PreCode,Code).
%% end compile text template

compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_fllist(ParserTerm,L,T,I),
	!,
	compile_body_list_obj(L,T,I,WS,Object,OidCode,Code,BodyFrontList,Status).

%% Case like this: pred(?X@...)
%% ?X@Mod is treated separately from other ...@Mod cases because
%% we have to create a libmodobj code to compute ?X@Mod.
%% This libmodobj-code is placed in
%% OidCode so that it would precede the code for pred(...)
compile_body_pathexp(ParserTerm,_WS,Object,OidCode,NULL,[],NO_ERRORS) :-
	is_flworkspace(ParserTerm,P,NestedWS),
	is_flvariable(P,VarName,VarIndex),
	!,
	compile_var(VarName,VarIndex,VarCode),
	workspaceobj_struct(VarCode,NestedWS,Object,OidCode).

compile_body_pathexp(ParserTerm,_WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flworkspace(ParserTerm,P,NestedWS),
	!,
	compile_pathexp_with_explicit_workspace(P,NestedWS,Object,OidCode,Code,BodyFrontList,Status).

compile_body_pathexp(ParserTerm,WS,Object,OidCode,_Code,[],Status) :-
        is_flsimpleprimitive(ParserTerm,PrimName,Args),
        !,
        compile_simple_primitive(PrimName,Args,WS,OidCode,Object,Status).

/*
%% OBSOLETE - expansion is now done in the parser
compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flsetarg(ParserTerm,Setarg,_Idx),
	!,
	compile_body_setarg_list(Setarg,WS,SetList,OidCode,Code,BodyFrontList,Status),
	Object = _, %% NOTE: a prolog var, since we'll be macro-expanding
	put_attr(Object,SETARGATTRIBUTE,member(Object,SetList)).
*/

compile_body_pathexp(ParserTerm,_WS,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status),
        !.

compile_body_pathexp(ParserTerm,_WS,_Object,_OidCode,_Code,_BodyFrontList,[Err]) :-
	approx_flindex(ParserTerm,ErrIdx),
        compiling_error(ErrIdx,ERROR_INVALID_TERM_THIS_CONTEXT,Err).

%% compile_pathexp_with_explicit_workspace(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)
compile_pathexp_with_explicit_workspace(ParserTerm,WS,Object,OidCode,NULL,[],NO_ERRORS) :-
	is_flvariable(ParserTerm,VarName,VarIndex),
	!,
	compile_var(VarName,VarIndex,VarCode),
	workspaceobj_struct(VarCode,WS,Object,OidCode).
compile_pathexp_with_explicit_workspace(ParserTerm,_WS,_Object,_OidCode,_Code,_BodyFrontList,[Err]) :-
	(atomlit_struct(BODYLITERAL,ParserTerm,_)
        ; is_flterm(ParserTerm,_,_,_)
        %% transactional guys are caught by the parser
	%%; transactionalatomlit_struct(BODYLITERAL,ParserTerm,_)
	),
	!,
	approx_flindex(ParserTerm,Index),
	compiling_error(Index,NO_WORKSPACE,Err).
compile_pathexp_with_explicit_workspace(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_body_pathexp_top(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status).


%% compile_pathexp_no_workspace(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)
compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,BodyFrontList,Status) :-
	is_flatom(ParserTerm,_A),
	!,
	compile_atomobj(ParserTerm,Object,BodyFrontList,Status).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_modularized_pratom(ParserTerm,Atm,Idx),
	!,
	modularized_pratom_struct(Atm,Idx,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],Status) :-
	is_fltransactionalatom(ParserTerm,_A),
	!,
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
	transactionalatomobj_struct(ParserTerm,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltoken(ParserTerm,FL_THISMODULE,_Index),
	!,
	/*
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	*/
	thismodule_struct(Object).

%% Anonymous OIDs can appear in the "body": they can appear
%% in reified formulas, which are compiled as body literals
%% This is DEAD CODE: Suffix-less newoids are no longer generated by the parser
compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,[],Status) :-
	is_fltoken(ParserTerm,FL_NEWOID,Index),
	!,
	/*
	%% no point checking skolems!!!
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	*/
	( (has_context(CONTEXT_COMPILER_GOAL_REIFICATION)
	 ; has_context(CONTEXT_COMPILER_DESCRIPTORS(_))
	 )
	->
	    Code = NULL,
	    (compiling_flrshell_command ->
		%% In the shell we do:
		%% ?- ?X = ${p(\#)} ==>> p(shell-skolem)
		OidCode = NULL,
		new_dynoidobj(Index,Object)
	    ; %% If not in the shell, generate a new Skolem constant
		OidCode = NULL,
		new_oidobj(Index,Object)
	    ),
            Status = NO_ERRORS
	; %% Otherwise, p(\#) ==>> p(?N), \skolemquery(?N)
	    OidCode = NULL,
	    new_prvariable(Index,Object),
            (has_context(CONTEXT_COMPILING_METAUNIV) ->
                compiling_error(Index,ERR_NEWOID_IN_METAUNIV,Err),
                Status = [Err]
	    ; prologterm_struct(FL_SKOLEMQUERY,1,[Object],flrnewoid,Code),
                Status = NO_ERRORS
            )
	).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltoken(ParserTerm,FLSPECIALSKOLEM,Num,Index),
	!,
	new_oidobj(Num,Index,Object).

%% A numbered global OID \##N that appears in rule body
compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,[],NO_ERRORS) :-
	is_fltoken(ParserTerm,FL_NEWOID_GLOBAL,Num,Index),
	!,
        Code = NULL,
        (compiling_flrshell_command ->
            OidCode = NULL,
            new_dynoidobj(Num,Index,Object)
        ; %% If not in the shell, generate a new Skolem constant
            OidCode = NULL,
            new_oidobj_global(Num,Index,Object)
        ).


%% A numbered OID that appears in a reified formula in rule body
compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,[],Status) :-
	is_fltoken(ParserTerm,FL_NEWOID,Num,Index),
	!,
	/*
	%% do not check the context of the skolems!
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	*/
	((has_context(CONTEXT_COMPILER_GOAL_REIFICATION)
	 ; has_context(CONTEXT_COMPILER_DESCRIPTORS(_))
	 )
	->
	    Code = NULL,
	    (compiling_flrshell_command ->
		OidCode = NULL,
		new_dynoidobj(Num,Index,Object)
	    ; %% If not in the shell, generate a new Skolem constant
		OidCode = NULL,
		new_oidobj(Num,Index,Object)
	    ),
            Status = NO_ERRORS
	; %% Otherwise, p(\#) ==>> p(?N), \skolemquery(?N)
	    OidCode = NULL,
	    prvariable_for_numbered_skolem(Index,Num,Object),
            (has_context(CONTEXT_COMPILING_METAUNIV) ->
                compiling_error(Index,ERR_NEWOID_IN_METAUNIV,Err),
                Status = [Err]
	    ; prologterm_struct(FL_SKOLEMQUERY,1,[Object],flrnewoid,Code),
                Status = NO_ERRORS
            )
	).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_SPECIAL_FILE_TOKEN,Index),
	!,
	get_current_compile_file(FileName),
        (has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
            generate_prolog_term(FL_DYNRULE_FICTITIOUS_FILENAME,1,[FileName],Object)
	; atomobj_struct(FileName,Index,Object)
        ).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_SPECIAL_LINE_TOKEN,Index),
	!,
	flora_token_index_to_line(Index,Line),
	numobj_struct(Line,Index,Object).

%% \@! - rule id token
compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],Status) :-
	is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_RULEID_SYM,Index),
	!,
	( has_context(CONTEXT_COMPILER_DESCRIPTORS(Mode)) ->
	    approx_flindex(ParserTerm,Idx),
	    construct_default_ruleid_descriptor(Mode,Idx,DescrIdCode),
	    %% the CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS context is
	    %% cleared out in compile_complex_descriptor/6
	    set_context(CONTEXT_COMPILER_ALLOW_NUMERIC_RULEIDS),
	    Object = DescrIdCode,
	    Status = NO_ERRORS
	; %% Note: descriptors are compiled BEFORE CONTEXT_COMPILER_DYNRULE
	    %% is set. So, this test must be after
	    %% has_context(CONTEXT_COMPILER_DESCRIPTORS(Mode)) above
	    (has_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)) -> true
	    ; has_context(CONTEXT_COMPILER_RULE(DescrIdCode))
	    )
	->
	    Object = DescrIdCode,
	    Status = NO_ERRORS
	; compiling_error(Index,RULEID_TOKEN_NOT_IN_RULE,Err),
	    Status = [Err]
	).

%% \@? - the null value
compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],Status) :-
	is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_NULL_QUASI_SYM,_Index),
	!,
        compile_null_value(Object,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,NULL,[],Status) :-
	is_fltoken(ParserTerm,FL_SPECIAL_VAR_TOKEN,Suffix,Index),
	!,
	(memberchk(Suffix, [FL_SPECIAL_FILE_TOKEN,FL_SPECIAL_LINE_TOKEN]) ->
	    special_variable_struct(Suffix,Object),
	    OidCode=NULL,
	    Status = NO_ERRORS
	; Suffix == FL_SPECIAL_CALLER_TOKEN ->
	    new_prvariable(NO_INDEX,Object),
	    caller_module_binding_code(Object,OidCode),
	    Status = NO_ERRORS
	; 
	    compiling_error(Index,UNSUPPORTED_SPECIAL_TOKEN,TokenErr),
	    Status = [TokenErr]
	).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	(is_flnumber(ParserTerm,_N)
	; number(ParserTerm)
	),
	!,
	numobj_struct(ParserTerm,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_flvariable(ParserTerm,Name,Index),
	!,
	compile_var(Name,Index,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltransactionalvariable(ParserTerm,Name,Index),
	!,
	compile_transactionalvar_without_trans(Name,Index,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],Status) :-
	is_flstring(ParserTerm,_S,Index),
	!,
	(has_persistentoption(FL_EXPERT) ->
	    strobj_struct(ParserTerm,Object),
	    Status = NO_ERRORS
	; compiling_error(Index,ERROR_EXPERT_SYNTAX,Err),
	    Status = [Err]
	).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_flcharlist(ParserTerm,_S,_I),
	!,
	strobj_struct(ParserTerm,Object).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],Status) :-
	is_flbuiltin_identifier(ParserTerm,Ident),
	!,
	(Ident == FL_PI_NUMBER -> numobj_struct(FL_PI_NUMBER_VALUE,Object)
	; Ident == FL_E_NUMBER -> numobj_struct(FL_E_NUMBER_VALUE,Object)
	; verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	    builtin_identifier_struct(ParserTerm,Object)
	).

compile_pathexp_no_workspace(ParserTerm,Object,VarBindingCode,NULL,[],Status) :-
	is_fldatatype(ParserTerm,_Sort,_Lit,_Index),
	!,
	datatypeobj_struct(ParserTerm,Object,VarBindingCode,Status).

compile_pathexp_no_workspace(ParserTerm,Object,NULL,NULL,[],NO_ERRORS) :-
	is_fltransactionalstring(ParserTerm,_S),
	!,
	transactionalstrobj_struct(ParserTerm,Object).

compile_pathexp_no_workspace(ParserTerm,NULL,OidCode,NULL,BodyFrontList,Status) :-
        is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx),
	!,
	compile_delayquant(Quant,Condition,Goal,Idx,OidCode,BodyFrontList,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,NULL,[],Status) :-
	is_flaggregate(ParserTerm,Op,V,GV,SortSpec,B),
	!,
	%% Aggregates are treated as OID, so its code would come
	%% ahead of the code of the literal it occurs in
	compile_aggregate(Op,V,GV,SortSpec,B,Object,OidCode,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,NULL,BodyFrontList,Status) :-
	is_reifyop(ParserTerm,Formula),
	!,
        (has_context(CONTEXT_COMPILER_BODY_REIFY_4_DELETE) ->
            new_flvariable(NO_INDEX,_Flvar,Object), %% head var replacing Object
            compile_reifyop(Formula,FormulaObject,OidCode,Status),
            %% ppp(${ooo}) is translated as ?X ~ ooo, ppp(?X) in agreement with
            %% compile_head_pathexp/6
            ( no_errors_found(Status) ->
                univeqform_struct(Object,FormulaObject,BodyFront)
            ;
                true
            ),
            BodyFrontList = [BodyFront]
        ;
            compile_reifyop(Formula,Object,OidCode,Status),
            BodyFrontList = []
        ).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flplib(ParserTerm,P),
	!,
	compile_prologlibobj(P,Object,OidCode,Code,BodyFrontList,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flplib(ParserTerm,P,Module),
	!,
	compile_prologlibobj(P,Module,Object,OidCode,Code,BodyFrontList,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flpliball(ParserTerm,P),
	!,
	compile_prologalllibobj(P,Object,OidCode,Code,BodyFrontList,Status).

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	is_flpliball(ParserTerm,P,Module),
	!,
	compile_prologalllibobj(P,Module,Object,OidCode,Code,BodyFrontList,Status).
	
compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,[],Status) :-
	is_flfloralib(ParserTerm,P,Module),
	!,
	compile_floralibobj(P,Module,Object,OidCode,Code,Status).


/******************************************************************************
  compile_body_termobj(+FunctorTerm,+Arity,+ArgList,+Workspace,-Object,-OidCode,-Code,?BodyFrontList,+Transactional,-Status)

  BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  Transactional - flag if Funct is transactional
		    Values: TRANSACTIONAL_SYMBOL or NONTRANSACTIONAL_SYMBOL
******************************************************************************/
compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,BodyFrontList,Transactional,CompileStatus) :-
	var(BodyFrontList),
	!,
        ( udf_expansion_test(Funct,N),
	    has_UDF(Funct,N,Args,Predicate,Object /* return value */,FunctBodyFrontList,S1)
	->
	    ( no_errors_found(S1) -> 
		OidCode=NULL,
		Code=NULL,
		compile_udf_body_literal(Funct,Predicate,PCode,PBodyFrontList,S),
		SymbolContext = UDF_SYMBOL,
		( no_errors_found(S) -> 
		    append(FunctBodyFrontList,PBodyFrontList,BodyFrontList1),
		    append(BodyFrontList1,[PCode],BodyFrontList),
		    %%BodyFrontList = [PCode|BodyFrontList1],
		    Status = NO_ERRORS
		;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_UDF_COMPILE,Err),
		    Status = [Err|S]
		)
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S1]
	    )
        ;
	    set_context(CONTEXT_COMPILER_TERM_NAME),
	    compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,Code,BodyFrontList,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object)
	    ; true
	    )
        ),
	!,
	verify_symbol_context(Funct,N,WS,SymbolContext,
			      Transactional,SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).

compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,[],Transactional,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,FUNCTION_SYMBOL,
			      Transactional,SymbolStatus),
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,Code,_BodyFrontList,Status),
	!,
	( no_errors_found(Status) -> termobj_struct(FObj,N,AObj,Object)
	; true
	),
	append(SymbolStatus,Status,CompileStatus).

/****************************************************************************
  compile_body_termlit(+FunctorTerm,+Arity,+ArgList,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)
  BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
****************************************************************************/
%% Terms declared with :- usesensor are treated here
compile_body_termlit(Funct,N,Args,WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	is_flatom(Funct, FAtom, FunctIdx),
	(has_permaoption(usesensor(FAtom,N))
	; has_permaoption(usesensor((FAtom,PlMod),N))
	%% the below allows _add'ed files to inherit the usesensor directive 
	; flora_delayed_sensor_literal(FAtom,N,FLORA_DEFAULT_WORKSPACE),
	    \+has_permaoption(defsensor(FAtom,N))
	; flora_delayed_sensor_literal((FAtom,PlMod),N, FLORA_DEFAULT_WORKSPACE),
	    \+has_permaoption(defsensor(FAtom,N,PlMod))
	),
	!,
	verify_symbol_context(Funct,N,WS,SENSOR_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	is_anonymous_flvariable(Anon,NO_INDEX),
	%% compile_delayed_literal expects FLLIST as Arglist
	is_fllist(ArgsList,[Anon,Anon|Args],[],NO_INDEX),
	(atom(PlMod)
	->
	    is_flatom(ModParserTerm,PlMod,NO_INDEX),
	    compile_delayed_literal(Funct,ArgsList,ModParserTerm,Code,OidCode,BodyFrontList,Status)
	;
	    %% if it is a sensor defined in a .flr file, scramble its
	    %% name by adding FLORA_PREFIX
	    flora_scramble_atom(FAtom,ScrambledAtom),
	    is_flatom(ScrambledFunct,ScrambledAtom,FunctIdx),
	    compile_delayed_literal(ScrambledFunct,ArgsList,Code,OidCode,BodyFrontList,Status)
	),
	!,
	append(SymbolStatus,Status,CompileStatus).

compile_body_termlit(Funct,N,Args,WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    termlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
	    attach_workspace(TCode,WS,WSCode,WSStatus),
	    conjunct_struct(WSCode,ObjCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus==NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

compile_body_transactional_termlit(Funct,N,Args,WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,
			      TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transactionaltermlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
	    attach_workspace(TCode,WS,WSCode,WSStatus),
	    conjunct_struct(WSCode,ObjCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus==NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

/****************************************************************************
  compile_body_list_obj(+ObjTermList,+ObjTerm,+Index,+WS,-Object,-OidCode,-Code,?BodyFrontList,-Status)
    Lists are like this: [a,b,c|rest]
    ObjTermList refers to the list [a,b,c] and ObjTerm to rest.

 BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([]) ignores user defined functions
****************************************************************************/
compile_body_list_obj(ObjTermList,ObjTerm,Index,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	(var(BodyFrontList) -> true; BodyFrontList1=[], BodyFrontList2=[]),
	compile_body_pathexplist(ObjTermList,WS,ObjList,OidCodeList,ObjListCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		BodyFrontList=BodyFrontList1,
		Obj=[],
		OidCodeObj=NULL,
		ObjCode=NULL,
		Status = NO_ERRORS
	    ;
	      compile_body_pathexp_top(ObjTerm,WS,Obj,OidCodeObj,ObjCode,BodyFrontList2,Status),
	      ( var(BodyFrontList) ->
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	      ;
		true
	      )
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_struct(ObjListCode,ObjCode,Code),
		conjunct_struct(OidCodeList,OidCodeObj,OidCode)
	    ;
	      true
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_body_objref(+ObjTerm,+SpecType,+AttTerm,+Workspace,-Object,-OidCode,-Code,-Status)

  Process an object reference like a.b.c@module
  An objref can be more complex, e.g., a[f->g].b[h->p].c[k->u]@module
****************************************************************************/
compile_body_objref(ObjTerm,SpecType,AttTerm,WS,Object,OidCode,Code,Status) :-
	compile_body_pathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OidCodeList,OACode,[],PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    body_objref_struct(SpecType,Obj,Att,Index,Object,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    Code = OACode,
	    conjunct_struct(OidCodeList,WTCode,OidCode)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_body_bin_relation(+ObjTerm1,+RelType,+ObjTerm2,+Workdpace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Obj1,OidCode,Code,Status) :-
	compile_body_pathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OidCode,OCode,BodyFrontList,PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    birelate_struct(BODYLITERAL,Obj1,RelType,Obj2,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    conjunct_code(BodyFrontList,BodyFrontCode),
	    conjunct_code([BodyFrontCode,WTCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_body_objspec(+SpecBody,+ObjTerm,+Workspace,-Object,-OidCode,-Code,-BodyFrontList,-Status)

  Code produced by this and similar predicates is divided into
  OidCode and Code. 
  OidCode is the code needed to compute the attribute of frame
  and the oid of the value part (in ->, *->, etc.)
  Code represents the code needed to compute the the attribute specification.
  For instance, in  a.b[c.d->e.f],
      OidCode will represent the computation of a.b, c.d, and e.f:
	 prand(prmvd(a,b,_newvar1),prand(prmvd(c,d,_newvar2),prmvd(e,f,_newvar3)))
      Code will represent the -> part:
                 prmvd(_newvar1,_newvar2,_newvar3)
      Object is the code for restricting
****************************************************************************/
compile_body_objspec(SpecBody,ObjTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	%% TODO: check if SpecBody can be a var. If not, we could optimize
	%% by splitting this into 2 clauses and putting [] in place of SpecBody
	%% in the rule head.
	( SpecBody == [] ->
	    ( is_flobjref(ObjTerm,OTerm,ATerm,SpecType) ->
		compile_body_pathexplist([OTerm,ATerm],WS,[OObj,AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
		( no_errors_found(PathexpStatus) ->
		    approx_flindex(ATerm,Index),
		    body_objref_struct(SpecType,OObj,AObj,Index,Object,TCode),
		    attach_workspace(TCode,WS,WTCode,WSStatus),
		    conjunct_struct(WTCode,ObjCode,Code)
		;
		    WSStatus = NO_ERRORS
	        ),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
            ; %% workspace(flobjref) - optimization for that case
                is_flworkspace(ObjTerm,ObjTerm2,WS2), 
                is_flobjref(ObjTerm2,_,_,_) ->
                %% redo compile_body_objspec with unwrapped ObjTerm2 and WS2
                compile_body_objspec([],ObjTerm2,WS2,Object,OidCode,Code,BodyFrontList,Status)
	    ;
		%% object exists test: a[]@module
		compile_body_pathexp_top(ObjTerm,WS,Object,OidCode,ObjCode,BodyFrontList,PathexpStatus),
                !,
		( no_errors_found(PathexpStatus) -> 
		    objexists_struct(BODYLITERAL,Object,ECode),
		    attach_workspace(ECode,WS,WSECode,WSStatus),
		    conjunct_struct(WSECode,ObjCode,Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    )
	; % oid spec plus object spec. something like a.b[c->d]@module
	  compile_body_pathexp_top(ObjTerm,WS,Object,ObjOidCode,ObjCode,BodyFrontList1,S),
	  ( no_errors_found(S) -> 
	      compile_body_specbody(Object,SpecBody,WS,SpecOidCode,SpecCode,
				    BodyFrontList2,Stat2),
              !,
	      ( no_errors_found(Stat2) -> 
		  %% Because ObjCode contains : and ::, we put it after
		  %% the code for frame --- a heuristic that assumes that
		  %% computing a:b  (or a::b)when a or b are vars, is expensive.
		  %% Ideally we should check the type of ObjCode or used
		  %% delay for ObjCode
		  conjunct_struct(SpecCode,ObjCode,Code),
		  conjunct_struct(ObjOidCode,SpecOidCode,OidCode)
	      ; 
		  true
	      ),
	      append(S,Stat2,Status),
	      append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	  ;
	    BodyFrontList = BodyFrontList1,
	    Status=S
          )
        ),
	!.
compile_body_objspec(SpecBody,_ObjTerm,_WS,_Object,_OidCode,_Code,_BodyFrontList,[Err]) :-
        approx_flindex(SpecBody,Idx),
        compiling_error(Idx,ERROR_SYNTAX_MAYBE_PARENS,Err).


/****************************************************************************
  compile_body_specbody(+Object,+SpecTerm,+Workspace,-OidCode,-Code,-BodyFrontList,-Status)

     SpecTerm here represents the inner part of a frame.
     Object represents the frame's oid.

     For instance, in a[c->d,e->f], Object will be pratom(a,4) and SpecTerm
     flconjunct(flmvdattspec(flatom(c,8),->,[flatom(d,10)]),
                flmvdattspec(flatom(e,12),->,[flatom(f,14)]))
****************************************************************************/
compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_body_specbody(Object,L,WS,OidCode1,LCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    compile_body_specbody(Object,R,WS,OidCode2,RCode,BodyFrontList2,Status),
            !,
	    ( no_errors_found(Status) -> 
		conjunct_struct(OidCode1,OidCode2,OidCode),
		conjunct_struct(LCode,RCode,Code)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ).

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_fldisjunct(SpecTerm,L,R),
	!,
	compile_body_specbody(Object,L,WS,OidCode,LCode,BodyFrontList1,S),
        !,
	( no_errors_found(S) -> 
	    compile_body_specbody(Object,R,WS,OidCode,RCode,BodyFrontList2,Status),
	    ( no_errors_found(Status) -> 
		disjunct_struct(LCode,RCode,Code)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ).

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_default_negation(SpecTerm,G,NAFType),
	!,
	set_context(CONTEXT_COMPILER_DEFAULT_NEGATION),
	compile_body_specbody(Object,G,WS,OidCode,GCode,BodyFrontList,Status),
        !,
	( no_errors_found(Status) -> 
	    %% Only _Quantifier=NULL or Exists are allowed
	    get_quantification_info(GCode,_Quantifier,FormCode,_QuantVars,FreeVarObjs),
	    conjunct_struct(OidCode,FormCode,CombinedCode),
	    (NAFType == FL_RULELOGNAF
	    -> naf_struct_flora(CombinedCode,FreeVarObjs,Code)
	    ; naf_struct_prolog(CombinedCode,Code)
	    )
	; true
	),
	clear_context(CONTEXT_COMPILER_DEFAULT_NEGATION).

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_body_specbody(Object,G,WS,OidCode,GCode,BodyFrontList,Status1),
	( no_errors_found(Status1) -> 
	    conjunct_struct(OidCode,GCode,CombinedGCode),
	    neg_struct(CombinedGCode,Idx,Code,Status)
	; Status = Status1
	).

%% Quantification under default negation
compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_fllogicquantifier(SpecTerm,FL_EXISTS,QuantVarNames,VarsCode,Formula,Idx),
	has_context(CONTEXT_COMPILER_DEFAULT_NEGATION),
	!,
	%% no quantified don't care vars (?,?_) 
	(memberchk(FL_ANON_VAR,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = NO_ERRORS
	),

	compile_body_specbody(Object,Formula,WS,OidCode,FormCode,BodyFrontList,S2),
        !,
	(S1==NO_ERRORS -> S3=S2
	; S3 = [Err1|S2]
	),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars([Object,OidCode,FormCode],AllVarList),
	vars_to_var_names(AllVarList,AllVarList_names),
	(no_errors_found(S3) ->
	    %% quantified vars must occur in Formula
	    (subset(QuantVarNames,AllVarList_names) -> Stat4 = NO_ERRORS
	    ; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err4),
		Stat4 = [Err4]
	    ),

	    subtract_varnames_from_vars(AllVarList,QuantVarNames,FreeVarObjs_aux),
	    %% remove don't care vars, since no need to delay because of them
	    remove_prdontcare_and_FL_CONTEXT_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	    %% this is used if naf-exists is nested deep inside the code
	    remove_quantified_vars(FreeVarObjs_aux2,FreeVarObjs),
	    
            compile_datatype_objects(VarsCode,PRVarsCode,StatVarsCode),
	    rename_prvariables(QuantVarNames,NEWQUANTIFIEDVAR,
                               (PRVarsCode,FormCode),
			       (RenamedPRVarsCode,RenamedFormCode),
                               RenamedQuantVars),
            append(StatVarsCode,Stat4,Status)
	; Status = S3
	),
	!,
	( no_errors_found(Status) -> 
	    %% Create the code for compiled quantification.
	    conjunct_code([RenamedPRVarsCode,OidCode,RenamedFormCode],
                          CombinedCode),
	    list_struct(RenamedQuantVars,[],RenamedQuantVarsListObj),
	    list_struct(FreeVarObjs,[],FreeVarObjsListObj),
	    quantifier_struct(FL_EXISTS,CombinedCode,RenamedQuantVarsListObj,FreeVarObjsListObj,Code)
	;
	    true
	).


%% OidCodeList below gets bound to code needed to produce
%% the attribute (M) and the value (V). We conjunct this code in front of the
%% code for the frame
%% NULL means that we don't pass OID code out, because we use it right here.

%% No OidCode is passed outside: we consume it here
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,_ArrowType,ValTermList,SpecType),
	!,
	compile_body_pathexp_top(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
        !,
	( no_errors_found(S) -> 
	    ( ValTermList == [] ->
		mvdattdef_struct(SpecType,BODYLITERAL,Object,AttObj,SCode),
		attach_workspace(SCode,WS,WSCode,Status1),
		%% Fold OidCode in front of frame
		conjunct_code([AOidCode,ACode,WSCode],Code)
	    ;
	      compile_body_mvd_attspec(Object,AttObj,SpecType,ValTermList,WS,VOidCode,WSCode,BodyFrontList2,Status1),
	      ( no_errors_found(Status1) -> 
		  %% ACode: Code to produce attribute
		  %% WSCode: code to produce pure attr specs and 
		  %%         the objects that represents the values
		  conjunct_code([AOidCode,VOidCode,ACode,WSCode],Code)
	      ; true
	      )
	    ),
	    append(S,Status1,Status),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
        ;
	  BodyFrontList = BodyFrontList1,
	  Status=S
        ).

%% signatures: =>, *=>, etc.
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_body_pathexp_top(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
        !,
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(SpecType,BODYLITERAL,Object,AttObj,SCode),
		attach_workspace(SCode,WS,WSCode,Status1),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		BodyFrontList = BodyFrontList1
	    ;
		compile_body_pathexp_top(ValTerm,WS,ValObj,VOidCode,VCode,BodyFrontList2,PathexpStatus),
		( no_errors_found(PathexpStatus) -> 
		    sigattspec_struct(SpecType,BODYLITERAL,Object,AttObj,ValObj,SCode),
		    attach_workspace(SCode,WS,WSCode,WSStatus),
                    %% VCode should be after WSCode - similarly to the case of
                    %% ->. For ->, the code is generated slightly differently,
                    %% but still VCode comes after the code for o[p->v]
		    conjunct_code([AOidCode,VOidCode,ACode,WSCode,VCode],Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status1 = PathexpStatus
		; Status1 = WSStatus
		),
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	    ),
	    append(S,Status1,Status)
	;
	    BodyFrontList = BodyFrontList1,
	    Status = S
        ).

compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_body_pathexp_top(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
        !,
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(SpecType,BODYLITERAL,Object,AttObj,SCode),
		attach_workspace(SCode,WS,WSCode,Status1),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		BodyFrontList = BodyFrontList1
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
		compile_body_pathexplist([Lower,Upper],WS,[OLower,OUpper],COidCode,CCode,BodyFrontList2,S_C),
		pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
		( no_errors_found(S_C) -> 
		    compile_body_pathexp_top(ValTerm,WS,ValObj,VOidCode,VCode,BodyFrontList3,PathexpStatus),
		    ( no_errors_found(PathexpStatus) -> 
			sigattspec_struct(SpecType,BODYLITERAL,Object,AttObj,ValObj,SCode),
			attach_workspace(SCode,WS,WSCode,WSStatus1),
			sigattconstr_struct(SpecType,BODYLITERAL,Object,AttObj,OLower,OUpper,CSCode),
			attach_workspace(CSCode,WS,CWSCode,WSStatus2),
			conjunct_code([AOidCode,VOidCode,ACode,VCode,WSCode,COidCode,CCode,CWSCode],Code)
		    ;
			WSStatus1 = NO_ERRORS, WSStatus2 = NO_ERRORS
		    ),
		    (WSStatus1 == NO_ERRORS, WSStatus2 == NO_ERRORS
		    -> Status1 = PathexpStatus
		    ; append(WSStatus1,WSStatus2,Status1)
		    )
		;
		    Status1 = S_C
		),
		append_lists([BodyFrontList1,BodyFrontList2,BodyFrontList3], BodyFrontList)
	    ),
	    append(S,Status1,Status)
	;
	    BodyFrontList = BodyFrontList1,
	    Status = S
        ).

%% boolean signatures: =>.
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_ArrowType,SpecType),
	!,
	compile_body_pathexp_top(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    boolsig_struct(SpecType,BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

%% boolean signatures: =>% for transactional method
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltransig(SpecTerm,AttTerm,_ArrowType,SpecType),
	!,
	compile_body_pathexp_top(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    transig_struct(SpecType,BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

%% +>>
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flincattspec(SpecTerm,AttTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_body_pathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    incattspec_struct(SpecType,Object,AttObj,ValObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    %% Fold OidCode in front of frame
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

%% same for ->->@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltolistattspec(SpecTerm,AttTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_body_pathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    tolistattspec_struct(SpecType,Object,AttObj,ValObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

%% Obj[true], Obj[fail], Obj[!] translate as true, fail, and !
compile_body_specbody(_Object,SpecTerm,_WS,NULL,Code,[],Status) :-
	is_flpassthru(SpecTerm,P),
	(is_flatom(P, Atom, I)
	; is_flbuiltin_identifier(P,Atom,I)
	),
	!,
	(Atom==FL_CUT -> cut_struct(I,Code)
	; atomobj_struct(P,Code)
	),
	Status = NO_ERRORS.

%% Obj[X>Y], Obj[X=Y], etc. This happens when we have p[...,${2>1},...]
compile_body_specbody(_Object,SpecTerm,_WS,NULL,Code,BodyFrontList,Status) :-
	is_flpassthru(SpecTerm,P),
	is_flterm(P, Funct, N, Args),
	!,
	compile_prlgterm(Funct,N,Args,
			 TCode,_OidCode,ACode,BodyFrontList,Status),
	( no_errors_found(Status) -> conjunct_struct(ACode,TCode,Code)
	; true
	).

%% for O[BoolMeth]@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flmethspec(SpecTerm,MethTerm,SpecType),
	!,
	compile_body_pathexp_top(MethTerm,WS,MethObj,OidCode,MCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    methspec_struct(SpecType,BODYLITERAL,Object,MethObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,MCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

%% O[%M]@module
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltranspec(SpecTerm,TranTerm,SpecType),
	!,
	compile_body_pathexp_top(TranTerm,WS,TranObj,OidCode,TCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    transpec_struct(SpecType,BODYLITERAL,Object,TranObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,TCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_body_mvd_attspec(+Object,+AttObj,+SpecType,+ValTermList,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)

  SpecType: INHERITABLE/NONINHERITABLE

  Compiles ->, etc., when it has one or more value terms
****************************************************************************/
compile_body_mvd_attspec(Object,AttObj,SpecType,[T],WS,OidCode,Code,BodyFrontList,Status) :-
	!,
	compile_body_pathexp_top(T,WS,TObj,OidCode,TCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    mvdattspec_struct(SpecType,BODYLITERAL,Object,AttObj,TObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(WSCode,TCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).

compile_body_mvd_attspec(Object,AttObj,SpecType,[T|L],WS,OidCode,Code,BodyFrontList,Status) :-
	!,
	compile_body_mvd_attspec(Object,AttObj,SpecType,[T],WS,OidCodeFront,WTCode,BodyFrontList1,S),
        !,
	( no_errors_found(S) -> 
	    compile_body_mvd_attspec(Object,AttObj,SpecType,L,WS,OidCodeBack,WLCode,BodyFrontList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_struct(WTCode,WLCode,Code),
		conjunct_struct(OidCodeFront,OidCodeBack,OidCode)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ).


/****************************************************************************
  compile_body_objeql(+Obj1,+Obj2,+Workspace,-OidCode,-Code,-BodyFrontList,-Status)
****************************************************************************/
compile_body_objeql(Obj1,Obj2,WS,OidCode,Code,BodyFrontList,Status) :-
	compile_body_pathexplist([Obj1,Obj2],WS,[O1,O2],OidCode,OCode,BodyFrontList,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    objeql_struct(BODYLITERAL,O1,O2,OECode),
	    attach_workspace(OECode,WS,WSCode,WSStatus),
	    conjunct_struct(OCode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_reifyop(+Formula,-Object,-OidCode,-Status)
  Compiling ${...}
****************************************************************************/
/*
compile_reifyop(Formula,Object,OidCode,Status) :-
	has_context(CONTEXT_COMPILER_BODY_PATHEXP),
	\+has_context(CONTEXT_COMPILER_UPDATE_LITERALS),
	!,
	%% PrependedCode might come from LIBMODLIT or LIBMODOBJ
	compute_reification_expr(Formula,AttrValCode,PrependedCode,Status),
	( no_errors_found(Status) -> 
	    new_prvariable(NO_INDEX,Object),
	    attrvar_code(Object,AttrValCode,FLSEMANTICUNIFICATION,PutAttrCode),
	    conjunct_struct(PrependedCode,PutAttrCode,OidCode)
	;
	    true
	).
*/
compile_reifyop(Formula,Object,OidCode,Status) :-
	compute_reification_expr(Formula,Object,OidCode,Status).

compute_reification_expr(Formula,Object,OidCode,Status) :-
	Formula = [Rule|_],
	(is_fldynrule(Rule,_Head,_Body,_Descr)
	; is_flruleworkspace(Rule,_RealRule,_WS)
	),
	!,
	set_context(CONTEXT_COMPILER_RULE_REIFICATION),
        %% singleton/unbound vars are flagged in reified/inserted rules
	compile_dynrule(FL_INSERTRULE,Rule,Object,Status),
	clear_context(CONTEXT_COMPILER_RULE_REIFICATION),
	OidCode=NULL.

compute_reification_expr(Formula,Object,OidCode,Status) :-
	push_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	compile_body(Formula,Object1,Status),
	pop_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	(is_florasyslib_struct(Object1,Index,LibType,_N,Args),
	    (LibType == FLLIBMODLIT ; LibType == FLNEGLIBMODLIT)
	%% If it is compiled into a LIBMODLIT/3, replace with LIBMODOBJ
	->
	    convert_FLLIBMODLIT_to_FLLIBMODOBJ(LibType,Index,Args,Object,OidCode)
	; is_prconjunct(Object1,First,Second),
	    is_florasyslib_struct(First,_,FLLIBMODOBJ,_,_)
	-> OidCode = First,
	    Object = Second
	;
	    reify_struct(Object1,Object),
	    OidCode = NULL
	).

%% convert_FLLIBMODLIT_to_FLLIBMODOBJ(+LibType,+Index,+Args,-LibModObjVar,-PrLibModObj)
%% Note: both input (Args) and output (LibModObjVar/PrLibModObj) are PR-code.
%% Take an FLLIBMODLIT florasyslib_struct and make FLLIBMODOBJ code for
%% computing the variable that replaces FLLIBMODLIT. For instance,
%%   p($a@?M) ---> FLLIBMODOBJ(...,a,?M,...,LibModObjVar), p(LibModObjVar)
%% \neg p($a@?M) ---> FLNEGLIBMODOBJ(...,a,?M,...,LibModObjVar), p(LibModObjVar)
%%  LibType: FLLIBMODLIT or FLNEGLIBMODLIT
convert_FLLIBMODLIT_to_FLLIBMODOBJ(LibType,Index,Args,LibModObjVar,PrLibModObj) :-
	new_prvariable(Index,LibModObjVar),
	%% LIBMODLIT/3 already has the FL_CONTEXT argument -- no
	%% need to add it here
	Args = [Pred,WS,FWContext],
	(has_context(CONTEXT_COMPILER_HEADLITERAL)
	-> NewArgs = [FL_HEAD,Pred,WS,FWContext,LibModObjVar]
	;  NewArgs = [FL_BODY,Pred,WS,FWContext,LibModObjVar]
	),
	(LibType == FLLIBMODLIT -> ObjLibType = FLLIBMODOBJ
	; ObjLibType = FLNEGLIBMODOBJ
	),
	florasyslib_struct(Index,ObjLibType,5,NewArgs,PrLibModObj).


/****************************************************************************
  compile_simple_primitive(+PrimName,+Args,+WS,-OidCode,-Code,-Status)
  Compiles true{...}, false{...}, undefined{...}
****************************************************************************/
compile_simple_primitive(PrimName,Args,WS,OidCode,Code,Status) :-
        approx_flindex(Args,PrimIndex),
        check_simple_primitive_arguments(PrimName,PrimIndex,Args,ErrorIssued,Stat1),
        (ErrorIssued == true -> Status = Stat1
        ;
            length(Args,Arity),
            %% some primitives (listed in flora_simple_primitive_extra_args/3)
            %% get additional arguments inserted by the compiler
            get_extra_args_for_simple_primitive(PrimName,PrimIndex,Arity,ExtraArgs),
            (flora_simple_primitive_extra_args(PrimName,_,_) ->
                %% this context is used in flrprolog.P - mainly so that
                %% the predicate dynrule/1, which
                %% is used as the file name placeholder for dynamic rules,
                %% will compile as Prolog
                set_context(CONTEXT_COMPILER_SIMPLEPRIMITIVE_WITH_EXTRA_ARGS)
            ; true
            ),
            length(ExtraArgs,NumOfExtraArgs),
            RealArity is Arity+NumOfExtraArgs,
            push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
            compile_body_pathexplist(Args,WS,ArgsCode1,OidCode,_,_,Stat2),
            append(Stat1,Stat2,Status),
            pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
            flora_simple_primitive(PrimName,RealArity,PrimPredicate,PrimModule),
            append(ArgsCode1,ExtraArgs,ArgsCode),
            prologterm_struct(PrimPredicate,RealArity,ArgsCode,PrimModule,CodePre),
            prologliblit_struct(CodePre,Code),
            clear_context(CONTEXT_COMPILER_SIMPLEPRIMITIVE_WITH_EXTRA_ARGS)
        ).

check_simple_primitive_arguments(PrimName,PrimIndex,Args,ErrorIssued,Status) :-
        (PrimName == FL_TEXTIT_PRIMITIVE ->
            check_textit_arguments(PrimIndex,Args,ErrorIssued,Status)
        ; Status = NO_ERRORS
        ).

%% If ExtraArgs is a var, Status does not contain errors (possibly warnings)
check_textit_arguments(PrimIndex,Args,ErrorIssued,Status) :-
        Args = [Goal,Format,GoalArgs|Condition],
        ((\+ is_fllist(GoalArgs,_,_,_) ; \+is_flatom(Format,_,_)) ->
            compiling_error(PrimIndex,ERR_TEXTIT_WRONG_ARGS,Err0),
            ErrorIssued = true,
            Status = [Err0]
        ;
            collect_flvar_names(Goal,GoalVarNames),
            collect_flvar_names(GoalArgs,GoalArgVarNames),
            collect_flvar_names(Condition,ConditionVarNames),
            append(GoalVarNames,ConditionVarNames,GoalAndCondVarNames),
            append(GoalArgVarNames,ConditionVarNames,GoalArgAndCondVarNames),
            list_difference_eq(GoalVarNames,GoalArgAndCondVarNames,GoalExtras1),
            delete_silent_var_names(GoalExtras1,GoalExtras),
            list_difference_eq(GoalArgVarNames,GoalAndCondVarNames,ArgListExtras),
            %% anon vars in goal are discouraged to avoid complacency mistakes
            (memberchk(FL_ANON_VAR,GoalArgVarNames) ->
                ErrorIssued = true,
                compiling_error(PrimIndex,ERR_TEXTIT_EXTRA_SUBST_VARS,Err),
                Stat1 = [Err]
            ; ArgListExtras \== [] ->
                ErrorIssued = true,
                compiling_error(PrimIndex,ERR_TEXTIT_EXTRA_SUBST_VARS,Err),
                Stat1 = [Err]
            ; GoalExtras \== [] ->
                compiling_warning(PrimIndex,WARN_TEXTIT_EXTRA_GOAL_VARS,Warn),
                Stat1 = [Warn]
            ; Stat1 = NO_ERRORS
            ),
            (get_flatom_name(Format,FormatAtm),
                count_substitution_points(FormatAtm,SubstNumber),
                is_fllist(GoalArgs,ActualList,_,IdxArgs),
                length(ActualList,GoalArgsNumber),
                SubstNumber \== GoalArgsNumber ->
                ErrorIssued = true,
                compiling_error(IdxArgs,ERR_TEXTIT_SUBST_MISMATCH,Err2),
                Stat2 = [Err2]
            ; Stat2 = NO_ERRORS
            ),
            append(Stat1,Stat2,Status)
        ).

/****************************************************************************
  compile_truthvalue(+Form,+Op,-OidCode,-Code,-Status)
  Compiles true{...}, false{...}, undefined{...}
****************************************************************************/
compile_truthvalue(Formula,Op,Code,Status) :-
	atomobj_struct(Op,OpCode),
	compile_body(Formula,FCode,Status),
	!,
	( no_errors_found(Status) -> 
	   truthvalue_struct(FCode,OpCode,Code)
	; true
	).


/****************************************************************************
   compile_tag_primitive(+DescriptorParserTerm,?HeadList,-Code,-Status)
****************************************************************************/
compile_tag_primitive(DescriptorParserTerm,HeadList,Code,Status) :-
	compile_body_pathexp_top(DescriptorParserTerm,FL_THISMODULE,TagCode,_,_,[],S1),
        !,
	( no_errors_found(S1) -> 
	    set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	    set_context(CONTEXT_COMPILER_HEADLITERAL),
            set_context(CONTEXT_COMPILER_BODY_REIFY_4_DELETE),
	    compile_delete_litlist(HeadList,HLC,Status),
            clear_context(CONTEXT_COMPILER_BODY_REIFY_4_DELETE),
	    clear_context(CONTEXT_COMPILER_HEADLITERAL),
	    clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	    ( no_errors_found(Status) -> 
		list_struct(HLC,[],HeadListCode),
		tagprimitive_struct(TagCode,HeadListCode,Code)
	    ; true
	    )
	; Status = S1
	).


/****************************************************************************
   compile_prefixprimitive(+Prefix,+Expansion,+Module,-Code,-Status)

   Compiles the prefix{...} primitive.
****************************************************************************/
compile_prefixprimitive(Prefix,Expansion,Module,Code,Status) :-
	(memberchk(Module,[NULL,FL_THISMODULE]) -> thismodule_struct(ModuleCode)
	; compile_atomvar(Module,ModuleCode)
	),
	compile_body_pathexplist([Prefix,Expansion],FL_THISMODULE,[PrefixCode,ExpansionCode],_,_,[],Status),
	!,
	( no_errors_found(Status) -> 
	    prefixprimitive_struct(PrefixCode,ExpansionCode,ModuleCode,Code)
	; true
	).


/****************************************************************************
  compile_prologliblit(+ParserTerm,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @\prolog
****************************************************************************/
compile_prologliblit(ParserTerm,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,
			     TCode,OidCode,ACode,BodyFrontList,Status)
	;
	    atomobj_struct(ParserTerm,TCode),
	    OidCode=NULL,
	    ACode=NULL,
	    BodyFrontList = [],
	    Status = NO_ERRORS
	),
        ( no_errors_found(Status) -> 
            prologliblit_struct(TCode,PCode),
            conjunct_struct(ACode,PCode,Code)
        ; true
        ).


/*******************************************************************************
 compile_prologliblit(+ParserTerm,+Module,-OidCode,-Code,?BodyFrontList,-Status)

 Compiles Prolog library call @\prolog(module)
*******************************************************************************/
compile_prologliblit(ParserTerm,Module,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Module,
			     TCode,OidCode,ACode,BodyFrontList,Status)
	;
            compile_atomvar(Module,ModCode),
	    plgatomobj_struct(ParserTerm,ModCode,TCode),
	    ACode=NULL,
	    OidCode=NULL,
	    BodyFrontList = [],
	    Status = NO_ERRORS
	),
        ( no_errors_found(Status) -> 
            prologliblit_struct(TCode,PCode),
            conjunct_struct(ACode,PCode,Code)
        ; true
        ).
/* OLD VERSION
compile_prologliblit(ParserTerm,Module,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Module,
			     TCode,OidCode,ACode,BodyFrontList,Status)
	;
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Module,TCode),
	    ACode=NULL,
	    OidCode=NULL,
	    BodyFrontList = [],
	    Status = NO_ERRORS
	),
	( no_errors_found(Status) -> 
	    %% build a special structure for the coder
	    %% prologliblit_struct is NOT added by compile_prologliblit/6 ---
	    %% only by compile_prologliblit/7
	    prologliblit_struct(TCode,PCode),
	    conjunct_struct(ACode,PCode,Code)
	    %% generate an import statement for the corresponding XSB predicate
	    %%is_flatom(Module,MName),
	    %%get_flatom_name(Funct,FAtom),
	    %%import_struct(FAtom,N,MName,ICode),
	    %%directive_struct(ICode,DCode),
	    %%report_directive(DCode)
	;
	  true
	).
*/

/*******************************************************************************
  compile_prologallliblit(+ParserTerm,-OidCode,-Code,-BodyFrontList,-Status)

  Compiles Prolog library call @\prologall
*******************************************************************************/
compile_prologallliblit(ParserTerm,OidCode,Code,BodyFrontList,Status) :-
	compile_prologliblit(ParserTerm,OidCode,PrelimCode,BodyFrontList,Status1),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermLitCode,PrelimCode) -> true
	; PrelimCode = PrelimTermCode, ACode=NULL
	),
	!,
	%% PrelimTermLitCode is bound & we decompose it (getting PrelimTermCode)
	prologliblit_struct(PrelimTermCode,PrelimTermLitCode),
        (is_pratom(PrelimTermCode,_,ErrIdx) ->
            compiling_error(ErrIdx,ERROR_PROP_PROLOGALL,Err),
            Status = [Err]
        ;
            %% PrelimTermCode is bound and we decompose it into F,N,Args
            prologterm_struct(FunctCode,N,ArgsCode,PrelimTermCode),
            new_prvarlist_from_args(ArgsCode,NewVarList),
            generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
            prologterm_struct(FunctCode,N,NewVarList,TermCode),
            prologliblit_struct(TermCode,TermLitCode),
            generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
            conjunct_code([ACode,ToPrologCode,TermLitCode,FromPrologCode],Code),
            Status = Status1
        ).


/*******************************************************************************
  compile_prologallliblit(+ParserTerm,+Module,-OidCode,-Code,-BodyFrontList,-Status)

  Compiles Prolog library call @\prologall(module)
*******************************************************************************/
compile_prologallliblit(ParserTerm,Module,OidCode,Code,BodyFrontList,Status) :-
	compile_prologliblit(ParserTerm,Module,OidCode,PrelimCode,BodyFrontList,Status1),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermLitCode,PrelimCode) -> true
	; PrelimCode = PrelimTermLitCode, ACode=NULL
	),
	!,
	%% PrelimTermLitCode is bound & we decompose it (getting PrelimTermCode)
	prologliblit_struct(PrelimTermCode,PrelimTermLitCode),
	(is_prplgatom(PrelimTermCode,_,_,ErrIdx) ->
            compiling_error(ErrIdx,ERROR_PROP_PROLOGALL,Err),
            Status = [Err]
        ;
            %% PrelimTermCode is bound and we decompose it into F,N,Args
            prologterm_struct(FunctCode,N,ArgsCode,Module,PrelimTermCode),
            new_prvarlist_from_args(ArgsCode,NewVarList),
            generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
            prologterm_struct(FunctCode,N,NewVarList,Module,TermCode),
            prologliblit_struct(TermCode,TermLitCode),
            generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
            conjunct_code([ACode,ToPrologCode,TermLitCode,FromPrologCode],Code),
            Status = Status1
        ).


/*******************************************************************************
 compile_prologlibobj(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @\prolog in the arguments position
  E.g., f(member(X,[a])@\prolog)
  This feature might be useful for meta-programming.  
*******************************************************************************/
compile_prologlibobj(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Object,OidCode,Code,BodyFrontList,Status)
	;
	    atomobj_struct(ParserTerm,Object),
	    %%atomobj_struct(ParserTerm,FObj),
	    %%N=0,
	    %%prologterm_struct(FObj,0,[],Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyFrontList=[],
	    Status = NO_ERRORS
	).


/*******************************************************************************
  compile_prologlibobj(+ParserTerm,+Module,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @\prolog(module) in the arguments position
*******************************************************************************/
compile_prologlibobj(ParserTerm,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Module,
			     Object,OidCode,Code,BodyFrontList,Status)
	;
            compile_atomvar(Module,ModCode),
	    plgatomobj_struct(ParserTerm,ModCode,Object),
	    %%atomobj_struct(ParserTerm,FObj),
	    %%N=0,
	    %%prologterm_struct(FObj,0,[],Module,Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyFrontList=[],
	    Status = NO_ERRORS
	).


/*******************************************************************************
  compile_prologalllibobj(+ParserTerm,-Object,-OidCode,-Code-,?BodyFrontList,-Status)

  Compiles @\prologall in argument position, e.g., foo(f(...)@\prologall
******************************************************************************/
compile_prologalllibobj(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_prologlibobj(ParserTerm,PrelimObject,PrelimOidCode,PrelimCode,BodyFrontList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([FromPrologCode,PrelimCode],Code).

/****************************************************************************
  compile_prologalllibobj(+ParserTerm,+Module,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles @\prologall(module) in argument position,
  e.g., foo(f(...)@\prologall(module)
***************************************************************************/
compile_prologalllibobj(ParserTerm,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_prologlibobj(ParserTerm,Module,PrelimObject,PrelimOidCode,PrelimCode,BodyFrontList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([PrelimCode,FromPrologCode],Code).


/*******************************************************************************
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,-Object,-OidCode,-Code,?BodyFrontList,-Status)
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,+PlgModule,-Object,-OidCode,-Code,?BodyFrontList,-Status)
  
 BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
*******************************************************************************/
compile_prlgterm(Funct,N,Args,Object,OidCode,Code,BodyFrontList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Object),
	push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	compile_body_pathexplist(Args,FL_THISMODULE,AObj,OidCode,Code,BodyFrontList,Status),
	pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	!.

%% Generate prolog term with module prefix
compile_prlgterm(Funct,N,Args,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Module,Object),
	push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
	compile_body_pathexplist(Args,FL_THISMODULE,AObj,OidCode,Code,BodyFrontList,Status),
	pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK).

/*******************************************************************************
   generate_convert_to_prolog_code(+AObjList,+VarList,-Code)
*******************************************************************************/
generate_convert_to_prolog_code([],_,NULL).

generate_convert_to_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_DONOT_UNIFY_VARS - do not unify when both arguments are vars
	%%prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],CodeH),
	/* Previously we used P2H_DONOT_UNIFY_VARS here, but this meant that,
	   for example     ?- write(f(?X,?X))@\prologall.
           will print the two versions of ?Y as different vars.
           Do not know why P2H_DONOT_UNIFY_VARS was used here before.
	*/
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],CodeH),
	%%prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_UNIFY_VARS],CodeH),
	generate_convert_to_prolog_code(AObjT,VarT,CodeT),
	conjunct_struct(CodeH,CodeT,Code).

/*******************************************************************************
   generate_convert_from_prolog_code(+AObjList,+VarList,-Code)
*******************************************************************************/
generate_convert_from_prolog_code([],_,NULL).

generate_convert_from_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_UNIFY_VARS - unify when both arguments are vars
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_UNIFY_VARS],CodeH),
	generate_convert_from_prolog_code(AObjT,VarT,CodeT),
	conjunct_struct(CodeH,CodeT,Code).
		

/*******************************************************************************
  compile_head_floraliblit(+ParserTerm,+Workspace,-Code,-H2BCodeFront,-H2BCodeBack,-Status)

  This procedure compiles a head literal associated with a Flora system
  module specification.
*******************************************************************************/
compile_head_floraliblit(ParserTerm,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_head_literal_top(ParserTerm,WSCode,Code,H2BCodeFront,H2BCodeBack,Status).


/*******************************************************************************
  compile_head_literal_top(+ParserTerm,+Workspace,-HeadLitCode,-H2BCodeFront,-H2BCodeBack,-Status)

  HeadLitCode is the main code for the literal.
              Note: set arguments are treated by the parser, so they don't
	      appear in the head. But they can appear in the body.
  H2BCodeFront - code passed from head to body, which is supposed to be
                 prepended to the code of the body
  H2BCodeBack - code passed from head to body, which is supposed to be
                appended to the code of the body
*******************************************************************************/
compile_head_literal_top(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
        set_context(CONTEXT_COMPILER_HEADLITERAL),
	compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status),
	%%multiply_setarg_code(Code,HeadLitCode),
	%%HeadLitCode=Code,
        clear_context(CONTEXT_COMPILER_HEADLITERAL).

compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_fltransactionalterm(ParserTerm,Funct,N,Args),
	!,
	compile_head_transactional_termlit(Funct,N,Args,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flterm(ParserTerm,Funct,N,Args),
	!,
	compile_head_termlit(Funct,N,Args,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2),
	!,
	compile_head_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,_Obj,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flobjspec(ParserTerm,ObjTerm,Spec,_),
	!,
	compile_head_objspec(Spec,ObjTerm,WS,_Obj,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flobjeql(ParserTerm,O1,O2),
	!,
	compile_head_objeql(O1,O2,WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,_WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flneg(ParserTerm,PosPart,Idx),
	!,
	detach_flworkspace(PosPart,PosPartSansWS,PosWS),
	compile_head_neg(PosPartSansWS,PosWS,Idx,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,_WS,HeadLitCode,OidCode,NULL,Status) :-
	is_reifyop(ParserTerm,Formula),
	!,
	compile_reifyop(Formula,HeadLitCode,OidCode,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,NULL,NULL,Status) :-
        is_flvariable(ParserTerm,VarName,Index),
	!,
	%% Is this possible? Should be taken care by the libmodlit code
	compile_var(VarName,Index,VarCode),
	attach_workspace(VarCode,WS,HeadLitCode,Status).

compile_head_literal(ParserTerm,WS,HeadLitCode,NULL,NULL,Status) :-
        is_fltransactionalvariable(ParserTerm,VarName,Index),
	!,
	%% Is this possible? Should be taken care by the libmodlit code
	compile_transactionalvar(VarName,Index,VarCode),
	attach_workspace(VarCode,WS,HeadLitCode,Status).

compile_head_literal(ParserTerm,_WS,HeadLitCode,H2BCodeFront,H2BCodeBack,Status) :-
	is_flfloralib(ParserTerm,P,Module),
	!,
	compile_head_floraliblit(P,Module,HeadLitCode,H2BCodeFront,H2BCodeBack,Status).

compile_head_literal(ParserTerm,_WS,HeadLitCode,NULL,NULL,Status) :-
	is_fldatatype(ParserTerm,_Sort,_Lit,Index),
	!,
	datatypeobj_struct(ParserTerm,Code1,_VarBindingCode,Status1),
	(atomlit_struct(HEADLITERAL,Code1,HeadLitCode) -> Status = Status1
	; compiling_error(Index,INVALID_LITERAL_RULE_HEAD,Err),
            append([Err],Status1,Status)
        ).

compile_head_literal(ParserTerm,_WS,HeadLitCode,NULL,NULL,Status) :-
	is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index),
	!,
	datatypeobj_struct(ParserTerm,Code1,_VarBindingCode,Status),
	transactionalatomlit_struct(HEADLITERAL,Code1,HeadLitCode).

compile_head_literal(ParserTerm,WS,HeadLitCode,NULL,NULL,Status) :-
	is_flatom(ParserTerm,_),
	!,
	%% atom (0-ary predicate)
	atomlit_struct(HEADLITERAL,ParserTerm,AtmCode),
	attach_workspace(AtmCode,WS,HeadLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; append(SymbolStatus,WSStatus,Status)
	).
	
compile_head_literal(ParserTerm,WS,HeadLitCode,NULL,NULL,Status) :-
	is_fltransactionalatom(ParserTerm,_A),
	!,
	transactionalatomlit_struct(HEADLITERAL,ParserTerm,ACode),
	attach_workspace(ACode,WS,HeadLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,
			      TRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; append(SymbolStatus,WSStatus,Status)
	).

compile_head_literal(ParserTerm,WS,HeadLitCode,NULL,NULL,Status) :-
	is_flbuiltin_identifier(ParserTerm,_),
	!,
	atomlit_struct(HEADLITERAL,ParserTerm,BICode),
	attach_workspace(BICode,WS,HeadLitCode,WSStatus),
	verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	(WSStatus == NO_ERRORS -> Status = SymbolStatus
	; append(SymbolStatus,WSStatus,Status)
	).


compile_head_literal(ParserTerm,_WS,_HeadLitCode,_H2BFrnt,_H2BBck,[Err]) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head_literal'],Err).


/****************************************************************************
  compile_head_pathexplist(+ParserTermList,+WS,-ObjectList,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_pathexplist([],_WS,[],NULL,NULL,NULL,NO_ERRORS) :- !.

compile_head_pathexplist([T|L],WS,[TObj|LObj],Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexp(T,WS,TObj,TCode,TH2BCodeFront,TH2BCodeBack,S),
	(var(TCode) -> TCode = NULL ; true),
	clear_context(CONTEXT_COMPILER_TERM_NAME),
        !,
	( no_errors_found(S) -> 
	    compile_head_pathexplist(L,WS,LObj,LCode,LH2BCodeFront,LH2BCodeBack,S2),
	    (var(LCode) -> LCode = NULL ; true),
	    ( no_errors_found(S2) -> 
		conjunct_struct(TCode,LCode,Code),
		conjunct_struct(TH2BCodeFront,LH2BCodeFront,H2BCodeFront),
		conjunct_struct(TH2BCodeBack,LH2BCodeBack,H2BCodeBack),
		append(S,S2,Status)
	    ;
		Status=S2
	    )
	;
	  Status=S
        ),
	!.


/*******************************************************************************
  compile_head_pathexp(+ParserTerm,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)

  Path expression in rule head

*******************************************************************************/
compile_head_pathexp(ParserTerm,WS,Object,NULL,NULL,NULL,Status) :-
        is_fltransactionalatom(ParserTerm,_A),
	!,
	verify_symbol_context(ParserTerm,0,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
	transactionalatomobj_struct(ParserTerm,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,NO_ERRORS) :-
	is_flnumber(ParserTerm,_N),
	!,
	numobj_struct(ParserTerm,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,NO_ERRORS) :-
	is_flvariable(ParserTerm,Name,Index),
	!,
	compile_var(Name,Index,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,NO_ERRORS) :-
        is_fltransactionalvariable(ParserTerm,Name,Index),
	!,
	compile_transactionalvar_without_trans(Name,Index,Object).

compile_head_pathexp(ParserTerm,WS,Object,NULL,NULL,NULL,Status) :-
	is_flbuiltin_identifier(ParserTerm,Ident),
	!,
	(Ident == FL_PI_NUMBER -> numobj_struct(FL_PI_NUMBER_VALUE,Object)
	; Ident == FL_E_NUMBER -> numobj_struct(FL_E_NUMBER_VALUE,Object)
	; verify_symbol_context(ParserTerm,0,WS,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	    builtin_identifier_struct(ParserTerm,Object)
	).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,VarBindingCode,NULL,Status) :-
	is_fldatatype(ParserTerm,_Sort,_Lit,_Index),
	!,
	datatypeobj_struct(ParserTerm,Object,VarBindingCode,Status).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,Status) :-
	is_flstring(ParserTerm,_S,Index),
	!,
	(has_persistentoption(FL_EXPERT) -> Status = NO_ERRORS
	; compiling_error(Index,ERROR_EXPERT_SYNTAX,Err),
	    Status = [Err]
	),
	strobj_struct(ParserTerm,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,NO_ERRORS) :-
	is_flcharlist(ParserTerm,_S,_I),
	!,
	strobj_struct(ParserTerm,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,NO_ERRORS) :-
	is_fltransactionalstring(ParserTerm,_S),
	!,
	transactionalstrobj_struct(ParserTerm,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,Status) :-
	is_fltoken(ParserTerm,Token,Index),
	!,
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	compile_head_fltoken(Token,Index,Object).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,Status) :-
	is_fltoken(ParserTerm,Token,Suffix,Index),
	!,
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Stat1),
	compile_head_fltoken(Token,Suffix,Index,Object,Stat2),
	append(Stat1,Stat2,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flbirelate(ParserTerm,OT1,RelType,OT2),
	!,
	compile_head_bin_relation(OT1,RelType,OT2,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flobjspec(ParserTerm,ObjTerm,Spec,_),
	!,
	compile_head_objspec(Spec,ObjTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flobjref(ParserTerm,ObjTerm,AttTerm,SpecType),
	!,
	compile_head_objref(ObjTerm,SpecType,AttTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flterm(ParserTerm,Funct,N,Args),
	!,
	compile_head_termobj(Funct,N,Args,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
        is_fltransactionalterm(ParserTerm,Funct,N,Args),
	!,
	compile_head_termobj(Funct,N,Args,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flarith(ParserTerm,StrippedParseTerm),
	!,
	push_context(CONTEXT_COMPILER_ARITHMETICS),
	compile_head_pathexp(StrippedParseTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status),
	pop_context(CONTEXT_COMPILER_ARITHMETICS).


#if exists("extensions/flrevalexp_compile_head.P")
#include "extensions/flrevalexp_compile_head.P"
#endif

%% expression like =Expr as an argument in rule head
compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flevalexp(ParserTerm,StrippedParseTerm),
	!,
	push_context(compiling_arithmetics),
	compile_head_pathexp(StrippedParseTerm,WS,ExprCode,Code,H2BCodeFront,ExprBodyCodeBack,Status),
	new_quantified_prvariable(NO_INDEX,Object),
	code_line_and_file_by_prterm(ExprCode,Line,CurrFileName),
	prologterm_struct(flora_arith_IS_builtin,4,[CurrFileName,Line,Object,ExprCode],FLDELAYSUPPORTMOD,EvalExprCode),
	conjunct_struct(ExprBodyCodeBack,EvalExprCode,H2BCodeBack),
	pop_context(compiling_arithmetics).



compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_fllist(ParserTerm,L,T,I),
	!,
	compile_head_list_obj(L,T,I,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,_WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flworkspace(ParserTerm,P,NestedWS),
	!,
	compile_head_pathexp(P,NestedWS,Object,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,H2BCodeFront,NULL,Status) :- 
	is_flatom(ParserTerm,_A),
	!,
	compile_atomobj(ParserTerm,Object,BodyFrontList,Status),
	(BodyFrontList==[] -> H2BCodeFront=NULL
	;
	    conjunct_code(BodyFrontList,H2BCodeFront)
	).

compile_head_pathexp(ParserTerm,_WS,Object,NULL,H2BCodeFront,NULL,Status) :- 
	is_reifyop(ParserTerm,Formula),
	!,
	%% Code: code to get Object
	/* We push fllibmodobj, creating a reified statement,
	   to the body. This allows us to have reified statements with
	   var module in the head. For instance,
	    p(${a(?X)@?M}) :- a(?X,?M).
	    a(1,mmm).
	    ?- p(${a(?X)@mmm}).
	*/
	%% If H2BCodeFront != NULL, it means that head-reification could
	%% not be fully computed due to a var in the module or literal
	%% position. In that case, fllibmodobj/5 is pushed to the body;
	%% it will then compute the reification or will unify with it.
	%%compile_reifyop(Formula,Object,H2BCodeFront,Status). %% OLD
        %% NEW: If reification, we replace head(${foo}) with ?NewVar and throw
        %%      ?NewVar ~ foo into the body.
        new_flvariable(NO_INDEX,_FlObject,Object), %% head var replacing formula
        compile_reifyop(Formula,FormulaObject,H2BCodeFront1,Status),
        ( no_errors_found(Status) ->
            univeqform_struct(Object,FormulaObject,H2BCodeFront2),
            conjunct_code([H2BCodeFront1,H2BCodeFront2],H2BCodeFront)
        ;
            true
        ).


compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,OidCode,Status) :- 
	is_flaggregate(ParserTerm,Op,V,GV,SortSpec,B),
	!,
	%% Aggregates are treated as OID, so its code would come
	%% ahead of the code of the literal it occurs in
	compile_aggregate(Op,V,GV,SortSpec,B,Object,OidCode,Status).

/*
%% In the head setarg expansion is now done in the parser
compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :- 
	is_flsetarg(ParserTerm,Setarg,_Idx),
	!,
	compile_head_setarg_list(Setarg,WS,SetList,Code,H2BCodeFront,H2BCodeBack,Status),
	Object = _, %% NOTE: a prolog var, since we'll be macro-expanding
	put_attr(Object,SETARGATTRIBUTE,member(Object,SetList)).
*/

compile_head_pathexp(ParserTerm,_WS,_Obj,_Code,_H2BFrnt,_H2BBck,[Err]) :- 
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head_pathexp'],Err).


/****************************************************************************
  compile_head_termobj(+FunctorTerm,+Arity,+ArgList,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)

****************************************************************************/
compile_head_termobj(Funct,N,Args,WS,Object,Code,H2BCodeFront,H2BCodeBack,CompileStatus) :-
        ( udf_expansion_test(Funct,N),
	    has_UDF(Funct,N,Args,Predicate,Object /* return value */,FunctBodyFrontList,S1)
	->
	    ( no_errors_found(S1) -> 
	    	H2BCodeBack=NULL,
	    	Code=NULL,
	    	compile_udf_body_literal(Funct,Predicate,PCode,PH2BCodeFront,S),
	    	SymbolContext = UDF_SYMBOL,
	    	( no_errors_found(S) -> 
		    conjunct_code(FunctBodyFrontList,FunctBodyFrontCode),
		    conjunct_code(PH2BCodeFront,PH2BCodeFront2),
		    conjunct_code([FunctBodyFrontCode,PH2BCodeFront2,PCode],
				  H2BCodeFront),
		    Status = NO_ERRORS
	    	;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_UDF_COMPILE,Err),
		    Status = [Err|S]
	    	)
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S1]
	    )
        ;
	    set_context(CONTEXT_COMPILER_TERM_NAME),
	    compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeFront,H2BCodeBack,Status),
	    SymbolContext = FUNCTION_SYMBOL,
            !,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object)
	    ; true
	    )
        ),
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	verify_symbol_context(Funct,N,WS,SymbolContext,Transactionality,SymbolStatus),
	!,
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_termlit(+FunctorTerm,+Arity,+ArgList,+WS,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_termlit(Funct,N,Args,WS,Code,H2BCodeFront,H2BCodeBack,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    termlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
	    attach_workspace(TObj,WS,WSTObj,WSStatus),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus==NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

compile_head_transactional_termlit(Funct,N,Args,WS,Code,H2BCodeFront,H2BCodeBack,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(CONTEXT_COMPILER_TERM_NAME),
	compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    transactionaltermlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
	    attach_workspace(TObj,WS,WSTObj,WSStatus),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus==NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).



/****************************************************************************
  compile_head_list_obj(+ObjTermList,+ObjTerm,+Index,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_list_obj(ObjTermList,ObjTerm,Index,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexplist(ObjTermList,WS,ObjList,ObjListCode,ObjListH2BCodeFront,ObjListH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		Obj=[],
		ObjCode=NULL,
		ObjH2BCodeFront=NULL,
		ObjH2BCodeBack=NULL,
		Status1 = NO_ERRORS
	    ;
	      compile_head_pathexp(ObjTerm,WS,Obj,ObjCode,ObjH2BCodeFront,ObjH2BCodeBack,Status1)
	    ),
            !,
	    ( no_errors_found(Status1) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_struct(ObjListCode,ObjCode,Code),
		conjunct_struct(ObjListH2BCodeFront,ObjH2BCodeFront,H2BCodeFront),
		conjunct_struct(ObjListH2BCodeBack,ObjH2BCodeBack,H2BCodeBack)
	    ;
	      true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_head_objref(+ObjT,+SpecType,+AttT,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
  SpecType: INHERITABLE/NONINHERITABLE
****************************************************************************/
compile_head_objref(ObjTerm,SpecType,AttTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OACode,OAH2BCodeFront,OAH2BCodeBack,PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    head_objref_struct(SpecType,Obj,Att,Index,Object,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    OAH2BCodeFront = H2BCodeFront,
	    conjunct_struct(OAH2BCodeBack,WTCode,H2BCodeBack),
	    Code = OACode
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	;  Status = WSStatus
	).


/****************************************************************************
  compile_head_bin_relation(+OT1,+RelType,+OT2,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Obj1,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    birelate_struct(HEADLITERAL,Obj1,RelType,Obj2,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    conjunct_struct(OCode,WTCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	;  Status = WSStatus
	).


/****************************************************************************
  compile_head_objspec(+SpecBody,+ObjTerm,+WS,-Object,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_objspec(SpecBody,ObjTerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status) :-
	%% TODO: check if SpecBody can be a var. If not, we could optimize
	%% by splitting this into 2 clauses and putting [] in place of SpecBody
	%% in the rule head.
	( SpecBody == [] ->
	    ( is_flobjref(ObjTerm,OTerm,ATerm,SpecType) ->
		compile_head_objref(OTerm,SpecType,ATerm,WS,Object,Code,H2BCodeFront,H2BCodeBack,Status)
	    ;
		compile_head_pathexp(ObjTerm,WS,Object,ObjCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
                !,
		( no_errors_found(PathexpStatus) -> 
		    objexists_struct(HEADLITERAL,Object,ECode),
		    attach_workspace(ECode,WS,WSECode,WSStatus),
		    conjunct_struct(ObjCode,WSECode,Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    )
	;
	  compile_head_pathexp(ObjTerm,WS,Object,ObjCode,ObjH2BCodeFront,ObjH2BCodeBack,S),
            !,
            ( no_errors_found(S) -> 
                compile_head_specbody(SpecBody,Object,WS,SCode,SH2BCodeFront,SH2BCodeBack,Status1),
                ( no_errors_found(Status1) -> 
                    conjunct_struct(ObjCode,SCode,Code),
                    conjunct_struct(ObjH2BCodeFront,SH2BCodeFront,H2BCodeFront),
                    conjunct_struct(ObjH2BCodeBack,SH2BCodeBack,H2BCodeBack)
                ; true
                ),
                append(S,Status1,Status)
            ;
                Status=S
            )
        ),
	!.


/****************************************************************************
  compile_head_specbody(+SpecTerm,+Object,+WS,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
****************************************************************************/
compile_head_specbody(SpecTerm,Object,_WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flworkspace(SpecTerm,Spec,SpecWS),
	!,
	compile_head_specbody(Spec,Object,SpecWS,Code,H2BCodeFront,H2BCodeBack,Status).

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_head_specbody(L,Object,WS,LCode,LH2BCodeFront,LH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    compile_head_specbody(R,Object,WS,RCode,RH2BCodeFront,RH2BCodeBack,Status),
	    ( no_errors_found(Status) -> 
		conjunct_struct(LCode,RCode,Code),
		conjunct_struct(LH2BCodeFront,RH2BCodeFront,H2BCodeFront),
		conjunct_struct(LH2BCodeBack,RH2BCodeBack,H2BCodeBack)
	    ; true
	    )
	;
	  Status=S
        ),
	!.

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_head_specbody(G,Object,WS,GCode,H2BCodeFront,H2BCodeBack,S),
	!,
	( no_errors_found(S) -> 
	    neg_struct(GCode,Idx,Code,Status)
	; Status = S
	).

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,_ArrowType,VL,SpecType),
	!,
	compile_head_pathexp(AttTerm,WS,AObj,ACode,AH2BCodeFront,AH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    ( VL == [] ->
		mvdattdef_struct(SpecType,HEADLITERAL,Object,AObj,SCode),
		attach_workspace(SCode,WS,WSSCode,Status1),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeFront=AH2BCodeFront,
		H2BCodeBack=AH2BCodeBack
	    ;
	      compile_head_mvd_attspec(Object,AObj,SpecType,VL,WS,VCode,VH2BCodeFront,VH2BCodeBack,Status1),
                !,
                ( no_errors_found(Status1) -> 
                    conjunct_struct(ACode,VCode,Code),
                    conjunct_struct(AH2BCodeFront,VH2BCodeFront,H2BCodeFront),
                    conjunct_struct(AH2BCodeBack,VH2BCodeBack,H2BCodeBack)
                
                ; true
                )
	    ),
	    append(S,Status1,Status)
        ;
	  Status=S
        ),
	!.

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flmethspec(SpecTerm,MethTerm,SpecType),
	!,
	compile_head_pathexp(MethTerm,WS,MethObj,MCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    methspec_struct(SpecType,HEADLITERAL,Object,MethObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(MCode,WSSCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_fltranspec(SpecTerm,TranTerm,SpecType),
	!,
	compile_head_pathexp(TranTerm,WS,TranObj,TCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    transpec_struct(SpecType,HEADLITERAL,Object,TranObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(TCode,WSSCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.


%% signatures: =>
compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,AH2BCodeFront,AH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(SpecType,HEADLITERAL,Object,AttObj,SCode),
		attach_workspace(SCode,WS,WSSCode,Status1),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeFront=AH2BCodeFront,
		H2BCodeBack=AH2BCodeBack
	    ;
		compile_head_pathexp(ValTerm,WS,ValObj,VCode,VH2BCodeFront,VH2BCodeBack,PathexpStatus),
                !,
		( no_errors_found(PathexpStatus) -> 
		    sigattspec_struct(SpecType,HEADLITERAL,Object,AttObj,ValObj,SCode),
		    attach_workspace(SCode,WS,WSSCode,WSStatus),
		    conjunct_code([ACode,VCode,WSSCode],Code),
		    conjunct_struct(AH2BCodeFront,VH2BCodeFront,H2BCodeFront),
		    conjunct_struct(AH2BCodeBack,VH2BCodeBack,H2BCodeBack)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status1 = PathexpStatus
		; Status1 = WSStatus
		)
	    ),
	    append(S,Status1,Status)
	;
	    Status = S
        ),
	!.

compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,_ArrowType,ValTerm,SpecType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,AH2BCodeFront,AH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(SpecType,HEADLITERAL,Object,AttObj,SCode),
		attach_workspace(SCode,WS,WSSCode,Status1),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeFront = AH2BCodeFront,
		H2BCodeBack = AH2BCodeBack
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		push_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
		compile_head_pathexplist([Lower,Upper],WS,[OLower,OUpper],CCode,CH2BCodeFront,CH2BCodeBack,S_C),
		pop_context(CONTEXT_COMPILER_NO_SYMBOL_CHECK),
                !,
		( no_errors_found(S_C) -> 
		    compile_head_pathexp(ValTerm,WS,ValObj,VCode,VH2BCodeFront,VH2BCodeBack,PathexpStatus),
                    !,
		    ( no_errors_found(PathexpStatus) -> 
			sigattspec_struct(SpecType,HEADLITERAL,Object,AttObj,ValObj,SCode),
			attach_workspace(SCode,WS,WSSCode,WSStatus1),
			sigattcondef_struct(SpecType,HEADLITERAL,Object,AttObj,OLower,OUpper,ValObj,CSCode),
			attach_workspace(CSCode,WS,CWSSCode,WSStatus2),
			(WSStatus1 == NO_ERRORS, WSStatus2 == NO_ERRORS -> Status1 = PathexpStatus
			; append(WSStatus1,WSStatus2,Status1)
			),
			conjunct_code([ACode,CCode,VCode,WSSCode,CWSSCode],Code),
			conjunct_code([AH2BCodeFront,CH2BCodeFront,VH2BCodeFront],H2BCodeFront),
			conjunct_code([AH2BCodeBack,CH2BCodeBack,VH2BCodeBack],H2BCodeBack)
		    ;
			Status1 = PathexpStatus
		    )
		;
		    Status1 = S_C
		)
	    ),
	    append(S,Status1,Status)
	;
	    Status = S
        ),
	!.


%% boolean signatures: =>.
compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_ArrowType,SpecType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    boolsig_struct(SpecType,HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.


%% boolean signatures: =>% for transactional method
compile_head_specbody(SpecTerm,Object,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	is_fltransig(SpecTerm,AttTerm,_ArrowType,SpecType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
	    transig_struct(SpecType,HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

/*******************************************************************************
  compile_head_mvd_attspec(+Object,+AttObj,+SpecType,+VL,+WS,-Code,-H2BCodeFront,-H2BCodeBack,-Status)
*******************************************************************************/
compile_head_mvd_attspec(_Obj,_AttObj,_SpecType,[],_WS,NULL,NULL,NULL,NO_ERRORS) :- !.

compile_head_mvd_attspec(Object,AttObj,SpecType,[T|L],WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	!,
	compile_head_pathexp(T,WS,TObj,TCode,TH2BCodeFront,TH2BCodeBack,S),
        !,
	( no_errors_found(S) -> 
	    mvdattspec_struct(SpecType,HEADLITERAL,Object,AttObj,TObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(TCode,WSSCode,TSCode),
	    compile_head_mvd_attspec(Object,AttObj,SpecType,L,WS,LCode,LH2BCodeFront,LH2BCodeBack,AttspecStatus),
	    append(AttspecStatus,WSStatus,Status1),
            !,
	    ( no_errors_found(Status1) -> 
		conjunct_struct(TSCode,LCode,Code),
		conjunct_struct(TH2BCodeFront,LH2BCodeFront,H2BCodeFront),
		conjunct_struct(TH2BCodeBack,LH2BCodeBack,H2BCodeBack)
	    ; true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_head_objeql(+Obj1,+Obj2,+Workspace,-Code,-H2BCodeFront,-H2BCodeBack,-Status)

  H2BCodeFront - code passed from head to body, which is supposed to be
                 prepended to the code of the body
  H2BCodeBack - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_objeql(Obj1,Obj2,WS,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_pathexplist([Obj1,Obj2],WS,[O1,O2],OCode,H2BCodeFront,H2BCodeBack,PathexpStatus),
        !,
	( no_errors_found(PathexpStatus) -> 
            check_unequatable_datatypes(O1,O2,DTStatus),
            (DTStatus == NO_ERRORS ->
                objeql_struct(HEADLITERAL,O1,O2,OECode),
                attach_workspace(OECode,WS,WSCode,WSStatus),
                conjunct_struct(OCode,WSCode,Code)
            ; WSStatus = DTStatus
            )
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

/****************************************************************************
  compile_head_neg(+PosPart,+WS,+Idx,-Code,-H2BCodeFront,-H2BCodeBack,-Status)

  H2BCodeFront - code passed from head to body, which is supposed to be
                 prepended to the code of the body
  H2BCodeBack - code passed from head to body, which is supposed to be
                appended to the tail of the code of the body
****************************************************************************/
compile_head_neg(PosPart,WS,Idx,Code,H2BCodeFront,H2BCodeBack,Status) :-
	compile_head_literal_top(PosPart,WS,PosCode,H2BCodeFront,H2BCodeBack,S),
	%% compile_head_literal_top/6 clears the CONTEXT_COMPILER_HEADLITERAL
	%% context, so, we reenable it here. This context is used in
	%% modularized_pratom_struct/3/4
	set_context(CONTEXT_COMPILER_HEADLITERAL),
        !,
	( no_errors_found(S) -> 
	    head_neg_struct(PosCode,Idx,NegCode,Status1),
	    attach_workspace(NegCode,WS,Code,WSStatus),
	    (WSStatus == NO_ERRORS -> append(S,Status1,Status)
	    ; append(Status1,WSStatus,Status)
	    )
	; Status = S
	),
	clear_context(CONTEXT_COMPILER_HEADLITERAL),
	!.


/****************************************************************************
  compile_insert(+Op,+List,+Cond,-Code,-Status)
****************************************************************************/
compile_insert(Op,List,Cond,Code,Status) :-
	compile_insert_literals(List,CodeList,S),
        !,
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status1),
            !,
	    ( no_errors_found(Status1) -> 
		list_struct(CodeList,[],ListCode),
		insert_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.

/*******************************************************************************
  compile_insert(+Op,+List,-Code,Status)
  NOTE: When inserting rules, we check for singleton/unsafe variables
        at runtime in flrdynrule.P.
        When inserting facts, we do not check for these variables at run time.
*******************************************************************************/
compile_insert(Op,List,Code,Status) :-
	compile_insert_literals(List,CodeList,Status),
        !,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    insert_struct(Op,ListCode,Code1),
            %% Note: CodeList may contain rules, so collect DYNRULE_VARLIST
	    get_dynrule_varlist(VarList),
	    add_dynrule_attr_code(VarList,Code1,Code)
	;
	  true
        ),
	!.


/****************************************************************************
  compile_insert_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_insert_literals(List,DBCodeList,Status) :-
	set_context(CONTEXT_COMPILER_UPDATE_LITERALS),
	compile_insert_litlist(List,Code,Status),
	prconjunct2list(Code,CodeList),
	( no_errors_found(Status) -> 
	    compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	!,
	clear_context(CONTEXT_COMPILER_UPDATE_LITERALS).


/****************************************************************************
  compile_insert_litlist(+List,-Code,-Status)

  Code is the conjunctions of atoms to be inserted.
****************************************************************************/
compile_insert_litlist([],NULL,NO_ERRORS) :- !.

compile_insert_litlist([H|T],Code,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_dynrule(OpAtom,R,HCode,S),
        !,
	( no_errors_found(S) -> 
	    compile_insert_litlist(T,TCode,Status1),
	    ( no_errors_found(Status1) -> conjunct_struct(HCode,TCode,Code)
	    ; true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
	),
	!.

compile_insert_litlist([HWS|T],Code,Status) :-
	%% regular fact. may have path expression inside
	detach_flworkspace(HWS,H,WS),
	(is_flstealthlit(H,H1) -> IsStealthLit = set
	;  H1 = H
	),
        %% Need to set CONTEXT_COMPILER_DYNRULE in case H1 gets converted
        %% into a rule and then we need the module context variable
        %% to be PRDYNFLCONTEXTVAR(PRDYNFLCONTEXTVAR)) and
        %% not  PRFLCONTEXTVAR(PRFLCONTEXTVAR))
        set_context(CONTEXT_COMPILER_DYNRULE(FL_INSERTRULE)),
	compile_head_literal_top(H1,WS,HeadCode,H2BCodeFront,H2BCodeBack,S),
        clear_context(CONTEXT_COMPILER_DYNRULE(FL_INSERTRULE)),
	!,
	( no_errors_found(S) -> 
	    ( H2BCodeFront==NULL, H2BCodeBack==NULL ->
		%% If literal is a prolog term, generate code that will simply
		%% insert this term using adaptive assert
		((is_prologterm(HeadCode,_,_) ; is_wsprologterm(HeadCode)) ->
		    generate_prolog_liblit(WRAP_DYNPROLOG_FACT,1,[HeadCode],HeadCode1)
		; nonvar(IsStealthLit) -> stealth_code(HeadCode,HeadCode1)
		; HeadCode1 = HeadCode
		),
		compile_insert_litlist(T,TCode,S2),
                !,
		( no_errors_found(S2) -> 
		   conjunct_struct(HeadCode1,TCode,Code)
		; true
		),
		append(S,S2,Status)

	    ;   %%%% Fact must be converted to rule
                %% arrange for dynrule variables
                new_prvariable(NO_INDEX,HVL),
                new_prvariable(NO_INDEX,BVL),
                collect_name_var_pairs(H,HeadVars),
                list_struct(HeadVars,[],HVLValue),
                (HeadVars==[] -> true
                ; report_dynrule_varlist(HVL,HVLValue)
                ),
                collect_name_var_pairs([],BodyVars),
                list_struct(BodyVars,[],BVLValue),
                (BodyVars==[] -> true
                ; report_dynrule_varlist(BVL,BVLValue)
                ),
		%% Head literal contains a path expr, so it becomes a rule.
		%% Treat it as a dynamically inserted rule.

		%% Since this rule came from a dynamic fact that contains
		%% a path expression, the annotation code is empty.
		%% The last FL_TRUE is the defeasible condition to be
		%% attached to rule bodies.
		approx_flindex(H,RuleIdx),
		compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_DYNRULE,DescrIdCode,DescrVarsTerm,DefaultMetaFactDiffList,_),
		set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
		set_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+FL_INSERTRULE)),
		%% CHECK!!!!
		prconjunct2list(HeadCode,HCode),
		list_struct(HCode,[],HeadCodeList),
		%% only the vars in the fact-term are to be checked
		delay_literals_checking_code([],H,H2BCodeFront,H2BCodeBack,DescrVarsTerm,DelayCheckCode),
		%% CHECK!!!!! Rule enabler for facts-turned-rules?
		construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_DYNRULE,RuleEnablerTest,FileName),
		PreBody = RuleEnablerTest,
		%% CHECK!!!!! Delay checker for inserting facts-turned-rules?
		PostBody = DelayCheckCode,
		get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
		DefaultMetaFactDiffList = DefaultMetaFactList - [],
		list_struct(DefaultMetaFactList,[],MetaFactCode),
		list_struct([H2BCodeFront],[],H2BCodeFrontList),
		list_struct([H2BCodeBack],[],H2BCodeBackList),
		list_struct([PostBody],[],PostBodyList),
		florasyslib_struct(FLSYSRULEUPDATE,15,
				   [DescrIdCode,FileName,DescrVarsTerm,
				    StmtNum,MetaFactCode,
				    HeadCodeList,
				    FL_TRUE,  %% Body
				    HVL,BVL,
				    FL_TRUE,  %% DTvarscode
				    H2BCodeFrontList,H2BCodeBackList,
				    PreBody,
				    PostBodyList,
				    FL_TRUE], %% default defeat condition
				   HDynruleCode),
		clear_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)),
		clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
		compile_insert_litlist(T,TCode,S2),
		( no_errors_found(S2) -> 
		    conjunct_struct(HDynruleCode,TCode,Code)
		; true
		),
		append(S,S2,Status)
	    )
	;
	    Status=S
	),
	!.


/****************************************************************************
  compile_delete(+Op,+List,+Cond,-Code,-Status)

  for delete operations with a condition.
****************************************************************************/
compile_delete(Op,List,Cond,Code,Status) :-
	compile_delete_literals(List,CodeList,S),
        !,
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status1),
            !,
	    ( no_errors_found(Status1) -> 
		list_struct(CodeList,[],ListCode),
		delete_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_delete(+Op,+List,-Code,-Status)

  for delete operations without a condition.
****************************************************************************/
compile_delete(Op,List,Code,Status) :-
	compile_delete_literals(List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    delete_struct(Op,ListCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_delete_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_delete_literals(List,DBCodeList,Status) :-
	set_context(CONTEXT_COMPILER_UPDATE_LITERALS),
	set_context(CONTEXT_COMPILER_BODY_REIFY_4_DELETE),
	compile_delete_litlist(List,CodeList,Status),
        !,
	( no_errors_found(Status) -> 
	    compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	!,
        clear_context(CONTEXT_COMPILER_BODY_REIFY_4_DELETE),
	clear_context(CONTEXT_COMPILER_UPDATE_LITERALS).


/****************************************************************************
  compile_delete_litlist(+List,-CodeList,-Status)
****************************************************************************/
compile_delete_litlist([],[],NO_ERRORS) :- !.

compile_delete_litlist([H|T],CodeList,Status) :-
	%% When delete list contains an object equality definition, the compiler
	%% will prepare to load the basic equality trailer, unless it is
	%% overridden by an explicity directive.
	is_flobjeql(H,O1,O2),
	!,
	compile_body_objeql(O1,O2,FL_THISMODULE,OidCode,SpecCode,_,S),
	conjunct_struct(OidCode,SpecCode,HCode),
	approx_flindex(O1,Idx),
	report_option(FLOBJEQLDEF,Idx),
        !,
	( no_errors_found(S) -> 
	    prconjunct2list(HCode,HCodeList),
	    compile_delete_litlist(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		append(HCodeList,TCodeList,CodeList)
	    ; true
	    )
	;
	  Status=S
        ),
	!.

compile_delete_litlist([H|T],CodeList,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_dynrule(OpAtom,R,HCode,S),
        !,
	( no_errors_found(S) -> 
	    compile_delete_litlist(T,TCodeList,Status),
            !,
	    ( no_errors_found(Status) -> 
		CodeList = [HCode|TCodeList]
	    ; true
	    )
	;
	  Status=S
	),
	!.

compile_delete_litlist([HWS|T],CodeList,Status) :-
	%% Call compile_body_literal_top because path expressions should be
	%% compiled into queries.
        set_context(CONTEXT_COMPILER_DELETE),
	detach_flworkspace(HWS,H,WS),
	(is_flstealthlit(H,H1) -> IsStealthLit = set
	; H1 = H
	),
	compile_body_literal_top(H1,WS,HOidCode,HSpecCode,LitFrontListCode,S),
        clear_context(CONTEXT_COMPILER_DELETE),
        !,
	( no_errors_found(S) -> 
	    (HOidCode == NULL, LitFrontListCode == [] ->
		(is_prologterm(HSpecCode,_,_) ->
		    %% This tells flrdbop.P and flrbtdbop.P that this fact is
		    %% to be asserted as Prolog, not into a trie.
		    %% Currently the asserts aren't backtrackable: to fix later.
		    generate_prolog_liblit(WRAP_DYNPROLOG_FACT,1,[HSpecCode],HWSCode1)
		; nonvar(IsStealthLit) -> stealth_code(HSpecCode,HWSCode1)
		; HWSCode1 = HSpecCode
		),
		prconjunct2list(HWSCode1,HWSCode)
	    ;
                set_context(CONTEXT_COMPILER_DELETE_RULE),
		prconjunct2list(HSpecCode,HList),
		RuleIdx = NO_INDEX,
		compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_DYNRULE,DescrIdCode,DescrVarsTerm,DefaultMetaFactDiffList,_),
		set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
		set_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+FL_DELETERULE)),
		list_struct(HList,[],HeadCodeList),
		%% Rule enabler for facts-turned-rules
		construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_DYNRULE,RuleEnablerTest,FileName),
		PreBody = RuleEnablerTest,
		list_struct([FL_TRUE],[],PostBodyList), %% delay checker
		get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
		DefaultMetaFactDiffList = DefaultMetaFactList - [],
		list_struct(DefaultMetaFactList,[],MetaFactCode),
		list_struct([],[],EmptyListCode), %% empty list
                (HOidCode==NULL ->
                    list_struct(LitFrontListCode,[],H2BCodeFrontList)
                ;
                    list_struct([HOidCode|LitFrontListCode],[],H2BCodeFrontList)
                ),
		list_struct([NULL],[],H2BCodeBackList),
		HVL = EmptyListCode,
		BVL = EmptyListCode,
		florasyslib_struct(FLSYSRULEUPDATE,15,
				   [DescrIdCode,FileName,DescrVarsTerm,
				    StmtNum,
				    MetaFactCode,
				    HeadCodeList,
				    FL_TRUE,  %% Body
				    HVL,BVL,
				    FL_TRUE,  %% DTvarscode
				    H2BCodeFrontList,H2BCodeBackList,
				    PreBody,
				    PostBodyList,
				    FL_TRUE], %% default defeat condition
				   HWSCode),
		clear_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)),
		clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE)
            ),
            clear_context(CONTEXT_COMPILER_DELETE_RULE),
	    compile_delete_litlist(T,TCodeList,S2),
            !,
	    ( no_errors_found(S2) -> 
		(is_list(HWSCode) ->
		    append(HWSCode,TCodeList,CodeList)
		; CodeList = [HWSCode|TCodeList]
		),
		append(S,S2,Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_dbupdate_list(+CodeList,-DBCodeList)

  This predicate processes the list of literals in a DB update. For each
  literal, it adds the name of the storage trie for the module.

  Note: a DB update can only update a Flora user module or the update's
        host module. If a Flora system module allows update,
	it must provide an update interface.
****************************************************************************/
compile_dbupdate_list([],[]) :- !.

compile_dbupdate_list([C|CL],[C|DBCodeList]) :-
	( is_prvariable(C)
        ; is_florasyslib_struct(C,_,_,_,_)
	),
	!,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	is_florasyslib_struct(C,_,FLSYSRULEUPDATE,_,_),
	!,
	%% Already compiled, don't tack on FLSYSDBUPDATE
	DBCode = C,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	( workspace_struct(_P,WS,C) ->
	    %% The name of the module is known.
	    storage_struct(WS,SCode)
	;
	    thisstorage_struct(fdb,SCode),
	    thismodule_struct(WS)
	),
	atomobj_struct(FLSYSDBUPDATE,FCode),
	prologterm_struct(FCode,3,[C,SCode,WS],DBCode),
	!,
	compile_dbupdate_list(CL,DBCodeList).

/****************************************************************************
  compile_updaterule(+Op,+List,-Code,-Status)
****************************************************************************/
compile_updaterule(Op,List,Code,Status) :-
	is_flatom(Op,OpAtom,Index),
	compile_dynrule_list(OpAtom,List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    updaterule_syslib(OpAtom,UpdateruleLib),
	    florasyslib_struct(Index,UpdateruleLib,1,[ListCode],Code1),
	    get_dynrule_varlist(VarList),
	    add_dynrule_attr_code(VarList,Code1,Code)
	;
	    true
        ).

%% compile_dynrule_list(+Op,+RuleList,-RuleListCode,-Status)
compile_dynrule_list(_Op,[],[],NO_ERRORS) :- !.
compile_dynrule_list(Op,[H|L],[HCode|LCode],Status) :-
	compile_dynrule(Op,H,HCode,S),
	!,
	( no_errors_found(S) -> 
	    compile_dynrule_list(Op,L,LCode,S1),
	    append(S,S1,Status)
	; S = Status
	).

%% compile single dynamic rule
%% compile_dynrule(+Op,+R,-RCode,-Status)
compile_dynrule(Op,R,RCode,Status) :-
	is_flruleworkspace(R,Rule,WS),
	!,
	workspaceterm_struct(WS,WSTerm),
	set_context(dynruleworkspace(WSTerm)),
	compile_dynrule(Op,Rule,RCode,Status),
	!,
	clear_contextall(dynruleworkspace(_)).

compile_dynrule(_Op,R,RCode,Status) :-
	is_flvariable(R,Name,Index),
	varobj_struct(Name,Index,RCode),
	Status = NO_ERRORS.

%% Note: prolog-headed rules (declared as :- prolog), including sensors,
%%       are not allowed to be dynamic in FLORA-2.
compile_dynrule(Op,R,RCode,Status) :-
	is_fldynrule(R,Head,Body,DescriptorList),
	approx_flindex(R,RuleIdx),
	%% If delete op: default rule id descriptor should be Var
	%% and shouldn't generate the rule enabling metafact.
	%% In this case we use the same representation as in clause{...},
	%% whence the FL_DESCRMODE_CLAUSE mode in compile_descriptor_list/6
	(is_fldeleteruleop(Op) -> DescrMode = FL_DESCRMODE_CLAUSE
	; is_fllatent_query(Body,_) -> DescrMode = FL_DESCRMODE_LATENT_DYNQUERY
	; DescrMode = FL_DESCRMODE_DYNRULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,DescrMode,DescrIdCode,DescrVarsTerm,MetaFactDiffList,DescriptorStatus),
        !,
	( no_errors_found(DescriptorStatus) -> 
	    (is_fllatent_query(Body,RealBody) ->
		compile_dyn_latent_query(Op,DescrIdCode,MetaFactDiffList,RealBody,RCode,Status)
	    ; compile_dynrule_main(Op,Head,Body,DescrIdCode,DescrVarsTerm,MetaFactDiffList,RCode,Status)
	    )
	;
	    Status = DescriptorStatus
	).


%% compile_dyn_ic(+Op,+DescrIdCode,+MetaFactDiffList,+Body,-LatentQueryDiffList,-Status)
%% op: delete/insert/insertrule/etc.
compile_dyn_latent_query(Op,DescrIdCode,MetaFactDiffList,Body,LatentQuerySigCode,Status) :-
	set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	set_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+Op)),
	compile_body_top(Body,BCode,BodyStatus),
        !,
	( no_errors_found(BodyStatus) -> 
	    collect_prdatatypevars(BCode,DTVarsCodeList),
	    conjunct_code(DTVarsCodeList,DTVarsCode),
	    conjunct_struct(DTVarsCode,BCode,LatentQueryBodyCode),
	    thismodule_struct(ThisMod),

	    %% info for singleton var checking
            collect_prvars((DescrIdCode,MetaFactDiffList),DescrPRVarList_pre),
            remove_nonuser_prvars(DescrPRVarList_pre,DescrPRVarList),
            prvar_to_flvar_struct_list(DescrPRVarList,DescrFLVars),

	    new_prvariable(NO_INDEX,BVL), % attr var for body var list
            collect_flvars(Body,BodyVars),
            subtract_vars(BodyVars,DescrFLVars,BodyOnlyVars),
	    collect_name_var_pairs(BodyOnlyVars,BodyVarPairs),
	    list_struct(BodyVarPairs,[],BVLValue),
	    (BodyVarPairs==[] -> true
	    ; report_dynrule_varlist(BVL,BVLValue)
	    ),

	    %% code to bind the CallerMod variable to the calling module
	    caller_module_binding_code(ThisMod,CallerBindingCode),
	    construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_LATENT_DYNQUERY,LatentQueryEnablerTest,_),
	    conjunct_struct(CallerBindingCode,LatentQueryEnablerTest,PreLatentQueryCode),
	    get_current_compile_file_for_descriptor(File,FL_DESCRMODE_LATENT_DYNQUERY),
	    (approx_prindex(DescrIdCode,Idx), Idx \== NO_INDEX -> true
	    ; approx_flindex(Body,Idx)
	    ),
	    get_current_stmt_number_for_descriptor(Idx,StmtNum),
	    MetaFactDiffList = MetaFactList - [],
	    list_struct(MetaFactList,[],MetaFactCode),
	    (is_fldeleteruleop(Op) ->
		florasyslib_struct(FLSYSDELQUERYSIG,5,[DescrIdCode,File,ThisMod,MetaFactCode,LatentQueryBodyCode],LatentQuerySigCode)
	    ; florasyslib_struct(FLSYSINSQUERYSIG,8,[DescrIdCode,File,ThisMod,StmtNum,MetaFactCode,PreLatentQueryCode,LatentQueryBodyCode,BVL],LatentQuerySigCode)
	    )
	;
	  true
	),
        remove_dontcare_flvars(DescrFLVars,DescrFLVarsClean),
        check_latent_query_flvars_for_safety(DescrFLVarsClean,Body,VarStat),
        flatten([BodyStatus,VarStat],Status),
	clear_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)),
	clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	!.

%% main workhorse that compiles dynamic rules
%% compile_dynrule_main(+Op,+Head,+Body,+DescrIdCode,+DescrVarsTerm,+MetaFactDiffList,-RuleCode,-Status) :-
compile_dynrule_main(Op,Head,Body,DescrIdCode,DescrVarsTerm,MetaFactDiffList,RuleCode,Status) :-
        set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	set_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+Op)),
	compile_head_top(Head,HeadNF,rule,HeadCode,H2BCodeFront,H2BCodeBack,HeadStatusPre),
	%% no :- prolog predicates in dynamic rule heads
	(has_prologlit(HeadCode,IdxH)
	-> compiling_error(IdxH,NO_PROLOG_IN_DYNRULE_HEAD,PlgStatus1),
	    PlgStatus = [PlgStatus1]
	; PlgStatus = NO_ERRORS
	),
	append(HeadStatusPre,PlgStatus,HeadStatus),
        new_prvariable(NO_INDEX,HVL), % attr var for head var list
        new_prvariable(NO_INDEX,BVL), % attr var for body var list
        !,
	( no_errors_found(HeadStatus) -> 
	    compile_body_top(Body,BodyCode,BodyStatus),
	    ( no_errors_found(BodyStatus) -> 
		( is_fldeleteruleop(Op) ->  true
		;   collect_name_var_pairs(Head,HeadVars),
		    list_struct(HeadVars,[],HVLValue),
		    (HeadVars==[] -> true
		    ; report_dynrule_varlist(HVL,HVLValue)
		    ),
		    collect_name_var_pairs(Body,BodyVars),
		    list_struct(BodyVars,[],BVLValue),
		    (BodyVars==[] -> true
		    ; report_dynrule_varlist(BVL,BVLValue)
		    )
		),
		make_datatype_vars_code(HeadCode,HeadDTvarscode),
		make_datatype_vars_code(BodyCode,BodyDTvarscode),
		conjunct_struct(HeadDTvarscode,BodyDTvarscode,DTvarscode),

	        list_struct(HeadCode,[],HeadCodeList),
	        list_struct(H2BCodeFront,[],H2BCodeFrontList),
	        list_struct(H2BCodeBack,[],H2BCodeBackList),
		construct_defeasible_condition_for_signature_or_dynrule(HeadCode,DescrIdCode,DescrVarsTerm,DefeatCondCode),
		%% Note: Head cannot contain sensors, so no need to check
		%% multi-headed rules if sensors mix with non-sensors
		(has_context(CONTEXT_COMPILER_UDF_DEFINITION) ->
                    RuleEnablerTest = true, FileName = NULL
		;
                    (has_context(CONTEXT_COMPILER_FOR_ADDITION) ->
                        EnableTestMode = FL_DESCRMODE_ADDRULE
                    ; EnableTestMode = FL_DESCRMODE_DYNRULE
                    ),
                    ( is_fldeleteruleop(Op) ->
                        set_context(CONTEXT_COMPILER_DELETE_RULE)
                    ; true
                    ),
                    construct_rule_enabling_test(DescrIdCode,EnableTestMode,RuleEnablerTest,FileName),
                    ( is_fldeleteruleop(Op) -> 
                        clear_context(CONTEXT_COMPILER_DELETE_RULE)
                    ; true
                    )
		),
		delay_literals_checking_code_list(HeadNF,Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,DelayCheckCodeList),
		PreBody = RuleEnablerTest,
		PostBody = DelayCheckCodeList,
		list_struct(PostBody,[],PostBodyList),
		approx_prindex(DescrIdCode,RuleIdx),
		get_current_stmt_number_for_descriptor(RuleIdx,StmtNum),
		MetaFactDiffList = MetaFactList - [],
		list_struct(MetaFactList,[],MetaFactCode),
		florasyslib_struct(FLSYSRULEUPDATE,15,
				   [DescrIdCode,FileName,DescrVarsTerm,
				    StmtNum,MetaFactCode,
				    HeadCodeList,
				    BodyCode,
				    HVL,BVL,
				    DTvarscode,
				    H2BCodeFrontList,
				    H2BCodeBackList,
				    PreBody,
				    PostBodyList,
				    DefeatCondCode],
				   RuleCode),
		flatten([HeadStatus,BodyStatus],Status)
	    ;
		flatten([HeadStatus,BodyStatus],Status)
	    )
	;
	    Status=HeadStatus
	),
	!,
        clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	clear_context(CONTEXT_COMPILER_DYNRULE(DescrIdCode+_)).

/*
remove_empty_list([],[]) :- !.
remove_empty_list([[]|L],NL) :- 
	!,
	remove_empty_list(L,NL).
remove_empty_list([H|L],[H|NL]) :- 
	remove_empty_list(L,NL).
*/

%% remove all occurrences of Elt from List.
%% this is a stop clause for var-terminated lists
remove_all(_Elt,Tail,Tail) :-
	var(Tail),
	!.
remove_all(_Elt,[],[]) :- !.
remove_all(Elt,[Elt|List],List2) :-
	!,
	remove_all(Elt,List,List2).
remove_all(Elt,[H|List],[H|List2]) :-
	remove_all(Elt,List,List2).


/****************************************************************************
             compile_stop_delay(VarList,Code)
     !!{...} and !! - immediate execution of delayed literals
****************************************************************************/
compile_stop_delay(_VarList,Idx,_Code,[Err]) :-
	has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	!,
	compiling_error(Idx,NO_IMMEDIATE_EXECUTION_OF_DELAY,Err).
compile_stop_delay(VarList,_Idx,Code,Status) :-
	(var(VarList) ->
	    (has_context(CONTEXT_COMPILER_BODY(BVarList)) -> true ; BVarList = []),
	    (has_context(CONTEXT_COMPILER_HEAD(HVarList)) -> true ; HVarList = []),
	    append(HVarList,BVarList,VarList)
	; true
	),
	compile_body_pathexplist(VarList,FL_THISMODULE,VarListCode,_,_,[],Status),
	list_struct(VarListCode,[],ArgsCode),
	list_struct([],[],EmptyListCode), %% empty list
	prologterm_struct(FLORA_DELAY_CHECKER,2,[ArgsCode,EmptyListCode],Code).


/****************************************************************************
             Table maintenance predicates
     refresh{...} removes the corresponding calls from Prolog tables.
****************************************************************************/
compile_refresh(List,Code,Status) :-
	compile_delete_litlist(List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    table_refresh_struct(ListCode,Code)
	;
	  true
        ).

/****************************************************************************
  compile_clause(+Mode,+HeadList,+Body,-Code,-BodyFrontList,-Status)
  Mode determines which rules to search for: static only, dynamic only, etc.
****************************************************************************/
compile_clause(Descriptor,Mode,HeadList,Body,Code,BodyFrontList,Status) :-
	approx_flindex(HeadList,ClauseIdx),
	compile_descriptor_list(Descriptor-ClauseIdx,FL_DESCRMODE_CLAUSE,DescrIdCode,
				DescrVarTerm,
				MetaFactDiffList,Descr_Status),
        !,
	( no_errors_found(Descr_Status) -> 
	    (Mode == NULL -> ModeCode = Mode
	    ;
		compile_atomvar(Mode,ModeCode)
	    ),
	    set_context(CONTEXT_COMPILER_CLAUSE_PRIMITIVE),
	    set_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	    set_context(CONTEXT_COMPILER_HEADLITERAL),
            set_context(CONTEXT_COMPILER_DELETE),
            /*
               DEPRECATED: compile_delete_litlist(HeadList,HLC,Head_Status),
                           HeadOidCode = [], HeadLitFrontListCodePre = [],
            */
            compile_body_literal_list(HeadList,HeadOidCode,HLC,HeadLitFrontListCodePre,Head_Status),
	    clear_context(CONTEXT_COMPILER_HEADLITERAL),
            clear_context(CONTEXT_COMPILER_DELETE),
            convert_udf_hilog_predlist(HeadLitFrontListCodePre,HeadLitFrontListCode),
            !,
	    ( no_errors_found(Head_Status) -> 
		list_struct(HLC,[],HeadListCode),
		compile_body_top(Body,BodyCode,Status),
                !,
		( no_errors_found(Status) -> 
		    MetaFactDiffList = MetaFactList - [],
		    conjunct_code(MetaFactList,MetaFactsCode),
		    clause_struct(DescrIdCode,DescrVarTerm,MetaFactsCode,
				  ModeCode,HeadListCode,BodyCode,Code),
                    append(HeadOidCode,HeadLitFrontListCode,BodyFrontList)
		;
		    true
		)
	    ;
		Status = Head_Status
	    )
	;
	    Status = Descr_Status
        ),
	!,
        clear_context(CONTEXT_COMPILER_WITH_VAR_MODULE),
	clear_context(CONTEXT_COMPILER_CLAUSE_PRIMITIVE).

/****************************************************************************
	    compile_callmetafacts(+MetaFacts,-Code,-Status)
****************************************************************************/
compile_callmetafacts(MetaFacts,Code,Status) :-
	compile_body(MetaFacts,MetaCode,Status),
	generate_prolog_liblit(call_metafacts,1,[MetaCode],flrdescriptor_support,Code).

/****************************************************************************
    Error handling: catch{Goal,Err,Handler}
****************************************************************************/
compile_catch(Goal,Err,Handler,Code,Status) :-
	compile_body(Goal,GoalCode,GoalStatus),
        !,
	( no_errors_found(GoalStatus) -> 
	    compile_body_pathexp_top(Err,FL_THISMODULE,ErrCode,_OidCode,_ObjSpec,[],ErrStatus),
	    ( no_errors_found(ErrStatus) -> 
		compile_body(Handler,HandlerCode,Status),
                !,
		( no_errors_found(Status) -> 
		    catch_struct(GoalCode,ErrCode,HandlerCode,Code)
		; true
		)
	    ; Status = ErrStatus
	    )
	; Status = GoalStatus
	),
	!.

/****************************************************************************
     throw{Err}
****************************************************************************/
compile_throw(Err,Code,Status) :-
	compile_body_pathexp_top(Err,FL_THISMODULE,ErrCode,_OidCode,_ObjSpec,[],Status),
	!,
	( no_errors_found(Status) -> throw_struct(ErrCode,Code)
	; true
	).


/****************************************************************************
     p2h{Prolog,Hilog}
****************************************************************************/
compile_p2h(Prolog,Hilog,Code,Status) :-
	compile_body_pathexp_top(Prolog,FL_THISMODULE,PCode,_POidCode,_PObjSpec,[],PStatus),
	( no_errors_found(PStatus) -> 
	    compile_body_pathexp_top(Hilog,FL_THISMODULE,HCode,_HOidCode,_HObjSpec,[],Status),
	    ( no_errors_found(Status) -> p2h_struct(PCode,HCode,Code)
	    ; true
	    )
	; Status = PStatus
	),
	!.


/****************************************************************************
  compile_exec_directive(+DirectList,+WS,-Code,-Status)
  compile_execdirect_list(+DirectList,+WS,-DirectCodeList,-Status)
****************************************************************************/
compile_exec_directive(DirectList,WS,Code,Status) :-
	compile_execdirect_list(DirectList,WS,DirectCodeList,Status),
	conjunct_code(DirectCodeList,Code).


compile_execdirect_list([],_,[],NO_ERRORS) :- !.

compile_execdirect_list([D|L],WS,[DCode|LCode],Status) :-
	compile_execdirect(D,WS,DCode,S1),
	( no_errors_found(S1) -> 
	    compile_execdirect_list(L,WS,LCode,Status)
	; Status = S1
	).


/****************************************************************************
  compile_execdirect(+Direct,+WS,-Code)
****************************************************************************/
compile_execdirect(DirectTerm,_WS,Code,Status) :-
        %%to compile the export directive
	is_flexport_list(DirectTerm,Term),
        !,
	compile_export(Term,Code,Status).


is_exec_rule_structure_db_direct(ERGO_STRUCTURE_DB_DIRECT(Module,Flag),Module,Flag).
compile_execdirect(DirectTerm,_WS,Code,Status) :-
        is_exec_rule_structure_db_direct(DirectTerm,Module,Flag),
        !,
        compile_rule_struct_exec_direct(Module,Flag,Code,Status).

compile_execdirect(DirectTerm,WS,Code,Status) :-
	(WS == FL_THISMODULE -> thismodule_struct(Mod)
	; compile_atomvar(WS,Mod)
	),
	( is_flopdef(DirectTerm,Precedence,Associativity,Op) ->
	    florasyslib_struct(FLLIBSHDIRECT,5,[FL_OP,Mod,Precedence,Associativity,Op],Code),
	    Status = NO_ERRORS

	; is_flsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_body_list_obj won't break here: parser checks everything
	    compile_body_list_obj(L,T,I,WS,OptionListCode,_OidCode,_Code,[],Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flsetsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_body_list_obj won't break here: parser checks everything
	    compile_body_list_obj(L,T,I,WS,OptionListCode,_OidCode,_Code,[],Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSETSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flsetruntime(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_body_list_obj won't break here: parser checks everything
	    compile_body_list_obj(L,T,I,WS,OptionListCode,_OidCode,_Code,[],Status),
	    florasyslib_struct(FLLIBSETRUNTIME,1,[OptionListCode],Code)

	; is_flindex(DirectTerm,A,P) ->
	    %% transactional numbers are used only in :- index %arity-argument
            ( transactionalnumobj_struct(A,ACode)
	    ; is_fltransactionalvariable(A,AN,AI),
		transactionalvar_struct(AN,AI,ACode)
	    ; numobj_struct(A,ACode)
	    ; is_flvariable(A,AN,AI), varobj_struct(AN,AI,ACode)
	    ),
	    (numobj_struct(P,PCode)
	    ; is_flvariable(P,PN,PI), varobj_struct(PN,PI,PCode)
	    ),
            florasyslib_struct(FLLIBSHDIRECT,4,[FL_INDEX,Mod,ACode,PCode],Code),
	    Status = NO_ERRORS

	; is_flsensordirect(DirectTerm,SensCall,DelayCond) ->
	    compile_defsensor_direct(SensCall,DelayCond,Direct,Status),
	    directive_struct(Direct,Code)

	%% This runtime usesensor directive enables to use sensors in the shell
	%% This directive can be called from within a file or interactively.
	; is_flusesensordirect(DirectTerm,PairList,Idx) ->
	    verify_symbol_context_pairlist(PairList,Idx, USE_SENSOR_SYMBOL,
					   NONTRANSACTIONAL_SYMBOL,Status),
	    maplist(strip_pairlist_index(_,_),PairList,PairListSansIdx),
	    verbatim_struct(PairListSansIdx,PairListCode),
	    thismodule_struct(ThisMod),
	    florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code),
	    report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX)

	%% Run-time useudf directive. It defines the use of a function
	%% **only** in the shell and only for the module main.
	; is_fluseudf_direct(DirectTerm,PairList,Idx) ->
            compile_useudf_directive(PairList,Idx,Status2),
	    (compiling_flrshell_command -> Status = Status2
	    ;
		compiling_error(Idx,ERROR_USEFUNCTION_IN_SHELL_ONLY,Err),
		Status = [Err|Status2]
	    ),
	    Code = NULL

	/*
	%% Executable :- prolog and :- table directives are not allowed!!!
	%% They are used inside files/documents for optimization only
	%% We consider them non-logical and users are not allowed to call
	%% them directly (sensors are also prolog, but are different in
	%% this respect)
	;  is_flprolog_directive(DirectTerm,PairList,Idx) ->
	    ....
	;  is_fltabledirect(DirectTerm,PredSpecList,_Idx) ->
	    ....
	*/

	;   %% Ensure that prefix definition is recorded in the current module
	    %% to be used in other modules. For instance, if somebody make a
	    %% reference to prefix#local@module
	    %% Executable prefix directives are always global
	    %% and recorded in the registry.
	    is_flprefixdef(DirectTerm,PrefixName,_Locality,PrefixExpansion) ->
	    florasyslib_struct(FLLIBPREFIXDEF,3,[Mod,PrefixName,PrefixExpansion],Code),
	    Status = NO_ERRORS

        ;  is_new_global_oid_scope(DirectTerm) ->
            new_dontcare_prvariable(NO_INDEX,AnonVar),
            new_dontcare_prvariable(NO_INDEX,AnonVar2),
            generate_prolog_liblit(flora_increment_counter,4,
                                   [NEWOID_GLOBAL,1,AnonVar,AnonVar2],
                                   flrporting, Code),
            Status = NO_ERRORS
	),
	!.


/*******************************************************************************
compile_delayed_literal(+Op,+Args,-SpecCode,-OidCode,-BodyFrontList,-Status)
compile_delayed_literal(+Op,+Args,+Mod,-SpecCode,-OidCode,-BodyFrontList,-Status)
  Args are expected to be FLLIST
*******************************************************************************/
%% compile_delayed_literal/6
compile_delayed_literal(Op,Args,SpecCode,OidCode,BodyFrontList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	%% Normally, CurrFileName is an atom. But can be flvar, if reification
	(has_context(CONTEXT_COMPILER_DYNRULE(_+UpdOp)),is_fldeleteruleop(UpdOp) ->
	    new_flvariable(Index,CurrFileParserObj,_)
	; atom(CurrFileName) ->
	    is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX)
	; %% assume it is flvar
	    CurrFileParserObj = CurrFileName
	),
	(has_context(CONTEXT_COMPILER_DYNRULE(_+UpdOp)),is_fldeleteruleop(UpdOp) ->
	    new_flvariable(Index,ParsedLine,_)
	; Line == NULL ->
	    is_flnumber(ParsedLine,0,NO_INDEX)
	; %% assume it is flvar
	    ParsedLine = Line
	),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[Op,CurrFileParserObj,ParsedLine,Args],
			 SpecCode,OidCode,_ACode,BodyFrontList,Status).
%% compile_delayed_literal/7
compile_delayed_literal(Op,Args,Mod,SpecCode,OidCode,BodyFrontList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	%% Normally, CurrFileName is an atom. But can be flvar, if reification
	(atom(CurrFileName)
	-> is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX)
	; %% assume it is flvar
	    CurrFileParserObj = CurrFileName
	),
	(Line == NULL
	-> is_flnumber(ParsedLine,0,NO_INDEX)
	; %% assume it is flvar
	    ParsedLine = Line
	),
	is_flplib(OpModTerm,Op,Mod),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[OpModTerm,CurrFileParserObj,ParsedLine,Args],
			 SpecCode,OidCode,_ACode,BodyFrontList,Status).


/*******************************************************************************
%% Used for reading FLORA-2 terms (including reified formulas) from within
%% FLORA-2 programs
	flora_compile_pathexp(+ParserTerm,-Code,-Status)
*******************************************************************************/
flora_compile_pathexp(ParserTerm,Code,Status) :-
	compile_body_pathexp_top(ParserTerm,FL_THISMODULE,ObjectCode,OidCode,SpecCode,[],Status1),
	!,
	%%( no_errors_found(Status1), (OidCode \= NULL ; SpecCode \= NULL) -> 
	( no_errors_found(Status1), SpecCode \= NULL -> 
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,READING_NONREIFIED_MOLECULE, S),
	    Status = [S|Status1]
	;
	    %%Code = ObjectCode, Status = Status1
	    conjunct_struct(OidCode,ObjectCode,Code1),
            Status = Status1,
            (is_prreify(Code1,_) -> Code = Code1
            ; reify_struct(Code1,Code)
            )
	).


%% list of data type literals
compile_datatype_list([],[],NO_ERRORS) :- !.
compile_datatype_list([H|Tail],[HCode|TailCode],Status) :-
	(integer(H)
	-> HCode = H, S1 = NO_ERRORS %% list of characters inside DATATYPE
	;
	    compile_body_pathexp_top(H,FL_THISMODULE,HCode,_,_,[],S1)
	),
        !,
	( no_errors_found(S1) -> 
	   compile_datatype_list(Tail,TailCode,Status)
	;
	    Status=S1
	),
	!.

%% Check if Goal is negatable by NEG (explicit negation)
%% Only F-logic atoms (except the derived ones) and HiLog
%% predicates are negatable.
is_head_neg_negatable_literal(PRATOMLIT(_,_)) :- !.
is_head_neg_negatable_literal(PRTERMLIT(_,_,_)) :- !.
is_head_neg_negatable_literal(PREXISTS(_,_)) :- !.
is_head_neg_negatable_literal(PRISA(_,_,_)) :- !.
is_head_neg_negatable_literal(PRSUB(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PROBJEQL(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIGDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIGDEF(_,_,_)) :- !.

is_head_neg_negatable_literal(X) :-
	is_prologterm(X,Struct,Arity,_Args),
	is_modularized_pratom(Struct,Atom,_),
	Arity1 is Arity-1,
	flora_negatable_prlgdef(Atom,Arity1,_),
	!.

is_body_neg_negatable_literal(X) :- is_head_neg_negatable_literal(X), !.
is_body_neg_negatable_literal(X) :-
	workspace_struct(L,WS,X),
        \+ (floralib_struct(_,WS), flora_nonnegatable_system_module(WS)),
	is_head_neg_negatable_literal(L),
	!.
is_body_neg_negatable_literal(X) :-
	prologterm_atom_arity(X,Atm,Arity1),
	%% modularized prolog predicates have an extra FL_CONTEXT argument
	Arity is Arity1-1,
	flora_negatable_prlgdef(Atm,Arity,_),
	!.
is_body_neg_negatable_literal(X) :-
	(is_florasyslib_struct(X, _I,FLLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLLIBMODOBJ,_N,Args)
	; is_florasyslib_struct(X, _I,FLNEGLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLNEGLIBMODOBJ,_N,Args)
	),
	!,
	Args = [P|_],
	is_body_neg_negatable_literal(P).
is_body_neg_negatable_literal(X) :-
	X = PRVARIABLE(_,_),
	%% Allow variables to be negated so that
	%% ?X = ${a[b->c]}, neg ?X would be possible.
	%%has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
	!.

%% Literals to which \neg does not apply and they are passed
%% outside of \neg unmodified
is_body_neg_passthrough_literal(FL_TRUE) :- !.
%% this one is used to make neg(UDFHILOGPREDICATENAME(....),Goal) into
%% UDFHILOGPREDICATENAME(....), neg(Goal)
is_body_neg_passthrough_literal(X) :-
	is_prologterm(X,Struct,4,_Args),
	is_pratom(Struct,UDFHILOGPREDICATENAME,_),
	!.
%% FL_SKOLEMQUERY == \skolemquery, which is builtin_identifier, not prologterm
%% this is probably never used
is_body_neg_passthrough_literal(X) :-
	is_prologterm(X,FL_SKOLEMQUERY,1,_Args,_),
	!.

is_body_neg_passthrough_literal(PRAND(PutAttr,_)) :-
        is_prologliblit(PutAttr,Y),
	is_prologterm(Y,Z,_,_Args,_),
        is_pratom(Z,flora_put_attr,_),
	!.
/*
%% enabling this breaks this test:
%% ?X ~ \neg a[b->c,e->d]@foo, ?M=foo, ?X@?M ~ \neg a[b->c,e->d]@?M.
%% Should succeed, but fails if FLSYSLIB is made passthrough 
is_body_neg_passthrough_literal(Goal) :-
        is_florasyslib_struct(Goal,_,_,_,_),
        !.
*/

/*
is_prtermlit(PRTERMLIT(Obj,N,Args),Obj,N,Args).
is_body_neg_passthrough_literal(X) :-
	is_prtermlit(X,Struct,1,_),
	is_prbuiltin_identifier(Struct,FL_SKOLEMQUERY),
	!.
*/

/*
is_unimplemented_neg_negatable_literal(X) :-
	is_florasyslib_struct(X, _I,_F,_N,_Args).
*/


%% This check is done at the end of every rule to see if some of the 
%% delayed conditions can be evaluated and simplified.
%% delay_literals_checking_code(+Head,+Body,+H2BCodeFront,+H2BCodeBack,+DescrVarsTerm,-Code)
%% Head & Body are FL code. DescrVarsTerm is PR code
%% CONSIDER SWITCHING TO PR-CODE, as in delay_checking_code_for_rulelog_naf/2
delay_literals_checking_code_list([],_Body,_H2BCodeFront,_H2BCodeBack,_DescrVarsTerm,[]) :- !.
delay_literals_checking_code_list([H|Rest],Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,[HC|RestC]) :-
	delay_literals_checking_code(H,Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,HC),
	delay_literals_checking_code_list(Rest,Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,RestC).
delay_literals_checking_code(Head,_Body,_H2BCodeFront,_H2BCodeBack,_DescrVarsTerm,NULL) :-
	%% should not add delay-checker to sensor rules
	is_defined_as_sensor(Head),
	!.
delay_literals_checking_code(Head,Body,H2BCodeFront,H2BCodeBack,DescrVarsTerm,Code) :-
	collect_flvars(Head,HeadVars1),
	collect_flvars(Body,BodyVars1),
	%% DescrVarsTerm is a pr-object, so use collect_prvars
	collect_prvars(DescrVarsTerm,DescrPrvars),
	prvar_to_flvar_struct_list(DescrPrvars,DescrFlvars),
	%% BodyVars2 now contains descriptor vars
	append(BodyVars1,DescrFlvars,BodyVars2),
	remove_dupflvars(HeadVars1,HeadVars),
	remove_dupflvars(BodyVars2,BodyVars),
	(has_context(CONTEXT_COMPILER_RULE_REIFICATION),
	    has_context(CONTEXT_COMPILER_BODY_PATHEXP)
	-> %% use new flvariables
	    is_flvariable(ParserHeadVars,FL_ANON_VAR,NO_INDEX),
	    is_flvariable(ParserBodyVars,FL_ANON_VAR,NO_INDEX)
	;
	    is_fllist(ParserHeadVars,HeadVars,[],NO_INDEX),
	    is_fllist(ParserBodyVars,BodyVars,[],NO_INDEX)
	),
	%% To match reified rules, we make DelayCheckCode into a new var
	(has_context(CONTEXT_COMPILER_RULE_REIFICATION) -> new_dontcare_prvariable(NO_INDEX,Code)
	%% Optimization: if HeadVars contains BodyVars+DescrVars,
	%% no delay checking is needed for that rule.
	%% Instead, we put NULL in place of the delay checker.
	%% This NULL is ignored in generating the code.
	; vars_contains(HeadVars,BodyVars) -> Code = NULL
	; compile_prlgterm(FLORA_DELAY_CHECKER,2,
			   [ParserBodyVars,ParserHeadVars],
			   Code,_OidCode,_ACode,[],_Status)
	),
	!.

%% delay_checking_code_for_rulelog_naf(+PRBody,-Code)
%% This is like delay_literals_checking_code/6 but is used only for the
%% inside of FLORA_NAF_PREDICATE. It takes PR-code as argument, not FL-code
delay_checking_code_for_rulelog_naf(PRBody,Code) :-
	collect_prvars(PRBody,PRBodyVars),
	remove_prdontcare_and_FL_CONTEXT_vars(PRBodyVars,PurePRBodyVars),
	prvar_to_flvar_struct_list(PurePRBodyVars,FLBodyVars),
	remove_dupflvars(FLBodyVars,BodyVars),
	is_fllist(ParserBodyVars,BodyVars,[],NO_INDEX),
	is_fllist(ParserHeadVars,[],[],NO_INDEX),
	compile_prlgterm(FLORA_DELAY_CHECKER,2,
			   [ParserBodyVars,ParserHeadVars],
			   Code,_OidCode,_ACode,[],_Status),
	!.


%% sensors can't be in the heads of dynamic rules.
%% so we need to check only the permaoptions
is_defined_as_sensor(Head) :-
	prologterm_atom_arity(Head,Funct,Arity),
	is_pratom(Funct,Atom,_),
	!,
	has_permaoption(usesensor(Atom,Arity)).

%% Code that generates a prolog liblit with a given name.
%% **** This is PR code that goes to the coder.
%% Arguments must already be compiled (ie pr-code)
%% For instance, to generate "dummy" true code, use:
%%      generate_prolog_liblit(FL_TRUE,0,[],Code)
%% +PrologAtom, +Arity, +ArgsList, -Code
%% generate_prolog_liblit/4
generate_prolog_liblit(Atom,Arity,Args,Code) :-
	atomobj_struct(Atom,AtomCode),
	!,
        prologterm_struct(AtomCode,Arity,Args,Code1),
        prologliblit_struct(Code1,Code).
generate_prolog_liblit(AtomCode,Arity,Args,Code) :-
	is_modularized_pratom(AtomCode,_,_),
	!,
        prologterm_struct(AtomCode,Arity,Args,Code1),
        prologliblit_struct(Code1,Code).
%% generate_prolog_liblit/5
generate_prolog_liblit(Atom,Arity,Args,PrlgModule,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,PrlgModule,Code1),
        prologliblit_struct(Code1,Code).

%% generate_prolog_term/4 - without module
generate_prolog_term(Atom,Arity,Args,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,Code).
/*
%% generate_prolog_term/5 - with module - unused
generate_prolog_term(Atom,Arity,Args,PrlgModule,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,PrlgModule,Code1).
*/


compile_null_value(Object,NO_ERRORS) :-
        new_prvariable(NULL,NullVarObj),
        %% Do not use generate_prolog_liblit here -- use generate_prolog_term.
        %% Otherwise, a mismath between NULL() and usermod:NULL() may occur
        %%generate_prolog_liblit('NULL',1,[NullVarObj],Object).
        generate_prolog_term('NULL',1,[NullVarObj],Object).


get_current_compile_file(CurrFileName) :-
	( flora_current_compile_filename(CurrFileName)->true
	; CurrFileName = FL_SHELL_FICTITIOUS_FILENAME
	).

compiling_flrshell_command :-
        \+ has_context(CONTEXT_READ_PARSE_COMPILE),
        \+ flora_current_compile_filename(_).

get_current_compile_file_for_descriptor(CurrFileName,_Mode) :-
	has_context(CONTEXT_COMPILER_RULE_REIFICATION),
	filename_in_ruleid_struct(CurrFileName).
get_current_compile_file_for_descriptor(CurrFileName,Mode) :-
	memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_PLAIN_QUERY]),
	!,
	new_prvariable(NO_INDEX,CurrFileName).
get_current_compile_file_for_descriptor(FileNameObj,Mode) :-
	memberchk(Mode,[FL_DESCRMODE_DYNRULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_LATENT_DYNQUERY]),
        %% We want dynrule(Filename) == FL_DYNRULE_FICTITIOUS_FILENAME(Filename)
        %% in the ADD mode
	(has_context(CONTEXT_COMPILER_DELETE_RULE) ->
            %% If deleting a rule, ignore the file name so
            %% we could do it across files
            new_prvariable(NO_INDEX,FN)
        ; flora_current_compile_filename(FN) -> true
	; new_prvariable(NO_INDEX,FN)
	),
        %% this is FL_DYNRULE_FICTITIOUS_FILENAME(Filename)
	generate_prolog_term(FL_DYNRULE_FICTITIOUS_FILENAME,1,[FN],FileNameObj),
	!.

get_current_compile_file_for_descriptor(CurrFileName,_Mode) :-
	get_current_compile_file(CurrFileName).

get_current_stmt_number_for_descriptor(StmtIndex,StmtNum) :-
	extract_real_token_number(StmtIndex,RealIndex),
	(has_context(CONTEXT_COMPILER_GOAL_REIFICATION) -> new_prvariable(NO_INDEX,StmtNum)
	; has_context(CONTEXT_COMPILER_RULE_REIFICATION) -> new_prvariable(NO_INDEX,StmtNum)
	;
	    \+ integer(RealIndex) ->
	    (RealIndex == [] -> StmtIndexOut = '[ ]'
	    ; StmtIndexOut = RealIndex
	    ),
	    flora_abort(['Compiler bug!!! Non-integer token number: ', StmtIndexOut],FLORA_ABORT_NOTRACE)
	; RealIndex > 0 -> flora_token_rulenum(RealIndex,StmtNum)
	; StmtNum = -1
	).

/*
%% This often looses warnings and errors, so we replaced with append and flatten
%%
%% This can simplify code when there is no dependency in the intervening code
%% on the outcome of the status codes in the Arg 1 list
merge_status([],[]) :- !.
merge_status([S|Rest],T) :-
	(S == NO_ERRORS -> merge_status(Rest,T)
	; T = S
	).
*/


/***************************************************************************
    rename_prvariables(+VarNameList,+VarType,+OldFormula,-NewFormula,-NewVarList)
       Replaces each occurrence of each variable in VarNameList with
       a newly created variable (the same for different occurrences of the
       same var name) of type VarType.
       Returns a new formula and the variable objects used
       in the substitutions.
       VarType: NEWVAR, NEWDONTCAREVAR, NEWFLCONTEXTVAR, NEWQUANTIFIEDVAR 

    rename_one_prvariable(+VarName,+NewVarObj,+Body,-NewBody),
       Replaces each occurrence of a var object having VarName
       as the variable name with NewVarObj. Returns the newly created formula.
***************************************************************************/
rename_prvariables([],_VarType,Body,Body,[]) :- !.
rename_prvariables([VarName|VarNameList],VarType,Body,NewBody,[NewVarObj|NewVarList]) :-
	flora_new_varobj(VarType,NO_INDEX,NewVarObj),
	rename_one_prvariable(VarName,NewVarObj,Body,NewBody1),
	rename_prvariables(VarNameList,VarType,NewBody1,NewBody,NewVarList).

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	(
	  atomic(Body) -> NewBody = Body
	; var(Body) -> NewBody  = Body
	; is_list(Body)
	-> rename_one_prvariable_in_list(VarName,NewVarObj,Body,NewBody)
	; is_prvariable(Body,VarName,_Idx) -> NewBody = NewVarObj
	; is_pratomnumberstringbuiltin(Body,_) ->  NewBody = Body
	; is_prdatatype(Body,_,_,_) ->  NewBody = Body
	; is_prdatatypelist(Body,_) ->  NewBody = Body
	),
	!.

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	Body =.. [Wrapper|Args],
	rename_one_prvariable_in_list(VarName,NewVarObj,Args,NewArgs),
	NewBody =.. [Wrapper|NewArgs].

rename_one_prvariable_in_list(_,_,[],[]) :- !.
rename_one_prvariable_in_list(VarName,NewVarObj,[T|Terms],[NewT|NewTerms]) :-
	rename_one_prvariable(VarName,NewVarObj,T,NewT),
	rename_one_prvariable_in_list(VarName,NewVarObj,Terms,NewTerms).

/***************************************************************************
    replace_flvars_with_vars(ParserTerm,-NewRarserTerm)
     
    Replaces each occurrence of an flvar structure with
    the name of the variable in that flvar structure prefixed with an '_'

    Not used at the moment.

    ParserTerm can be a parser term or a list of such terms.
***************************************************************************/
replace_flvars_with_vars([],[]) :- !.
replace_flvars_with_vars(ParserTerm,ParserTerm) :-
	(var(ParserTerm) ; atomic(ParserTerm)),
	!.
replace_flvars_with_vars([H|T],[HR|TR]) :-
	!,
	replace_flvars_with_vars(H,HR),
	replace_flvars_with_vars(T,TR).

%% Reminder: unused
replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	is_flvariable(ParserTerm,Name,_Index),
	!,
	(Name = FL_ANON_VAR -> ParserTermR = FL_ANON_VAR
	%% regular variables are encoded to be distinct from transactional
	%% vars using the suffix 1 instead of 2
	; fmt_write_string(ParserTermR,'_%s1',arg(Name))
	).

replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	is_fltransactionalvariable(ParserTerm,Name,_Index),
	!,
	(Name = FL_ANON_VAR -> ParserTermR = FL_ANON_VAR
	%% transactional variables are encoded to be distinct from regular
	%% vars using the suffix 2 instead of 1
        ; fmt_write_string(ParserTermR,'_%s2',arg(Name))
	).

replace_flvars_with_vars(ParserTerm,ParserTerm) :-
	is_flatomnumberstringbuiltin(ParserTerm),
	!.
replace_flvars_with_vars(ParserTerm,ParserTerm) :-
	is_fltrans_atomnumberstring(ParserTerm),
	!.
replace_flvars_with_vars(ParserTerm,ParserTerm) :-
	is_fltoken(ParserTerm),
	!.

replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	is_fldatatype(ParserTerm,Sort,Lit,Index),
	!,
        (is_flvariable(Lit,Name,_Indx2) ->
	    (Name = FL_ANON_VAR -> ParserTermR = FL_ANON_VAR
	    %% datatype variables are encoded to be distinct from other
	    %% vars using the suffix 3 instead of 1 or 2.
	    ; fmt_write_string(ParserTermR,'_%s3',arg(Name))
	    )
	; is_list(Lit) ->
	    replace_flvars_with_vars(Lit,LitR),
	    is_fldatatype(ParserTermR,Sort,LitR,Index)
	; is_fldatatypelist(Lit,ListLit) ->
	    replace_flvars_with_vars(ListLit,ListLitR),
	    is_fldatatypelist(LitR,ListLitR),
	    is_fldatatype(ParserTermR,Sort,LitR,Index)
	;  ParserTermR = ParserTerm
	),
	!.

%% This predicate is unused
replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	is_fllogicquantifier(ParserTerm,Quant,VarNames,VarsCode,FormulaCode,Idx),
	!,
	replace_flvars_with_vars([VarNames,FormulaCode],
				 [VarNamesR,FormulaCodeR]),
	is_fllogicquantifier(ParserTermR,Quant,VarNamesR,VarsCode,FormulaCodeR,Idx).

%% Note: Vars, ProtVars are always passed unbound.
replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	is_flaggregate(ParserTerm,Op,AggrFlVar,GrpFlVars,Sort,FormulaCode),
	!,
	is_flvariable(AggrFlVar,_,_),
	replace_flvars_with_vars([AggrFlVar,GrpFlVars,Sort,FormulaCode],
				 [AggrFlVarR,GrpFlVars,SortR,FormulaCodeR]),
	is_flaggregate(ParserTermR,Op,AggrFlVarR,GrpFlVars,SortR,FormulaCodeR).

replace_flvars_with_vars(ParserTerm,ParserTermR) :-
	ParserTerm =.. [F|Args],
	replace_flvars_with_vars(Args,ArgsR),
	ParserTermR =.. [F|ArgsR].


/*****************************************************************************
   Some token index management predicates
*****************************************************************************/
%% Get the line number and file name of code represented by a PRTERM
code_line_and_file_by_prterm(_CompiledTerm,Line,File) :-
	%% in reified cases, do not put the line and file, since reified terms
	%% are not used where they are compiled, so the line number
	%% (and likely) file name are going to be wrong.
	%% Also, explicit line number & file name will prevent unification.
	(has_context(CONTEXT_COMPILER_GOAL_REIFICATION);has_context(CONTEXT_COMPILER_CLAUSE_PRIMITIVE)),
	!,
	%%new_prvariable(NO_INDEX,Line),
	%%new_prvariable(NO_INDEX,File).
	new_quantified_prvariable(NO_INDEX,Line),
	new_quantified_prvariable(NO_INDEX,File).

code_line_and_file_by_prterm(CompiledTerm,Line,File) :-
	(approx_prindex(CompiledTerm,Index), Index \== NO_INDEX
	-> flora_token_index_to_line(Index,Line)
	; Line = NULL
	),
	!,
	get_current_compile_file(File).

%% Get the line number and file name of code represented by line/position index
code_line_and_file_by_index(Index,LineVar,FileVar) :-
	has_context(CONTEXT_COMPILER_GOAL_REIFICATION),
        %% This has a problem, if textit goals have reified arguments,
        %% as they'll get line numbers instead of vars.
	\+has_context(CONTEXT_COMPILER_TEXTIT_ARGS2_4),
	!,
	%% if reification, file/line should be variables
	new_flvariable(Index,LineVar,_),
	new_flvariable(Index,FileVar,_).
code_line_and_file_by_index(NO_INDEX,NULL,NULL) :- !.
code_line_and_file_by_index(Index,Line,File) :-
	flora_token_index_to_line(Index,Line),
	get_current_compile_file(File).

get_index_line(NO_INDEX,NULL) :- !.
get_index_line(Index,Line) :- flora_token_index_to_line(Index,Line).




/****************************************************************************
 add_symbol(+Name,+N,+WS,+Index,+LineNumber,+FileN,+SymContext,+Transactional)
 has_symbol(?Name,?N,?WS,?Index,?LineNumber,?File,?SymContext,?Transactional)
 flora_clear_compilation_symbols
 add_nowarn_symbol(+Name,+N,+SymContext)
 has_nowarn_symbol(+Name,+N,+SymContext)

Predicates for checking usage of symbols with the same name and arity
The goal is to generate warnings/errors if the same symbol is used in different
contexts or a UDF is used before it is declared, etc. 
****************************************************************************/
add_symbol(_Name,_N,_WS,Index,_LineNumber,_File,_SymContext,_Transactional) :-
	%% do not add symbols that are not in the user program
	(var(Index) ; Index == NO_INDEX),
	!.
add_symbol(Name,N,_WS,_Index,_LineNumber,_File,_SymContext,_Transactional) :-
	%% do not add builtins
	flora_nodefp(Name,N),
	!.
add_symbol(Name,N,WS,_Index,_LineNumber,_File,SymContext,Transactional) :-
	%% in flrnosymbolcontext.P
	ignore_symbol_context(Name,N,WS,SymContext,Transactional),
	!.
add_symbol(Name,N,_WS,_Index,_LineNumber,_File,_SymContext,_Transactional) :-
	%% do not add delayed builtins
	%%flora_get_flatomvar_name(WS,WSName),
	%%flora_delayed_literal(Name,N,WSName),
	flora_delayed_builtin_literal(Name,N),
	!.
add_symbol(_Name,_N,_WS,_Index,_LineNumber,_File,_SymContext,_Transactional) :-
	%% do not add symbols used in shell commands: errors/warnings get
	%% too confusing for the user
	compiling_flrshell_command,
	!.
%% if checking symbols for constants is off, then do not add constant symbols
add_symbol(_Name,0,_WS,_Index,_LineNumber,_File,_SymContext,_Transactional) :-
	symbol_warnings_flag(FLORA_CONSTOFF),
	!.
add_symbol(Name,N,FL_THISMODULE,Index,LineNumber,File,SymContext,Transactional) :-
	!,
	assert(symbol(Name,N,FL_THISMODULE,Index,LineNumber,File,SymContext,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(symbol(Name,N,WSName,Index,LineNumber,File,SymContext,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(symbol(Name,N,WSName,Index,LineNumber,File,SymContext,Transactional)).

add_nowarn_symbol(Name,N,FL_THISMODULE,SymContext,Transactional) :-
	!,
	assert(nowarn_symbol(Name,N,FL_THISMODULE,SymContext,Transactional)).
add_nowarn_symbol(Name,N,WS,SymContext,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(nowarn_symbol(Name,N,WS,SymContext,Transactional)).
add_nowarn_symbol(Name,N,WS,SymContext,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(nowarn_symbol(Name,N,WSName,SymContext,Transactional)).
add_nowarn_symbol(Name,N,WS,SymContext,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(nowarn_symbol(Name,N,WSName,SymContext,Transactional)).

has_symbol(Name,Arity,_,NO_INDEX,-1,_File,BUILTIN_SYMBOL,_) :-
	flora_nodefp(Name,Arity),
	!.
has_symbol(Name,Arity,_WS,NO_INDEX,-1,_File,BUILTIN_SYMBOL,_) :-
	flora_delayed_builtin_literal(Name,Arity),
	!.
has_symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional) :-
	%% don't match on _File: the symbol may come from an included file
	%%get_current_compile_file(_File),
	symbol(Name,N,WS,Index,LineNumber,File,SymContext,Transactional).


has_nowarn_symbol(Name,N,WS,SymContext,Transactional) :-
	nowarn_symbol(Name,N,WS,SymContext,Transactional),
	!.

has_nowarn_any_symbol(Name,N,WS,_SymContext,Transactional) :-
	nowarn_symbol(Name,N,WS,ANY_SYMBOL_CONTEXT,Transactional),
	!.

has_nowarn_any_symbol(Name,N,WS,SymContext,Transactional) :-
	has_nowarn_symbol(Name,N,WS,SymContext,Transactional).

flora_clear_compilation_symbols :-
        %% following \+ is a workaround for an XSB garbage collection bug:
	(\+ symbol(_,_,_,_,_,_,_,_) -> true ; retractall(symbol(_,_,_,_,_,_,_,_))),
	(\+ nowarn_symbol(_,_,_,_,_) -> true ; retractall(nowarn_symbol(_,_,_,_,_))),
	clear_turnoff_symbol_warnings_flag.

set_turnoff_symbol_warnings_flag(Flag):- 
	assert(symbol_warnings_flag(Flag)).

clear_turnoff_symbol_warnings_flag:- 
	(\+ symbol_warnings_flag(_) -> true ; retractall(symbol_warnings_flag(_))).


%% create code for metafact insertion for ADDED UDF definitions
make_code_for_inserting_metafacts(Metafacts-_,Code) :-
        list_struct(Metafacts,[],Metalist),
	thismodule_struct(ThisMod),
        get_current_compile_file(FN),
        generate_prolog_term(FL_DYNRULE_FICTITIOUS_FILENAME,1,[FN],CurrFileName),
        generate_prolog_term(flora_assert_metafact_list,3,
                             [Metalist,CurrFileName,ThisMod],
                             AssertCode),
        query_struct(AssertCode,Code).


/****************************************************************************
    udf_expansion_test(+Funct,+Arity)

  Test if a UDF should be expanded. This is used whenever a standard
  arithmetic expression used in "is" is defined as a UDF. For instance,
  \udf ?x+?y:=?z \if isnumber{?x}, isnumber{?y}, ?z \is ?x+?y, isnumber{?z}.
  Here we don't want + to be expanded as a UDF since we are currently defining
  that same UDF. If we do so, we will lose + as a builtin operator under "is"
****************************************************************************/
udf_expansion_test(Funct,N) :-
	get_flatom_name(Funct,FAtom),
	flrprolog:is_op_builtin(FAtom,N),
	!,
	\+has_context(CONTEXT_COMPILER_ARITHMETICS).
udf_expansion_test(_,_).

/****************************************************************************
no_errors_found(+Status)
****************************************************************************/
no_errors_found([]) :- !.
no_errors_found([warning(_,_)|Rest]) :-
	(var(Rest) ->
	    flora_abort(['Compiler bug!!! Some predicate returns variable as status!'],FLORA_ABORT_NOTRACE)
	;
	    \+ memberchk(error(_,_), Rest)
	).


%% check_unequatable_datatypes(+O1,+O2,-Status)
check_unequatable_datatypes(O1,O2,Status) :-
        check_unequatable_datatype(O1,Status1),
        (Status1 == NO_ERRORS ->
            check_unequatable_datatype(O2,Status)
        ; Status = Status1
        ).
check_unequatable_datatype(O,Status) :-
        (is_pratom(O,Atm,Idx),
            memberchk(Atm,[FL_TRUECONST,FL_FALSECONST,FL_UNDEFCONST])
        ; is_prnumber(O,_,Idx)
        ; is_prdatatype(O,PrSort,_,Idx),
            is_prbuiltin_identifier(PrSort,SortName,_),
            memberchk(SortName,[FL_IRI,FL_URI,FL_DATETIME,FL_DATE,
                                FL_DURATION, FL_TIME, FL_CURRENCY])
        ),
        !,
        compiling_error(Idx,ERR_UNEQUATABLE_DATATYPE,Err),
        Status = [Err].
check_unequatable_datatype(_,NO_ERRORS).


%% Maplist
maplist(_Pred,[],[]) :- !.
maplist(Pred,[X|Rest],[Y|MapRest]) :-
	copy_term(Pred,PredNew),
	arg(1,PredNew,X),
	arg(2,PredNew,Y),
	call(PredNew),
	!,
	maplist(Pred,Rest,MapRest).
%% if call(PredNew) fails, skip the item
maplist(Pred,[_|Rest],MapRest) :-
	maplist(Pred,Rest,MapRest).

%% This replaces atoms with scrambled or modularized atoms
%% in case there was a sensor or prolog declaration
atom_replacement(A,N,AA) :-
	has_permaoption(atomreplacement(A,N,AA)),
	!.
atom_replacement(A,_N,A).

%% this applies to pr-objects
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRBUILTIN_IDENTIFIER(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(PRATOM(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRATOM(F,I),N,PRATOM(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(Funct,_N,Funct).


%% The Index argument is not used currently
verify_symbol_context_pairlist([],_Index,_SymContext,_Trans,NO_ERRORS) :- !.
verify_symbol_context_pairlist([(P,A,Idx)|PairList],Index,SymContext,Trans,Status) :-
	%% P can be either the sensor name or (PrologSensor,PrologModule)
	(P = (PA,_) ; P=PA),
	!,
	is_flatom(PObj,PA,Idx),
	verify_symbol_context(PObj,A,SymContext,Trans,S1),
	verify_symbol_context_pairlist(PairList,Index,SymContext,Trans,S2),
	append(S2,S1,Status).
verify_symbol_context_pairlist([P/A/Idx|PairList],Index,SymContext,Trans,Status) :-
	(P = (PA,_) ; P=PA),
	!,
	is_flatom(PObj,PA,Idx),
	verify_symbol_context(PObj,A,SymContext,Trans,S1),
	verify_symbol_context_pairlist(PairList,Index,SymContext,Trans,S2),
	append(S2,S1,Status).

%% this takes predicate-arity pairs without the index
%% generates a query out of
%%    flrprolog:flora_define_modular_prolog([prolog(pred,arity,thisModule)|...])
make_runtime_modular_prolog_declarations(PairList,Code) :-
	maplist(term_to_prologterm_struct(_,_),PairList,PairListCode),
	list_struct(PairListCode,[],PairListCodeList),
	generate_prolog_liblit(flora_define_modular_prolog,1,
			       [PairListCodeList],
			       flrprolog,PreCode),
	query_struct(PreCode,Code).


%% converts prolog terms to PROLOGTERM structures
term_to_prologterm_struct(Term,PTermStruct) :-
	Term =.. [Funct|Args],
	functor(Term,_,N),
	thismodule_struct(ThisMod),
	N1 is N+1,
	append(Args,[ThisMod],Args1), %% add curent module
	prologterm_struct(Funct,N1,Args1,PTermStruct).

%% compile sensor literals in the file where defsensor is specified.
%% these literals get 2 arguments prepended
compile_sensor_literal(PrlgModName,FObj,N,ArgList,Code) :-
	special_variable_struct(FL_SPECIAL_FILE_TOKEN,FileVariableCode),
	special_variable_struct(FL_SPECIAL_LINE_TOKEN,LineVariableCode),
	NewArgList = [FileVariableCode,LineVariableCode|ArgList],
	termlit_replacement(FObj,N,NewFObj),
	SensArity2 is N+2,
	(var(PrlgModName) ->
	    prologterm_struct(NewFObj,SensArity2,NewArgList,Code)
	;
	    prologterm_struct(NewFObj,SensArity2,NewArgList,PrlgModName,Code)
	).


/*****************************************************************************
%% compile_body_setarg_list(+Setarg,+WS,-SetList,-OidCode,-Code,-BodyFrontList,-Status)
%% set expression {a1,a2,a3}
%%
%% SetList - the list [Elt1, Elt2, ...], where Elt1,Elt2, etc., are the
%%                  compiled object parts in the set expression
%% BodyFrontList -  the code resulting from stuff attached
%%                  to the elements of the set, e.g., elt[foo->bar]
%%                  OidCode, code to produce elements of the set
%%                  goes into BodyFrontList
******************************************************************************/
/*
%% OBSOLETE
compile_body_setarg_list([],_WS,[],NULL,NULL,[],NO_ERRORS) :- !.
compile_body_setarg_list([Elt|Rest],WS,SetList,OidCode,Code,BodyFrontList,Status) :-
	compile_body_pathexp_top(Elt,WS,EltObj,EltOidCode,EltFrameStuff,EltFrontList,S),
        !,
	( no_errors_found(S) -> 
	    compile_body_setarg_list(Rest,WS,RestSetList,ResrOidCode,RestCode,RestFrontList,S2),
            !,
	    ( no_errors_found(S2) -> 
		SetList = [EltObj|RestSetList],
		conjunct_struct(EltOidCode,ResrOidCode,OidCode),
		conjunct_struct(EltFrameStuff,RestCode,Code),
		append(EltFrontList,RestFrontList,BodyFrontList),
		append(S,S2,Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ).
*/


get_extra_args_for_simple_primitive(PrimName,PrimIndex,Arity,OutArgs) :-
	flora_simple_primitive_extra_args(PrimName,Arity,OutArgsSpec),
	!,
	simple_primitive_argspecs_to_codes(OutArgsSpec,OutArgs,PrimIndex).
get_extra_args_for_simple_primitive(_,_,_,[]).

simple_primitive_argspecs_to_codes([],[],_) :- !.
simple_primitive_argspecs_to_codes([H|T],[HC|TC],PrimIndex) :-
	(H == 'F' ->
	    get_current_compile_file(File),
	    atomobj_struct(File,NO_INDEX,ThisFileShortName),
	    HC = ThisFileShortName
	; H == 'FF' ->
	    (flora_compiler_environment(file,ThisFileFulName) -> true
	    ; ThisFileFulName = FL_SHELL_FICTITIOUS_FILENAME
	    ),
	    HC = ThisFileFulName
	; H == '@' ->
	    thismodule_struct(ThisModule),
	    HC = ThisModule
	; H == 'L' ->
            get_index_line(PrimIndex,Line),
            (integer(Line) -> numobj_struct(Line,HC)
            ; atomobj_struct(FL_UNKNOWN_OBJECT,HC)
            )
        ; number(H) -> numobj_struct(H,HC)
        ; atom(H) -> atomobj_struct(H,HC)
	; flora_abort(['Compiler bug!!! something wrong with simple_primitive_argspecs_to_codes'], FLORA_ABORT_NOTRACE)
	),
	simple_primitive_argspecs_to_codes(T,TC,PrimIndex).


%% count the number of unescaped %s in an atom
count_substitution_points(In,Number) :-
        atom_codes(In,InList),
        count_substitution_points_in_list(InList,Number).

count_substitution_points_in_list([],0) :- !.
count_substitution_points_in_list([CH_BACKSLASH,_|Rest],Number) :-
        !,
        count_substitution_points_in_list(Rest,Number).
count_substitution_points_in_list([CH_PERCENT,Char|Rest],Number) :-
        (Char == CH_S ; Char == CH_s),
        !,
        count_substitution_points_in_list(Rest,Number1),
        Number is Number1+1.
count_substitution_points_in_list([_Char|Rest],Number) :-
        count_substitution_points_in_list(Rest,Number).



/*
%% unifies two lists of variables. returns the compiler code for that
make_unify_prvarlists_code([],[],true) :- !.
make_unify_prvarlists_code([NewGVar|RestNewGVars],[GVar|RestGVars],Result) :-
        generate_prolog_liblit('=',2,[NewGVar,GVar],Unify),
        (RestGVars == [] -> Result = Unify
        ;
            make_unify_prvarlists_code(RestNewGVars,RestGVars,RestUnify),
            conjunct_struct(Unify,RestUnify,Result)
        ).
*/





/*
%% used to debug symbol context info
show_nowarn_symbols :-
	nowarn_symbol(A,B,C,D,E),
	DBGOUTLN(nowarn(A,B,C,D,E)),
	fail.
show_nowarn_symbols.
*/

/*******************************************************************************
    Handling attributed variables for set arguments multipliers.
*******************************************************************************/
/*
%% OBSOLETE - expansion is now done entirely in the parser
:- install_verify_attribute_handler(SETARGATTRIBUTE,
				    AttrVal,VarBinding,
				    setarg_unify_handler(AttrVal,VarBinding)).
:- install_attribute_portray_hook(SETARGATTRIBUTE,Attr,write(Attr)).
%% we might not need to check if the attribute value is a list:
%% this is just a precaution against weird bindings
setarg_unify_handler(AttrVal,_VarBinding) :- is_list(AttrVal).

get_setarg_multiplier(PRTerm,Multiplier) :-
	get_all_attrvars(PRTerm,AttrVars),
	get_setarg_multiplier_from_list(AttrVars,Multiplier).

get_setarg_multiplier_from_list([],FL_TRUE) :- !.
get_setarg_multiplier_from_list([Var|Rest], (Membership,RestMems)) :-
	get_attr(Var,SETARGATTRIBUTE,Membership),
	!,
	del_attr(Var,SETARGATTRIBUTE),
	get_setarg_multiplier_from_list(Rest,RestMems).
get_setarg_multiplier_from_list([_|Rest], RestMems) :-
	get_setarg_multiplier_from_list(Rest,RestMems).

%% multiply the literal, if it has set arguments inside
multiply_setarg_code(Code,MultCode) :-
	get_setarg_multiplier(Code,Multiplier),
	(Multiplier == FL_TRUE -> MultCode = Code
	; findall(Code,Multiplier,MultLitList),
	    conjunct_code(MultLitList,MultCode)
	).
*/


/******************************************************************************
%% process_contextvars_in_prterm(+PRTerm)

%%%%%%%%% Context attributed vars: used as context for facts %%%%%%%%%%%%%%%%%%
%% o If PRTerm is a true fact then process_contextvars_in_prterm/1 is called
%%   and context is made into just a prvariable
%%   (i.e., the CONTEXTATTRIBUTE attr is deleted).
%% o If PRTerm is a fact-turned-rule then process_contextvars_in_prterm/1
%%   is not called. Instead, head_context_info_structure/1 attaches a
%%   CONTEXTATTRIBUTE attribute to the context variable (== FL_CONTEXT(_,_,_))
%%   When the coder writes this variable out, the variable unifies
%%   with the context.
******************************************************************************/

:- install_verify_attribute_handler(CONTEXTATTRIBUTE,
				    AttrVal,VarBinding,
				    AttrVal=VarBinding).
:- install_attribute_portray_hook(CONTEXTATTRIBUTE,Attr,write(Attr)).

process_contextvars_in_prterm(PRTerm) :-
	get_all_attrvars(PRTerm,AttrVars),
	process_contextvars(AttrVars).

process_contextvars([]) :- !.
process_contextvars([H|Tail]) :-
	get_attr(H,CONTEXTATTRIBUTE,_Context),
	!,
	del_attr(H,CONTEXTATTRIBUTE),
	new_context_prvariable(NO_INDEX,H),
	process_contextvars(Tail).
process_contextvars([_|Tail]) :-
	process_contextvars(Tail).

get_all_attrvars(PRTerm,AttrVars) :- flrterm_vars_split(PRTerm,_,AttrVars,0).

%% compiler silencer
'_$_$flrcompiler_dummy_export' :-
	false,
	%% the above dummy 'false' prevents elimination of the rest by
	%% the Prolog preprocessor (as opposed to gpp)
	replace_flvars_with_vars(_,_),
        remove_FL_CONTEXT_flvars(_,_),
        is_prologterm(_,_,_,_,_),
        is_prterm(_,_,_,_),
        is_strict_pratom(_,_,_),
        is_prbuiltin_identifier(_,_),
	is_prtransactionalnumber(_,_,_).


is_rule_structure_db_direct(ERGO_STRUCTURE_DB_DIRECT).

compile_direct(DirectTerm,DirIdx,[Code],NO_ERRORS) :-
	is_rule_structure_db_direct(DirectTerm),
	!,
	report_option(ERGO_STRUCTURE_DB_OPTION,DirIdx),
        thismodule_struct(ModuleCode),
        atomobj_struct(on,FlagCode),
        generate_prolog_liblit(set_use_rule_structural_db_mode,2,
                               [ModuleCode,FlagCode],flrutils,Direct),
        directive_struct(Direct,Code).

compile_rule_struct_exec_direct(Module,Flag,Code,Status) :-
        compile_body_pathexplist([Module,Flag],NULL,[ModuleCode,FlagCode],_,_,_,Status),
        generate_prolog_liblit(set_use_rule_structural_db_mode,2,
                               [ModuleCode,FlagCode],flrutils,Code).


