/* File:      flrparser.P  -- The Flora Parser
**
** Author(s): Guizhen Yang, Michael Kifer
**
** Contact:   see  CONTACTS.txt
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2023;
**      Coherent Knowledge Systems, LLC, 2014-2023;
**      Vulcan, Inc., 2008 - 2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


%% NOTE: MUST have flrregistry: and machine: prefixes here.
%% Otherwise XSB will think usermod!
:- if('NOWARN'(
       (flrregistry:flora_configuration(installdir,FlrDir),
        machine:slash(S),
        fmt_write_string(Opt,'%s%sopt%soptcompile.P',arg(FlrDir,S,S)),
        %% opt/opt.switch.off turns off the optimization
        fmt_write_string(OptOff,'%s%sopt%sopt.switch.off',arg(FlrDir,S,S)),
        \+file_exists(OptOff),
        file_exists(Opt)
       )
      )).
:- compiler_options([xpp_on(gpp,optcompile)]).
:- else.
:- compiler_options([xpp_on]).
:- endif.
#mode standard Prolog

%%#define SHOW_COMPOSER_TERM
%%#define SHOW_CANON_TERM


#include "flora_exceptions.flh"
#include "flora_status_codes.flh"
#include "flora_characters.flh"
#include "standard.h"

#define CANOTERM        canoterm
#define CANOLIST        canolist
#define CANOBRACE       canobrace
#define CANOEMPTYTERM   canoemptyterm

#define CANOPARENBAR      canoparenbar
#define CANOBRACKBAR      canobrackbar
#define CANOBRACEBAR      canobracebar
#define CANOBRACEBRBRACE  canobracebrace
#define CANOBACKPAREN     canobackparen
#define CANOBACKBRACK     canobackbrack
#define CANOBACKBRACE     canobackbrace

#define SETARGATTRIBUTE parsesetarg

%% Types of DB literal parsing:
%%    - insert
#define FLINS           flins
%%    - delete
#define FLDEL           fldel
%%    - refresh
#define FLREF           flref
%%    - clause
#define FLCLS           flcls

%% parsing a term argument, so no frames allowed
#define PURE_PATHEXPS_ONLY     1
%% parsing other than a term argument; frames are allowed
#define ANY_PATHEXP            0


%% @\module - system module
#define FLORASYSMOD             florasysmod
#define FLORAUSERMOD            florausermod
#define FLORAMODULE             floramodule
%% @\prolog(), @\prolog(...)
#define PROLOGMODULE            prologmodule
%% @\prologall(), @\prologall(...)
#define PROLOGALLMODULE         prologallmodule

#define FLORARULEWORKSPACE      floraruleworkspace

#define ALLOW_VARIABLES         allow_variables
#define DISALLOW_VARIABLES      disallow_variables

#define ALLOW_TRANS              allow_trans
#define DISALLOW_TRANS           disallow_trans

#define ANON_OID_COUNT           parser_anon_oid_count
#define NEWFLVAR                 newflvar

%% Context for calling parse_db_term
#define DB_LITERAL               dbliteral
#define DB_PATHEXP               dbpathexp


#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_contexts.flh"

#define PARSER_CONTEXT          FLORA_SYMBOL('parsecontext')

:- dynamic PARSER_CONTEXT(_).
:- index(PARSER_CONTEXT/1,0).

prepare_for_parsing_rule :-
        flora_set_counter(ANON_OID_COUNT,1),
        flora_set_counter(NEWFLVAR,1),
        clear_context(_).


/****************************************************************************
                           AN APPROXIMATING BNF GRAMMAR

%% To avoid confusion between some language elements and meta-syntax
%% (e.g., parentheses and brackets are part of BNF and also of the language
%% being described), we enclose some symbols in single quotes to make it
%% clear that they are part of the language syntax, not of the grammar.
%% However, in Flora-2 these symbols can be used with or without the quotes.

Statement := (Rule | Query | LatentQuery | Directive) '.'

Rule := (RuleDescriptor)? Head (':-' Body)? '.'

Query := '?-' Body '.'

LatentQuery := RuleDescriptor '!-' Body '.'

Directive := ':-' ExportDirective | OperatorDirective | SetSemanticsDirective
                     | IgnoreDependencyCheckDirective | ImportModuleDirective
                     | PrefixDirective | CompilerDirective | IndexDirective

RuleDescriptor := '\@\{' RuleTag '\}'
                  | '\@\@\{' BooleanRuleDescriptor '\}'
                  | '@!\{' RuleId ( '[' SpecBody ']' )? '\}'

RuleTag := Term
RuleId := Term
BooleanRuleDescriptor := Term
DescrBody := DescrBodyElement (',' DescrBodyElement)*
DescrBodyElement := Term | Term '->' Term

%% Heads in ERGO can also have ==>, <==, <==>, \or, and quantifiers
Head := ('\neg')? HeadLiteral
Head := Head (',' | '\and') Head

HeadLiteral := BinaryRelationship | ObjectSpecification | Term

Body := BodyLiteral
Body := BodyConjunct | BodyDisjunct | BodyNegative | ControlFlowStatement
Body := 'forall(' VarList ')' '^' '(' Body ')'
             | 'exist(' VarList ')' '^' '(' Body ')'
             | 'exists(' VarList ')' '^' '(' Body ')'
Body := Body '@' ModuleName
Body := BodyConstraint

ModuleName := Atom | 'Atom()' | Atom '(' Atom ')' | ThisModuleName

BodyConjunct := Body (',' | '\and') Body
BodyDisjunct := Body (';' | '\or') Body
BodyNegative := (('\naf' | '\neg' | '\+') Body)
BodyConstraint := '{' CLPR-style constraint '}'

ControlFlowStatement  := IfThenElse | UnlessDo
                          | WhileDo | WhileLoop
                          | DoUntil | LoopUntil
IfThenElse := '\if' Body '\then' Body  ('\else' Body)? 
                | Body '<~~' Body | Body '~~>' Body | Body '<~~>' Body
                | Body '<==' Body | Body '==>' Body | Body '<==>' Body
UnlessDo   := '\unless' Body '\do' Body
WhileDo    := '\while' Body '\do' Body
WhileLoop  := '\while' Body '\loop' Body
DoUntil    := '\do' Body '\until' Body
LoopUntil  := '\loop' Body '\until' Body

BodyLiteral := BinaryRelationship | ObjectSpecification | Term
                | DBUpdate | RuleUpdate | Refresh
                | NewSkolemOp | Builtin | Loading | Compiling
                | CatchExpr | ThrowExpr | TruthTest

Builtin := ArithmeticComparison | Unification | MetaUnification | ...

Loading := '[' LoadingCommand (',' LoadingCommand)* ']'
           | 'load{' LoadingCommand (',' LoadingCommand)* '}'
LoadingCommand := Filename ('>>' atom)

Compiling := 'compile{' Filename '}'

BinaryRelationship := PathExpression ':' PathExpression
BinaryRelationship := PathExpression '::' PathExpression

ObjectSpecification := PathExpression '[' SpecBody ']'

SpecBody := ('\naf')? MethodSpecification
SpecBody := ('\neg')? ExplicitlyNegatableMethodSpecification
SpecBody := SpecBody ',' SpecBody
SpecBody := SpecBody ';' SpecBody

MethodSpecification :=  ('%')? Term
MethodSpecification :=  PathExpression
                        (ValueReferenceConnective | SigReferenceConnective)
                        PathExpression

ValueReferenceConnective :=  '->' | '+>' | '->->' | '-->>'

SigReferenceConnective := ('{' (Integer|Variable) ':' (Integer|Variable) '}')? ('=>' )

ExplicitlyNegatableMethodSpecification := Term
ExplicitlyNegatableMethodSpecification :=
             PathExpression ExplicitlyNegatableReferenceConnective PathExpression

ExplicitlyNegatableReferenceConnective := '->' | SigReferenceConnective

                                        
PathExpression := Atom | Number | String | Iri | Variable | SpecialOidToken
PathExpression := Term | List | ReifiedFormula
PathExpression := PathExpression  PathExpressionConnective PathExpression
PathExpression := BinaryRelationship
PathExpression := ObjectSpecification
PathExpression := Aggregate

Iri := SQname | FullIri

SQname := Identifier '#' String

FullIri := '\'String

PathExpressionConnective :=  '.' | '!'

SpecialOidToken :=  AnonymousSkolem | NumberedSkolem | ThisModuleName

ReifiedFormula := '${' (Body | '(' Rule ')') '}'

%% No quotes are allowed in the following special tokens!
%% No space alowed between \# and Integer
%% AnonymousSkolem & NumberedSkolem can occur only in rule head
%% or in reified formulas
AnonymousSkolem   := '\#'
%% No space between \# and Integer
NumberedSkolem    := '\#'Integer
ThisModuleName := '\@'

List := '[' PathExpression (',' PathExpression)* ('|' PathExpression)? ']'

Term := Functor '(' Arguments ')'

Term := '%' Functor '(' Arguments ')'

Functor := PathExpression

Arguments := PathExpression (',' PathExpression)*

Aggregate := AggregateOperator '{' TargetVariable (GroupingVariables)? '|' Body '}'
AggregateOperator := 'max' | 'min' | 'avg' | 'sum' | 'setof' | 'setof'
%% Note: only one TargetVariable is permitted.
%% It must be a variable, not a term. If you need to aggregate over terms,
%% as for example, in setof/setof, use the following idiom:
%%      S = setof{ V | ... , V=Term }
TargetVariable := Variable
GroupingVariables := '[' VarList ']'

Variable := '?' ([\_a-zA-Z][\_a-zA-Z0-9]*)?
VarList := Variable, (',' Variable)*

DBUpdate := DBOp '{' UpdateList ('|' Body)? '}'
DBOp := 'insert' | 'insertall' | 'delete' | 'deleteall' | 'erase' | 'eraseall'
%% In \ERGO, UpdateList can also contain stealth literals
UpdateList := HeadLiteral ('@' Atom)?
UpdateList := UpdateList (',' | '\and') UpdateList
Refresh := 'refresh{' UpdateList '}'

RuleUpdate := RuleOp '{' RuleList '}'
RuleOp := 'insertrule' | 'insertrule_a' | 'insertrule_z' |
               'deleterule' | 'deleterule_a' | 'deleterule_z'
RuleList := Rule | '(' Rule ')'  ( (',' | '\and')  '(' Rule ')' )*

NewSkolemOp := 'skolem{' Variable '}'

CatchExpr := 'catch{' Body, Term, Body '}'
ThrowExpr := 'throw{' Term '}'
TruthTest := 'true{' Body '}' | 'undefined{' Body '}' | 'false{' Body '}'
****************************************************************************/


/****************************************************************************
  canonical_form(+ComposerTerm,-CanoniTerm)
  canonical_form(+ComposerTerm,-CanoniTerm,-PrimaryIndex)
  translates a structure constructed by the composer into an intermediate
  canonical form. That is to make the functor/arguments syntax compatible
  with the operator syntax.

  CANOTERM(CANOTERM,            % can be any CANOTERM
           Arity,               % is known at compile time
           ParenthesisType,     % can be '(', '[', or '{'
           ListOfArguments,     % are CANOTERMs separated by ',' at top level
           FunctorIndex,        % primary index of the functor (error message)
           ParenthesisIndex     % index of the parenthesis (error message)
          )

  CANOLIST(ListOfElements,      % are CANOTERMs separated by ',' at top level
           Tail,                % is separated by '|'
           NumberOfElements,    % separated by ',' at the top level excluding tail
           ParenthesisIndex     % index of the bracket '[' (error message)
           BarIndex             % index of the bar '|' if any
          )

  CANOBRACE(ListOfElements,     % are CANOTERMs separated by ',' at top level
            NumberOfElements,   % number of terms between {...}
            ParenthesisIndex    % index of the brace '{' (error message)
           )

  CANOEMPTYTERM(Index)          % This is empty term represented as ()

  OBJECT(PrimitiveType, % primary type as returned by the composer
         Index          % index (error message)
        )

  Primitive Types:
    IDENTIFIER
    VARIABLE
    NUMBER
    QUOTED_ATOM
    ASCII_STRING
    SYMBOL_TOKEN
    SPECIAL_TOKEN
****************************************************************************/
canonical_form(ComposerTerm,CanoniTerm) :-
        canonical_form(ComposerTerm,CanoniTerm,_Index).


#if exists("extensions/flrparser_canonical.P")
#include "extensions/flrparser_canonical.P"
#endif

/*
   Parsing -:

   preprocesses -: as follows:
	   aaaa-:bbbb-:cccc-:dddd-:eeee.
   becomes
          eeee :- (((dddd,cccc),bbbb),aaaa)
*/
canonical_form(INFIX(FL_RIGHTIMPLYOP,Body,Head,Index),CanoniTerm,Index4) :-
	unwrap_rightimply(Head,Body1,Head1,Index2),
	(Body1 == NULL -> Body2 = Body, Index3 = Index
	; Body2 = INFIX(FL_COMMA,Body1,Body,Index),
	    Index3 = Index2
	),
	ComposerTerm = INFIX(FL_IMPLYOP,Head1,Body2,Index3),
	canonical_form(ComposerTerm,CanoniTerm,Index4).

/****************************************************************************
  unwrap_rightimply(+Term,-NewBody,-NewHead)
****************************************************************************/
unwrap_rightimply(INFIX(FL_RIGHTIMPLYOP,Body,Head,Idx),NewBody,NewHead,Idx3) :-
	!,
	unwrap_rightimply(Head,Body2,NewHead,Idx2),
	(Body2==NULL -> NewBody = Body, Idx3 = Idx
	; NewBody=INFIX(FL_COMMA,Body2,Body,Idx),
	    Idx3 = Idx2
	).
unwrap_rightimply(ComposerTerm,NULL,ComposerTerm,NO_INDEX).

%% end of -: processing


%% This is to handle arguments enclosed by brackets.
canonical_form(INFIX(S,Left,Right,Index),CanoniTerm,Index) :-
        %% Need to break associativity of these F-logic path operators.
        %% For example, a.b[f->g] is sent in like (a).(b[f->g]).
        %% But the real semantics should be ((a).(b))[f->g].
        %% The same for the CURI operator as in a#b[f->g].
        (is_pathop(S) ; is_curi_op(S) ; is_datatypeop(S)),
        !,
        %% Separate the arguments of the right operator.
        functor_and_arguments(Right,RightFunct,Args),
        canonical_form(Left,LL,_Ileft),
        canonical_form(RightFunct,RR,Iright),
        arrange_arguments(Args,S,Index,LL,RR,Iright,CanoniTerm).

canonical_form(INFIX(FL_OBJEQL,Left,Right,Index),CanoniTerm,Index) :-
        %% Need to change the associativity of a:=:(b@m) to (a:=:b)@m.
        Right = INFIX(FL_AT,RealRight,Module,Idx2),
        !,
        Out = INFIX(FL_AT,INFIX(FL_OBJEQL,Left,RealRight,Idx2),Module,Index),
        canonical_form(Out,CanoniTerm,Index).

canonical_form(INFIX(FL_UNIVEQFORM,Left,Right,Index),CanoniTerm,Index) :-
        %% change associativity of ~(->(attr,val),term) to ->(attr,~(val,term))
        %% change associativity of ~(=>(attr,val),term) to =>(attr,~(val,term))
        Left = INFIX(Arrow,Attr,Value,Idx2),
        memberchk(Arrow,[FL_MVDARROW,FL_MVDSIGARROW]),
        !,
        Out = INFIX(Arrow,Attr,INFIX(FL_UNIVEQFORM,Value,Right,Idx2),Index),
        canonical_form(Out,CanoniTerm,Index).
canonical_form(INFIX(FL_NOTUNIVEQFORM,Left,Right,Index),CanoniTerm,Index) :-
        %% change associativity of !~(->(attr,val),term) to ->(attr,~(val,term))
        %% change associativity of !~(=>(attr,val),term) to =>(attr,~(val,term))
        Left = INFIX(Arrow,Attr,Value,Idx2),
        memberchk(Arrow,[FL_MVDARROW,FL_MVDSIGARROW]),
        !,
        Out = INFIX(Arrow,Attr,INFIX(FL_NOTUNIVEQFORM,Value,Right,Idx2),Index),
        canonical_form(Out,CanoniTerm,Index).

canonical_form(INFIX(S,Left,Right,Index),CanoniTerm,Index) :-
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        CanoniTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[LL,RR],Index,NO_INDEX),
        canonical_form(Left,LL,_Ileft),
        canonical_form(Right,RR,_Iright).

canonical_form(PREFIX(S,O,Index),CanoniTerm,Index) :-
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        %% Ambiguity arises when a prefix operator is written as a functor.
        %% E.g., table(p,2). In such a case, it is transformed into a term.
        ( O=ARGUMENT(FL_PARENTHESIS,A,I1,_I2) ->
            CanoniTerm=CANOTERM(Funct,N,FL_PARENTHESIS,Args,Index,I1),
            comma_separated_list(A,Args,N)
        ;
          CanoniTerm=CANOTERM(Funct,1,FL_PARENTHESIS,[OO],Index,NO_INDEX),
          canonical_form(O,OO,_I)
        ).

canonical_form(SUFFIX(S,O,Index),CanoniTerm,Index) :-
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        CanoniTerm=CANOTERM(Funct,1,FL_PARENTHESIS,[OO],Index,NO_INDEX),
        canonical_form(O,OO,_I).

canonical_form(FUNCTION(Funct,Arg),CanoniTerm,Index) :-
        !,
        canonical_form(Funct,F,Index),
        ( Arg = ARGUMENT(B,A,I1,_I2) ->
            (B==FL_BRACE -> replace_synonyms(F,SynF)
            ; SynF = F
            ),
            CanoniTerm=CANOTERM(SynF,N,B,AList,Index,I1),
            %% For brackets, convert comma-separated list of arguments into
            %% a canonical expression so we could parse its elements
            ( memberchk(B,[FL_BRACKET,FL_BRACKBAR]) ->
                N=1,
                AList=[T],
                canonical_form(A,T,_I)
            ;
              comma_separated_list(A,AList,N)
            )
        ; Arg=ARGUMENT(B,I1,_I2),
            (B==FL_BRACE -> replace_synonyms(F,SynF)
            ; SynF = F
            )
        ->
            CanoniTerm=CANOTERM(SynF,0,B,[],Index,I1)
        ).

%% Peel off pairs of `(' and `)'.
canonical_form(ARGUMENT(FL_PARENTHESIS,Arg,_I1,_I2),A,Index) :-
        !,
        canonical_form(Arg,A,Index).

%% Term that is a nonempty list [a,b] or [a|b]
canonical_form(ARGUMENT(FL_BRACKET,Arg,I1,_I2),CANOLIST(AList,T,N,I1,Ib),I1) :-
        !,
        %% a list
        ( Arg = INFIX(FL_BAR,Left,Right,Ib) ->
            comma_separated_list(Left,AList,N),
            canonical_form(Right,T,_Ir)
        ;
          T = [],
          Ib=NO_INDEX,
          comma_separated_list(Arg,AList,N)
        ).
%% empty list
canonical_form(ARGUMENT(FL_BRACKET,I1,_I2),CANOLIST([],[],0,I1,NO_INDEX),I1) :- !.

canonical_form(ARGUMENT(FL_BRACE,Arg,I1,_I2),CANOBRACE(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BRACE,I1,_I2),CANOBRACE([],0,I1),I1) :- !.

%% (|
canonical_form(ARGUMENT(FL_PARENBAR,Arg,I1,_I2),CANOPARENBAR(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_PARENBAR,I1,_I2),CANOPARENBAR([],0,I1),I1) :- !.

%% [|
canonical_form(ARGUMENT(FL_BRACKBAR,Arg,I1,_I2),CANOBRACKBAR(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BRACKBAR,I1,_I2),CANOBRACKBAR([],0,I1),I1) :- !.

%% {|
canonical_form(ARGUMENT(FL_BRACEBAR,Arg,I1,_I2),CANOBRACEBAR(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BRACEBAR,I1,_I2),CANOBRACEBAR([],0,I1),I1) :- !.

%% {{
canonical_form(ARGUMENT(FL_BRACEBRACE,Arg,I1,_I2),CANOBRACEBRBRACE(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BRACEBRACE,I1,_I2),CANOBRACEBRBRACE([],0,I1),I1) :- !.

%% \(
canonical_form(ARGUMENT(FL_BACKPAREN,Arg,I1,_I2),CANOBACKPAREN(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BACKPAREN,I1,_I2),CANOBACKPAREN([],0,I1),I1) :- !.

%% \[
canonical_form(ARGUMENT(FL_BACKBRACK,Arg,I1,_I2),CANOBACKBRACK(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BACKBRACK,I1,_I2),CANOBACKBRACK([],0,I1),I1) :- !.

%% \{
canonical_form(ARGUMENT(FL_BACKBRACE,Arg,I1,_I2),CANOBACKBRACE(AList,N,I1),I1) :-
        !,
        comma_separated_list(Arg,AList,N).
canonical_form(ARGUMENT(FL_BACKBRACE,I1,_I2),CANOBACKBRACE([],0,I1),I1) :- !.


canonical_form(ARGUMENT(FL_PARENTHESIS,I1,_I2),CANOEMPTYTERM(I1),I1) :- !.

canonical_form(OBJECT(T,I),OBJECT(T,I),I) :- !.

/*****************************************************************************
**
**  Replace functors with synonyms from flora_special_builtin_synonym/2
**  May be extended to do further transformations in the future.
**
**  For now we only apply synonyms to builtins of the form ident{...}
**  (checked in canonical_form/3)
**
*****************************************************************************/
replace_synonyms(Funct,SynoFunct) :-
        is_obj_quoted_atom_struct(Funct,Atom,Index),
        !,
        flora_special_builtin_synonym(Atom,SynoAtom),
        is_obj_quoted_atom_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(Funct,SynoFunct) :-
        is_obj_ascii_string_struct(Funct,Atom,Index),
        !,
        flora_special_builtin_synonym(Atom,SynoAtom),
        is_obj_ascii_string_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(Funct,SynoFunct) :-
        is_obj_identifier_struct(Funct,Atom,Index),
        !,
        flora_special_builtin_synonym(Atom,SynoAtom),
        is_obj_identifier_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(X,X).
        


/****************************************************************************
  comma_separated_list(+ComposerTerm,-ListOfCommaSeparatedArguments,-Arity)

  Produce a list of comma separated terms out of a composer term. Note
  that `,' is defined as right associative. Only the top level commas
  are considered to be separating the list.
****************************************************************************/
comma_separated_list(INFIX(FL_COMMA,Left,Right,_I),[LL|RList],N) :-
        !,
        canonical_form(Left,LL,_Ileft),
        comma_separated_list(Right,RList,M),
        N is M+1.

comma_separated_list(ComposerTerm,[CanoniTerm],1) :-
        !,
        canonical_form(ComposerTerm,CanoniTerm,_Index).

%% convert a CANOTERM obtained from parsing  a+b+c+d into a list (in reverse)
sum_canoterm_to_list(CANOTERM(SumOp,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),[Right|LList]) :-
        get_name(SumOp,FL_PLUS),
        !,
        sum_canoterm_to_list(Left,LList).

sum_canoterm_to_list(CanoniTerm,[CanoniTerm]) :-
        !.


/****************************************************************************
  comma_separated_canoterm_to_list(+CanoniTerm,-CanoniTermList)
  Converts a comma-separated list into a normal list
****************************************************************************/
comma_separated_canoterm_to_list(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),[L|RList]) :-
        %% Comma as an operator is right associative.
        get_atom(Funct,FL_COMMA),
        !,
        comma_separated_canoterm_to_list(R,RList).

comma_separated_canoterm_to_list(CanoniTerm,[CanoniTerm]) :- !.



/****************************************************************************
  functor_and_arguments(+ComposerTerm,-Functor,-ArgumentsList)

  Flatten HiLog terms like this: F(A,B)(C,D,E) into F and [(A,B),(C,D,E)].
  Each argument is separated out as a single entity. Another example is
  F(a,b)[f->g], which is broken into F and [(a,b), [f->g]].
****************************************************************************/
functor_and_arguments(FUNCTION(Funct,Arg),F,AList) :-
        !,
        functor_and_arguments(Funct,F,L),
        append(L,[Arg],AList).

%% handle the case abc^^foo[...]
functor_and_arguments(INFIX(S,Left,Right,Idx),OutFunc,Args) :-
        is_datatypeop(S),
        !,
        functor_and_arguments(Right,RightFun,Args),
        OutFunc = INFIX(S,Left,RightFun,Idx).

functor_and_arguments(T,T,[]).


/****************************************************************************
  arrange_arguments(+Args,+Sym,+IndSym,+Left,+Right,+IndRight,-CanoniTerm)

  Args is a list of arguments, e.g., [(a,b), [f->g]].
  Sym is the infix operator and IndSym is its index number.
  Left is the left operand.
  Right is the right operand and IndRight is its index.

  Need to break associativity of these F-logic path operators. For
  example, a.b[f->g] is sent in like (a).(b[f->g]).  But the real
  semantics should be ((a).(b))[f->g]. Note that a.b[f->g] from the top
  level will call:
  arrange_arguments([[f->g]],'.',some_index,a,b,some_index,CanoniTerm).
  When this procedure returns, CanoniTerm should be ((a).(b))[f->g].
****************************************************************************/
arrange_arguments([],S,Index,Left,Right,_Iright,CanoniTerm) :-
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        CanoniTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX).

arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
        %% [f->g] is a special case. Note that a.b[f->g] should be read
        %% as (a.b)[f->g].
        ( A = ARGUMENT(FL_BRACKET,Arg,I1,_I2) ->
            canonical_form(Arg,ArgTerm,_Ia),
            N=1,
            ArgList=[ArgTerm]
        ;
          A = ARGUMENT(FL_BRACKET,I1,_I2),
          N = 0,
          ArgList = []
        ),
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
        T=CANOTERM(FunctTerm,N,FL_BRACKET,ArgList,Index,I1),
        arrange_arguments(L,T,Index,CanoniTerm).

arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
        %% [f->g] is a special case. Note that a.b[f->g] should be read
        %% as (a.b)[f->g].
        ( A = ARGUMENT(FL_BRACKBAR,Arg,I1,_I2) ->
            canonical_form(Arg,ArgTerm,_Ia),
            N=1,
            ArgList=[ArgTerm]
        ;
          A = ARGUMENT(FL_BRACKBAR,I1,_I2),
          N = 0,
          ArgList = []
        ),
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
        T=CANOTERM(FunctTerm,N,FL_BRACKBAR,ArgList,Index,I1),
        arrange_arguments(L,T,Index,CanoniTerm).

/**
%% We do NOT want a.b(f,g) to be read as (a.b)(f,g)!
%% This is a path expression in its own right (ie, a.(b(f,g)))
%% and should not be parsed as a formula
arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
        %% Note that a.b(f,g) should be read as (a.b)(f,g).
        %% but this comes out as (a).(b(f,g)) from the composer.
        %% So, rearrange like in the case of a.b[f->g].
        is_objrefop(S), %% only do it for a.b(...) and a!b(...)
        ( A = ARGUMENT(FL_PARENTHESIS,Arg,I1,_I2) ->
            canonical_form(Arg,ArgTerm,_Ia),
            N=1,
            ArgList=[ArgTerm]
        ;
          A = ARGUMENT(FL_PARENTHESIS,I1,_I2),
          N = 0,
          ArgList = []
        ),
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
        T=CANOTERM(FunctTerm,N,FL_PARENTHESIS,ArgList,Index,I1),
        arrange_arguments(L,T,Index,CanoniTerm).
**/

%% Datatype operator is not treated right by the composer when it appears
%% in the predicate position:  "abcd"^^efgh(f,g)
%% is composed as ^^("abcd",(efgh(f,g))) instead of ^^("abcd",efgh)(f,g).
%% Similarly the CURI prefix operator misbehaves if the right-side is an 
%% infix operator, like mod:
%% rdf#mod(?output)
%% We rectify the associativity here.
arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
        (is_datatypeop(S) ; is_curi_op(S)),
        (A = ARGUMENT(FL_PARENTHESIS,Arg,I1,_I2) ->
            comma_separated_list(Arg,ArgList,N)
        ; A = ARGUMENT(FL_PARENTHESIS,I1,_I2) ->
            ArgList = [], N = 0
        ),
        !,
        Funct=OBJECT(QUOTED_ATOM(S),Index),
        FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
        T=CANOTERM(FunctTerm,N,FL_PARENTHESIS,ArgList,Index,I1),
        arrange_arguments(L,T,Index,CanoniTerm).

arrange_arguments([A|L],S,Index,Left,Right,Iright,CanoniTerm) :-
        ( A = ARGUMENT(B,Arg,I1,_I2) ->
            comma_separated_list(Arg,ArgList,N)
        ;
          A = ARGUMENT(B,I1,_I2),
          N = 0,
          ArgList = []
        ),
        !,
        %% If the argument is not enclosed by [...], then associate
        %% it with the right operand.
        RR=CANOTERM(Right,N,B,ArgList,Iright,I1),
        arrange_arguments(L,S,Index,Left,RR,Iright,CanoniTerm).


/****************************************************************************
  arrange_arguments(+Args,+CanoniTerm,+Index,-CanoniTerm)

  This predicate is called when the associativity of the path operator
  has been resolved.
****************************************************************************/
arrange_arguments([],CanoniTerm,_Index,CanoniTerm) :- !.

arrange_arguments([A|L],Funct,Index,CanoniTerm) :-
        ( A = ARGUMENT(B,Arg,I1,_I2) ->
            ( B == FL_BRACKET ->
                canonical_form(Arg,ArgTerm,_Ia),
                N=1,
                ArgList=[ArgTerm]
            ; B == FL_BRACKBAR ->
                canonical_form(Arg,ArgTerm,_Ia),
                N=1,
                ArgList=[ArgTerm]
            ;
              comma_separated_list(Arg,ArgList,N)
            )
        ;
          A = ARGUMENT(B,I1,_I2),
          N = 0,
          ArgList = []
        ),
        !,
        T=CANOTERM(Funct,N,B,ArgList,Index,I1),
        arrange_arguments(L,T,Index,CanoniTerm).


/****************************************************************************
  is_pathop(+Operator)
****************************************************************************/
is_pathop(FL_ISA)       :- !.
is_pathop(FL_SUB)       :- !.
is_pathop(FL_MVD)       :- !.
is_pathop(FL_INHERIMVD) :- !.


/****************************************************************************
  utilities
****************************************************************************/

%% This is also exported. Operates on FL-terms
flora_get_flatom_name(FLTOKEN(Name,_),Name).
flora_get_flatom_name(FLATOM(Name,_),Name).
flora_get_flatom_name(FLBUILTIN_IDENTIFIER(Name,_),Name).
flora_get_flatom_name(FLTRANSACTIONALATOM(Name,_),Name).

flora_get_flatom_name(FLTOKEN(Name,I),FLTOKEN,Name,I).
flora_get_flatom_name(FLATOM(Name,I),FLATOM,Name,I).
flora_get_flatom_name(FLBUILTIN_IDENTIFIER(Name,I),FLBUILTIN_IDENTIFIER,Name,I).
flora_get_flatom_name(FLTRANSACTIONALATOM(Name,I),FLTRANSACTIONALATOM,Name,I).

%% This is also exported. Operates on FL-terms
flora_get_flatomvar_name(FLVAR(Name,_),Name1) :-
        !,
        flora_concat_atoms(['?',Name],Name1).
flora_get_flatomvar_name(FLTRANSACTIONALVAR(Name,_),Name1) :-
        !,
        flora_concat_atoms(['%?',Name],Name1).
flora_get_flatomvar_name(Atom,Name) :- flora_get_flatom_name(Atom,Name).

%% get_name/2 - operates on canonical terms
get_name(OBJECT(Type,Idx),Out) :- get_name_aux(Type,Idx,Out).
get_name_aux(IDENTIFIER(Name),_I,Name).
get_name_aux(QUOTED_ATOM(Name),_I,Name).
get_name_aux(BUILTIN_IDENTIFIER(Name),_I,Name).

%% get_name/3
get_name(OBJECT(Type,Idx),Out,Idx) :- get_name_aux(Type,Idx,Out,Idx).
get_name_aux(IDENTIFIER(Name),I,Name,I).
get_name_aux(QUOTED_ATOM(Name),I,Name,I).
get_name_aux(BUILTIN_IDENTIFIER(Name),I,Name,I).

is_variable(OBJECT(VARIABLE(Name),I),Name,I).

get_flname_struct(OBJECT(Type,Idx),Out) :- get_flname_struct_aux(Type,Idx,Out).
get_flname_struct_aux(IDENTIFIER(Name),I,FLATOM(Name,I))  :- !.
get_flname_struct_aux(QUOTED_ATOM(Name),I,FLATOM(Name,I)).
%% Don't add  BUILTIN_IDENTIFIER to get_flname_struct. 
%% Gets confused and can't load system modules like @\sys, etc.

get_flbuiltin_identifier_struct(OBJECT(BUILTIN_IDENTIFIER(Name),I),FLATOM(Name,I))  :- !.
is_builtin_identifier_struct(OBJECT(BUILTIN_IDENTIFIER(Name),I),Name,I).

%% get_atom/2 - operates on canonical terms
get_atom(OBJECT(Type,Idx),Out) :- get_atom_aux(Type,Idx,Out).
get_atom_aux(SYMBOL_TOKEN(Atom),_I,Atom).
get_atom_aux(IDENTIFIER(Atom),_I,Atom).
get_atom_aux(BUILTIN_IDENTIFIER(Atom),_I,Atom).
get_atom_aux(QUOTED_ATOM(Atom),_I,Atom).

%% get_atom/3
get_atom(OBJECT(Type,Idx),Out,Idx) :- get_atom_aux(Type,Idx,Out,Idx).
get_atom_aux(SYMBOL_TOKEN(Atom),I,Atom,I).
get_atom_aux(IDENTIFIER(Atom),I,Atom,I).
get_atom_aux(BUILTIN_IDENTIFIER(Atom),I,Atom,I).
get_atom_aux(QUOTED_ATOM(Atom),I,Atom,I).

get_transactionalatom(OBJECT(Type,Idx),Out) :-
        get_transactionalatom_aux(Type,Idx,Out).
get_transactionalatom_aux(TRANSACTIONAL_IDENTIFIER(Atom),_I,Atom).
get_transactionalatom_aux(TRANSACTIONAL_QUOTED_ATOM(Atom),_I,Atom).
get_transactionalatom_aux(TRANSACTIONAL_SYMBOL_TOKEN(Atom),_I,Atom).
get_transactionalatom_aux(TRANSACTIONAL_BUILTIN(Atom),_I,Atom).

transactional_to_regular(OBJECT(Type,Idx),Out) :-
        transactional_to_regular_aux(Type,Idx,Out).
transactional_to_regular_aux(TRANSACTIONAL_IDENTIFIER(Atom),I,OBJECT(IDENTIFIER(Atom),I)).
transactional_to_regular_aux(TRANSACTIONAL_QUOTED_ATOM(Atom),I,OBJECT(QUOTED_ATOM(Atom),I)).
transactional_to_regular_aux(TRANSACTIONAL_SYMBOL_TOKEN(Atom),I,OBJECT(SYMBOL_TOKEN(Atom),I)).
transactional_to_regular_aux(TRANSACTIONAL_BUILTIN(Atom),I,OBJECT(BUILTIN_IDENTIFIER(Atom),I)).
transactional_to_regular_aux(TRANSACTIONAL_ASCII_STRING(Str),I,OBJECT(ASCII_STRING(Str),I)).
%% transactional numbers are used only in :- index %arity-argument
transactional_to_regular_aux(TRANSACTIONAL_NUMBER(N),I,OBJECT(NUMBER(N),I)).
transactional_to_regular_aux(TRANSACTIONAL_VARIABLE(Name),I,OBJECT(VARIABLE(Name),I)).

get_integer(OBJECT(NUMBER(N),_I),N) :- integer(N).
%% transactional numbers are used only in :- index %arity-argument
get_transactionalinteger(OBJECT(TRANSACTIONAL_NUMBER(N),_I),N) :- integer(N).
get_number(OBJECT(NUMBER(N),_I),N) :- number(N).

get_index(CANOTERM(_F,_N,B,_L,Ifunct,Ibrace),Index) :-
        !,
        (memberchk(B,[FL_BRACKET,FL_BRACE,FL_BRACKBAR,FL_PARENBAR,FL_BRACEBAR,FL_BACKBRACK,FL_BACKPAREN,FL_BACKBRACE]) -> Index=Ibrace
        ; Index=Ifunct
        ).

%% Operates on canonical terms
get_index(CANOLIST(_L,_T,_N,Index,_Ib),Index).
get_index(CANOBRACE(_L,_N,Index),Index).
get_index(CANOEMPTYTERM(Index),Index).
get_index(OBJECT(_PrimitiveType,Index),Index).

get_index(CANOPARENBAR(_L,_N,Index),Index).     % (|
get_index(CANOBRACKBAR(_L,_N,Index),Index).     % [|
get_index(CANOBRACEBAR(_L,_N,Index),Index).     % {|
get_index(CANOBRACEBRBRACE(_L,_N,Index),Index). % {{
get_index(CANOBACKPAREN(_L,_N,Index),Index).    % \(
get_index(CANOBACKBRACK(_L,_N,Index),Index).    % \[
get_index(CANOBACKBRACE(_L,_N,Index),Index).    % \{

%% Operates on FL-terms
%% Check if this is used!!!
get_index(FLATOM(_Name,Index),Index).
get_index(FLSTRING(_Str,Index),Index).
get_index(FLVAR(_Name,Index),Index).
get_index(FLBUILTIN_IDENTIFIER(_Name,Index),Index).
get_index(FLDATATYPE(_Sort,_Lit,Index),Index).
get_index([Term|_],Index) :- get_index(Term,Index).
get_index(_T,NO_INDEX).


%% get_spectoken/2
get_spectoken(OBJECT(Type,_Idx),Atom) :- get_spectoken_aux(Type,Atom).
%% get_spectoken_aux/2
%% unnumbered oids
get_spectoken_aux(SPECIAL_TOKEN(Atom),Atom).
%% numbered anon oids and quasi-variables/quasi-constants like \?F, \?L
get_spectoken_aux(SPECIAL_TOKEN(Atom,_Suffix),Atom).

%% get_spectoken/3
get_spectoken(OBJECT(Type,_Idx),Atom,Suff) :- get_spectoken_aux(Type,Atom,Suff).
%% get_spectoken_aux/3
get_spectoken_aux(SPECIAL_TOKEN(Atom,Suffix),Atom,Suffix).

is_spectoken(OBJECT(Type,_Idx)) :- get_spectoken_aux(Type,_), !.
is_spectoken(OBJECT(Type,_Idx)) :- get_spectoken_aux(Type,_,_).


is_conjunction(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_,_),Left,Right) :-
        get_name(Funct,FL_AND_CONNECTIVE).

is_rule(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],_If,_Ip),Head,Body) :-
        get_name(Funct,FL_IMPLYOP).

is_directive(CANOTERM(Funct,1,FL_PARENTHESIS,[Directive],_If,_Ip),Directive) :-
        get_name(Funct,FL_IMPLYOP).

is_query(CANOTERM(Funct,1,FL_PARENTHESIS,[Query],_If,_Ip),Query) :-
        get_name(Funct,FL_QUERYOP).

/*
is_quantified_clause(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_,_),Left,Right) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR).
*/

%% latent query
is_latent_query(CANOTERM(Funct,_N,FL_PARENTHESIS,IClist,If,Ip),ICcanoconj) :-
        get_name(Funct,FL_LATENT_QUERYOP),
        list_to_canoterm_conjunct(IClist,ICcanoconj,If,Ip).

%% udf
is_udf(CANOTERM(Funct,1,FL_PARENTHESIS,[Def],_If,_Ip),Def) :-
        get_name(Funct,FL_UDFF).

is_rule_or_fact(CanoTerm) :-
        \+is_query(CanoTerm,_),
        \+is_latent_query(CanoTerm,_),
        \+is_directive(CanoTerm,_).

is_annotatable(CanoTerm) :-
        \+is_query(CanoTerm,_),
        \+is_directive(CanoTerm,_).

is_annotated_statement(CANOTERM(Funct,2,FL_PARENTHESIS,[Descriptor,Statement],_If,_Ip),Descriptor,Statement) :-
        get_name(Funct,FL_DESCRIPTORFUNC).

is_user_defined_function(CANOTERM(Funct,1,FL_PARENTHESIS,[CANOTERM(Funct2,2,FL_PARENTHESIS,[CANOTERM(Funct3,2,FL_PARENTHESIS,[Function,ReturnValue],_,_),Body],_,_)],_If,_Ip),Function,Body,ReturnValue) :-
        get_name(Funct,FL_UDFF),
        (get_name(Funct2,FL_UDFIF) ; get_name(Funct2,FL_IMPLYOP)),
        get_name(Funct3,FL_UDFEQ).

%% Error: definition of UDF but the third functor is not :=
is_user_defined_function_typo(CANOTERM(Funct,1,FL_PARENTHESIS,[CANOTERM(Funct2,2,FL_PARENTHESIS,[CANOTERM(Funct3,2,FL_PARENTHESIS,[_Function,_ReturnValue],_,_),_Body],_,_)],_If,_Ip),_Function,_Body,_ReturnValue,Funct3) :-
        get_name(Funct,FL_UDFF),
        (get_name(Funct2,FL_UDFIF) ; get_name(Funct2,FL_IMPLYOP)),
        !.

%% Error: definition of UDF but the second functor is :=
%% Can be due to wrong 3rd functor and priorities
is_user_defined_function_typo(CANOTERM(Funct,1,FL_PARENTHESIS,[CANOTERM(Funct2,2,FL_PARENTHESIS,[_H,CANOTERM(Funct3,_N3,_P3,_Args3,_,_)|_Args2],_,_)],_If,_Ip),_Function,_Body,_ReturnValue,Funct3) :-
        get_name(Funct,FL_UDFF),
        get_name(Funct2,FL_UDFEQ).

%% Error: definition of UDF but the second functor is not if
is_user_defined_function_typo(CANOTERM(Funct,1,FL_PARENTHESIS,[CANOTERM(Funct2,_N,_P,_Args,_,_)],_If,_Ip),_Function,_Body,_ReturnValue,Funct2) :-
        get_name(Funct,FL_UDFF).

%% Error: definition of UDF but the first functor is not "udf"
%% and one of the arguments functor is function 
%% Can be due to operators priorities
is_user_defined_function_inside_typo(CANOTERM(Funct,_,_,[CANOTERM(Funct2,_,_P,_Args,_,_)|_],_If,_Ip),_Function,_Body,_ReturnValue,Funct) :-
        get_name(Funct,FName),
        FName \= FL_UDFF,
        get_name(Funct2,FL_UDFF).
is_user_defined_function_inside_typo(CANOTERM(Funct,_,_,[CANOTERM(_Funct2,_,_,[CANOTERM(Funct3,1,_P,_Args,_,_)|_],_,_)|_],_If,_Ip),_Function,_Body,_ReturnValue,Funct) :-
        get_name(Funct,FName),
        FName \= FL_UDFF,
        get_name(Funct3,FL_UDFF).
is_user_defined_function_inside_typo(CANOTERM(Funct,_,_,[CANOTERM(Funct2,2,_,[_,CANOTERM(Funct3,_,_,_,_,_)],_,_)|_],_If,_Ip),_Function,_Body,_ReturnValue,Funct3) :-
        get_name(Funct,FL_UDFF),
        get_name(Funct2,FL_UDFEQ),
        (
          get_name(Funct3,FL_LEFTNAFIMPLY) ;
          get_name(Funct3,FL_RIGHTNAFIMPLY) ;
          get_name(Funct3,FL_NAFIFF) ;
          get_name(Funct3,FL_LEFTNEGIMPLY) ;
          get_name(Funct3,FL_RIGHTNEGIMPLY) ;
          get_name(Funct3,FL_NEGIFF) ;
          get_name(Funct3,FL_MVDSIGARROW) ;
          get_name(Funct3,FL_MVDARROW) ;
          get_name(Funct3,FL_LT) ;
          get_name(Funct3,FL_GT) 
        ).

is_user_defined_function_fact(CANOTERM(Funct,1,FL_PARENTHESIS,[CANOTERM(Funct2,2,FL_PARENTHESIS,[Function,Value],_,_)],_If,_Ip),Function,Value) :-
        get_name(Funct,FL_UDFF),
        get_name(Funct2,FL_UDFEQ).

%% Singleton reification
is_reification(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),Args,N,Ip) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom).

is_curi_canoterm(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),Args) :-
        get_atom(Funct,F),
        is_curi_op(F).

is_canolist(CANOLIST(L,T,_N,I,_Ib),L,T,I).
is_canobrace(CANOBRACE(List,N,I),List,N,I).

annotated_construct_struct(DescriptorsCode,ContentCode,FLANNOTATEDCONSTRUCT(DescriptorsCode,ContentCode)).

annotation_struct(IdConstruct,Type,Idx,FLDESCRIPTOR(IdConstruct,Type,Idx)).

flcallmetafacts_struct(MetaFacts,Idx,FLCALLMETAFACTS(MetaFacts,Idx)).

%% Binary relationship, like : or ::
is_birelop(FL_ISA)    :- !.
is_birelop(FL_SUB)    :- !.

%% compacr URI op #
is_curi_op(FL_CURIOP) :- !.

is_datatypeop(FL_DATATYPE_CONNECTOR) :- !.

is_objrefop(FL_MVD)          :- !.
is_objrefop(FL_INHERIMVD) :- !.

%% =>,
is_sigattspecop(FL_MVDSIGARROW) :- !.
%% ->
is_mvdattspecop(FL_MVDARROW)   :- !.

is_export_spec(FL_MVDARROW)    :- !.

is_boolsigop(FL_BOOLSIGARR)    :- !.

%% +>>
is_incattspecop(FL_ALLINARROW)   :- !.
%% ->->
is_tolistattspecop(FL_TOLISTARROW)   :- !.

is_aggregtop(FL_MIN)        :- !.
is_aggregtop(FL_MAX)        :- !.
is_aggregtop(FL_SUM)        :- !.
is_aggregtop(FL_AVG)        :- !.
is_aggregtop(FL_COUNT)      :- !.
is_aggregtop(FL_SUMDISTINCT)        :- !.
is_aggregtop(FL_AVGDISTINCT)        :- !.
is_aggregtop(FL_COUNTDISTINCT)      :- !.
is_aggregtop(FL_COLLECTSET) :- !.
is_aggregtop(FL_COLLECTBAG) :- !.
is_aggregtop(FL_SET)        :- !.
is_aggregtop(FL_BAG)        :- !.

is_sortable_aggregop(FL_COLLECTSET) :- !.
is_sortable_aggregop(FL_COLLECTBAG) :- !.
is_sortable_aggregop(FL_SET)        :- !.
is_sortable_aggregop(FL_BAG)        :- !.
is_uniq_aggregop(FL_COUNT).
is_uniq_aggregop(FL_SUM).
is_uniq_aggregop(FL_AVG).

is_negop(FL_NEG)        :- !.
is_plgnafop(FL_PLGNAF)  :- !.
is_rulelognafop(FL_RULELOGNAF)  :- !.

%% 2nd arg is the canonical name of the quantifier
is_logicalquantifier(FL_EXISTS,FL_EXISTS)        :- !.
is_logicalquantifier(FL_EXIST,FL_EXISTS)         :- !.
is_logicalquantifier('\\exists',FL_EXISTS)        :- !.
is_logicalquantifier('\\exist',FL_EXISTS)        :- !.
is_logicalquantifier('some',FL_EXISTS)        :- !.
is_logicalquantifier('\\some',FL_EXISTS)        :- !.
is_logicalquantifier(FL_FORALL,FL_FORALL)       :- !.
is_logicalquantifier('\\forall',FL_FORALL)       :- !.
is_logicalquantifier('all',FL_FORALL)       :- !.
is_logicalquantifier('\\all',FL_FORALL)       :- !.
is_logicalquantifier('each',FL_FORALL)       :- !.
is_logicalquantifier('\\each',FL_FORALL)       :- !.
is_logicalquantifier('every',FL_FORALL)       :- !.
is_logicalquantifier('\\every',FL_FORALL)       :- !.
is_existentialquant(FL_EXISTS)    :- !.
is_existentialquant(FL_EXIST)     :- !.
is_universalquant(FL_FORALL)    :- !.

is_delayquant(FL_MUST).
is_delayquant(FL_WISH).

is_hypothetical(FL_POSSIBLE)    :- !.
is_hypothetical(FL_IMPOSSIBLE)  :- !.

%% empty term: ()
is_emptyterm(CANOEMPTYTERM(_I)) :- !.

is_datatype_canoterm(CANOTERM(Funct,2,FL_PARENTHESIS,[Lexical,Type],Idx,_),
                     Lexical,Type,Idx) :-
        get_atom(Funct,F),
        is_datatypeop(F).


emptyterm_struct(Index,FLEMPTYTERM(Index)).

flrule_struct(Head,Body,FLRULE(Head,Body)).

%% fact-directive
%% If this was a fact-directive then yield an FLDIRECTIVE rather than FLFACT
flfact_struct([FLDIRECTIVE(Head,Idx)],FLDIRECTIVE(Head,Idx)) :- !.
flfact_struct(Head,FLFACT(Head)).

flquery_struct(Body,FLQUERY(Body)).
%% latent query !-
fllatent_query_struct(Body,FLLATENTQUERY(Body)).
fldirective_struct(Direct,Index,FLDIRECTIVE(Direct,Index)).
fludf_struct(Function,Body,ReturnValue,FLUDF(Function,Body,ReturnValue)).
fludffact_struct(Function,ReturnValue,FLUDFFACT(Function,ReturnValue)).
fludfsymbol_struct(Term,FLUDFSYM(Term)). %% :- symbol_context{udf p(?)}.
flsensorsymbol_struct(Term,FLSENSORSYM(Term)). %%:-symbol_context{sensor p(?)}.
flprlgsymbol_struct(Term,FLPRLGSYM(Term)). %% :- symbol_context{prlg p(?)}.

flexport_wrap_term(WS,Term,Modules,UpdTag,Code) :-
        ( var(UpdTag) ->
                Code = (WS,Term,Modules,FLEXPORT_READABLE)
        ;
                Code = (WS,Term,Modules,FL_UPDATABLE)
        ).
flexport_unwrap_term((WS,Term,Modules,Updtag),WS,Term,Modules,Updtag).

%%flexport_struct(Term,Modules,Updtag,FLEXPORT(Term,Modules,FLATOM(Updtag,_I))).
flexport_struct(DynamicModule,Term,Modules,Updtag,FLEXPORT(DynamicModule,Term,Modules,FLATOM(Updtag,_I))).
flexport_struct_list(TermList,FLEXPORT_LIST(TermList)).

%% Locality: global/local - whether the IRI prefix is local or global
flprefixdef_struct(PrefixName,Locality,PrefixStr,FLPREFIXDEF(PrefixName,Locality,PrefixStr)).

fldynrule_struct(Head,Body,Descriptors,FLDYNRULE(Head,Body,Descriptors)).

flimportmodule_struct(Module,FLIMPORTMOD(Module)).

flopdef_struct(P,A,O,FLOPDEF(P,A,O)).
flindxdirect_struct(A,P,FLINDEX(A,P)).
flprologdirect_struct(SpecList,Idx,FLPROLOG(SpecList,Idx)).
fltabledirect_struct(SpecList,Idx,FLTABLE(SpecList,Idx)).
flusesensordirect_struct(SpecList,Idx,FLUSESENSOR(SpecList,Idx)).
flsensordirect_struct(SensCall,DelayCond,FLSENSOR(SensCall,DelayCond)).
flusefunctiondirect_struct(SpecList,Idx,FLUSEFUNCTION(SpecList,Idx)).

flnontabled_module_struct(FLNONTABLEDMOD).
flnontabled_data_module_struct(FLNONTABLEDDATAMOD).

flsemanticsdirect_struct(A,FLSEMANTICS(AList)) :-
        fllist_struct(A,[],NO_INDEX,AList).
flsetsemanticsdirect_struct(A,FLSETSEMANTICS(AList)) :-
        fllist_struct(A,[],NO_INDEX,AList).

flsetruntime_direct_struct(A,FLSETRUNTIME(AList)) :-
        fllist_struct(A,[],NO_INDEX,AList).

fldefeasible_struct(TheoryModule,FLDEFEASIBLE(TheoryModule)).
fldefeasible_rule_default_struct(FLDEFEASIBLE_RULE_DEFAULT).
flstrict_rule_default_struct(FLSTRICT_RULE_DEFAULT).

flverbatim_struct(Instruction,FLVERBATIM(Instruction)).
flencoding_struct(Instruction,FLENCODINGDIRECT(Instruction)).
flrnew_global_oid_scope_structure(FLNEW_GLOBAL_OIDSCOPE).
flsuppress_rule_signatures_struct(FLSUPPRESS_RULESIGNS).

fldatatype_struct(Sort,Literal,Idx,FLDATATYPE(Sort,Literal,Idx)).
fldatatype_listvalue_struct(ListLit,FLDATATYPELIST(ListLit)).

%% flora's compiler_options
flcmpoptdirect_struct(OptList,FLCMPOPT(OptList)).

%% ignore dependency checking on hilog predicates
flignoredepdirect_struct(PredList,FLIGNOREDEP(PredList)).

%% ignore symbols context checking 
flsymbolcontextdirect_struct(PredList,FLSYMBOLCONTEXT(PredList)).


%% primitive structures with index for textual information
%% Use flobject_struct/2, if you need to parse Funct
%% NOTE: No transactional objects here:
%%                   they must be in fltransactionalobject_struct
flobject_struct(OBJECT(Type,Idx),Out) :- flobject_struct_aux(Type,Idx,Out).
flobject_struct_aux(IDENTIFIER(Atom),I,FLATOM(Atom,I)).
flobject_struct_aux(QUOTED_ATOM(Atom),I,FLATOM(Atom,I)).
flobject_struct_aux(SYMBOL_TOKEN(Atom),I,FLATOM(Atom,I)).
flobject_struct_aux(VARIABLE(Name),I,FLVAR(Name,I)).
flobject_struct_aux(NUMBER(Num),I,FLNUMBER(Num,I)).
flobject_struct_aux(ASCII_STRING(Str),I,Out) :-
        ((has_context(CONTEXT_PARSER_NL_TEMPLATES)
         ; has_context(CONTEXT_PARSER_USING_NL_TEMPLATE)
         )
        %% if templates, bypass the expert mode checking of "..."
        -> flcharlist_struct(Str,I,Out)
        ;  
            flstring_struct(Str,I,Out)
        ).
%% NOTE: Unnumbered skolems are converted into special numbered ones
%% (distinct from user-defined numbered skolems).
%% This is done in order to preserve co-reference when splitting anon oids
%% like in this case: a[b->\#[c->d]] ~~~> a[b->\#_1],\#_1[c->c].
%% The number is prefixed with '_' in order to not confuse it with
%% user-given suffixes
flobject_struct_aux(SPECIAL_TOKEN(FL_NEWOID),I,FLTOKEN(FL_NEWOID,Suff,I)) :-
        !,
        flora_increment_counter(ANON_OID_COUNT,1,_,Num),
        flora_concat_items(['_',Num],Suff).
flobject_struct_aux(SPECIAL_TOKEN(Atom),I,FLTOKEN(Atom,I)).
%%  support for numbered anon oids
flobject_struct_aux(SPECIAL_TOKEN(Atom,Num),I,FLTOKEN(Atom,Num,I)).
flobject_struct_aux(BUILTIN_IDENTIFIER(Name),I,FLBUILTIN_IDENTIFIER(Name,I)).



fltransactionalobject_struct(OBJECT(Type,Idx),Out) :-
        fltransactionalobject_struct_aux(Type,Idx,Out).
fltransactionalobject_struct_aux(TRANSACTIONAL_IDENTIFIER(Atom),I,FLTRANSACTIONALATOM(Atom,I)).
%% For now we just translate transactional builtins as transactional atoms
%% Will see is we change it later
fltransactionalobject_struct_aux(TRANSACTIONAL_BUILTIN(Atom),I,FLTRANSACTIONALATOM(Atom,I)).
fltransactionalobject_struct_aux(TRANSACTIONAL_QUOTED_ATOM(Atom),I,FLTRANSACTIONALATOM(Atom,I)).
fltransactionalobject_struct_aux(TRANSACTIONAL_SYMBOL_TOKEN(Atom),I,FLTRANSACTIONALATOM(Atom,I)).
fltransactionalobject_struct_aux(TRANSACTIONAL_VARIABLE(Name),I,FLTRANSACTIONALVAR(Name,I)).
fltransactionalobject_struct_aux(TRANSACTIONAL_ASCII_STRING(Str),I,FLTRANSACTIONALSTRING(Str,I)).

fltransactionalqname_struct(QN,FLTRANSACTIONALPREDSPEC(QN)).
is_fltransactionalpredspec_struct(FLTRANSACTIONALPREDSPEC(_QN)).
is_fltransactionalpredspec_struct(FLTRANSPEC(_QN)).

%% transactional numbers are used only in :- index %arity-argument
fltransactionalnumber_struct(OBJECT(TRANSACTIONAL_NUMBER(Num),I),FLTRANSACTIONALNUMBER(Num,I))  :- !.

fltransactionalatom_struct(Atom,Index,FLTRANSACTIONALATOM(Atom,Index)).

%% Will see is we change it later
fltermdescriptor_struct(TermName,TermArity,FLTERMDESCRIPTOR(TermName,TermArity))   :- !.
fltransactionaltermdescriptor_struct(TermName,TermArity,FLTRANSACTIONALTERMDESCRIPTOR(TermName,TermArity))   :- !.

is_fltransactionalatom_struct(FLTRANSACTIONALATOM(_Atom,_I)) :- !.
is_fltransactionalobject_struct(FLTRANSACTIONALATOM(_Atom,_I)) :- !.
is_fltransactionalobject_struct(FLTRANSACTIONALVAR(_Name,_I)) :- !.

is_flatom_struct(FLATOM(Atom,_I),Atom).
is_flatom_struct(FLATOM(Atom,I),Atom,I).
is_flnumber_struct(FLNUMBER(_Num,_I)).
is_flnumber_struct(FLNUMBER(Num,_I),Num).
%%is_flnumber_struct(FLNUMBER(Num,I),Num,I).
is_flstring_struct(FLSTRING(_Str,_I)).
is_flstring_struct(FLSTRING(Str,I),Str,I).
is_flcharlist_struct(FLCHARLIST(Str,I),Str,I).

flcharlist_struct(Str,I,FLCHARLIST(Str,I)).
flstring_struct(Str,I,FLSTRING(Str,I)).

bool_constant(FL_TRUE,FL_TRUECONST).
bool_constant(FL_FALSE2,FL_FALSECONST).
bool_constant(FL_UNDEFINED,FL_UNDEFCONST).

%% Type: FL_LONG/FL_DOUBLE
%% is_number_charlist(+Type,+List,+Idx,-Number,-Status) :-
is_number_charlist(Type,List,Idx,Number,Status) :-
        catch(number_codes(Number,List),_,number_error_handler(Type,Error)),
        flora_canonical_type_name(Type,CanonType),
        (nonvar(Error) -> parsing_error(Idx,Error,Status)
        ; CanonType == FL_DOUBLE -> Status = NO_ERRORS 
        ; CanonType == FL_NUMBER -> Status = NO_ERRORS 
        ; integer(Number), CanonType==FL_LONG -> Status = NO_ERRORS
        ; member(CanonType,[FL_LONG,FL_NUMBER,FL_DOUBLE]) ->
            parsing_error(Idx,ERROR_NUMBER,Status)
        ).

number_error_handler(FL_LONG,ERROR_INTEGER).
number_error_handler(FL_DOUBLE,ERROR_REAL).
number_error_handler(FL_NUMBER,ERROR_NUMBER).

/*
convert_booleans(FLATOM(FL_TRUE,I),FLBUILTIN_IDENTIFIER(FL_TRUECONST,I)).
convert_booleans(FLATOM(FL_FALSE2,I),FLBUILTIN_IDENTIFIER(FL_FALSECONST,I)).
convert_booleans(FLATOM(FL_UNDEFINED,I),FLBUILTIN_IDENTIFIER(FL_UNDEFCONST,I)).
*/

is_fltransactionalstring_struct(FLTRANSACTIONALSTRING(Str,I),Str,I).

is_flbuiltin_identifier_struct(FLBUILTIN_IDENTIFIER(Name,_I),Name).
is_flbuiltin_identifier_struct(FLBUILTIN_IDENTIFIER(Name,I),Name,I).

is_fldatatype_struct(FLDATATYPE(_Sort,_Lit,_I)).

flatom_struct(Atom,Index, FLATOM(Atom,Index)).
flnumber_struct(Atom,Index, FLNUMBER(Atom,Index)).

get_flvar_struct(OBJECT(VARIABLE(Name),I),FLVAR(Name,I)).
get_fltransactionalvar_struct(OBJECT(TRANSACTIONAL_VARIABLE(Name),I),FLTRANSACTIONALVAR(Name,I)).
is_flvar_struct(FLVAR(_Name,_I)).
is_flvar_struct(FLVAR(Name,I),Name,I).
is_fltransactionalvar_struct(FLTRANSACTIONALVAR(_Name,_I)).
is_anonymous_flvar_struct(FLVAR(FL_ANON_VAR,_I)).
is_anonymous_flvar_struct(FLVAR(FL_ANON_VAR,I),I).
is_anonymous_fltransactionalvar_struct(FLTRANSACTIONALVAR(FL_ANON_VAR,_I)).
is_anonymous_fltransactionalvar_struct(FLTRANSACTIONALVAR(FL_ANON_VAR,I),I).

%% In a list, Front is the part before | and Tail the part after |
%% For instance, in [a,b|[c,d]], front=[flatom(a,9),flatom(b,11)]
%% Tail = fllist([flatom(r,14),flatom(v,16)],[],13))
fllist_struct(Front,Tail,Index,FLLIST(Front,Tail,Index)).
is_fllist_struct(FLLIST(_Front,_Tail,_Idx)).
is_fllist_struct(FLLIST(Front,Tail,Idx), Front, Tail, Idx).

%% simulates FL_TRUECONST object as if created by the lexer
trueconst_obj(OBJECT(BUILTIN_IDENTIFIER(FL_TRUECONST),NO_INDEX)).

flcut_struct(Index,FLCUT(Index)).
%% primitive structures with index for textual information

%% Atoms that are passed down as literals when they appear in an object spec.
%% For instance, Obj[true], Obj[fail], Obj[!].
passthru_atom(FL_CUT).
passthru_atom(FL_TRUECONST).
passthru_atom(FL_UNDEFCONST).
passthru_atom(FL_FALSECONST).

flpassthru_struct(Struct,FLPASSTRU(Struct)).
is_passthru_struct(FLPASSTRU(_Struct)).

%% The following are prolog predicates not allowed in frames--considered errors
%% if they appear as frame properties, but allowed as property values.
%% For instance, p[a->1, b=c] - error; p[a->?b>1] - good == p[a->?b], ?b>c.
passthru_pred(FL_UNIVEQ,2).         %% =
passthru_pred(FL_UNIVNOTEQ,2).      %% \=
passthru_pred(FL_EQ,2).             %% ==
passthru_pred(FL_NOTEQ,2).          %% \==
passthru_pred(FL_ORDERLT,2).        %% @<
passthru_pred(FL_ORDEREQLT,2).      %% @=<
passthru_pred(FL_ORDERGT,2).        %% @>
passthru_pred(FL_ORDEREQGT,2).      %% @>=
passthru_pred(FL_MATHEQ,2).         %% =:=
passthru_pred(FL_MATHNOTEQ,2).      %% =\=
passthru_pred(FL_LT,2).             %% =
passthru_pred(FL_EQLT,2).           %% =<
passthru_pred(FL_GT,2).             %% >
passthru_pred(FL_EQGT,2).           %% >=
passthru_pred(FL_IS,2).             %% \is
passthru_pred(FL_C_UNEQUAL,2).      %% !=
passthru_pred(FL_C_NOTSAME,2).      %% !==
passthru_pred(FL_IN,2).             %% \in
passthru_pred(FL_INN,2).            %% \in
passthru_pred(FL_SUBLIST,2).        %% \in
%%------------------------------------------
%% The following ones are treated separately, by is_passthru_other_term/1.
%% They are listed here just for documentation.
passthru_pred(FL_OBJEQL,2).         %% :=:
passthru_pred(FL_UNIVEQFORM,2).     %% ~ 
passthru_pred(FL_NOTUNIVEQFORM,2).  %% !~

is_passthru_term(Term,Index) :-
        flterm_struct(Funct,Arity,_Args,Term), % decompose Term
        !,
        (is_flatom_struct(Funct,Atom,Index)
        ; is_flbuiltin_identifier_struct(Funct,Atom,Index)
        ),
        passthru_pred(Atom,Arity).

is_delayed_passthru_term(Term,StrippedTerm,Index) :-
        is_fldelayedliteral(Term,Op,FlArgs),
        !,
        %% unwrap fl-delay
        is_fllist_struct(FlArgs, ArgList, _, _),
        length(ArgList,Arity),
        flterm_struct(Op,Arity,ArgList,StrippedTerm),
        is_passthru_term(StrippedTerm,Index).

is_passthru_other_term(Term) :-
        (is_flworkspace(Term,RealTerm,_) -> true
        ; is_flmodulespec_struct(Term,RealTerm,_)
        ),
        flobjeql_struct(_,_,RealTerm),
        !.
is_passthru_other_term(Term) :-
        fluniveqform_struct(_,_,Term),
        !.
is_passthru_other_term(Term) :-
        flprlgnaf_struct(Goal,Term),
        fluniveqform_struct(_,_,Goal),
        !.

process_passthru([],[]) :- !.
process_passthru([H|T],[HOut|TOut]) :-
        !,
        process_passthru_singleton(H,HOut),
        process_passthru(T,TOut).
%% The case when H is not a list
process_passthru(H,HOut) :-
        process_passthru_singleton(H,HOut).

process_passthru_singleton(H,HOut) :-
        (is_passthru_term(H,_) -> flpassthru_struct(H,HOut)
        ; is_delayed_passthru_term(H,_H2,_) -> flpassthru_struct(H,HOut)
        ; is_passthru_other_term(H) -> flpassthru_struct(H,HOut)
        ; HOut = H
        ).

is_delayed_builtin_literal(Term) :-
        is_fldelayedliteral(Term,FlAtom,FlArgs),
        flora_get_flatom_name(FlAtom,Name),
        %% unwrap fl-delay
        is_fllist_struct(FlArgs, ArgList, _, _),
        length(ArgList,Arity),
        flora_delayed_builtin_literal(Name,Arity).


flbirelate_struct(Subject,R,Object,FLBIRELATE(Subject,R,Object)).

%% object specified using a path expression: a.b and a!b
flobjref_struct(FL_MVD,Object,Attribute,FLOBJREF(Object,Attribute,NONINHERITABLE)) :- !.
flobjref_struct(FL_INHERIMVD,Object,Attribute,FLOBJREF(Object,Attribute,INHERITABLE)).

%% Composes PARSED Funct with PARSED args to compose a parsed term
%% If the term is -(Number) or +(Number) then convert to flnumber
%% Otherwise, normal term
flterm_struct(Fun,1,[NumberObj],NumberObj) :-
        is_flatom_struct(Fun,FL_PLUS),
        nonvar(NumberObj),
        is_flnumber_struct(NumberObj),
        !.
flterm_struct(Fun,1,[NumberObj],NumberObj1) :-
        is_flatom_struct(Fun,FL_MINUS),
        nonvar(NumberObj),
        flnumber_struct(Num,Index, NumberObj),
        !,
        Num1 is -Num,
        flnumber_struct(Num1,Index, NumberObj1).
flterm_struct(FLTRANSACTIONALPREDSPEC(Funct),Arity,Args,FLTRANSACTIONALTERM(Funct,Arity,Args)) :- !.
flterm_struct(Funct,Arity,Args,FLTERM(Funct,Arity,Args)).

flarith_struct(Term,FLARITH(Term)).

fltransactionalterm_struct(Funct,Arity,Args,FLTRANSACTIONALTERM(Funct,Arity,Args)).
is_fltransactionalterm_struct(FLTRANSACTIONALATOM(_Funct,_Ifx)) :- !.
is_fltransactionalterm_struct(FLTRANSACTIONALTERM(_Funct,_Arity,_Args)) :- !.
is_fltransactionalterm_struct(FLTERM(FuncSpec,_Arity,_Args)) :-
        is_fltransactionalpredspec_struct(FuncSpec).

flaggregt_struct(Op,Var,GroupVars,SortSpec,Conds,FLAGGREGATE(Op,Var,GroupVars,SortSpec,Conds)).
is_flaggregt_struct(FLAGGREGATE(_Op,_Var,_GroupVars,_SortSpec,_Conds)).

flobjeql_struct(O1,O2,FLOBJEQL(O1,O2)).
flobjspec_struct(Object,Spec,Type,FLOBJSPEC(Object,Spec,Type)).

%% Arrow: represents the arrow type: ->, =>, ...
%% Type: INHERITABLE or NONINHERITABLE
flmvdattspec_struct(Attribute,Arrow,Value,Type,FLMVDATTSPEC(Attribute,Arrow,Value,Type)).
flsigattspec_struct(Attribute,Arrow,Value,Type,FLSIGATTSPEC(Attribute,Arrow,Value,Type)).
%% signature constraint a[b=>{low:high}]
flsigattconspec_struct(Attribute,Constr,Arrow,Value,Type,FLSIGATTCONSPEC(Attribute,Constr,Arrow,Value,Type)).
%% a[b+>>c]
flincattspec_struct(Attribute,Arrow,Value,Type,FLINCATTSPEC(Attribute,Arrow,Value,Type)).
%% a[b->->c]
fltolistattspec_struct(Attribute,Arrow,Value,Type,FLTOLISTATTSPEC(Attribute,Arrow,Value,Type)).

flboolsig_struct(FLTRANSACTIONALPREDSPEC(Attribute),Arrow,Type,FLTRANSIG(Attribute,Arrow,Type)) :- !.
flboolsig_struct(Attribute,Arrow,Type,FLBOOLSIG(Attribute,Arrow,Type)).

fltransig_struct(FLTRANSACTIONALPREDSPEC(Attribute),Arrow,Type,FLTRANSIG(Attribute,Arrow,Type)) :- !.
fltransig_struct(Attribute,Arrow,Type,FLTRANSIG(Attribute,Arrow,Type)).

flmethspec_struct(FLTRANSACTIONALPREDSPEC(Method),Type,FLTRANSPEC(Method,Type)) :- !.
flmethspec_struct(Method,Type,FLMETHSPEC(Method,Type)).

fltranspec_struct(FLTRANSACTIONALPREDSPEC(Tran),Type,FLTRANSPEC(Tran,Type)) :- !.
fltranspec_struct(Tran,Type,FLTRANSPEC(Tran,Type)).

flsigconstr_struct(LowerBound,UpperBound,FLSIGCONSTR(LowerBound,UpperBound)). 


is_flattspec_struct(FLMVDATTSPEC(_Att,_Arr,_V,Type),Type)    :- !.
is_flattspec_struct(FLINCATTSPEC(_Att,_Arr,_V,Type),Type)    :- !.
is_flattspec_struct(FLTOLISTATTSPEC(_Att,_Arr,_V,Type),Type) :- !.
is_flattspec_struct(FLTRANSPEC(_Tran,Type),Type) :- !.
is_flattspec_struct(FLMETHSPEC(_Method,Type),Type).

is_flsigspec_struct(FLBOOLSIG(_Att,_Arr,Type),Type) :- !.
is_flsigspec_struct(FLTRANSIG(_Att,_Arr,Type),Type) :- !.
is_flsigspec_struct(FLSIGATTSPEC(_Att,_Arr,_V,Type),Type) :- !.
is_flsigspec_struct(FLSIGATTCONSPEC(_Att,_Constr,_Arr,_V,Type),Type).

get_spectype(Spec,Type) :- is_flattspec_struct(Spec,Type), !.
get_spectype(Spec,Type) :- is_flsigspec_struct(Spec,Type), !.
%% Spec can be an empty list: foo[]
get_spectype(_Spec,NONINHERITABLE).

is_obj_identifier_struct(OBJECT(IDENTIFIER(_Str),_Index)) :- !.
is_obj_quoted_atom_struct(OBJECT(QUOTED_ATOM(_Str),_Index)) :- !.
is_obj_ascii_string_struct(OBJECT(ASCII_STRING(_Str),_Index)) :- !.

is_obj_identifier_struct(OBJECT(IDENTIFIER(Str),Index), Str, Index) :- !.
is_obj_quoted_atom_struct(OBJECT(QUOTED_ATOM(Str),Index), Str, Index) :- !.
is_obj_ascii_string_struct(OBJECT(ASCII_STRING(Str),Index), Str, Index) :- !.
is_obj_builtin_identifier_struct(OBJECT(BUILTIN_IDENTIFIER(Str),Index), Str, Index) :- !.

flconjunct_struct(NULL,Cond2,Cond2) :- !.
flconjunct_struct(Cond1,NULL,Cond1) :- !.
flconjunct_struct(Cond1,Cond2,FLCONJUNCT(Cond1,Cond2)).
fldisjunct_struct(Cond1,Cond2,FLDISJUNCT(Cond1,Cond2)).

flprlgnaf_struct(Goal,FLPLGNAF(Goal)).
flrulelognaf_struct(Goal,FLRULELOGNAF(Goal)).

flneg_struct(Goal,Index,FLNEG(GoalMult,Index)) :-
        %% we have to expand setarg here so that neg p({a,b}) will be translated
        %% neg(p(a),p(b)) rather than neg p(a), neg p(b).
        %% This is needed in the head (in the body this is also done in
        %% the compiler), but to simplify we do it here in all cases.
        multiply_setarg_code(Goal,GoalList),
        parse_list2flconjunct(GoalList,GoalMult).

%% duplicates in var names are eliminated
flquantifier_struct(Quant,VarNames,VarsCode,FormulaCode,Idx,
                    FLQUANTIFIER(Quant,SortedVars,VarsCode,FormulaCode,Idx)) :-
        (VarNames == FL_STAR -> SortedVars=VarNames
        ; sort(VarNames,SortedVars)
        ).

fldelayquant_struct(Quant,Cond,Goal,Index,FLDELAYQUANTIFIER(Quant,Cond,Goal,Index)).

flhypothetical_struct(Op,Goal,Index,FLHYPOTHETICAL(Op,Goal,Index)).

flload_struct(List,FLLOAD(List)).
fladd_struct(List,FLADD(List)).
%% FLADDNEW - like FLADD, but file is not added to the module
%% if it was added before, EVEN if the module was modified.
%% This exists to work around the low time resolution in XSB for file modtimes.
%% Because the resolution is in seconds, it is possible that file mod time
%% and its add-time are the same even though the add happened later.
%% In such a case, FLADD will still re-add the file even though it should not
%% have done so. FLADDNEW will not re-add in such a situation.
fladdnew_struct(List,FLADDNEW(List)).

flconstraint_struct(Constr,FLCONSTRAINT(Constr)).

is_flworkspace_struct(FLWORKSPACE(_G,_N)).

%% Encoding these module specs: @mod @\mod @\prolog(mod) @\prologall(mod)
flmodule_struct(_,IgnoreWSLit,_,IgnoreWSLit) :-
        ignore_workspace_literal(IgnoreWSLit),
        !.
flmodule_struct(FLORAUSERMOD,Literal,ModuleIn,FLWORKSPACE(Literal,Module)) :-
        !,
        (ModuleIn == NULL -> Module = FL_THISMODULE
        ; Module = ModuleIn
        ).
flmodule_struct(FLORASYSMOD,Literal,ModuleIn,FLFLORALIB(Literal,Module)) :-
        !,
        (ModuleIn == NULL -> Module = FL_THISMODULE
        ; Module = ModuleIn
        ).
flmodule_struct(FLORARULEWORKSPACE,Literal,ModuleIn,FLRULEWORKSPACE(Literal,Module)) :-
        !,
        (ModuleIn == NULL -> Module = FL_THISMODULE
        ; Module = ModuleIn
        ).
flmodule_struct(PROLOGMODULE,Goal,ModuleIn,FLPLIB(Goal,Module)) :-
        !,
        (ModuleIn == NULL -> Module = usermod
        ; Module = ModuleIn
        ).
flmodule_struct(PROLOGALLMODULE,Goal,ModuleIn,FLPLIBALL(Goal,Module)) :-
        !,
        (ModuleIn == NULL -> Module = usermod
        ; Module = ModuleIn
        ).

is_prologmodule(PROLOGMODULE).
is_prologmodule(PROLOGALLMODULE).
is_prologmodule(PROLOGMODULE(M),M).
is_prologmodule(PROLOGALLMODULE(M),M).

%% code for \@ workspace
flthismodule_struct(FLTOKEN(FL_THISMODULE,NO_INDEX)).
is_thismodule(FLTOKEN(FL_THISMODULE,_)).

%% Encoding module specs of the form @\prolog() and @\prologall()
%% Takes a goal and protects it against hilog conversion
flplib_struct(Goal,FLPLIB(Goal)).
flpliball_struct(Goal,FLPLIBALL(Goal)).

fldelayedliteral_struct(Op,Args,FLDELAYEDLITERAL(Op,Args)).
%%fldelayedliteral_struct(Op,Args,Mod,FLDELAYEDLITERAL(Op,Args,Mod)).

%% Given module spec, get back module type and module name
flora_get_module_from_spec(FLORAUSERMOD(Mod),FLORAUSERMOD,Mod) :- !.
flora_get_module_from_spec(FLORASYSMOD(Mod),FLORASYSMOD,Mod) :- !.
flora_get_module_from_spec(PROLOGMODULE,PROLOGMODULE,usermod) :- !.
flora_get_module_from_spec(PROLOGMODULE(Mod),PROLOGMODULE,Mod) :- !.
flora_get_module_from_spec(PROLOGALLMODULE(Mod),PROLOGALLMODULE,Mod) :- !.
flora_get_module_from_spec(NULL,FLORAUSERMOD,FL_THISMODULE) :- !.
flora_get_module_from_spec(NULL,PROLOGMODULE,_) :- !, fail.
flora_get_module_from_spec(NULL,PROLOGALLMODULE,_) :- !, fail.
flora_get_module_from_spec(ThisModToken,FLORAUSERMOD,FL_THISMODULE) :-
        is_thismodule(ThisModToken),
        !.
%% This is for debugging only. Should never happen.
flora_get_module_from_spec(Spec,Type,_Mod) :-
        nonvar(Spec),
        var(Type),
        flora_abort([UNKNOWN_ERROR,'\n\t\t Details: in flora_get_module_from_spec'],FLORA_ABORT_NOTRACE).

has_module_type(PROLOGMODULE,PROLOGMODULE).
has_module_type(PROLOGMODULE(_),PROLOGMODULE).
has_module_type(PROLOGALLMODULE,PROLOGALLMODULE).
has_module_type(PROLOGALLMODULE(_),PROLOGALLMODULE).
has_module_type(FLORAUSERMOD(_),FLORAMODULE).
has_module_type(FLORASYSMOD(_),FLORAMODULE).


is_flmodulespec_struct(FLWORKSPACE(_G,_N)) :- !.
is_flmodulespec_struct(FLPLIB(_G)) :- !.
is_flmodulespec_struct(FLPLIB(_G,_N)) :- !.
is_flmodulespec_struct(FLFLORALIB(_L,_M)) :- !.
is_flmodulespec_struct(FLFLORALIB(L,M),L,M) :- !.
is_flmodulespec_struct(FLPLIBALL(_G)) :- !.
is_flmodulespec_struct(FLPLIBALL(_G,_N)) :- !.

is_dbinsertop(FL_INSERT) :- !.
is_dbinsertop(FL_INSERTALL) :- !.

is_dbinsertop(FL_BTINSERT) :- !.
is_dbinsertop(FL_BTINSERTALL) :- !.

is_dbdeleteop(FL_DELETE) :- !.
is_dbdeleteop(FL_DELETEALL) :- !.
is_dbdeleteop(FL_ERASE) :- !.
is_dbdeleteop(FL_ERASEALL) :- !.

is_dbdeleteop(FL_BTDELETE) :- !.
is_dbdeleteop(FL_BTDELETEALL) :- !.
is_dbdeleteop(FL_BTERASE) :- !.
is_dbdeleteop(FL_BTERASEALL) :- !.

is_updateop(X) :- is_dbdeleteop(X), !.
is_updateop(X) :- is_dbinsertop(X), !.
is_updateop(X) :- is_ruleupdateop(X), !.

%%is_loadop(FL_LOAD).

is_tablerefreshop(FL_REFRESH) :- !.
%%is_newmoduleop(FL_NEWMODULE) :- !.
%%is_callermoduleop(FL_CALLERMODULE) :- !.

%% !!{...} - stop delaying calls hanging off of the given variables
is_stopdelayop(FLORA_STOP_DELAY) :- !.

is_catchop(FL_CATCH) :- !.
is_throwop(FL_THROW) :- !.
is_p2hop(FL_P2H) :- !.

is_ruleupdateop(FL_INSERTRULE) :- !.
is_ruleupdateop(FL_INSERTRULE_A) :- !.
is_ruleupdateop(FL_INSERTRULE_Z) :- !.
is_ruleupdateop(FL_DELETERULE_A) :- !.
is_ruleupdateop(FL_DELETERULE_Z) :- !.
is_ruleupdateop(FL_DELETERULE) :- !.

is_nonlogical_updateop(FL_INSERT) :- !.
is_nonlogical_updateop(FL_INSERTALL) :- !.
is_nonlogical_updateop(FL_DELETE) :- !.
is_nonlogical_updateop(FL_DELETEALL) :- !.
is_nonlogical_updateop(FL_ERASE) :- !.
is_nonlogical_updateop(FL_ERASEALL) :- !.
is_nonlogical_updateop(Op) :- is_ruleupdateop(Op).

is_clauseop(FL_CLAUSE) :- !.

is_reifyop(FL_REIFYOP) :- !.

%% true{...}, false{...}, undefined{...}
is_truthvalue_op(FL_TRUE_PRIMITIVE) :- !.
is_truthvalue_op(FL_FALSE_PRIMITIVE) :- !.
is_truthvalue_op(FL_UNDEFINED_PRIMITIVE) :- !.

is_tag_primitive_op(FL_TAG_PRIMITIVE) :- !.
is_prefixprimitive_op(FL_PREFIX_PRIMITIVE) :- !.

flrefresh_struct(List,FLREFRESH(List)).

flstopdelay_struct(List,I,FLSTOPDELAY(List,I)).
flstopdelay_struct(I,FLSTOPDELAY(I)).

fltruthvalue_struct(Formula,OpName,FLTRUTHVALUE(Formula,OpName)).
fltag_primitive_struct(Descriptors,Head,FLTAGPRIMITIVE(Descriptors,Head)).
flprefixprimitive_struct(Prefix,Expansion,Module,FLPREFIXPRIMITIVE(Prefix,Expansion,Module)).

flinsert_struct(Op,List,Cond,FLINSERT(Op,List,Cond)).
flinsert_struct(Op,List,FLINSERT(Op,List)).
fldelete_struct(Op,List,Cond,FLDELETE(Op,List,Cond)).
fldelete_struct(Op,List,FLDELETE(Op,List)).

flnewmodule_struct(Op,Mod,FLNEWMODULE(Op,Mod)).
flerasemodule_struct(Op,Mod,FLERASEMODULE(Op,Mod)).
flcallermodule_struct(Op,Var,FLCALLERMODULE(Op,Var)).
flupdaterule_struct(Op,RuleList,FLUPDATERULE(Op,RuleList)).

flsimpleprimitive_struct(Primitive,Args,FLSIMPLEPRIMITIVE(Primitive,Args)).

flclause_struct(Head,Body,FLCLAUSE(Head,Body)).
flclause_struct(Mode,Head,Body,FLCLAUSE(Mode,Head,Body)).
%%flclause_with_descriptor_struct(Descriptors,Head,Body,FLANNOTATEDCLAUSE(Descriptors,Head,Body)).
flclause_with_descriptor_struct(Descriptors,Mode,Head,Body,FLANNOTATEDCLAUSE(Descriptors,Mode,Head,Body)).

%% is_simple_primitive_obj(+Finct,+N,-PrimitiveName)
is_simple_primitive_obj(Funct,N,PrimitiveName) :-
        get_name(Funct,PrimitiveName),
        (flora_simple_primitive(PrimitiveName,N,_,_)
        ; flora_simple_primitive_extra_args(PrimitiveName,N,_)
        ).

prefixable_simple_primitive(FL_ALERT,('+')).
prefixable_simple_primitive(FL_ALERT,('-')).
prefixable_simple_primitive(FL_CONSTRAINT,('+')).
prefixable_simple_primitive(FL_CONSTRAINT,('-')).

is_flcallermodule_struct(FLCALLERMODULE(_,_)).
is_flupdaterule_struct(FLUPDATERULE(_,_)).
is_flnewmodule_struct(FLNEWMODULE(_,_)).
is_flnewmodule_struct(FLERASEMODULE(_,_)).
is_flinsert_struct(FLINSERT(_,_)).
is_flinsert_struct(FLINSERT(_,_,_)).
is_fldelete_struct(FLDELETE(_,_)).
is_fldelete_struct(FLDELETE(_,_,_)).
is_flrefresh_struct(FLREFRESH(_)).
ignore_workspace_literal(Lit) :-
        (is_flcallermodule_struct(Lit)
        ; is_flnewmodule_struct(Lit)
        ; is_flupdaterule_struct(Lit)
        ; is_flinsert_struct(Lit)
        ; is_fldelete_struct(Lit)
        ; is_flrefresh_struct(Lit)
        ).

is_term_struct(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),Funct,N,Args) :-
        flobject_struct(Funct,_).

flifthenelse_struct(Cond,Then,Else,FLIFTHENELSE(Cond,Then,Else)).
flifthen_struct(Cond,Then,FLIFTHEN(Cond,Then)).

%% struct for meta ~
fluniveqform_struct(Left,Right,FLUNIVEQFORM(Left,Right)).
%% struct for =..
flmetauniv_struct(Left,Right,FLMETAUNIV(Left,Right)).

%% -->>: same as Prolog ->
flprolog_ifthen_struct(Left,Right,FLPROLOGIFTHEN(Left,Right)).

%% struct for ${...}
flreify_struct(Formula,FLREIFYOP(Formula)).
is_flreify_struct(FLREIFYOP(_Formula)).
is_flreify_struct(FLREIFYOP(Formula),Formula).

flcatch_struct(Goal,Error,Handler,FLCATCH(Goal,Error,Handler)).
flthrow_struct(Error,FLTHROW(Error)).
flp2h_struct(Prolog,Hilog,FLP2H(Prolog,Hilog)).

flcontrolconstruct_struct(Cond,Action,FLWHILEDO,FLWHILEDO(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLWHILELOOP,FLWHILELOOP(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLDOUNTIL,FLDOUNTIL(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLLOOPUNTIL,FLLOOPUNTIL(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLUNLESSDO,FLUNLESSDO(Cond,Action)).

%% Arg 1: parser's wrapper for control construct
%% Arg 2: top-level keyword of control construct
%% Arg 3: second keyword of construct
get_control_construct_definition(FLWHILEDO,FL_WHILE,FL_DO).
get_control_construct_definition(FLWHILELOOP,FL_WHILE,FL_LOOP).
get_control_construct_definition(FLDOUNTIL,FL_DO,FL_UNTIL).
get_control_construct_definition(FLLOOPUNTIL,FL_LOOP,FL_UNTIL).
get_control_construct_definition(FLUNLESSDO,FL_UNLESS,FL_DO).

control_construct_real_name(FL_WHILE,while).
control_construct_real_name(FL_DO,do).
control_construct_real_name(FL_LOOP,loop).
control_construct_real_name(FL_UNLESS,unless).
control_construct_real_name(FL_UNTIL,until).

convert_to_quoted_atomobj(OBJECT(Type,Idx),Out) :-
        convert_to_quoted_atomobj_aux(Type,Idx,Out).
convert_to_quoted_atomobj_aux(ASCII_STRING(Str),I,OBJECT(QUOTED_ATOM(Atm),I)) :-
        !,
        atom_codes(Atm,Str).
convert_to_quoted_atomobj_aux(IDENTIFIER(Atm),I,OBJECT(QUOTED_ATOM(Atm),I)).
convert_to_quoted_atomobj_aux(BUILTIN_IDENTIFIER(Atm),I,OBJECT(QUOTED_ATOM(Atm),I)).

/*
%% convert \# to a numbered oid with negative number (therefore unique in rule)
%% if not a numbered oid then no change
%% get_spectoken/3
get_spectoken(OBJECT(SPECIAL_TOKEN(Atom),I),Atom,I).
%% get_spectoken/4
get_spectoken(OBJECT(SPECIAL_TOKEN(Atom,Suffix),I),Atom,Suffix,I) :- !.
convert_unnumbered_oid(X,Y) :-
        get_spectoken(X,FL_NEWOID,Idx),
        !,
        flora_increment_counter(ANON_OID_COUNT,-1,_,Suff),
        get_spectoken(Y,FL_NEWOID,Suff,Idx).
convert_unnumbered_oid(X,X).
*/
        

/*
%% Management of global parser context
clear_context(X) :- flora_retractall_substitute(PARSER_CONTEXT(X)).
set_context(X) :-
        (\+has_context(X)
        -> assert(PARSER_CONTEXT(X))
        ; true
        ).
has_context(X) :- PARSER_CONTEXT(X).
*/


set_context(X) :-
        (atom(X) -> flora_set_counter(X,1)
        ; flora_abort([X, ': ',FLSYSTEM,' parser bug. Invalid parser context'],
                      FLORA_ABORT_NOTRACE)
        ).

has_context(X) :-
        flora_get_counter(X,1).
%% this is exported
has_parser_context(X) :- has_context(X).

clear_context(X) :-
        (atom(X) -> flora_set_counter(X,0)
        ; var(X) ->
            /*
            %% these seem unnecessary: counters are cleared properly in code
            clear_context(CONTEXT_PARSER_USESENSOR_DIRECTIVE),
            clear_context(CONTEXT_PARSER_FACT),
            clear_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT),
            clear_context(CONTEXT_PARSER_QUERY),
            clear_context(CONTEXT_PARSER_LATENT_QUERY),
            clear_context(CONTEXT_PARSER_RULEHEAD),
            clear_context(CONTEXT_PARSER_UDF_FACT),
            clear_context(CONTEXT_PARSER_DESCRIPTOR),
            clear_context(CONTEXT_PARSER_DEFAULT_NEGATION),
            clear_context(CONTEXT_PARSER_HYPOTHETICAL),
            clear_context(CONTEXT_PARSER_CLP_CONSTRAINT),
            */
            clear_context(CONTEXT_PARSER_REIFY)
        ;
            true
        ).

flora_set_parser_context(X) :- set_context(X).
flora_clear_parser_context(X) :- clear_context(X).

flora_reset_parser :-
        clear_context(CONTEXT_PARSER_NL_TEMPLATES),
        clear_context(CONTEXT_PARSER_NL_TEMPLATE_SENTENCE_PART),
        clear_context(CONTEXT_PARSER_UDF_HEAD),
        retractall(FLORA_INCLUDE_DEPENDENCY(_,_)),
        retractall(FLORA_TEMPLATE_DEPENDENCY(_,_)),
        flora_set_template(ERGOTEXT_PARSETIME_DUMMY_MODULE,off),
        flora_abolish_table_predicate(FLORA_INCLUDE_DEPENDENCY_CLOSURE(_,_)).


/****************************************************************************
  parsing_error(+IndexOrTerm,+ErrorMessage,-Status)
  parsing_error(+CanoniTerm,+ErrorMessage,-Status)

  If ErrorMessage is a list, it is first concatenated.

  Note on handling the Status parameter in parsing predicates:
  If a call to a parsing predicate comes with non-empty Status,
  DO NOT call parsing_error/3, but rather pass the Status parameter 
  up to the caller.

  Status must ALWAYS be UNbound
****************************************************************************/
parsing_error(Index,ErrorMessage,Status) :-
        is_list(ErrorMessage),
        flora_concat_atoms(ErrorMessage,RealMesg),
        parsing_error(Index,RealMesg,Status).
parsing_error(Index,ErrorMessage,Status) :-
        extract_real_token_number(Index,RealIdx),
        !,
        Status=[error(RealIdx,ErrorMessage)].
parsing_error(CanoniTerm,ErrorMessage,Status) :-
        (get_index(CanoniTerm,I),
            extract_real_token_number(I,RealIdx),
            RealIdx \== NO_INDEX ->
            Status=[error(RealIdx,ErrorMessage)]
        ;
            flora_abort('Internal parser bug: invalid term in parsing_error/3',
                        FLORA_ABORT_NOTRACE)
        ).


%% this is slightly different from the version used in flrcompiler.P
extract_real_token_number(Index,RealIdx) :-
        var(Index),
        get_attr(Index,FLTOKENIDX,RealIdx),
        !.
extract_real_token_number(Index,Index) :-
        integer(Index).


/****************************************************************************
  flora_parse(+ComposerTerm,-Code,-Status)
  is the top level dispatcher.
****************************************************************************/
flora_parse(NULL,[NULL],NO_ERRORS) :- !.


#include "extensions/flrparser_template.P"


flora_parse(ComposerTerm,Code,Status) :-
        prepare_for_parsing_rule,
#ifdef SHOW_COMPOSER_TERM
        DBGOUTLN('------------parser: composer out--------------'),
        DBGOUTLN(ComposerTerm),
        DBGOUTLN('----------------------------------------------'),
#endif
        canonical_form(ComposerTerm,CanoniTerm),
#ifdef SHOW_CANON_TERM
        DBGOUTLN('------------parser: canonical form------------'),
        DBGOUTLN(CanoniTerm),
        DBGOUTLN('----------------------------------------------'),
#endif
        parse_canonical(CanoniTerm,Code1,Status),
        (\+ memberchk(error(_,_),Status) -> commalist2list(Code1,Code)
        ; true
        ),
        !.

%% This rule is for debugging.
flora_parse(ComposerTerm,_Code,Status) :-
        get_index(ComposerTerm,Ind),
        parsing_error(Ind,[UNKNOWN_ERROR,'\n\t\t Details: in flora_parse'],Status).


parse_canonical(CanoniTerm,Code,Status) :-
        (is_rule(CanoniTerm,Head,Body) ->
            flora_parse_rule(Head,Body,Code,Status)

        ; is_directive(CanoniTerm,Directive) ->
            parse_directive(Directive,Code,Status)

        ; is_query(CanoniTerm,Query) ->
            flora_parse_query(Query,Code,Status)

        ; get_statement_descriptors(CanoniTerm,Descriptors,Statement),
            Descriptors \== [] ->
            %% false means: no vars in descriptor Id
            parse_toplevel_annotated_statement(Descriptors,Statement,false,Code,Status)

        %% latent query
        ; is_latent_query(CanoniTerm,IC) ->
            flora_parse_latent_query(IC,Code,Status)

        ; is_user_defined_function(CanoniTerm,Function,Body,ReturnValue) ->
            flora_parse_user_defined_function(Function,Body,ReturnValue,Code,Status)

        ; is_user_defined_function_fact(CanoniTerm,Function,ReturnValue) ->
            flora_parse_user_defined_function_fact(Function,ReturnValue,Code,Status)

        ; is_user_defined_function_inside_typo(CanoniTerm,_Function,_Body,_ReturnValue,ErrorTerm) ->
          parsing_error(ErrorTerm,ERROR_UDF,Status)

        ; is_user_defined_function_typo(CanoniTerm,_Function,_Body,_ReturnValue,ErrorTerm) ->
            parsing_error(ErrorTerm,ERROR_UDF,Status)

        ; is_conjunction(CanoniTerm,Left,Right) ->
            parse_canonical(Left,LCode,LStatus),
            (LStatus == NO_ERRORS ->
                parse_canonical(Right,RCode,Status),
                Code = (LCode,RCode)
            ; Status = LStatus
            )

        %% reify op ${...} that occurs as a standalone formula
        ; is_reification(CanoniTerm,Args,_N,_Ip) ->
            parse_canonical_list(Args,CodeList,Status),
            list2commalist(CodeList,Code)

        ; %% flora_parse_fact must be the last one to call.
            flora_parse_fact(CanoniTerm,Code,Status)
        ).

parse_canonical_list([],[],NO_ERRORS) :- !.
parse_canonical_list([H|T],[HC|TC],Status) :-
        parse_canonical(H,HC,Stat1),
        (Stat1 == NO_ERRORS -> parse_canonical_list(T,TC,Status)
        ; Status = Stat1
        ).

/****************************************************************************
  parse_directive(+CanoniTerm,-Code,-Status)
  is the dispatcher for directives.
  Code: FLDIRECTIVE([directives+])

  Note: Textual information is not preserved for compiler directives.
****************************************************************************/
parse_directive(CanoniTerm,Code,Status) :-
        (CanoniTerm = CANOTERM(_Funct,_Arity,_,_L,If,_Ip)
        ; is_obj_identifier_struct(CanoniTerm,_,If)
        ; is_builtin_identifier_struct(CanoniTerm,_,If)
        ),
        (
          export_directive(CanoniTerm,NULL,CodeList,Status)
        ; operator_directive(CanoniTerm,CodeList,Status)
        ; index_directive(CanoniTerm,CodeList,Status)
        ; prolog_directive(CanoniTerm,CodeList,Status)
        ; table_directive(CanoniTerm,CodeList,Status)
        ; nontabled_module_directive(CanoniTerm,CodeList,Status)
        ; usesensor_directive(CanoniTerm,CodeList,Status)
        ; defsensor_directive(CanoniTerm,CodeList,Status)
        ; usefunction_directive(CanoniTerm,CodeList,Status)
        ; setsemantics_directive(CanoniTerm,CodeList,Status)
        ; semantics_directive(CanoniTerm,CodeList,Status)
        ; cmpopt_directive(CanoniTerm,CodeList,Status)
        ; prefixdef_directive(CanoniTerm,CodeList,Status)
        ; ignoredep_directive(CanoniTerm,CodeList,Status)
        ; importmodule_directive(CanoniTerm,CodeList,Status)
        ; defeasible_directive(CanoniTerm,CodeList,Status)
        ; defeasible_rule_default_directive(CanoniTerm,CodeList,Status)
        ; strict_rule_default_directive(CanoniTerm,CodeList,Status)
        ; verbatim_directive(CanoniTerm,CodeList,Status)
        ; encoding_directive(CanoniTerm,CodeList,Status)
        ; new_glob_oid_scope_directive(CanoniTerm,CodeList,Status)
        ; suppress_rule_signatures_directive(CanoniTerm,CodeList,Status)
        ; symbol_context_directive(CanoniTerm,CodeList,Status)
        ; ergotext_template_directive(CanoniTerm,CodeList,Status)
        ; rule_structure_db_directive(CanoniTerm,CodeList,Status)
        ),
        fldirective_struct(CodeList,If,Code),
        !.

parse_directive(CANOTERM(Funct,_N,_F,_Args,If,_Ip),_Code,Status) :-
        get_name(Funct,FL_AT),
        parsing_error(If,DISALLOWED_DIRECT,Status).

parse_directive(CanoniTerm,_Code,Status) :-
        parsing_error(CanoniTerm,UNKNOWN_DIRECT,Status).


/****************************************************************************
  exec_directive(+CanoniTerm,+FloraModSpec,-Code,-Status)
  Code: FLDIRECTIVE([directives])

  Note: This is to parse the executable directives either from a shell
        or inside a program. Normal directives only affect how a single
        program is translated. Executable directives affect the translation
        of all subsequent command entered from the shell.
****************************************************************************/
exec_directive(CanoniTerm,FloraModSpec,Code,Status) :-
        (
          CanoniTerm = CANOTERM(_Funct,_Arity,_,_L,If,_Ip)
        ; is_obj_identifier_struct(CanoniTerm,_,If)
        ; is_builtin_identifier_struct(CanoniTerm,_,If)
        ),
        fldirective_struct(CodeList,If,Code),
        ( 
          exec_export_directive(CanoniTerm,FloraModSpec,CodeList,Status)
        ; operator_directive(CanoniTerm,CodeList,Status)
        ; exec_index_directive(CanoniTerm,CodeList,Status)
        %% We do not allow executable prolog or table directives!
        %% These are to be used only inside files!
        ; exec_prolog_directive(CanoniTerm,CodeList,Status)
        ; exec_table_directive(CanoniTerm,CodeList,Status)
        ; usesensor_directive(CanoniTerm,CodeList,Status)
        ; usefunction_directive(CanoniTerm,CodeList,Status)
        ; defsensor_directive(CanoniTerm,CodeList,Status)
        ; exec_setsemantics_directive(CanoniTerm,CodeList,Status)
        ; exec_semantics_directive(CanoniTerm,CodeList,Status)
        ; exec_setruntime_directive(CanoniTerm,CodeList,Status)
        ; prefixdef_directive(CanoniTerm,CodeList,Status)
        ; exec_symbol_context_directive(CanoniTerm,CodeList,Status)
        ; new_glob_oid_scope_directive(CanoniTerm,CodeList,Status)
        ; exec_rule_structure_db_directive(CanoniTerm,CodeList,Status)
        ),
        !.


/***************************************************************************
   list_to_canoterm_conjunct(+ListOfCanoniTerms,-ConjunctOfCanoniTerms,+If,+Ip)
   Converts lists of canonical terms to comma-separated lists of canonical terms
***************************************************************************/

%% comma_separated_canoterm_to_list/2 dose the opposite conversion
list_to_canoterm_conjunct([H],H,_If,_Ip) :- !.
list_to_canoterm_conjunct([H|Tail],CANOTERM(Funct,2,FL_PARENTHESIS,[H,TailConj],If,Ip),If,Ip) :-
        get_name(Funct,FL_COMMA),
        list_to_canoterm_conjunct(Tail,TailConj,If,Ip).

/***************************************************************************
    parse_list2flconjunct(+List,-Commalist)
        converts list to commalist as an FL-term
    parse_list2flconjunct(+List,-FLConjunction)
        converts list to flconjunction

  These two operate on flterms
***************************************************************************/
%% list to flterm(flatom(FL_COMMA,19),2,[...,...])
parse_list2flcommalist([A],A) :- !.
parse_list2flcommalist([A|L], Code) :-
        parse_list2flcommalist(L,LL),
        flatom_struct(FL_COMMA,NO_INDEX,F),
        flterm_struct(F,2,[A,LL],Code).
        
%% convert list [...] to flconjunct
parse_list2flconjunct([A],A) :- !.
parse_list2flconjunct([A|L], Code) :-
        parse_list2flconjunct(L,LL),
        flconjunct_struct(A,LL,Code).

/*************************************************************************
   Import module directive

   importmodule_directive(+CanoniTerm,-CodeList,-Status)
*************************************************************************/
importmodule_directive(CANOTERM(Funct,_N,FL_BRACE,Modules,_If,_Ip),Code,Status) :-
        %% check directive name.
        get_name(Funct,FL_IMPORTMODULE),
        importmodule_parse_termlist(Modules,Code,Status),
        !.
%% error
importmodule_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),_Code,Status) :-
        %% check directive name.
        get_name(Funct,FL_IMPORTMODULE),
        !,
        parsing_error(If,ERROR_IMPORTMODULE,Status).

importmodule_parse_termlist([],[],NO_ERRORS) :- !.
importmodule_parse_termlist([H|T],Code,Status) :-
        importmodule_parse_term(H,HCode,HStatus),
        ( HStatus == NO_ERRORS ->
            importmodule_parse_termlist(T,TCode,Status),
            Code = [HCode|TCode]
        ;
                Status = HStatus
        ).

importmodule_parse_term(Module,Code,Status) :-
        export_check_module(Module,Status),
        \+get_flvar_struct(Module,_),
        parse_body_pathexp(Module,DISALLOW_TRANS,NULL,PURE_PATHEXPS_ONLY,Code1,Status),
        flimportmodule_struct(Code1,Code),
        !.

%% error case
importmodule_parse_term(Term,[],Status) :-
        get_index(Term,Ind),
        parsing_error(Ind,ERROR_IMPORT_MODULE_SYNTAX,Status).



/******************** PARSING FOR EXPORT ********************************/

/************************************************************************
        The canonical term structure is something like this:
                canoterm(export, N, FL_PARENTHESIS, Args, _, _)
        N       -> Indicates the number of terms in the external module (modules exported too) list.
        Args    ->[canoterm(>>, N', FL_PARENTHESIS, Args', _, _) | <ExportedModuleList = m2,m3... mn>]
        Args'   ->[canoterm(Exported_Term), m1],

        Semantics:
        1.No external modules specified:
          The particular perdicate has to be exported to all modules.

        2.None of the predicates of a module are exported:
          The modules does not require any encapsulation.

        When N=1, the difference is the following:

        In the case where there is a module name, the argument Args:
                canoterm(>>, N', FL_PARENTHESIS, Args', _, _)
        and Args' contains the exported term & the first module name.

        In case there is no external module.
        1. there is no >>
        2. the third argument is FL_BRACKET
        3. the canonical term actually represents the exported term

        The exported term list is first regularized and converted to
        a form  = [(ws,term,modules,is_updatable), (ws,term,modules,is_updatable), ...].
        We then individually work with the members of the list, reporting
        any errors if they occur.

****************************************************************************/


/****************************************************************************
 exec_export_directive(+CanoniTerm,+FloraModSpec,-CodeList,-Status)
 Parsing for the executable directive case.
****************************************************************************/
%% Export for a dynamic module.
%% WS = dynamic module name, may or may not be specified.
exec_export_directive(CanoniTerm,WS,CodeList,Status):-
        export_directive(CanoniTerm,WS,CodeList,Status).


/****************************************************************************
 export_directive(+CanoniTerm,+WorkSpace,-CodeList,-Status)
 The work-horse that does the parsing both in the executable and
 non-executable case.
****************************************************************************/
export_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),WS,[Code],Status) :-
        %% check directive name.
        get_name(Funct,FL_EXPORT),
        %% parse the exported terms
        regularize_export_spec(Args,WS,TermList),
        %% parse the list
        export_parse_term_list(TermList,[],TermListCode,Status),
        flexport_struct_list(TermListCode,Code),
        !.

%% error case.
export_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),_WS,_Code,Status) :-
        %% check directive name.
        get_name(Funct,FL_EXPORT),
        !,
        parsing_error(If,ERROR_EXPORT_PATH,Status).


/****************************************************************************
 regularize_export_spec(+ExportedTerms,+WorkSpace,-CodeList,-Status)
 The work-horse that first regularises and then does the parsing both 
 in the executable and non-executable case.
****************************************************************************/
%% Export as an operator, multiple terms exported.
%% :-(export(','((term>>m1),m2,m3... ))
regularize_export_spec([CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip)],WS,ListCode) :-
        get_name(Funct,FL_COMMA),
        !,
        %% convert a comma-separated list into a normal list
        comma_separated_canoterm_to_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),List),
        %% regularize to a list
        export_compose_term_list(List,[],WS,_IsUpd,ListCode).

%% no workspaces within the export expressions
regularize_export_spec([CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,_If,_Ip)],_WS,_ListCode) :-
        get_name(Funct,FL_AT),
        !,
        fail.

%% for all other cases.
%% :-(export( (term1),(term2),(term3) ))
%% One or many terms exported (may be enclosed by paranthesis).
%% typical canonical term = (export((term>>m1),m2,m3...mn))
regularize_export_spec(Args,WS,ListCode) :-
        %% regularize to a list
        export_compose_term_list(Args,[],WS,_IsUpd,ListCode),
        !.


/****************************************************************************
 export_compose_term_list(+Args,+InitTermCode,+WorkSpace,+IsUpdatable,-ExportCode)
 InitTermCode represents the list of terms processed till now.
 It is initally an empty list ([]) and gets populated progressively.
***************************************************************************/
%% single term exported
%% t1>>m1,m2,m3
export_compose_term_list(Args,_InitTermCode,WS,IsUpd,[Code]) :-
        export_check_single_term(Args),
        export_compose_term(Args,WS,IsUpd,Code).

export_compose_term_list([H|T],InitTermCode,WS,IsUpd,Code) :-
        %% The export_compose_term expects the argument to be a list.
        %% That list may contain more than one members in the case where the 
        %% term is exported to more than one modules.
        export_compose_term([H],WS,IsUpd,TermCode),
        %% The Code is usually a single term. However in cases 
        %% like (t1,t2) >> (m1,m2,m3), it is a list. In this case
        %% we need to explicitly append it to a list.
        %% When it is not a list, (t >> m1,m2...), then the append
        %% will fail and hence the second case.
        (       
          %% If TermCode is a list - append
          %% Happens when exported things like (t1,t2) >> (m1,m2,m3)
          append(TermCode,InitTermCode,List)

        ;
          %% TermCode is a simple term and not a list.
          List = [TermCode|InitTermCode]
        ),
        export_compose_term_list(T,List,WS,IsUpd,Code).

export_compose_term_list([],InitTermCode,_WS,_IsUpd,Code) :- 
        Code = InitTermCode,
        !.

/****************************************************************************
 export_compose_term(+ExportedTerm,+WorkSpace,+IsUpdatable,-TermCode)
****************************************************************************/
%% with the updatable tag.
export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,Args,_If,_Ip)],WS,_IsUpdatable,ExportCode) :-
        %% check whether the Funct is updatable
        get_name(Funct,FL_UPDATABLE),
        %% single or mutiple terms enclosed.
        (export_compose_term(Args,WS,FL_UPDATABLE,ExportCode) -> true
        ;
          export_compose_term_list(Args,[],WS,FL_UPDATABLE,ExportCode)
        ).


/****************************************************************************
 One or many external modules (or terms) specified.
 ==================================================
 Term >> (Module(s))
 canoterm(RIGHTTO,_,FL_PARENTHESIS, [canoterm(Term),canoterm(ModuleList)],_,_)

 (Term1, Term2, ...) >> (Module(s))
 canoterm(RIGHTTO,N,FL_PARENTHESIS, [ canoterm(comma,_,FL_PARENTHESIS,[canoterm(Term1),canoterm(Term2)...],_,_),
                                     canoterm(ModuleList)
                                   ],_,_)

 Term >> Module(s)
 canoterm(RIGHTTO,_,FL_PARENTHESIS, [canoterm([Term,FirstModule]),OtherModuleList],_,_)
****************************************************************************/
export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,[Term|FirstModule],_If,_Ip)|OtherModules],WS,IsUpdatable,Code) :- 
        get_name(Funct,FL_RIGHTTO),
        append(FirstModule,OtherModules,Modules),
        (
                %% may be a list of term instead of a sinlge term.
                %% (t1,t2) >> (m1,m2)
                export_wrap_multiple_terms(WS,Term,Modules,IsUpdatable,Code)
        ;       
                flexport_wrap_term(WS,Term,Modules,IsUpdatable,Code)
        ),
        !.


/****************************************************************************
 First term in case when export is used as an operator.
 ==================================================
 Say the export statement is :- export (_[c1->_]>>m3,m4), _[b1(_,_)->_]>>m1.

 comma_separated_list returns the exported list in the following form:
 [ canoterm(comma,_,FL_PARENTHESIS,[canoterm(FirstExportedTerm)],_,_),
   canoterm(SecondExportedTerm), ....]

 Thus for the first term, we need extract the canonical term by stripping the 
 comma. The predicate below does the same.
****************************************************************************/
export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,Args,_If,_Ip)],WS,IsUpdatable,Code) :- 
        get_name(Funct,FL_COMMA),
        export_compose_term(Args,WS,IsUpdatable,Code),
        !.

/****************************************************************************
 No modules specified (=exported to all modules).
 ================================================
 export(p(_,_)).
 export(_[a->_]).
 Term = canoterm(ExportedTerm)
****************************************************************************/
export_compose_term([CANOTERM(Funct,N,PType,Args,If,Ip)],WS,IsUpdatable,Code) :- 
        flexport_wrap_term(WS,CANOTERM(Funct,N,PType,Args,If,Ip),[],IsUpdatable,Code),
        !.

%% simple atom exported, export(flora2).
export_compose_term([Args],WS,IsUpdatable,Code) :- 
        get_name(Args,_Name),
        flexport_wrap_term(WS,Args,[],IsUpdatable,Code),
        !.

export_compose_term([Args],WS,IsUpdatable,Code) :- 
        get_transactionalatom(Args,_Name),
        flexport_wrap_term(WS,Args,[],IsUpdatable,Code),
        !.

%% variable exported. export(F).
export_compose_term([OBJECT(VARIABLE(Term),N)],WS,IsUpdatable,Code) :- 
        flexport_wrap_term(WS,OBJECT(VARIABLE(Term),N),[],IsUpdatable,Code),
        !.

export_compose_term([OBJECT(TRANSACTIONAL_VARIABLE(Term),N)],WS,IsUpdatable,Code) :- 
        flexport_wrap_term(WS,OBJECT(TRANSACTIONAL_VARIABLE(Term),N),[],IsUpdatable,Code),
        !.

/****************************************************************************
 export_wrap_multiple_terms(+WorkSpace,+Args,+InitTermCode,+Modules,+IsUpdatable,-Code)
 Transfroms (t1,t2) >> (m1,m2,m3) --> [(t1,(m1,m2,m3)) , (t2,(m1,m2,m3))]
***************************************************************************/
export_wrap_multiple_terms(WS,CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),Modules,IsUpdatable,Code) :-
        get_name(Funct,FL_COMMA),
        %% convert a comma-separated list into a normal list
        comma_separated_canoterm_to_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),List),
        export_wrap_termlist(List,[],WS,Modules,IsUpdatable,Code).


/****************************************************************************
 export_wrap_termlist(+Args,+InitTermCode,+WorkSpace,+Modules,+IsUpdatable,-Code)
***************************************************************************/
export_wrap_termlist([H|T],InitTermCode,WS,Modules,IsUpdatable,Code) :-
        flexport_wrap_term(WS,H,Modules,IsUpdatable,HCode),
        export_wrap_termlist(T,[HCode|InitTermCode],WS,Modules,IsUpdatable,Code).

export_wrap_termlist([],InitTermCode,_WS,_Modules,_IsUpd,Code) :- 
        Code = InitTermCode,
        !.
        

/****************************************************************************
 export_parse_term_list(+TermList,+IntialTermCode,-TermListCode,-Status)
****************************************************************************/
export_parse_term_list([H|T],InitialTerm,Code,Status) :-
        export_parse_term(H,HCode,HStatus),
        ( HStatus == NO_ERRORS ->
            export_parse_term_list(T,[HCode|InitialTerm],Code,Status)
        ;
            Status = HStatus
        ).

export_parse_term_list([],InitialTerm,Code,NO_ERRORS) :-
        Code = InitialTerm,
        !.


/****************************************************************************
 export_parse_term(+Term,-TermCode,-Status)
 Term = (WS,Term,Modules,IsUpd)
 TermCode = flrexport()
        The parsing of the exported term(s) takes place in two steps. 
 Initially, each exported term is normalized and wrapped in its 
 standard form. This list then gets parsed by unwrapping its members
 one-by-one.
****************************************************************************/
export_parse_term(TermCode,ExportCode,Status) :-
        flexport_unwrap_term(TermCode,WS,Term,Modules,IsUpdatable),
        %% check for errors in the term exported
        export_check_error(Term,S1),
        (S1==NO_ERRORS -> export_check_module(Modules,S2)
        ;
            S2=S1
        ),
        (S2==NO_ERRORS -> 
            export_parse_body_term(Term,WS,TCode,StatusBody),
            flfact_struct(TCode,FactTermCode),
            %% the module(s)
            (StatusBody == NO_ERRORS ->
                export_parse_modules(Modules,ModuleCode,Status)
            ;
                Status = StatusBody
            ),
            fllist_struct(ModuleCode,[],1,ModuleCodeList),
            export_struct(WS,FactTermCode,ModuleCodeList,IsUpdatable,ExportCode)
        ; Status=S2
        ).


/****************************************************************************
 export_parse_body_term(+Args,+WS,-Code,-Status)
 Parses the predicate body by calling the appropriate parse_rule_body predicate.
      WS is initialized through the exec_export_directive call. 
      When the same module exports the term, WS will be NULL.
      Else, it may be an atom or a variable.
 ATOM: ?- (export foo)@bar.
 VARIABLE: ?- (export foo)@?WS.
      In the latter case, the variable WS needs to be instantaited when the
 program is loaded else an error (Attempt to export from an invalid or 
 uninstantiated module/term) will be reported.
****************************************************************************/
export_parse_body_term(Term,WS,Code,Status) :-
        parse_rule_body(Term,WS,WS,Code,Status).


/****************************************************************************
 export_parse_modules(+Args,-ModuleCode,-Status)
***************************************************************************/
%% term >> (m1,m2,m3...mn). Modules enclosed within paranthesis.
export_parse_modules([CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip)],OtherModuleList,Status) :-
        get_name(Funct,FL_COMMA),
        !,
        comma_separated_canoterm_to_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),ModuleList),
        parse_body_pathexplist(ModuleList,NULL,PURE_PATHEXPS_ONLY,OtherModuleList,Status).
        
%% general case, term>>m1,m2,m3...mn. Modules NOT enclosed within parentheses.
export_parse_modules(OtherModules,OtherModuleList,Status) :-
        %% the other module names 
        parse_body_pathexplist(OtherModules,NULL,PURE_PATHEXPS_ONLY,OtherModuleList,Status).


/****************************************************************************
 export_struct(+WorkSpace,+TermCode,+ModuleListCode,+IsUpdatable,-ExportCode)
**************************************************************************/
export_struct(WS,TermCode,ModuleCodeList,IsUpdatable,ExportCode) :-
        flora_get_module_from_spec(WS,_ModuleType,Module),
        flexport_struct(Module,TermCode,ModuleCodeList,IsUpdatable,ExportCode).


/**************** start of error handling for export ************************/


/****************************************************************************
 export_check_single_term(+Term)
 %% whether only one term is exported.
 %% [Term,m1,m2...], term and the modules to which it is exported.
****************************************************************************/
%% module name is atom.
export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),OBJECT(IDENTIFIER(_Atom),_)|_T]) :- !.
%% module is system module.
export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),
                          CANOTERM(OBJECT(IDENTIFIER(_ATOM),_),_N1,_FL1,_ARGS,_If1,_Ip1)|_T]) 
                                :-!.
%% module name is variable.
export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),OBJECT(VARIABLE(_Atom),_)|_T]) :- !.


/****************************************************************************
 export_check_error(+Term,-Status)
****************************************************************************/
%% a simple atom exported.
export_check_error(Atom,NO_ERRORS) :-
        get_name(Atom,_Name),
        !.      

export_check_error(Atom,NO_ERRORS) :-
        get_transactionalatom(Atom,_Name),
        !.      

%% hilog predicate case, p(_,_) or %p(_,_)
export_check_error(CANOTERM(MethodName,_N,FL_PARENTHESIS,ArgList,_If,_Ip),Status) :-
        export_check_method_name(MethodName,S1),
        (S1==NO_ERRORS ->
            export_check_attribute_list(ArgList,Status)
        ; 
            Status=S1
        ),
        !.
        
%% Object spec : ...[...]
export_check_error(CANOTERM(ObjectID,_N,FL_BRACKET,[MethodBody],_If,_Ip),Status) :-
        export_check_variable(ObjectID,S1),
        (S1 == NO_ERRORS -> export_check_method(MethodBody,Status)
        ;
            Status=S1
        ),
        !.

%% Case when the term is a variable. Let it go through.
%% Term >> m1, m2
export_check_error(OBJECT(VARIABLE(_Term),_),NO_ERRORS).
export_check_error(OBJECT(TRANSACTIONAL_VARIABLE(_Term),_),NO_ERRORS).


/****************************************************************************
 export_check_variable(+Term,-Status)
****************************************************************************/
export_check_variable(Term,Status) :-
        ( get_flvar_struct(Term,_VariableStruct) -> Status = NO_ERRORS
        ; export_construct_error(Term,ERROR_EXPORT_ATOM,Status)
        ).


/****************************************************************************
 export_check_method(+Term,-Status)
****************************************************************************/
%% multiple predicates, separated by commas are exported to a set of modules.
export_check_method([H|T],Status) :-
        export_check_method(H,S1),
        (S1==NO_ERRORS -> export_check_method(T,Status)
        ;
            Status=S1
        ).

export_check_method(CANOTERM(Funct,_N,FL_PARENTHESIS,[H|T],_If,_Ip),Status) :-
        get_atom(Funct,FL_COMMA),
        export_check_method(H,S1),
        (S1==NO_ERRORS -> export_check_method(T,Status)
        ;
            Status=S1
        ),
        !.

export_check_method([],NO_ERRORS) :- !.

%% _[MethodName(AttrList) -> _]
%% _[MethodName(AttrList) => _]
export_check_method(CANOTERM(MethodSpec,_N1,FL_PARENTHESIS,[CANOTERM(MethodName,_N2,FL_PARENTHESIS,AttributeList,_If2,_Ip2),ReturnVar],_If1,_Ip1),Status) :-
        export_check_spec(MethodSpec,S1),
        (S1==NO_ERRORS -> export_check_method_name(MethodName,S2)
        ;
            S2=S1
        ),
        (S2==NO_ERRORS -> export_check_attribute_list(AttributeList,S3)
        ;
            S3=S2
        ),
        (S3==NO_ERRORS -> export_check_variable(ReturnVar,Status)
        ;
            Status=S3
        ),
        !.

%% method with no attributes.
%% _[MethodName -> _]
%% _[MethodName => _]
export_check_method(CANOTERM(MethodSpec,_N1,FL_PARENTHESIS,[MethodName,ReturnVar],_If1,_Ip1),Status) :-
        export_check_spec(MethodSpec,S1),
        (S1==NO_ERRORS -> export_check_method_name(MethodName,S2)
        ;
            S2=S1
        ),
        (S2==NO_ERRORS -> export_check_variable(ReturnVar,Status)
        ;
            Status=S2
        ),
        !.

%% tabled Boolean method like _[p(_)]
export_check_method(CANOTERM(MethodName,_N1,FL_PARENTHESIS,AttributeList,_If1,_Ip1),Status) :-
        export_check_method_name(MethodName,S1),
        (S1==NO_ERRORS -> export_check_attribute_list(AttributeList,Status)
        ;
            Status=S1
        ),
        !.

%% No arguments & return value (like [p]).
export_check_method(Term,Status) :-
        export_check_method_name(Term,Status).


/****************************************************************************
 export_check_method_name(+Term,-Status)
****************************************************************************/
%% case of a CURI
export_check_method_name(CANOTERM(MethodName,_N1,FL_PARENTHESIS,_AttributeList,_If1,_Ip1),NO_ERRORS) :-
        get_atom(MethodName,FL_CURIOP),
        !.
%% exported terms like p(a,?)[...] are not allowed.
export_check_method_name(CANOTERM(MethodName,_N1,FL_PARENTHESIS,AttributeList,_If1,_Ip1),Status) :-
        export_check_method_name(MethodName,S1),
        (S1==NO_ERRORS -> export_check_attribute_list(AttributeList,Status)
        ;
            Status=S1
        ),
        !.

%% only names with constant object ids like p, q allowed.
export_check_method_name(Term,Status) :-
        ( get_name(Term,_Name) -> Status = NO_ERRORS
        ; get_transactionalatom(Term,_Atom) -> Status = NO_ERRORS
        ; export_construct_error(Term,ERROR_EXPORT_ATOM_ATTR,Status)
        ).
                                        

/****************************************************************************
 export_check_spec(+Term,-Status)
 The term exported may be one of the following types:
        p ->  _
        p : q
        p :: q
 Thus this predicate checks whether the spec is allowed.
 is_birelop for (:,::), is_export_spec for (->).
****************************************************************************/
export_check_spec(Funct,NO_ERRORS) :-
        get_atom(Funct,F),
        (
          is_birelop(F)
        ;
          is_export_spec(F)
        ),
        !.

%% error, in case the spec is not one of the above, signal an error.
export_check_spec(OBJECT(QUOTED_ATOM(Name),I),Status) :-
        export_construct_error(OBJECT(QUOTED_ATOM(Name),I),ERROR_EXPORT_SPEC,Status).


/****************************************************************************
 export_check_attribute_list(+Term,-Status)
****************************************************************************/
export_check_attribute_list([H|T],Status) :-
        ( get_flvar_struct(H,_VariableStruct) -> S1=NO_ERRORS
        ; 
          %% If H is not a var, then construct error
          export_construct_error(H,ERROR_EXPORT_ATOM,S1)
        ),
        (S1==NO_ERRORS -> export_check_attribute_list(T,Status)
        ;
            Status=S1
        ).

export_check_attribute_list([],NO_ERRORS) :- !.


/****************************************************************************
 export_check_module(+Term,-Status)
****************************************************************************/
%% comma separated values.
export_check_module(CANOTERM(Funct,_N,FL_PARENTHESIS,ModList,_If,_Ip),Status) :-
        get_atom(Funct,FL_COMMA),
        export_check_module(ModList,Status),
        !.

%% a simple list
export_check_module([],NO_ERRORS) :- !.
export_check_module([H|T],Status) :-
        ( export_check_module(H,StatusModule) -> true
        ; parse_workspace(H,_HCode,StatusModule) -> true
        ; export_construct_error(H,ERROR_EXPORT_MODULE,StatusModule)
        ),
        (StatusModule == NO_ERRORS -> export_check_module(T,Status) 
        ;
            Status = StatusModule
        ),
        !.

export_check_module(H,Status) :-
        parse_workspace(H,_HCode,StatusModule),
        (StatusModule == NO_ERRORS -> Status = NO_ERRORS
        ; 
            export_construct_error(H,ERROR_EXPORT_MODULE,Status)
        ),
        !.


/****************************************************************************
 export_construct_error(+Term,+ErrorMessage,-StatusError)
****************************************************************************/
export_construct_error(Term,ErrMessage,Status) :- 
      get_index(Term,ErrNo),
      parsing_error(ErrNo,ErrMessage,Status).
/**************** end of error handling for export *************************/
/**************** end of parsing for export ********************************/

/****************************************************************************
  operator_directive(CanoniTerm,CodeList,Status)
  operator_definition(+Atom)
  operator_list(+Number,+Associativity,+OperatorList,-CodeList,-Status)
****************************************************************************/
operator_directive(CANOTERM(Funct,3,FL_BRACE,L,_If,_Ip),CodeList,Status) :-
        get_name(Funct,FL_OP),
        L=[Number,Associativity,Operator],
        ( get_integer(Number,Precedence), Precedence > 0 ->
            ( get_name(Associativity,A), operator_definition(A) ->
                ( get_atom(Operator,Op) ->
                    ( flora_conflict_operator(Precedence,A,Op) ->
                        parsing_error(Operator,NO_REDEFOP,Status)
                    ;
                      flopdef_struct(Precedence,A,Op,Code),
                      CodeList=[Code],
                      Status = NO_ERRORS
                    )

                ;  Operator=CANOLIST(OpList,T,N,_I,Ib), N > 0 ->
                     ( T == [] ->
                         parse_operator_list(OpList,Precedence,A,CodeList,Status)
                     ;
                       parsing_error(Ib,NO_LISTTAIL,Status)
                     )
                ;
                  parsing_error(Operator,ERROR_OPERATOR,Status)
                )
            ;
              parsing_error(Associativity,ERROR_OPDEF,Status)
            )
        ;
          parsing_error(Number,EXP_POSINTEGER,Status)
        ).


operator_definition(xfx) :- !.
operator_definition(yfx) :- !.
operator_definition(xfy) :- !.
operator_definition(fx)  :- !.
operator_definition(fy)  :- !.
operator_definition(yf)  :- !.
operator_definition(xf)  :- !.


parse_operator_list([],_Number,_Associativity,[],NO_ERRORS) :- !.

parse_operator_list([T|L],Number,Associativity,[Code|CodeList],Status) :-
        !,
        ( get_atom(T,Op) -> %% symbol tokens allowed as operators
            ( flora_conflict_operator(Number,Associativity,Op) ->
                parsing_error(T,NO_REDEFOP,Status)
            ;
                flopdef_struct(Number,Associativity,Op,Code),
                parse_operator_list(L,Number,Associativity,CodeList,Status)
            )
        ;
          parsing_error(T,ERROR_OPERATOR,Status)
        ).


/****************************************************************************
  index_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
index_directive(CANOTERM(Funct,N,FL_BRACE,[L|_Rest],_If,_Ip),[Code],Status) :-
    get_name(Funct,FL_INDEX),
    ( N==1 ->
        ( minus_pair(L,Arity,Pos) ->
            Status = NO_ERRORS,
            flindxdirect_struct(Arity,Pos,Code)
        ;
            parsing_error(L,ERROR_INDXDIREC,Status)
        )
    ;
        parsing_error(L,ERROR_INDXDIREC,Status)
    ).


minus_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),A,Pos) :-
    get_name(Funct,FL_MINUS),
    ( get_integer(L,Arity),A=Arity, !
    ;
        %% transactional numbers are used only in :- index %arity-argument
        get_transactionalinteger(L,Arity), fltransactionalnumber_struct(L,A)
    ),
    get_integer(R,Pos),
    Pos>0,
    Arity>=Pos.

/****************************************************************************
  exec_index_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
exec_index_directive(CANOTERM(Funct,1,FL_BRACE,[L],_If,_Ip),[Code],Status) :-
    get_name(Funct,FL_INDEX),
    ( minus_var_pair(L,Arity,Pos) ->
        Status = NO_ERRORS,
        flindxdirect_struct(Arity,Pos,Code)
    ;
        parsing_error(L,ERROR_INDXDIREC,Status)
    ).


exec_index_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,_T,_If,Ip),[_Code],Status) :-
    get_name(Funct,FL_INDEX),
    parsing_error(Ip,ERROR_INDXDIREC,Status).

minus_var_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Arity,Pos) :-
    get_name(Funct,FL_MINUS),
    %% transactional numbers are used only in :- index %arity-argument
    (
      (get_transactionalinteger(L,A), fltransactionalnumber_struct(L,Arity)
      ;
          get_integer(L,A), flobject_struct(L,Arity)
      )
    ->
      ( get_integer(R,P)
      ->
          P>0,
          A>=P,
          flobject_struct(R,Pos)
      ;
          get_flvar_struct(R,Pos)
      )
    ;
      (get_fltransactionalvar_struct(L,Arity); get_flvar_struct(L,Arity)),
      ( get_integer(R,P)
      ->
          flobject_struct(R,Pos)
      ;
          get_flvar_struct(R,Pos)
      )
    ).


/****************************************************************************
  prolog_directive(+CanoniTerm,-CodeList,-Status)
  table_directive(+CanoniTerm,-CodeList,-Status)
  usesensor_directive(+CanoniTerm,-CodeList,-Status)
  usefunction_directive(+CanoniTerm,-CodeList,-Status)

  Define a low-level predicate as a prolog predicate
  Table those predicates.
  Used for sensors and builtins primarily
****************************************************************************/
prolog_directive(CANOTERM(Funct,_N,FL_BRACE,Args,If,_Ip),[Code],Status) :-
        get_name(Funct,FL_PROLOG),
        !,
        set_context(restrict_reserved_keywords_arity),
        make_pred_arity_pair_list(Args,ArgCode,Status),
        clear_context(restrict_reserved_keywords_arity),
        flprologdirect_struct(ArgCode,If,Code).

exec_prolog_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),[_Code],Status) :-
        get_name(Funct,FL_PROLOG),
        !,
        parsing_error(If,NO_EXEC_PROLOG_DIRECTIVE,Status).

table_directive(CANOTERM(Funct,_N,FL_BRACE,Args,If,_Ip),[Code],Status) :-
        get_name(Funct,FL_TABLE),
        !,
        set_context(restrict_reserved_keywords_arity),
        make_pred_arity_slash_list(Args,ArgCode,Status),
        clear_context(restrict_reserved_keywords_arity),
        fltabledirect_struct(ArgCode,If,Code).

exec_table_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),[_Code],Status) :-
        get_name(Funct,FL_TABLE),
        !,
        parsing_error(If,NO_EXEC_TABLE_DIRECTIVE,Status).

nontabled_module_directive(CanoniTerm,[Code],NO_ERRORS) :-
        is_obj_identifier_struct(CanoniTerm,FL_NONTABLEDMOD,_Idx),
        !,
        flnontabled_module_struct(Code).
nontabled_module_directive(CanoniTerm,[Code],NO_ERRORS) :-
        is_obj_identifier_struct(CanoniTerm,FL_NONTABLEDDATAMOD,_Idx),
        !,
        flnontabled_data_module_struct(Code).

usesensor_directive(CANOTERM(Funct,_N,FL_BRACE,Args,If,_Ip),[Code],Status) :-
        get_name(Funct,FL_USESENSOR),
        !,
        set_context(CONTEXT_PARSER_USESENSOR_DIRECTIVE),
        make_pred_arity_slash_list(Args,ArgCode,Status),
        clear_context(CONTEXT_PARSER_USESENSOR_DIRECTIVE),
        flusesensordirect_struct(ArgCode,If,Code).

usefunction_directive(CANOTERM(Funct,_N,FL_BRACE,Args,If,_Ip),[Code],Status) :-
        get_name(Funct,FL_USEUDF),
        !,
        make_pred_arity_slash_list(Args,ArgCode,Status),
        flusefunctiondirect_struct(ArgCode,If,Code).
        

/****************************************************************************
      defsensor_directive(+CanoTerm,-Code,-Status)
      The compiler constructs a call to flrdelaysupport:flora_register_sensor/6

      The sensor directive has the form:

      :- sensor SensorCall,DelayCondition
      :- sensor SensorCall,XSBModule,DelayCondition

      The first argument to a sensor call is a free variable tht will be
      bound to a file name. The second is bound to a line number.
      The bindings for these vars are supplied by the compiler.
****************************************************************************/
%% version with an explicit XSB module for sensor
defsensor_directive(CANOTERM(Funct,3,FL_BRACE,[SensorCall,SensorXSBMod,DelayCond],_If,Ip),Code,Status) :-
        get_name(Funct,FL_DEFSENSOR),
        !,
        defsensor_directive_internal(SensorCall,SensorXSBMod,DelayCond,Ip,Code,Status).

%% version without explicit XSB module
defsensor_directive(CANOTERM(Funct,2,FL_BRACE,[SensorCall,DelayCond],_If,Ip),Code,Status) :-
        get_name(Funct,FL_DEFSENSOR),
        !,
        defsensor_directive_internal(SensorCall,usermod,DelayCond,Ip,Code,Status).

defsensor_directive(CANOTERM(Funct,_,FL_PARENTHESIS,_,_If,Ip),_,Status) :-
        get_name(Funct,FL_DEFSENSOR),
        !,
        parsing_error(Ip,INVALID_SENSOR_DECL,Status).


defsensor_directive_internal(SensorCall,SensorXSBMod,DelayCond,Ip,[Code],Status) :-
        %% XSB module is an atom
        (fixup_object(SensorXSBMod,SensorModObj),
            get_name(SensorModObj,SensorModName)
        ->
            S1 = NO_ERRORS
        ;   parsing_error(Ip,INVALID_SENSOR_MOD, S1)
        ),
        (S1 == NO_ERRORS,
            SensorCall = CANOTERM(SensFunct,_,_,_,_,_),
            %% if get_name/2 fails, it implies that SensFunct can't
            %% be a reserved keyword
            get_name(SensFunct,SensName),
            is_disallowed_reserved_builtin(SensName)
        -> parsing_error(SensFunct,ERROR_RESERVED_SYMBOL,S11)
        ; S11 = S1
        ),
        parse_pure_prolog_term(SensorCall,SensorModName,SensorCallCode,VarNameList1-Tail1,S2),
        %% parse_pure_prolog_term returns its own error codes, so
        %% we change them to a more appropriate error for this particular case
        (S2 == NO_ERRORS -> S22 = NO_ERRORS
        ; parsing_error(Ip,INVALID_SENSOR_CALL,S22)
        ),
        Tail1 = [],
        parse_pure_prolog_term(DelayCond,usermod,DelayCondCode,VarNameList2-Tail2,S3),
        (S3 == NO_ERRORS -> S33 = NO_ERRORS
        ; parsing_error(Ip,INVALID_SENSOR_COND,S33)
        ),
        Tail2 = [],
        (subset(VarNameList2,VarNameList1) -> S4 = NO_ERRORS
        ; parsing_error(Ip,SENSOR_VARS_ERROR,S4)
        ),
        merge_status([S11,S22,S33,S4],Status),
        flsensordirect_struct(SensorCallCode,DelayCondCode,Code).


/****************************************************************************
  setsemantics_directive(+CanoniTerm,-CodeList,-Status)
  exec_setsemantics_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
setsemantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),[Code],Status) :-
        get_name(Funct,FL_SETSEMANTICS),
        !,
        set_context(static_setsemantics_directive),
        parse_semantics_directive_args(DISALLOW_VARIABLES,Args,ArgsCode,Status),
        clear_context(static_setsemantics_directive),
        (Status == NO_ERRORS -> flsetsemanticsdirect_struct(ArgsCode,Code)
        ;
          true
        ).


exec_setsemantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip), [Code],Status) :-
        get_name(Funct,FL_SETSEMANTICS),
        !,
        parse_semantics_directive_args(DISALLOW_VARIABLES,Args,ArgsCode,Status),
        (Status == NO_ERRORS -> flsetsemanticsdirect_struct(ArgsCode,Code)
        ;
          true
        ).

/****************************************************************************
  exec_semantics_directive(+CanoniTerm,-CodeList,-Status)
  This is like setsemantics, but it is a query rather than command,
  so variables are allowed.
****************************************************************************/
semantics_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip), _Code,Status) :-
        get_name(Funct,FL_SEMANTICS),
        !,
        parsing_error(If,ERROR_EXECUTABLE_DIRECTIVE_ONLY,Status).

exec_semantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),[Code],Status) :-
        get_name(Funct,FL_SEMANTICS),
        !,
        parse_semantics_directive_args(ALLOW_VARIABLES,Args,ArgsCode,Status),
        (Status == NO_ERRORS -> flsemanticsdirect_struct(ArgsCode,Code)
        ;
          true
        ).

/****************************************************************************
  exec_setruntime_directive(+CanoniTerm,-CodeList,-Status)
  This is executable setruntime{...} directive for setting timeouts, subgoal
  size, answer size.
****************************************************************************/

exec_setruntime_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip), [Code],Status) :-
        get_name(Funct,FL_SETRUNTIME),
        !,
        parse_setruntime_directive_args(Args,ArgsCode,Status),
        (Status == NO_ERRORS -> flsetruntime_direct_struct(ArgsCode,Code)
        ;
          true
        ).

parse_setruntime_directive_args([],[],NO_ERRORS) :- !.
parse_setruntime_directive_args([CANOTERM(F,N,FL_PARENTHESIS,Args,If,Ip)|Rest],[OptCode|RestCode],Status) :-
        N>0,
        parse_one_setruntime_directive(CANOTERM(F,N,FL_PARENTHESIS,Args,If,Ip),OptCode,S1),
        !,
        (S1==NO_ERRORS -> parse_setruntime_directive_args(Rest,RestCode,Status)
        ;
            Status = S1
        ).
parse_setruntime_directive_args([CANOTERM(_,_,_,_,If,_Ip)|_],_,Status) :-
        parsing_error(If,ERROR_RUNTIMEOPT,Status).

parse_one_setruntime_directive(CANOTERM(F,N,FL_PARENTHESIS,Args,If,Ip),OptCode,Status) :-
        get_atom(F,FAtom),
        is_valid_setruntime_option(FAtom,Args),
        !,
        (parse_pure_prolog_term(CANOTERM(F,N,FL_PARENTHESIS,Args,If,Ip),usermod,OptCode,_,S1),
            S1 == NO_ERRORS
        -> Status=S1
        ; parsing_error(Ip,ERROR_RUNTIMEOPT,Status)
        ).


is_valid_setruntime_option(memory,[Limit|Rest]) :-
        get_number(Limit,_),
        (Rest == []
        ; Rest = [Action], get_name(Action,ActionAtm), atom(ActionAtm)
        ),
        !.

%% clear timeout
is_valid_setruntime_option(timeout,Options) :-
        !,
        is_valid_timeout_option_list(Options).

is_valid_timeout_option_list([Time]) :-
        get_integer(Time,0),
        !.
is_valid_timeout_option_list(Options) :-
        is_valid_timeout_option_list1([repeating,max],Options).
is_valid_timeout_option_list1([],Rest) :- !, Rest = [].
is_valid_timeout_option_list1(_,[]) :- !.
is_valid_timeout_option_list1(TypeList,[CANOTERM(Type,2,FL_PARENTHESIS,[Num,_Handler],_,_)|Rest]) :-
        get_name(Type,TypeAtm),
        select(TypeAtm,TypeList,TypeListRest),
        get_integer(Num,V), V > 0,
        is_valid_timeout_option_list1(TypeListRest,Rest).

is_valid_setruntime_option(goalsize,[TermSize,_Handler]) :-
        !,
        get_integer(TermSize,VT), VT >= 0.
is_valid_setruntime_option(answersize,[TermSize,_Handler]) :-
        !,
        get_integer(TermSize,VL), VL >= 0.
is_valid_setruntime_option(activegoals,[TermSize,_Handler]) :-
        !,
        get_integer(TermSize,VL), VL >= 0.
is_valid_setruntime_option(unification,[Arg]) :-
        get_name(Arg,V),
        memberchk(V,[fast,correct]).
is_valid_setruntime_option(unsafe_naf,[Arg]) :-
        get_name(Arg,V),
        memberchk(V,[warn,ignore,ignoreonce]).
is_valid_setruntime_option(setof,[Arg]) :-
        get_name(Arg,V),
        memberchk(V,[lax,strict]).

/****************************************************************************
  is_valid_term_name(Atom)

  Term name cannot start with a % so not to confuse with actions
*************************************************************************/
is_valid_term_name(Atom) :-
        \+flratom_char_code(Atom,0,CH_PERCENT).


/****************************************************************************
  defeasible_directive(+CanoniTerm,-CodeList,-Status)

      :- use_argumentation_theory.
   or
      :- use_argumentation_theory{module}.
****************************************************************************/
defeasible_directive(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,_Ip),[Code],NO_ERRORS) :-
        get_name(Funct,FL_DEFEASIBLE_DIRECTIVE),
        (is_obj_identifier_struct(Arg,Atom,Index)
        ;
            get_flbuiltin_identifier_struct(Arg,Atom),
            get_index(Atom,Index)
        ),
        !,
        flatom_struct(Atom,Index,ModuleCode),
        %% 2nd argument of status in the defeasible theory
        %% is to be compiled as reified
        flora_get_flatomvar_name(ModuleCode,ModName),
        flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],ModName),
        fldefeasible_struct(ModuleCode,Code).

defeasible_directive(CanoniTerm,[Code],NO_ERRORS) :-
        is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DIRECTIVE,Idx),
        !,
        flatom_struct(FL_DEFAULT_DEFEASIBLE_THEORY,Idx,ModuleCode),
        %% 2nd argument of status in the defeasible theory
        %% is to be compiled as reified
        flora_get_flatomvar_name(ModuleCode,ModName),
        flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],ModName),
        fldefeasible_struct(ModuleCode,Code).

/******************************************************************************
  defeasible_rule_default_directive(+CanoniTerm,-Codelist,-Status)
******************************************************************************/

defeasible_rule_default_directive(CanoniTerm,[Code],NO_ERRORS) :-
        (is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DEFAULT_DIRECTIVE,_)
        ; is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DEFAULT_DIRECTIVE2,_)),
        !,
        fldefeasible_rule_default_struct(Code).

strict_rule_default_directive(CanoniTerm,[Code],NO_ERRORS) :-
        (is_obj_identifier_struct(CanoniTerm,FL_STRICT_DEFAULT_DIRECTIVE,_)
        ; is_obj_identifier_struct(CanoniTerm,FL_STRICT_DEFAULT_DIRECTIVE2,_)),
        !,
        flstrict_rule_default_struct(Code).

/****************************************************************************
   verbatim_directive(+CanoniTerm,-CodeList,-Status)

       :- verbatim{string}

   This passes STRING (which is supposed to be an atom) straight to the output
   (the .P file). Useful when one wants to include something in the output
   file directly.
****************************************************************************/
verbatim_directive(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),[Code],Status) :-
        get_name(Funct,FL_VERBATIM),
        !,
        fixup_object(Arg,ArgAtmObj),
        (get_atom(ArgAtmObj,Atom,Index) ->
            flatom_struct(Atom,Index,ArgCode),
            flverbatim_struct(ArgCode,Code),
            Status = NO_ERRORS
        ;
            parsing_error(Ip,ERROR_VERBATIM_DIRECT,Status)
        ).

/****************************************************************************
   encoding_directive(+CanoniTerm,-CodeList,-Status)

      Compiler directive
       :- encoding{string}

   This passes STRING = utf8, cp1252, latin1
****************************************************************************/
encoding_directive(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),[Code],Status) :-
        get_name(Funct,FL_ENCODING),
        !,
        fixup_object(Arg,ArgAtmObj),
        (get_atom(ArgAtmObj,Atom,Index),
            convert_flora_to_xsb_encoding(Atom,XSBEnc)->
            flatom_struct(XSBEnc,Index,ArgCode),
            flencoding_struct(ArgCode,Code),
            Status = NO_ERRORS
        ;
            parsing_error(Ip,ERROR_ENCODING_DIRECT,Status)
        ).



/****************************************************************************
   new_glob_oid_scope_directive(+CanoniTerm,-CodeList,-Status)

       :- suppress_rule_signatures.

   reset the count for global OIDs thereby changing the context.
   
****************************************************************************/

new_glob_oid_scope_directive(CanoniTerm,[Code],NO_ERRORS) :-
        is_obj_identifier_struct(CanoniTerm,FL_NEW_GLOBAL_OID_SCOPE,_),
        !,
        flrnew_global_oid_scope_structure(Code).


/****************************************************************************
   suppress_rule_signatures_directive(+CanoniTerm,-CodeList,-Status)

       :- suppress_rule_signatures.

   Tells the compiler to not output rule signatures.
   This is used for builtin libraries, since in most cases the rules in those
   libraries are neither deleted nor queried. So, outputting signatures delays
   the load time and hogs the main memory.

   Right now this DOESN'T affect dynamic rules (_add or insertrule{...}).
   But given this is intended for libraries, we don't need to extend this
   option to dynamic rules.
****************************************************************************/
suppress_rule_signatures_directive(CanoniTerm,[Code],NO_ERRORS) :-
        is_obj_identifier_struct(CanoniTerm,FL_SUPPRESS_RULE_SIGNATURES,_),
        !,
        flsuppress_rule_signatures_struct(Code).


%% struct db
flrule_structuredirect_struct(ERGO_STRUCTURE_DB_DIRECT).
exec_flrule_structuredirect_struct(Module,Flag,ERGO_STRUCTURE_DB_DIRECT(Module,Flag)).

rule_structure_db_directive(CanoniTerm,[Code],NO_ERRORS) :-
	is_obj_identifier_struct(CanoniTerm,ERGO_STRUCTURE_DB_DIRECT,_),
	!,
	flrule_structuredirect_struct(Code).

%% ?- use_rule_structure_db{Module,on/off}.
exec_rule_structure_db_directive(CANOTERM(Funct,2,FL_BRACE,[Arg1,Arg2],_If,_Ip),[Code],NO_ERRORS) :-
        is_obj_identifier_struct(Funct,ERGO_STRUCTURE_DB_DIRECT,_),
        parse_pure_term(Arg1,NULL,ModuleCode,Status1), Status1 == NO_ERRORS,
        parse_pure_term(Arg2,NULL,FlagCode,Status2), Status2 == NO_ERRORS,
        !,
        exec_flrule_structuredirect_struct(ModuleCode,FlagCode,Code).
exec_rule_structure_db_directive(CANOTERM(Funct,2,FL_BRACE,[Arg1,Arg2],_If,_Ip),[],Status) :-
        is_obj_identifier_struct(Funct,ERGO_STRUCTURE_DB_DIRECT,_),
        (parse_pure_term(Arg1,_,_,Stat1), Stat1 == NO_ERRORS ->
            parsing_error(Arg2,ERROR_USE_STRUCTDB_EXECDIRECT,Status)
	; parsing_error(Arg1,ERROR_USE_STRUCTDB_EXECDIRECT,Status)
        ).
%% end struct db


/****************************************************************************
  cmpopt_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the :- compiler_options directive of Flora-2
****************************************************************************/
cmpopt_directive(CANOTERM(Funct,_N,FL_BRACE,Options,_If,_Ip),[Code],Status) :-
        get_name(Funct,FL_CMPOPT),
        !,
        ( parse_cmpoptlist(Options,TCode,Status) ->
            ( Status == NO_ERRORS -> flcmpoptdirect_struct(TCode,Code)
            ; true
            )
        ;
            parsing_error(Funct,ERROR_CMPOPT,Status)
        ).

parse_cmpoptlist([],[],NO_ERRORS) :- !.
parse_cmpoptlist([H|T],[HCode|TCode],Status) :-
        %% parse_pure_prolog_term: Vars = [] meaning: not allowing variables
        ( parse_pure_prolog_term(H,usermod,HCode,Vars-[],S), Vars = [] ->       
            (S == NO_ERRORS -> parse_cmpoptlist(T,TCode,Status)
            ; Status = S
            )
        ;
            parsing_error(H,ERROR_CMPOPT,Status)
        ).

/****************************************************************************
  prefixdef_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the prefix directive in the form of
    :- uriprefix A="abcd",B="efgh",....
****************************************************************************/
prefixdef_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),Code,Status) :-
        get_name(Funct,Name),
        %% Locality=local/global. Local prefixes aren't inherited by added files
        (Name == FL_PREFIXDEF -> Locality = global
        ; Name == FL_LOCALPREFIXDEF -> Locality = local
        ),
        prefixdef_parse_term_list(Args,Locality,Code,Status),
        !.

%% error case.
prefixdef_directive(CANOTERM(Funct,_N,_,_Args,If,_Ip),[],Status) :-
        get_name(Funct,Name),
        memberchk(Name,[FL_PREFIXDEF,FL_LOCALPREFIXDEF]),
        !,
        parsing_error(If,ERROR_PREFIX_DEF,Status).

/****************************************************************************
 prefixdef_parse_term_list(+TermList,+Locality,-CodeList,-Status)
 Locality: local/global
***************************************************************************/
prefixdef_parse_term_list([],_,[],NO_ERRORS) :- !.

prefixdef_parse_term_list([H|T],Locality,Code,Status) :-
        prefixdef_parse_term(H,Locality,HCode,HStatus),
        ( HStatus == NO_ERRORS ->
                prefixdef_parse_term_list(T,Locality,TCode,Status),
                append(HCode,TCode,Code)
        ;
                Status = HStatus
        ).

/****************************************************************************
 prefixdef_parse_term(+CanoniTerm,+Locality,-Code,-Status)
 Locality: local/global. Local prefixes are not inherited by added files
 ****************************************************************************/
prefixdef_parse_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),Locality,[Code],Status) :-
        get_name(Funct,FL_UNIVEQ), 
        N==2, 
        !,
        Args=[PrefixHead,PrefixBody],
        %% check that prefix name(the part before '=') is an atom
        ( is_obj_identifier_struct(PrefixHead,NameCode,_)
        -> %% check that part after '=' is string, quoted atom, or identfier
            ( ( is_obj_ascii_string_struct(PrefixBody,BodyCode1,_),
                  atom_codes(BodyCode,BodyCode1)
              ; is_obj_identifier_struct(PrefixBody,BodyCode,_)
              ; is_obj_quoted_atom_struct(PrefixBody,BodyCode,_)
              ; is_obj_builtin_identifier_struct(PrefixBody,BodyCode,_)
              ),
              is_valid_term_name(BodyCode)
            -> 
                flprefixdef_struct(NameCode,Locality,BodyCode,Code),
                Status = NO_ERRORS

            ; get_index(PrefixBody,Index_Body),
              parsing_error(Index_Body,ERROR_PREFIX_BODY,Status)
            )

        ; get_index(PrefixHead,Index_Head),
          parsing_error(Index_Head,ERROR_PREFIX_HEAD,Status)
        ).

%% error case
prefixdef_parse_term(CANOTERM(_Funct,_N,_FL_PARENTHESIS,_Args,If,_Ip),_,[],Status) :-
        parsing_error(If,ERROR_PREFIX_DEF,Status).


/****************************************************************************
  ignoredep_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the :- ignore_depchk directive
****************************************************************************/
ignoredep_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),[Code],Status) :-
        get_name(Funct,FL_IGNOREDEP),
        ( parse_body_template_list(Args,LCode,Status) ->
            flignoredepdirect_struct(LCode,Code)
        ;
            parsing_error(Funct,EXP_SPECLIST,Status)
        ).

/****************************************************************************
  symbol_context_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the :- ignore_depchk directive
****************************************************************************/
symbol_context_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),[Code],Status) :-
        get_name(Funct,FL_SYMBOL_CONTEXT),
        ( parse_body_symbol_list(Args,LCode,Status) ->
            flsymbolcontextdirect_struct(LCode,Code)
        ;
            parsing_error(Funct,EXP_TERMSLIST,Status)
        ).
exec_symbol_context_directive(CANOTERM(Funct,_N,FL_BRACE,_Args,_If,_Ip),_Code,Status) :-
        get_name(Funct,FL_SYMBOL_CONTEXT),
        !,
        parsing_error(Funct,ERROR_COMPILETIME_DIRECTIVE_ONLY,Status).

/****************************************************************************
  parse_body_symbol_list(+List,-CodeList,-Status)
****************************************************************************/
parse_body_symbol_list([],[],NO_ERRORS) :- !.
parse_body_symbol_list([H|T],[HCode|TCode],Status) :- 
        parse_body_symbol(H,HCode,S),
        (S == NO_ERRORS ->
            parse_body_symbol_list(T,TCode,Status)
        ;
            Status = S
        ).


/****************************************************************************
  parse_body_symbol(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
parse_body_symbol(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        workspace_template(R,RCode,S),
        ( S == NO_ERRORS ->
            parse_body_symbol_literal(L,DISALLOW_TERM_DESCRIPTOR,LCode,Status),
            (Status == NO_ERRORS -> 
                flora_get_module_from_spec(RCode,ModuleType,Module),
                flmodule_struct(ModuleType,LCode,Module,Code)
            ; 
                true
            )
        ; 
            Status = S
        ).

parse_body_symbol(CANOTERM(Funct,1,FL_PARENTHESIS,[Term],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_SYMBOL_CONTEXT_UDF),
        !,
        check_context_spec(Term,S1),
        (S1 == NO_ERRORS ->
            parse_body_symbol_literal(Term,DISALLOW_TERM_DESCRIPTOR,TermCode,Status),
            fludfsymbol_struct(TermCode,Code)
        ; Status = S1
        ).

parse_body_symbol(CANOTERM(Funct,1,FL_PARENTHESIS,[Term],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_SYMBOL_CONTEXT_SENSOR),
        !,
        check_context_spec(Term,S1),
        (S1 == NO_ERRORS ->
            parse_body_symbol_literal(Term,DISALLOW_TERM_DESCRIPTOR,TermCode,Status),
            flsensorsymbol_struct(TermCode,Code)
        ; Status = S1
        ).

parse_body_symbol(CANOTERM(Funct,1,FL_PARENTHESIS,[Term],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_SYMBOL_CONTEXT_PROLOG),
        !,
        check_context_spec(Term,S1),
        (S1 == NO_ERRORS ->
            parse_body_symbol_literal(Term,DISALLOW_TERM_DESCRIPTOR,TermCode,Status),
            flprlgsymbol_struct(TermCode,Code)
        ; Status = S1
        ).

parse_body_symbol(CanoniTerm,Code,Status) :-
        parse_body_symbol_literal(CanoniTerm,ALLOW_TERM_DESCRIPTOR,Code,Status).

check_context_spec(CANOTERM(Funct,2,FL_PARENTHESIS,[_L,_R],If,_Ip),Status) :-
        get_atom(Funct,FL_AT),
        !,
        parsing_error(If,ERROR_SYMBOL_CONTEXT_DIR,Status).
check_context_spec(_,NO_ERRORS).


/****************************************************************************
  parse_body_symbol_literal(+CanoniTerm,+AllowTermDescr,-Code,-Status)
****************************************************************************/

%% transactional vars as literals can appear only with module specifications
parse_body_symbol_literal(CanoniTerm,_AllowTermDescr,Code,Status) :-
        (get_flvar_struct(CanoniTerm,Code)
        ; get_fltransactionalvar_struct(CanoniTerm,Code)
        ),
        !,
        parsing_error(CanoniTerm,ERROR_VAR,Status).

%% term descriptor: TermName/ArgsNum
parse_body_symbol_literal(CanoniTerm,ALLOW_TERM_DESCRIPTOR,Code,Status) :-
        term_descriptor(CanoniTerm,Code,Status),
        !.

        
%% term
parse_body_symbol_literal(CanoniTerm,_AllowTermDescr,Code,Status) :-
        term_template(CanoniTerm,ALLOW_TRANS,ALLOW_TERM_VARARGS,Code,Status),
        !.

parse_body_symbol_literal(CanoniTerm,_AllowTermDescr,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_SYMBOL,Status).

/****************************************************************************
  term_descriptor(+CanoniTerm,-Code,-Status)
  term descriptor: checks whether CanoniTerm has the form TermName/TermArity
****************************************************************************/
term_descriptor(CANOTERM(Funct,2,_F,[TermName,_TermArity],_If,_Ip),NULL,Status) :-
        get_name(Funct,FL_SLASH),
        is_variable(TermName,_,_),
        parsing_error(TermName,ERROR_SYMBOL,Status),
        !.

term_descriptor(CANOTERM(Funct,2,_F,[TermName,TermArity],_If,_Ip),Code,NO_ERRORS) :-
        get_name(Funct,FL_SLASH),
        flobject_struct(TermArity,TermArityCode),
        term_descriptor_arity(TermArityCode),
        flobject_struct(TermName,TermNameCode),
        fltermdescriptor_struct(TermNameCode,TermArityCode,Code),
        !.

term_descriptor(CANOTERM(Funct,2,_F,[TermName,TermArity],_If,_Ip),Code,NO_ERRORS) :-
        get_name(Funct,FL_SLASH),
        flobject_struct(TermArity,TermArityCode),
        term_descriptor_arity(TermArityCode),
        fltransactionalobject_struct(TermName,TermNameCode),
        fltransactionaltermdescriptor_struct(TermNameCode,TermArityCode,Code),
        !.

%% Fix for curi
term_descriptor(CANOTERM(Funct,2,_F,[TermName,TermArity],_If,_Ip),Code,Status) :-
        get_name(Funct,FL_SLASH),
        flobject_struct(TermArity,TermArityCode),
        term_descriptor_arity(TermArityCode),
        parse_curi_canoterm(TermName,ALLOW_TRANS,NULL,TermNameCode,Status),
        (is_fltransactionalterm_struct(TermNameCode) ->
            fltransactionaltermdescriptor_struct(TermNameCode,TermArityCode,Code)
        ; fltermdescriptor_struct(TermNameCode,TermArityCode,Code)
        ),
        !.

term_descriptor(CANOTERM(Funct,_Arity,_F,_Args,_If,_Ip),NULL,Status) :-
        get_name(Funct,FL_SLASH),
        parsing_error(Funct,ERROR_SYMBOL,Status).

term_descriptor_arity(TermArity) :-
        is_flnumber_struct(TermArity),
        !.

term_descriptor_arity(TermArity) :-
        is_anonymous_flvar_struct(TermArity),
        !.
/****************************************************************************
  flora_parse_fact(+CanoniTerm,-Code,-Status)
****************************************************************************/
flora_parse_fact(CanoniTerm,NULL,Status) :-
        %% Handle special markups to include files that are generated by gpp.
        parse_gpp_markup(CanoniTerm,Status),
        !.

flora_parse_fact(CanoniTerm,Code,Status) :-
        set_context(CONTEXT_PARSER_FACT),
        parse_head(CanoniTerm,CodeList,Status),
        clear_context(CONTEXT_PARSER_FACT),
        (Status == NO_ERRORS ->
            flconjunct_list2list(CodeList,ConjunctlessList),
            flfact_struct(ConjunctlessList,Code)
        ; true
        ).


/****************************************************************************
  flora_parse_query(+CanoniTerm,-Code,-Status)
  flora_parse_latent_query(+CanoniTerm,-Code,-Status)
****************************************************************************/
flora_parse_query(CanoniTerm,Code,Status) :-
        is_query(CanoniTerm,Query),
        !,
        %%parsing_error(CanoniTerm,'Spurious query operator?',Status).
        flora_parse_query(Query,Code,Status),
        flora_warning_line('spurious `?-'' in command-line query:'),
        flora_warning_indentline,
        flwriteline_warn(Code).

flora_parse_query(CanoniTerm,Code,Status) :-
        set_context(CONTEXT_PARSER_QUERY),
        parse_rule_body(CanoniTerm,Goal,Status),
        flquery_struct(Goal,Code),
        clear_context(CONTEXT_PARSER_QUERY).

%% we do a minimal job checking if there is an IC descriptor.
%% we don't check if the descriptor actually has a rule id. If not, the user
%% won't be able to invoke the IC easily and will eventually
%% figure if he needs an id or not.
flora_parse_latent_query(CanoniTerm,Code,Status) :-
        has_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT),
        !,
        set_context(CONTEXT_PARSER_LATENT_QUERY),
        parse_rule_body(CanoniTerm,Goal,Status),
        fllatent_query_struct(Goal,Code),
        clear_context(CONTEXT_PARSER_LATENT_QUERY).
flora_parse_latent_query(CanoniTerm,_Code,Status) :-
        get_index(CanoniTerm,Idx),
        parsing_error(Idx,MISSING_DESCRIPTOR_IN_LATENT_QUERY,Status).

/****************************************************************************
  flora_parse_rule(+Head,+Body,-Code,-Status)
****************************************************************************/
flora_parse_rule(Head,Body,Code,Status) :-
        set_context(CONTEXT_PARSER_RULEHEAD),
        parse_head(Head,HeadCodeList,S),
        clear_context(CONTEXT_PARSER_RULEHEAD),
        ( S == NO_ERRORS ->
            flconjunct_list2list(HeadCodeList,ConjunctlessList),
            parse_rule_body(Body,BodyCode,Status),
            flrule_struct(ConjunctlessList,BodyCode,Code)
        ;
          Status = S
        ).


/****************************************************************************
  flora_parse_user_defined_function(+Function,+Body,+ReturnValue,-Code,-Status)
****************************************************************************/
flora_parse_user_defined_function(Function,Body,ReturnValue,Code,Status) :-
        parse_udf_function(Function,FunctionCode,S),
        ( S == NO_ERRORS -> 
                parse_udf_body(Body,BodyCode,S2),
                ( S2 == NO_ERRORS ->
                        parse_udf_return_value(ReturnValue,ReturnValueCode,Status),
                        fludf_struct(FunctionCode,BodyCode,ReturnValueCode,Code)
                ;
                        Status = S2
                )
        ;
                Status = S
        ).

/****************************************************************************
  flora_parse_user_defined_function_fact(+Function,+Value,-Code,-Status)
****************************************************************************/
flora_parse_user_defined_function_fact(Function,Value,Code,Status) :-
        set_context(CONTEXT_PARSER_UDF_FACT), %% we need to allow any arguments
        parse_udf_function(Function,FunctionCode,S),
        clear_context(CONTEXT_PARSER_UDF_FACT),
        ( S == NO_ERRORS -> 
                parse_head_pathexp(Value,DISALLOW_TRANS,NULL,PURE_PATHEXPS_ONLY,ValueCode,Status),
                fludffact_struct(FunctionCode,ValueCode,Code)
        ;
                Status = S
        ).


/****************************************************************************
   parse_toplevel_annotated_statement(+Descriptors,+Statement,+VarsOK,-Code,-Status)
   VarsOK: true/false. Tells if vars in descriptor Id are ok
****************************************************************************/
parse_toplevel_annotated_statement(Descriptors,Statement,VarsOK,Code,Status) :-
        (is_annotatable(Statement) ->
            set_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT),
            parse_canonical(Statement,Code1,Status1),
            clear_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT),
            (Status1 == NO_ERRORS ->
                ( (is_rule(Statement,_,_) ; is_latent_query(Statement,_)) ->
                    CodeConstr = Code1
                ; is_udf(Statement,_) -> CodeConstr = Code1
                /* if Code1 is an annotated fact, convert it to a rule:
                         fact :- true.
                   Code1 can be (FLFACT(...),FLFACT(...),...,FLFACT(...))
                   or FLFACT(single-fact) or FLFACT(list-of-facts)
                   strip_flfact_list/2 removes FLFACT and converts the stuff
                   into a kosher list used for rule heads.
                */
                ; strip_flfact_list(Code1,Head) ->
                    trueconst_obj(TruePredObject),
                    flobject_struct(TruePredObject,BodyCode),
                    flrule_struct(Head,BodyCode,CodeConstr)
                ),
                parse_descriptor_list(Descriptors,VarsOK,CodeLab,Status2),
                %% latent queries must have rule Ids
                (Status2 == NO_ERRORS,
                    is_latent_query(Statement,_),
                    flatten(CodeLab,CodeLabFlat),
                    \+ member(FLDESCRIPTOR(_,FLRULEID,_),CodeLabFlat)
                -> 
                    parsing_error(Descriptors,LATENT_Q_MUST_HAVE_ID,Status)
                ; is_fldirective(Code1,_,_) ->
                    parsing_error(Descriptors,DESCRIPTOR_IN_DIRECTIVE,Status)
                ; Status = Status2
                ),
                (Status == NO_ERRORS
                -> annotated_construct_struct(CodeLab,CodeConstr,Code)
                ;  true
                )
            ; Status = Status1
            )

        ; %%% Ignore descriptors in directives and queries.
          %%% Might use this information later, especially for queries.
            parse_canonical(Statement,Code,Status)
        ).

strip_flfact_list(FlFactConj,FlattenedList) :-
        commalist2list(FlFactConj,List),
        unwrap_flfacts(List,StrippedList),
        flatten(StrippedList,FlattenedList).
unwrap_flfacts([],[]) :- !.
unwrap_flfacts([H|T],[UH|UT]) :-
        (is_flfact(H,UH) -> true
        ; H=UH
        ),
        unwrap_flfacts(T,UT).

/****************************************************************************
  parse_gpp_markup(+CanoniTerm,+Status)

  flora_begin_file/1 and flora_end_file/1 are being called to control
  the file stack in the lexer.
  This is how Flora is able to maintain line numbers correctly
  in the presence of included files.
****************************************************************************/
parse_gpp_markup(CanoniTerm,NO_ERRORS) :-
        get_name(CanoniTerm,FLORA_GPP_MARKUP),
        %% This is just a delimiter for fault tolerance.
        %% Skip it.
        !.

parse_gpp_markup(CANOTERM(Funct,3,FL_PARENTHESIS,[Arg1,Arg2,Arg3],If,_Ip),Status) :-
        get_name(Funct,FLORA_GPP_MARKUP),
        (flora_current_compile_filename(CurrFile,full) ; true),
        !,
        ( ( get_name(Arg3,'') ->
              %% This is the top level file name. Reset line number.
              flora_reset_charpos
          
          ; get_name(Arg3,'1') ->
              %% This is the beginning of an included file.
              get_name(Arg2,FileName),
              %% This pushes new file on the file stack
              flora_begin_file(FileName)
          
          ; get_name(Arg3,'2') ->
              %% This is the end of an included file.
              get_integer(Arg1,LineNumber),
              %% pop file from the file stack
              flora_end_file(LineNumber)
          ),
          (nonvar(CurrFile), nonvar(FileName) ->
              assert(FLORA_INCLUDE_DEPENDENCY(CurrFile,FileName))
          ; true
          ),
          Status = NO_ERRORS,
          !
        ;
              parsing_error(If,ERROR_GPP,Status)
        ).


/****************************************************************************
  parse_udf_function(+CanoniTerm,-CodeList,-Status)
  parse_udf_body(+CanoniTerm,-CodeList,-Status)
  parse_udf_return_value(+CanoniTerm,-CodeList,-Status)

  These predicates are called to parse function, predicate and return value 
  in UDF structure 
****************************************************************************/
%%parse_udf_function(CanoniTerm,CodeList,Status):-parse_rule_body(CanoniTerm,CodeList,Status).

parse_udf_function(CANOTERM(Funct,2,FL_PARENTHESIS,[_L,_R],_If,_Ip),_Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        parsing_error(Funct,ERROR_UDF,Status).

parse_udf_function(CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,_If,_Ip),_Code,Status) :-
        get_atom(Funct,FAtom),
        %% don't allow the user to use reserved builtins as UDFs of any arity.
        is_disallowed_reserved_builtin(FAtom),
        !,
        parsing_error(Funct,ERROR_RESERVED_SYMBOL,Status).

parse_udf_function(CanoniTerm,Code,Status) :-
        set_context(CONTEXT_PARSER_UDF_HEAD),
        parse_body_pathexp(CanoniTerm,DISALLOW_TRANS,NULL,PURE_PATHEXPS_ONLY,Code,Status),
        clear_context(CONTEXT_PARSER_UDF_HEAD).

parse_udf_body(CanoniTerm,Code,Status) :-
        parse_rule_body(CanoniTerm,Code,Status). %% do not restrict udf body

parse_udf_return_value(ObjectTerm,Code,Status) :-
        parse_body_pathexp(ObjectTerm,DISALLOW_TRANS,NULL,PURE_PATHEXPS_ONLY,Code,Status),
        !.

parse_udf_return_value(ObjectTerm,_,Status):-
        parsing_error(ObjectTerm,ERROR_UDF_RETURN_VALUE,Status).


/****************************************************************************
  parse_head(+CanoniTerm,-CodeList,-Status)

  This predicate is called to parse the head of a rule, which is a canonical
  term. Since only conjunction is allowed in a rule head, the result of parsing
  it is a list of intermidiate terms.

  Note: Module name is not allowed in rule head.
****************************************************************************/

#if exists("extensions/flrparser_headORhook.P")
#include "extensions/flrparser_headORhook.P"
#endif

parse_head(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),CodeList,Status) :-
        get_atom(Funct,FL_AND_CONNECTIVE),
        !,
        parse_head(L,LCodeList,S),
        (S == NO_ERRORS -> parse_head(R,RCodeList,Status),
            (Status == NO_ERRORS -> append(LCodeList,RCodeList,CodeList)
            ; true
            )
        ;
            Status = S
        ).

parse_head(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_CodeList,Status) :-
        get_atom(Funct,F),
        %% ~~>, <~~, <~~> are illegal
        ( memberchk(F,[FL_LEFTNAFIMPLY,FL_RIGHTNAFIMPLY,FL_NAFIFF]) ->
            parsing_error(If,NO_NAF_IMPLY,Status)
        %% ==>, <==, <==> are illegal
        ; memberchk(F,[FL_LEFTNEGIMPLY,FL_RIGHTNEGIMPLY,FL_NEGIFF]) ->
            parsing_error(If,NO_NEG_IMPLY,Status)

        ; % Module name in rule head is prohibited.
          F == FL_AT,
          parsing_error(If,NO_WSASRULEHEAD,Status)
        ),
        !.

parse_head(CANOTERM(Funct,_N,FL_PARENTHESIS,_G,If,_Ip),_CodeList,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F)),
        !,
        parsing_error(If,NO_NEGATION,Status).

parse_head(CanoniTerm,CodeList,Status) :-
        get_statement_descriptors(CanoniTerm,Descriptors,Statement),
        Descriptors \== [],
        !,
        get_index(Descriptors,I),
        (is_rule(Statement,_,_) ->
            parsing_error(I,DESCRIPTOR_CONSTR_RULEHEAD,Status),
            CodeList = [NULL]
        ;
            %% currently we ignore descriptors in rule head
            %%parse_head(Statement,CodeList,Status)
            parsing_error(I,DESCRIPTOR_CONSTR_RULEHEAD,Status),
            CodeList = [NULL]
        ).

parse_head(CanoniTerm,CodeList,Status) :-
        parse_head_literal_top(CanoniTerm,NULL,CodeList,Status).


/****************************************************************************
  parse_head_literal_top(+CanoniTerm,+WorkSpace,-HeadLiteral,-Status)
  parse_head_literal(+CanoniTerm,+WorkSpace,-HeadLiteral,-Status)

  parses a single literal in the head of a rule. Check the grammar at
  the beginning to see what is allowed.
****************************************************************************/
#define PARSER_TNF_FLAG  _

parse_head_literal_top(CanoTerm,DWS,CodeList,Status) :-
        parse_head_literal(CanoTerm,DWS,HCodePre,S),
        multiply_setarg_code(HCodePre,HCodeList),
        (S == NO_ERRORS ->
            get_index(CanoTerm,Idx),
            to_TNF_list(HCodeList,Idx,CodeList,PARSER_TNF_FLAG,Status)
        ; Status = S
        ).

parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_AND_CONNECTIVE),
        !,
        parse_head_literal(L,DWS,LCodeList,S),
        (S == NO_ERRORS -> parse_head_literal(R,DWS,RCodeList,Status),
            (Status == NO_ERRORS -> flconjunct_struct(LCodeList,RCodeList,Code)
            ; true
            )
        ;
            Status = S
        ).

parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_OR_CONNECTIVE),
        !,
        parse_head_literal(L,DWS,LCodeList,S),
        (S == NO_ERRORS -> parse_head_literal(R,DWS,RCodeList,Status),
            (Status == NO_ERRORS -> fldisjunct_struct(LCodeList,RCodeList,Code)
            ; true
            )
        ;
            Status = S
        ).
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        is_birelop(F),
        !,
        parse_head_pathexp(Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
        (S==NO_ERRORS ->
            parse_head_pathexp(Right,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
        ; Status = S
        ),
        (Status == NO_ERRORS -> 
            flbirelate_struct(LCode,F,RCode,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true).

%% reify op ${...} that occurs as a formula
parse_head_literal(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),DWS,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        (list_to_canoterm_conjunct(Args, Conjunct, If, Ip) ->
            set_context(CONTEXT_PARSER_REIFY),
            parse_head_literal(Conjunct,DWS,Code,Status),
            clear_context(CONTEXT_PARSER_REIFY)
        ;  parsing_error(Ip,EXP_ARGS,Status)
        ).

%% Path expression without a []: a.c.b rather than a.b.c[].
%% '.'(_,_), '!'(_,_),
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        is_objrefop(F),
        !,
        parsing_error(If,ERROR_NONBOOLPATHEXP,Status).

parse_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        flora_nodefp(F,N),
        \+ has_context(CONTEXT_PARSER_DESCRIPTOR),
        !,
        parsing_error(If,NO_REDEFINITION,Status).

%% :=: in the head
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_OBJEQL),
        !,
        %% equality definition fact/rule
        parse_head_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,[LCode,RCode],Status),
        (Status == NO_ERRORS -> 
            flobjeql_struct(LCode,RCode,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true).

parse_head_literal(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        %% explicit negation
        is_negop(F),
        !,
        parse_head_literal_list(Args,DWS,ArgCode,Status),
        parse_list2flconjunct(ArgCode,ArgCodeConj),
        (Status == NO_ERRORS -> flneg_struct(ArgCodeConj,If,Code)
        ; true
        ).

#if exists("extensions/flrparser_headquanthook.P")
#include "extensions/flrparser_headquanthook.P"
#endif

%% no logical quantifiers in the head
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,_Vars,_,_),_],_If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QuantIdx),
        is_logicalquantifier(QuantAtom,_),
        !,
        parsing_error(QuantIdx,NO_QUANTIFIERS_IN_RULE_HEAD,Status).

parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,ALLOW_TRANS,DWS,CuriCode,Status),
        flora_get_module_from_spec(DWS,ModuleType,Module),
        flmodule_struct(ModuleType,CuriCode,Module,Code).

parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        parse_composer_datatype(Args,If,DWS,Code,Stat1),
        (nonvar(Code), is_flnumber_struct(Code), Stat1 == NO_ERRORS ->
            parsing_error(If,ERROR_HDLITERAL,Status)
        ; Status = Stat1
        ).

%% Parsing delay quantifiers
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,_Cond,_,_),_Goal],_If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QIndex),
        is_delayquant(QuantAtom),
        !,
        parsing_error(QIndex,ERROR_DELAY_QUANT_IN_HEAD,Status).

/*
parse_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[L,_R],_If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,FL_DESCRIPTORFUNC),
        !,
        parsing_error(L,ERROR_HDLITERAL,Status).
*/

parse_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        flora_reserved_symbol_not_literal(F,N),
        !,
        parsing_error(If,ERROR_HDLITERAL,Status).

parse_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        !,
        parse_head_term(Funct,N,Args,ALLOW_TRANS,DWS,TCode,Stat1),
        (nonvar(TCode), is_flnumber_struct(TCode), Stat1 == NO_ERRORS ->
            parsing_error(If,ERROR_HDLITERAL,Status)
        ; Stat1 == NO_ERRORS ->
            Status = Stat1,
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; Status = Stat1
        ).

%% Head a[...]
parse_head_literal(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_head_objspec_top(Funct,N,Args,DWS,NONINHERITABLE,ObjspecCode,Status),
        ( Status == NO_ERRORS ->
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,ObjspecCode,Module,Code)
        ; true
        ).
%% Head a[|...|]
parse_head_literal(CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_head_objspec_top(Funct,N,Args,DWS,INHERITABLE,ObjspecCode,Status),
        ( Status == NO_ERRORS ->
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,ObjspecCode,Module,Code)
        ; true
        ).

%% simple generic primitive like primName{Args} as a fact-directive
%% Here we are handling textit{...} in Ergo. In Flora-2 this is a noop
parse_head_literal(CANOTERM(Funct,N,FL_BRACE,Args,If,_Ip),DWS,Code,Status) :-
        is_simple_primitive_obj(Funct,N,PrimitiveName),
        PrimitiveName == FL_TEXTIT_PRIMITIVE,
        has_context(CONTEXT_PARSER_FACT),
        !,
        parse_simple_primitive(PrimitiveName,N,Args,DWS,CodePre,Status),
        fldirective_struct([CodePre],If,Code).

parse_head_literal(CanoniTerm,DWS,Code,Status) :-
        (get_atom(CanoniTerm,A)
        %% CanoniTerm = \@! - the default rule Id symbol
        ; has_context(CONTEXT_PARSER_DESCRIPTOR),
            get_spectoken(CanoniTerm,FL_SPECIAL_CONST_TOKEN,FL_RULEID_SYM),
            A = NULL
        ),
        !,
        ( flora_nodefp(A,0)
        ->
            parsing_error(CanoniTerm,ERROR_HDLITERAL,Status)
        ;
            flobject_struct(CanoniTerm,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code),
            Status = NO_ERRORS
        ).

parse_head_literal(CanoniTerm,DWS,Code,Status) :-
        get_transactionalatom(CanoniTerm,_A),
        !,
        fltransactionalobject_struct(CanoniTerm,TCode),
        Status = NO_ERRORS,
        flora_get_module_from_spec(DWS,ModuleType,Module),
        flmodule_struct(ModuleType,TCode,Module,Code).

parse_head_literal(CanoniTerm,_DWS,_Code,Status) :-
        !,
        parsing_error(CanoniTerm,ERROR_HDLITERAL,Status).


/****************************************************************************
  parse_head_literal_list(+List,+DWS,-CodeList,-Status)
****************************************************************************/
%% parse_head_literal_list/5 and parse_head_literal/4 do not do TNF - important
%% Parsing descriptors relies on that, since descriptor frames must stay
%% as one whole OBJSPEC: the compiler relies on that
parse_head_literal_list([],_,[],NO_ERRORS) :- !.
parse_head_literal_list([First|List],DWS,[FirstCode|ListCode],Status) :-
        parse_head_literal(First,DWS,FirstCode,Status1),
        (Status1 == NO_ERRORS
        ->
            parse_head_literal_list(List,DWS,ListCode,Status)
        ;
            Status = Status1
        ).


/****************************************************************************
  parse_rule_body(+CanoniTerm,-Goal,-Status)

  This predicate is called to parse the *entire* body of a rule. It takes a
  canonical term as input and parses it into an intermediate term to be
  compiled further. "CanoniTerm" can represent any logical formula of
  conjunction, disjunction, and negation. "Goal" is parsed accordingly. If
  success, "Status" is bound to NO_ERRORS or some warning message; otherwise,
  it is a list containing some error message.


  parse_rule_body(+CanoniTerm,+WorkSpace,+DefaultWorkSpace,-Goal,-Status)

  Note: Module name specification is distributive over negation, conjunction
        and disjunction in the rule body. WorkSpace is the inner-most module
        which might be a prolog module. DefaultWorkSpace is the inner-most
        non-prolog module. DefaultWorkSpace is distributed recrusively to reach
        reified formulas. DefaultWorkSpace works like nesting of variable
        scope.

        Moreover, module name specification is also distributive over
        if-then-else statement. For example, (if a then b else c)@mod has
        the same effect as (if a@mod then b@mod else c@mod).

****************************************************************************/
parse_rule_body(CanoniTerm,Goal,Status) :-
        parse_rule_body(CanoniTerm,NULL,NULL,Goal1,Status),
        (Status==NO_ERRORS -> to_LT(Goal1,Goal)
        ; var(Status) -> 
            flora_abort([UNKNOWN_ERROR,'\n\t\t variable status in parser'],
                        FLORA_ABORT_NOTRACE)
        ; true
        ).

parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,F),
        (F == FL_AND_CONNECTIVE; F == FL_OR_CONNECTIVE),
        !, % Module name is distributive over conjunction or disjunction.
        parse_rule_body(L,WS,DWS,LCode,S),
        ( S == NO_ERRORS ->
            parse_rule_body(R,WS,DWS,RCode,Status),
            ( Status == NO_ERRORS ->
                ( F == FL_AND_CONNECTIVE ->
                    flconjunct_struct(LCode,RCode,Code)
                ;
                    fldisjunct_struct(LCode,RCode,Code)
                )
            ;
              true
            )
        ;
          Status = S
        ).

%% \+, \naf
parse_rule_body(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F)),
        set_context(CONTEXT_PARSER_DEFAULT_NEGATION),
        !, % Module name is distributive over negation.
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_rule_body(Conjunct,WS,DWS,C,Status),
        (Status == NO_ERRORS ->
            (is_plgnafop(F) -> flprlgnaf_struct(C,Code)
            ; flrulelognaf_struct(C,Code)
            )
        ; true
        ),
        clear_context(CONTEXT_PARSER_DEFAULT_NEGATION).

parse_rule_body(CANOTERM(Funct,_N,FL_PARENTHESIS,Gs,If,Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_negop(F),
        !, %% Module name is distributive over negation.
        %% parse_rule_body is too general here. We do not want to allow
        %% anything but conjunctions/disjunctions of F-logic/first-order
        %% atomic formulas. No update ops, NOT, NAF, etc.
        %% This is taken care of by the compiler in neg_struct/head_neg_struct.
        list_to_canoterm_conjunct(Gs,Conjunct,If,Ip),
        parse_rule_body(Conjunct, WS, DWS,LitCode,Status),
        ( Status == NO_ERRORS -> flneg_struct(LitCode,If,Code)
        ; true
        ).

%% Parsing logical quantifiers.
%% QF: quantified formula. We allow only the following quantifiers here:
%%    existential
%% And only once, existential is allowed under \+ or not/naf,
%% others are not allowed under negation.
%% This would have to be generalized for Lloyd-Topor
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,Vars,_,_),Goal],_If,_Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QuantIdx),
        is_logicalquantifier(QuantAtom,QuantAtomCanon),
        !,
        %% parse_varlist/4 checks that Vars are indeed vars
        %% the compiler would have to make sure that Vars occus in Goal
        %% Vars = '*' means all vars in the quantified formula
        (Vars = [StarObj], get_atom(StarObj,FL_STAR)
        -> VarNames=FL_STAR, S1 = NO_ERRORS
        ; parse_varlist(Vars,VarCodeList,VarNames,S1)
        ),
        parse_rule_body(Goal, WS, DWS,GoalCode,S2),
        merge_status([S1,S2],Status),
        ( Status == NO_ERRORS ->
            get_typed_var_code_from_list(VarCodeList,VarsCode),
            flquantifier_struct(QuantAtomCanon,VarNames,VarsCode,GoalCode,QuantIdx,Code)
        ;
            true
        ).

%% Parsing delay quantifiers
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,Cond,_,_),Goal],_If,_Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QIndex),
        is_delayquant(QuantAtom),
        !,
        %% delay quantifiers are not allowed under \+ or not/naf
        (has_context(CONTEXT_PARSER_DEFAULT_NEGATION) ->
            parsing_error(QIndex,DELAY_QUANT_UNDER_NEGATION,S1)
        ;
            parse_prolog_condition(Cond,CondCode,S1)
        ),
        (S1 == NO_ERRORS ->
            parse_rule_body(Goal,WS,DWS,GoalCode,S2),
            (S2 == NO_ERRORS ->
                fldelayquant_struct(QuantAtom,CondCode,GoalCode,QIndex,Code),
                Status = NO_ERRORS
            ;
                Status = S2
            )
        ;
            Status = S1
        ).

parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(_Quant,1,FL_PARENTHESIS,[_Cond],_,_),_Goal],If,_Ip),_WS,_DWS,_Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        !,
        parsing_error(If,UNKNOWN_QUANTIFIER,Status).


parse_rule_body(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_hypothetical(F),
        !, %% Module name is distributive over hypothetical.
        list_to_canoterm_conjunct(Args, HypoBody, If, Ip),
        set_context(CONTEXT_PARSER_HYPOTHETICAL),
        parse_rule_body(HypoBody, WS, DWS,HypoBodyCode,Status),
        clear_context(CONTEXT_PARSER_HYPOTHETICAL),
        ( Status == NO_ERRORS -> flhypothetical_struct(F,HypoBodyCode,If,Code)
        ; true
        ).

parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_WS,DWS,Code,Status) :-
        get_atom(Funct,FL_AT),
        !, % nesting of module name scope
        %% The module name needs to be parsed early; otherwise, some
        %% incorrect syntax may be overridden by nested module specification.
        parse_workspace(R,RCode,S),
        ( S == NO_ERRORS ->
            ( (is_prologmodule(RCode)
              ; is_prologmodule(RCode,_)
              )
            -> parse_rule_body(L,RCode,DWS,Code,Status)
            ;  parse_rule_body(L,RCode,RCode,Code,Status)
            )
        ; 
            Status = S
        ).

%% reify op ${...} that occurs as a formula
parse_rule_body(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),WS,DWS,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        (list_to_canoterm_conjunct(Args, Conjunct, If, Ip) ->
            parse_rule_body(Conjunct,WS,DWS,Code,Status)
        ;  parsing_error(Ip,EXP_ARGS,Status)
        ).

%% Literal is a rule and we are inside reification
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],If,Ip),WS,WS,Code,Status) :-
        get_name(Funct,FL_IMPLYOP),
        (has_context(protecting_reification) ->
            ( has_context(CONTEXT_PARSER_REIFY) ->
                PrevContext = CONTEXT_PARSER_REIFY,
                clear_context(CONTEXT_PARSER_REIFY)
            ;
                true
            ),
            parse_dynrule(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],If,Ip),
                          WS,Code,Status),
            ( var(PrevContext) -> true; set_context(CONTEXT_PARSER_REIFY))
        ; parsing_error(If,ERROR_EMBEDDED_IMPLY,Status)
        ).

%% Delayed builtins: !=, >, >=, =:=, etc. Also sensors defined in .flr files
%% If the user wrote @\prolog or @\prologall then we pass it down to prolog
%% and do not delay. This is a change from the original treatment
parse_rule_body(CANOTERM(Funct,N,Paren,Args,If,Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FAtom1),
        (flora_delayed_builtin_literal(FAtom1,N), Paren==FL_PARENTHESIS
        -> FAtom = FAtom1
        ; Paren==FL_BRACE
        -> flora_simple_delayed_primitive(FAtom1,N,FAtom),
            flora_delayed_builtin_literal(FAtom,N)
        ),
        %% if @\plg or @\plgall, pass down to Prolog, don't delay
        \+ is_prologmodule(WS),
        \+ is_prologmodule(WS,_),
        %% If inside a CLP constraint, don't delay
        \+ has_context(CONTEXT_PARSER_CLP_CONSTRAINT),
        !,
        flatom_struct(FAtom,If,OpCode),
        (flora_argdef(FAtom,N,ArgTypes,DWS)
        -> parse_body_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,ACode,Status)
        ;  parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,ACode,Status)
        ),
        fllist_struct(ACode,[],Ip,ArgsCode),
        fldelayedliteral_struct(OpCode,ArgsCode,Code).


%% At this point, CanoniTerm is not a logical formula.
parse_rule_body(CANOTERM(Funct,1,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_IF),
        !,
        %% Module name is distributive over if-then-else statement.
        parse_body_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
        get_name(Funct,FL_THEN),
        !,
        parsing_error(If,ERROR_THENBODY,Status).

parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
        get_name(Funct,FL_ELSE),
        !,
        parsing_error(If,ERROR_ELSEBODY,Status).

%% @!{...} query in the rule body - main case
parse_rule_body(CANOTERM(Funct,1,FL_BRACE,Arg,If,_Ip),_WS,_DWS,Code,Status) :-
        get_atom(Funct,FL_RULEID_OP),
        !,
        %% Here Arg is the descriptor; VarsOK = true
        parse_descriptor_aux(FL_RULEID_OP,Arg,If,true,MetafactCodeLst,Status),
        parse_list2flconjunct(MetafactCodeLst,MetafactCode),
        flcallmetafacts_struct(MetafactCode,If,Code).
%% @!{...} query in the rule body
%% Should not be reachable - used only if FL_RULEID_OP is declared as
%% an operator. Disabled currently
parse_rule_body(CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],If,_Ip),_WS,_DWS,Code,Status) :-
        get_atom(Funct,FL_RULEID_OP),
        Arg = CANOBRACE(Descr,_,_),
        !,
        %% VarsOK = true
        parse_descriptor_aux(FL_RULEID_OP,Descr,If,true,MetafactCodeLst,Status),
        parse_list2flconjunct(MetafactCodeLst,MetafactCode),
        flcallmetafacts_struct(MetafactCode,If,Code).

%% Parse the a<~~b form of if-then
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[ThenPart,IfPart],_If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_LEFTNAFIMPLY),
        !,
        leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a~~>b form of if-then
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],_If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_RIGHTNAFIMPLY),
        !,
        leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a<~~>b form of if-then
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_NAFIFF),
        !,
        %% The restriction on omniform does not apply in ErgoText:
        %% Too much work to get it handle compiler_options and one can say
        %% that whoever does ErgoText is expert enough.
        ((has_compiler_persistentoption(FL_EXPERT)
         ; has_context(CONTEXT_PARSER_NL_TEMPLATES)
         ; has_context(CONTEXT_PARSER_USING_NL_TEMPLATE)
         )
        -> naf_iff(IfPart,ThenPart,WS,DWS,Code,Status)
        ; parsing_error(If,ERROR_EXPERT_SYNTAX,Status)
        ).

%% Parse the a<==b form of if-then (using NEG instead of NAF)
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[ThenPart,IfPart],_If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_LEFTNEGIMPLY),
        !,
        body_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a==>b form of if-then (using NEG instead of NAF)
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],_If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_RIGHTNEGIMPLY),
        !,
        body_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a<==>b form of if-then (using NEG instead of NAF)
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_NEGIFF),
        !,
        %% The restriction on omniform does not apply in ErgoText:
        %% Too much work to get it handle compiler_options and one can say
        %% that whoever does ErgoText is expert enough.
        ((has_compiler_persistentoption(FL_EXPERT)
         ; has_context(CONTEXT_PARSER_NL_TEMPLATES)
         ; has_context(CONTEXT_PARSER_USING_NL_TEMPLATE)
         )
        -> neg_iff(IfPart,ThenPart,WS,DWS,Code,Status)
        ; parsing_error(If,ERROR_EXPERT_SYNTAX,Status)
        ).

%% Parse the ~ meta predicate
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_UNIVEQFORM),
        !,
        parse_body_univeqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

%% Parse the !~ meta predicate
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_NOTUNIVEQFORM),
        !,
        parse_body_notuniveqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

%% Parse the =.. meta predicate
%% Workspace as in (A=..B)@foo is illegal.  But (A@foo =.. B) is fine.
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_METAUNIV),
        !,
        parse_body_metauniv(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code_pre,Status),
        multiply_setarg_code(Code_pre,Code_pre_list),
        parse_list2flconjunct(Code_pre_list,Code).

%% -->> : same as Prolog ->. Used mostly internally
parse_rule_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
        get_name(Funct,FL_PROLOG_IFTHEN),
        !,
        protect_reification(distribute_workspace(Args,WS,DWS,[LCode,RCode],Status)),
        (Status == NO_ERRORS ->
            flprolog_ifthen_struct(LCode,RCode,Code)
        ; true
        ).

%% Process the control constructs while-do/loop, loop/do-until, unless-do
parse_rule_body(CANOTERM(TopWrapper,1,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
        get_name(TopWrapper,TopName),
        get_control_construct_definition(_CtlWrapper,TopName,_InnerName),
        !,
        %% Args should be [CanonTerm]. If not, will issue a syntax error
        parse_body_controlconstruct(Args,WS,DWS,TopName,Code,Status).

%% If inner keyword of ctl construct occurs at the top level -- error
parse_rule_body(CANOTERM(TopWrapper,2,_Paren,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
        get_name(TopWrapper,TopName),
        get_control_construct_definition(_,_,TopName),
        !,
        parsing_error(If,UNEXPECTED_CONTROL,Status).


%% @\prolog()
parse_rule_body(CanoniTerm,Module,DWS,Code,Status) :-
        Module == PROLOGMODULE,
        !,
        %% Prolog builtin
        parse_prlgterm(CanoniTerm,DWS,TCode,Status),
        (Status == NO_ERRORS ->
            flplib_struct(TCode,Code_pre),
            multiply_setarg_code(Code_pre,Code_pre_list),
            parse_list2flconjunct(Code_pre_list,Code)
        ;
            true
        ).

%% @\prolog(...)
parse_rule_body(CanoniTerm,PrologModuleSpec,DWS,Code,Status) :-
        nonvar(PrologModuleSpec),
        flora_get_module_from_spec(PrologModuleSpec,PROLOGMODULE,Mod),
        !,
        %% Prolog module
        parse_prlgterm(CanoniTerm,DWS,TCode,Status),
        (Status == NO_ERRORS ->
            flmodule_struct(PROLOGMODULE,TCode,Mod,Code_pre),
            multiply_setarg_code(Code_pre,Code_pre_list),
            parse_list2flconjunct(Code_pre_list,Code)
        ; true
        ).

%% @\prologall()
parse_rule_body(CanoniTerm,Module,DWS,Code,Status) :-
        Module == PROLOGALLMODULE,
        !,
        %% Prolog builtin
        parse_pure_term(CanoniTerm,DWS,TCode,Status1),
        ( is_flvar_struct(TCode) ->
            parsing_error(CanoniTerm,ERROR_PRLGLIT,Status2),
            Status = Status2
        ; Status1 == NO_ERRORS ->
            flpliball_struct(TCode,Code_pre),
            multiply_setarg_code(Code_pre,Code_pre_list),
            parse_list2flconjunct(Code_pre_list,Code),
            Status = Status1
        ; Status = Status1
        ).

%% @\prologall(...)
parse_rule_body(CanoniTerm,PrologModuleSpec,DWS,Code,Status) :-
        nonvar(PrologModuleSpec),
        flora_get_module_from_spec(PrologModuleSpec,PROLOGALLMODULE,Mod),
        !,
        %% Prolog module
        parse_pure_term(CanoniTerm,DWS,TCode,Status1),
        ( is_flvar_struct(TCode) ->
            parsing_error(CanoniTerm,ERROR_PRLGLIT,Status2),
            Status = Status2
        ; Status1 == NO_ERRORS ->
            flmodule_struct(PROLOGALLMODULE,TCode,Mod,Code_pre),
            multiply_setarg_code(Code_pre,Code_pre_list),
            parse_list2flconjunct(Code_pre_list,Code),
            Status = Status1
        ; Status = Status1
        ).

parse_rule_body(CanoniTerm,WS,_DWS,Code,Status) :-
        is_annotated_statement(CanoniTerm,_Descriptors,Statement),
        has_context(protecting_reification),
        is_rule(Statement,_,_),
        !,
        parse_dynrule(CanoniTerm,WS,Code,Status).

parse_rule_body(CanoniTerm,_WS,_DWS,Code,Status) :-
        %% reified latent query without identifier - will give an error
        is_latent_query(CanoniTerm,_),
        !,
        flora_parse_latent_query(CanoniTerm,Code,Status).

parse_rule_body(CanoniTerm,_WS,_DWS,Code,Status) :-
        is_annotated_statement(CanoniTerm,_Descriptors,Statement),
        has_context(protecting_reification),
        is_latent_query(Statement,_),
        !,
        get_statement_descriptors(CanoniTerm,Descriptors1,Statement),
        parse_toplevel_annotated_statement(Descriptors1,Statement,true,Code,Status).

parse_rule_body(CanoniTerm,WS,DWS,Goal,Status) :-
        is_annotated_statement(CanoniTerm,_Descriptors,Statement),
        !,
        %% currently we ignore descriptors in rule body
        %% unless reified rule or constraint
        parse_rule_body(Statement,WS,DWS,Goal,Status).

%% @module
parse_rule_body(CanoniTerm,FloraModSpec,FloraModSpec,Code,Status) :-
        flora_get_module_from_spec(FloraModSpec,_ModuleType,Module),
        !,
        %% Flora user or system module
        (has_context(CONTEXT_PARSER_FACT),
            is_flvar_struct(Module)
        -> 
            %% Variables are not allowed in the module specs in the
            %% reifications that occur in facts or static rule heads.
            get_index(Module,Idx),
            parsing_error(Idx,NO_WS_VAR,Status)
        ;
            parse_body_literal(CanoniTerm,FloraModSpec,Code_pre,Status),
            multiply_setarg_code(Code_pre,CodeList),
            parse_list2flconjunct(CodeList,Code)
        ).

%% At this point, CanoniTerm is neither a logical formula nor a 
%% if-then-else statement, nor some other special builtin 
%% (like while-loops or meta operators)
parse_rule_body(CanoniTerm,NULL,NULL,Code,Status) :-
        !,
        %% no explicit module name
        parse_body_literal(CanoniTerm,NULL,Code_pre,Status),
        multiply_setarg_code(Code_pre,CodeList),
        parse_list2flconjunct(CodeList,Code).

/****************************************************************************
  parse_prolog_condition(+Condition,-CondCode,-Status)
  Prolog condition (nonvar,ground, etc.) in delay quantifiers
****************************************************************************/
parse_prolog_condition(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),CondCode,Status) :-
        !,
        parse_pure_prolog_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),usermod,CondCode,_,Status).

parse_prolog_condition([Condition|CondTail],Code,Status):-
        parse_prolog_condition(Condition,CondCode,S1),
        CondTail \= [],
        !,
        (S1 == NO_ERRORS ->
                parse_prolog_condition(CondTail,CondTailCode,Status),
                get_index(Condition,Idx),
                flatom_struct(FL_COMMA,Idx,F),
                flterm_struct(F,2,[CondCode,CondTailCode],Code)
        ;
                Status = S1
        ).

parse_prolog_condition([Condition],CondCode,Status):-
        parse_prolog_condition(Condition,CondCode,Status).

parse_prolog_condition(Condition,_CondCode,Status):-
        parsing_error(Condition,ERROR_DELAY_QUANT_CONDITION,Status).

/****************************************************************************
  parse_workspace(+CanoniTerm,-WSCode,-Status)

  This predicate is called to parse the module name of a workspace specification.
  Three types of module names are allowed:
  (1) Prolog module, e.g., @\prolog(basics), @\prolog(), @\prolog
                           @\prologall(basics), @\prologall(), @\prologall
      WSCode=PROLOGMODULE(name), or PROLOGMODULE
      WSCode=PROLOGALLMODULE(name), or PROLOGALLMODULE
  (2) Flora system module, e.g., @\io, @\pp.
      WSCode=FLORASYSMOD(name)
  (3) Flora user module, which could be either an atom or a variable.
      WSCode=FLORAUSERMOD(name), or FLORAUSERMOD(var)

  Note: Textual information is reserved for module names.
****************************************************************************/
%% Handle Flora user module specification. (@ ?M)
parse_workspace(CanoniTerm,FLORAUSERMOD(NVCode),NO_ERRORS) :-
        name_or_var(CanoniTerm,NVCode),
        !.

%% @\prolog, @\plg, etc.
parse_workspace(CanoniTerm,PROLOGMODULE,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(CanoniTerm,NVCode),
        is_flatom_struct(NVCode,FL_PLIB),
        !.
%% @\prologall, @\plgall, etc.
parse_workspace(CanoniTerm,PROLOGALLMODULE,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(CanoniTerm,NVCode),
        is_flatom_struct(NVCode,FL_PLIBALL),
        !.

%% Handle THIS MODULE specification, e.g., a[b->c]@ \@.
parse_workspace(CanoniTerm,FLORAUSERMOD(ThisModToken),NO_ERRORS) :-
        %% When \@ is specified as a module, we treat it
        %% as a user module even if \@ occurs in a system module.
        %% This is because \@ doesn't require us to notify flrlibman.P that a
        %% system module needs to be loaded.
        %% However, in case of a system module \@ gets substituted with
        %% FLORA_THIS_MODULE_NAME, so at compile time we get the right module.
        (get_spectoken(CanoniTerm,FL_THISMODULE)
        ; get_spectoken(CanoniTerm,FL_SPECIAL_VAR_TOKEN,FL_SPECIAL_CALLER_TOKEN)
        ),
        !,
        flobject_struct(CanoniTerm,ThisModToken).

%% Handle a Prolog module specified as @\prolog
parse_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),PROLOGMODULE,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(Mod,NVCode),
        is_flatom_struct(NVCode,FL_PLIB),
        !.

%% A Prolog module given as @\prolog(xsbmod)
parse_workspace(CANOTERM(Mod,1,FL_PARENTHESIS,[M],_Ifu,_Ipa),PROLOGMODULE(MCode),Status) :-
        get_flbuiltin_identifier_struct(Mod,NVCode),
        is_flatom_struct(NVCode,FL_PLIB),
        !,
        ( get_flname_struct(M,MCode) -> Status = NO_ERRORS
        ; parsing_error(M,ERROR_WSNAME,Status)
        ).

%% @\prologall module
parse_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),PROLOGALLMODULE,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(Mod,NVCode),
        is_flatom_struct(NVCode,FL_PLIBALL),
        !.

%% @\prologall(module) module
parse_workspace(CANOTERM(Mod,1,FL_PARENTHESIS,[M],_Ifu,_Ipa),PROLOGALLMODULE(MCode),Status) :-
        get_flbuiltin_identifier_struct(Mod,NVCode),
        is_flatom_struct(NVCode,FL_PLIBALL),
        !,
        ( get_flname_struct(M,MCode) -> Status = NO_ERRORS
        ; parsing_error(M,ERROR_WSNAME,Status)
        ).

%% system module specification @\module
parse_workspace(CanoniTerm,FLORASYSMOD(MCode),Status) :-
        get_flbuiltin_identifier_struct(CanoniTerm,MCode),
        is_flatom_struct(MCode,ModuleName),
        !,
        ( flora_system_module(ModuleName) -> Status = NO_ERRORS
        ; parsing_error(CanoniTerm,UNREG_SYSMOD,Status)
        ).

%% allow curi's as workspace: @ foo#bar
parse_workspace(CanoniTerm,FLORAUSERMOD(MCode),Status) :-
        parse_curi_canoterm(CanoniTerm,DISALLOW_TRANS,NULL,MCode,Status),
        !.

%% allow IRIs as workspace: "..."^^\iri
parse_workspace(CanoniTerm,FLORAUSERMOD(MCode),Status) :-
        is_datatype_canoterm(CanoniTerm,IRI,TypeCode,Idx),
        get_name(TypeCode,TypeName),
        flora_synonymous_type_names(TypeName,FL_IRI),
        !,
        parse_composer_datatype([IRI,TypeCode],Idx,NULL,MCode,Status).


%% system module specification @\module()
parse_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),FLORASYSMOD(MCode),Status) :-
        get_flbuiltin_identifier_struct(Mod,MCode),
        is_flatom_struct(MCode,ModuleName),
        !,
        ( flora_system_module(ModuleName) -> Status = NO_ERRORS
        ; parsing_error(Mod,UNREG_SYSMOD,Status)
        ).


parse_workspace(CanoniTerm,_WSCode,Status) :-
        parsing_error(CanoniTerm,ERROR_WSNAME,Status).


/****************************************************************************
  parse_body_ifthenelse(+CanoniTerm,+Workspace,+DWS,-Code,-Status)

  parses an if-then-else statement. "Workspace" is the module name specified
  for the entire statement and should be distributed over the substatements
  inside.
****************************************************************************/
parse_body_ifthenelse(CanoniTerm,WS,DWS,Code,Status) :-
        parse_body_ifthenelse(CanoniTerm,WS,DWS,NK,_NT,Code,S),
        ( S \== NO_ERRORS -> Status = S

        ; NK == [] -> Status = NO_ERRORS

        ; NK = then(Index) -> parsing_error(Index,UNEXPECTED_THEN,Status)

        ; NK = else(Index) -> parsing_error(Index,UNEXPECTED_ELSE,Status)
        ).


/****************************************************************************
  parse_body_ifthenelse(+CanoniTerm,+Workspace,+DWS,-NextKeyword,-NextTerm,-Code,-Status).

  Takes a canonical term (which represents a stream of tokens) and parses
  a normal statement at the beginning  of it. Moreover, it returns the next
  immediate keyword and the  residual canonical term (which represents the
  rest of the token stream).

  If NextKeyword is [], then NextTerm is []. Otherwise, NextKeyword is
  either then(Index) or else(Index) (here Index is the index number of the
  keyword that can be used to generate an error message).

  Status denotes success/failure when the beginning of the token stream
  is parsed.

  This procedure complements parse_rule_body/5 and handles the distribution of
   module name over if-then-else statements.
****************************************************************************/
parse_body_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,[CTerm],If,_Ip),WS,DWS,
                      NextKeyword,NextTerm,Code,Status) :-
        get_name(Funct,FL_IF),
        !,
        parse_body_ifthenelse(CTerm,WS,DWS,NK1,NT1,CondStruct,S1),
        ( S1 == NO_ERRORS ->
            ( NK1 = then(_IThen) ->
                parse_body_ifthenelse(NT1,WS,DWS,NK2,NT2,ThenStruct,S2), 
                ( S2 == NO_ERRORS ->
                    ( NK2 = else(_IElse) ->
                        flifthenelse_struct(CondStruct,ThenStruct,ElseStruct,Code),
                        parse_body_ifthenelse(NT2,WS,DWS,NextKeyword,NextTerm,ElseStruct,Status)
                    ;
                      flifthen_struct(CondStruct,ThenStruct,Code),
                      NextKeyword=NK2,
                      NextTerm=NT2,
                      Status = NO_ERRORS
                    )
                ;
                  Status = S2
                )

            ; NK1 == NO_ERRORS ->
                parsing_error(If,MISSING_THEN,Status)

            ; NK1 = else(IElse) ->
                parsing_error(IElse,MISSING_THEN,Status)
            )
        ;
          Status = S1
        ).

parse_body_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,[STerm,NextTerm],If,_Ip),WS,DWS,
                      NextKeyword,NextTerm,Code,Status) :-
        ( get_name(Funct,FL_THEN) ->
            NextKeyword=then(If)

        ; get_name(Funct,FL_ELSE) ->
            NextKeyword=else(If)
        ),
        !,
        parse_rule_body(STerm,WS,DWS,Code,Status).

parse_body_ifthenelse(CanoniTerm,WS,DWS,[],[],Code,Status) :-
        parse_rule_body(CanoniTerm,WS,DWS,Code,Status).


/*****************************************************************************
   leftNAF_implication(+IfPart,+ThenPart,+WS,+DWS,-Code,-Status)
   naf_iff(+Left,+Right,+WS,+DWS,-Code,-Status)
   If-then expressed using <~~ (naf-implication)
*****************************************************************************/
leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status) :-
        parse_rule_body(IfPart,WS,DWS,IfCode,Stat1),
        (Stat1 == NO_ERRORS
        -> parse_rule_body(ThenPart,WS,DWS,ThenCode,Status),
            (Status == NO_ERRORS
            ->
                flifthen_struct(IfCode,ThenCode,Code)
            ; true
            )
        ;
            Status = Stat1
        ).


naf_iff(Left,Right,WS,DWS,Code,Status) :-
        leftNAF_implication(Left,Right,WS,DWS,Code1,Status1),
        leftNAF_implication(Right,Left,WS,DWS,Code2,Status2),
        append(Status1,Status2,Status),
        (Status == NO_ERRORS ->
            flconjunct_struct(Code1,Code2,Code)
        ; true
        ).


/*****************************************************************************
   body_leftNEG_implication(+IfPart,+ThenPart,+WS,+DWS,-Code,-Status)
   neg_iff(+Left,+Right,+WS,+DWS,-Code,-Status)
   If-then expressed using <== (neg-implication)
   Also <==>
*****************************************************************************/
body_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status) :-
        parse_rule_body(IfPart,WS,DWS,IfCode,Stat1),
        (Stat1 == NO_ERRORS
        -> parse_rule_body(ThenPart,WS,DWS,ThenCode,Status),
            (Status == NO_ERRORS
            ->
                get_index(IfPart,Idx),
                flneg_struct(IfCode,Idx,NegIfCode),
                fldisjunct_struct(NegIfCode,ThenCode,Code)
            ; true
            )
        ;
            Status = Stat1
        ).

%% TODO: REWRITE to avoid double parsing of both Left and Right
neg_iff(Left,Right,WS,DWS,Code,Status) :-
        body_leftNEG_implication(Left,Right,WS,DWS,Code1,Status1),
        body_leftNEG_implication(Right,Left,WS,DWS,Code2,Status2),
        append(Status1,Status2,Status),
        (Status == NO_ERRORS ->
            flconjunct_struct(Code1,Code2,Code)
        ; true
        ).


/****************************************************************************
  parse_body_univeqform(+CanoniTerm,+WS,+DWS,-Code,-Status)
  parse_body_notuniveqform(+CanoniTerm,+WS,+DWS,-Code,-Status)

  Parse the meta ops ~ and !~
****************************************************************************/
parse_body_univeqform(CANOTERM(_Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
        protect_reification(distribute_workspace(Args,WS,DWS,[LCode,RCode],Status)),
        (Status == NO_ERRORS -> fluniveqform_struct(LCode,RCode,Code) ; true).

parse_body_notuniveqform(CANOTERM(_Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
        protect_reification(distribute_workspace(Args,WS,DWS,[LCode,RCode],Status)),
        (Status == NO_ERRORS
        -> fluniveqform_struct(LCode,RCode,Code1),
            flprlgnaf_struct(Code1,Code)
        ; true
        ).


/*******************************************************************************
  parse_body_metauniv(+CanoniTerm,+WS,+DWS,-Code,-Status)

  Parse the meta op =..
  (_ =.. _)@\prolog(mod) and (_ =.. _)@\prologall(mod)
  are illegal, but
  (_ =.. _)@\prolog() and (_ =.. _)@\prologall() are legal.
*******************************************************************************/
parse_body_metauniv(CANOTERM(_Funct,2,FL_PARENTHESIS,_Args,If,_Ip),WS,_DWS,_Code,Status) :-
        %% Only @\prolog() and @\prologall() are allowed;
        %% they don't match flora_get_module_from_spec/3
        %% The test below checks for @\prolog(mod), @\prologall(mod)
        is_prologmodule(WS,_),
        !,
        parsing_error(If,NO_WORKSPACE,Status).

%% If (_ =.. _)@\prolog() or (_ =.. _)@\prologall(), then use Prolog =..
parse_body_metauniv(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),WS,DWS,Code,Status) :-
        is_prologmodule(WS),
        !,
        (WS == PROLOGMODULE
        -> ( (get_flvar_struct(Left,LeftParsed), S1 = NO_ERRORS, !
             ; parse_prlgterm(Left,DWS,LeftParsed,S1)),
               (S1 == NO_ERRORS ->
                   parse_body_pathexplist([Right],DWS,PURE_PATHEXPS_ONLY,[RightParsed],Status)
               %% failed to parse the first term
               ; Status = S1
               )
           )
        ;  %% PROLOGALLMODULE
            ( parse_pure_term(Left,DWS,LeftParsed,S1),
                (S1 == NO_ERRORS -> parse_pure_term(Right,DWS,RightParsed,Status)
                %% failed to parse the first term
                ; Status = S1
                )
            )
        ),
        %% put together parsed terms using =.. (=Funct)
        (Status == NO_ERRORS ->
            %% FCode is parsed functor code
            flobject_struct(Funct,FCode),
            flterm_struct(FCode,2,[LeftParsed,RightParsed],Code1),
            %% protect predicate code against hilog conversion
            ( WS == PROLOGMODULE ->
                flplib_struct(Code1,Code_pre)
              %% WS == PROLOGALLMODULE
             ;  flpliball_struct(Code1,Code_pre)
            ) ,
            multiply_setarg_code(Code_pre,Code_pre_list),
            parse_list2flconjunct(Code_pre_list,Code)
        %% failed to parse the second term
        ; true
        ).

parse_body_metauniv(CANOTERM(_Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),DWS,DWS,Code,Status) :-
        parse_body_pathexp(Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LeftParsed,S1),
        (S1 == NO_ERRORS ->
            parse_body_pathexplist([Right],DWS,PURE_PATHEXPS_ONLY,[RightParsed],Status)
        ; %% failed to parse the first term
            Status = S1
        ),
        (Status == NO_ERRORS ->
            flmetauniv_struct(LeftParsed,RightParsed,Code)
        %% failed to parse the second term
        ; true
        ).


/****************************************************************************
  parse_body_controlconstruct(+CanoniTermList1,+WS,+DWS,+TopWrapper,-Code,-Status).
   Process control constructs while-do/loop, loop/do-until, unless-do
   CanoniTermList1 represents the inner part of the control construct,
   e.g., the do-part in while(do(Cond,Action)).
   It should be a singleton list that contains a canonic term.
   TopWrapper is the unary wrapper (whole,do,loop,unless) for the construct
****************************************************************************/
parse_body_controlconstruct([CANOTERM(InnerFunct,2,FL_PARENTHESIS,Args,If,_Ip)],WS,DWS,TopWrapper,Code,Status) :-
        get_name(InnerFunct,InnerName),
        !,
        (get_control_construct_definition(StructType,TopWrapper,InnerName)
        -> S1 = NO_ERRORS
        ;
            (control_construct_real_name(TopWrapper,TopWrapperName) -> true
            ; TopWrapper = TopWrapperName
            ),
            flora_concat_atoms(['Illegal connective `', InnerName, ''' in `',
                               TopWrapperName, ''' construct'],
                              ErrMsg),
            parsing_error(If,ErrMsg,S1)
        ),
        (S1==NO_ERRORS -> Args=[Cond,Action],
            parse_rule_body(Cond,WS,DWS,CondCode,S2),
            (S2== NO_ERRORS -> parse_rule_body(Action,WS,DWS,ActionCode,Status)
            ; Status = S2
            ),
            (Status == NO_ERRORS
            -> flcontrolconstruct_struct(CondCode,ActionCode,StructType,Code)
            ; true
            )
        ; Status = S1 % error
        ).

%% If wrong number of args or wrong parenthesis - issue an error
parse_body_controlconstruct([CANOTERM(_InnerFunct,_Arity,_Parenthesis,_Args,If,_Ip)],_WS,_DWS,TopWrapper,_Code,Status) :-
        (control_construct_real_name(TopWrapper,TopWrapperName) -> true
        ; TopWrapper = TopWrapperName
        ),
        flora_concat_atoms(['Illegal syntax in `', TopWrapperName, ''' construct'],
                           ErrMsg),
        parsing_error(If,ErrMsg,Status).


parse_body_controlconstruct([SomethingElse],_WS,_DWS,TopWrapper,_Code,Status) :-
        get_index(SomethingElse,Idx),
        (control_construct_real_name(TopWrapper,TopWrapperName) -> true
        ; TopWrapper = TopWrapperName
        ),
        flora_concat_atoms(['Illegal syntax in `', TopWrapperName, ''' construct'],
                           ErrMsg),
        parsing_error(Idx,ErrMsg,Status).



/****************************************************************************
  distribute_workspace(+List,+WS,+DWS,-TransformedList,-Status)

  Distribute the workspace through a list of formulae AND parse
  the individual list members with that workspace
****************************************************************************/
distribute_workspace([],_WS,_DWS,[],NO_ERRORS) :- !.
distribute_workspace([A|Args],WS,DWS,[TA|TArgs],Status) :-
        (get_flvar_struct(A,TA), Status1 = NO_ERRORS, !
        ;
            parse_rule_body(A,WS,DWS,TA,Status1)
        ),
        (Status1 == NO_ERRORS -> distribute_workspace(Args,WS,DWS,TArgs,Status)
        ; Status = Status1
        ).


/****************************************************************************
  parse_body_literal(+CanoniTerm,+DWS,-Code,-Status)

  This predicate is called to parse a literal in a rule body.

****************************************************************************/
parse_body_literal(CanoniTerm,DWS,Code,Status) :-
        exec_directive(CanoniTerm,DWS,TCode,Status),
        !,
        flora_get_module_from_spec(DWS,ModuleType,Module),
        flmodule_struct(ModuleType,TCode,Module,Code).

%% :(_,_), ::(_,_)
parse_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        is_birelop(F),
        !,
        parse_body_pathexp(Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
        (S==NO_ERRORS ->
            parse_body_pathexp(Right,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
        ; Status = S
        ),
        (Status == NO_ERRORS ->
            flbirelate_struct(LCode,F,RCode,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true
        ).

%% Path expression without a []: a.c.b rather than a.b.c[].
%% '.'(_,_), '!'(_,_),
parse_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        is_objrefop(F),
        !,
        parsing_error(If,ERROR_NONBOOLPATHEXP,Status).

%% catch{...}
parse_body_literal(CANOTERM(Funct,3,FL_BRACE,[Goal,Error,Handler],_If,_Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_catchop(Atom),
        !,
        parse_catch(Goal,Error,Handler,DWS,Code,Status).

%% throw{...}
parse_body_literal(CANOTERM(Funct,1,FL_BRACE,[Error],_If,_Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_throwop(Atom),
        !,
        parse_throw(Error,DWS,Code,Status).

%% p2h{...}
parse_body_literal(CANOTERM(Funct,2,FL_BRACE,[Prolog,Hilog],_If,_Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_p2hop(Atom),
        !,
        parse_p2h(Prolog,Hilog,DWS,Code,Status).


/*
%% We'd like to restrict the use of true{...}, but top level is too much.
%% Need some kind of stratification.
%% true{...}, false{...}, undefined{...} - check that they are used at top level
parse_body_literal(CANOTERM(Funct,1,FL_BRACE,[_Arg],_If,Ip),_DWS,_Code,Status) :-
        get_name(Funct,Atom),
        is_truthvalue_op(Atom),
        \+has_context(CONTEXT_PARSER_QUERY),
        !,
        parsing_error(Ip,ERROR_TRUTHVALUED_OP,Status).
*/

%% true{...}, false{...}, undefined{...}
parse_body_literal(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_truthvalue_op(Atom),
        !,
        flatom_struct(Atom,Ip,AtomCode),
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_rule_body(Conjunct,DWS,DWS,ArgCodePre,Status),
        (Status == NO_ERRORS
        ->
            to_LT(ArgCodePre,ArgCode),
            fltruthvalue_struct(ArgCode,AtomCode,Code)
        ;
            true
        ).

%% refresh{...}
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_tablerefreshop(Atom),
        !,
        (N == 0
        ->
            parsing_error(Ip,EXP_ARGS,Status)
        ;
            parse_tablerefresh(Args,DWS,Code,Status)
        ).

%% !!{...} - stop delay of calls hanging off of the given vars
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),_DWS,Code,Status) :-
        get_atom(Funct,Atom),
        is_stopdelayop(Atom),
        !,
        (N == 0
        ->
            parsing_error(Ip,EXP_ARGS,Status)
        ;
            parse_varlist(Args,ArgCode,_,Status),
            flstopdelay_struct(ArgCode,Ip,Code)
        ).

%% !! - stop delay of calls hanging off of ALL vars 
parse_body_literal(CanoniTerm,_DWS,Code,NO_ERRORS) :-
        get_atom(CanoniTerm,A),
        is_stopdelayop(A),
        !,
        get_index(CanoniTerm,I),
        flstopdelay_struct(I,Code).

%% !!{...} - stop delay of calls hanging off of the given vars
parse_body_literal(CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,_If,Ip),_DWS,_Code,Status) :-
        get_atom(Funct,Atom),
        is_stopdelayop(Atom),
        !,
        parsing_error(Ip,STOP_DELAY_OP_SYNTAX,Status).

%% tag{Tag, Head} - tag language primitive
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,_Args,If,_Ip),DWS,_Code,Status) :-
        get_name(Funct,Atom),
        is_tag_primitive_op(Atom),
        ( DWS \== NULL -> parsing_error(If,ERROR_TAGPRIMITIVEMOD,Status)
        ; N \= 2 -> parsing_error(If,ERROR_TAGPRIMITIVEARITY,Status)
        ).

%% tag{?Tag,?Head}.  tag{...}@Mod is not supported
parse_body_literal(CANOTERM(Funct,2,FL_BRACE,[Descriptors,Head],_If,_Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_tag_primitive_op(Atom),
        !,
        parse_term_or_var(Descriptors,DescriptorsCode,S1),
        (S1 == NO_ERRORS ->
            parse_dbliteral_list_conjunctless(FLCLS,[Head],DWS,HeadCodeList,NULL,Status),
            ( Status == NO_ERRORS
            -> fltag_primitive_struct(DescriptorsCode,HeadCodeList,Code)
            ; true
            )
        ;
            Status = S1
        ).

%% prefix{?X,?Expansion} and prefix{?X,?Expansion}@Module
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_name(Funct,Atom),
        is_prefixprimitive_op(Atom),
        N \= 2,
        !,
        parsing_error(If,ERROR_PREFIXPRIMITIVEARITY,Status).

%% prefix{?X,?Expansion} and prefix{?X,?Expansion}@Module
parse_body_literal(CANOTERM(Funct,2,FL_BRACE,[Prefix,Expansion],If,_Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_prefixprimitive_op(Atom),
        !,
        flora_get_module_from_spec(DWS,_ModuleType,ModuleCode),
        (name_or_var(Prefix,PrefixCode),
            name_or_var(Expansion,ExpansionCode) ->
            flprefixprimitive_struct(PrefixCode,ExpansionCode,ModuleCode,Code),
            Status = NO_ERRORS
        ; parsing_error(If,ERROR_PREFIXPRIMITIVESYNTAX,Status)
        ).

%% insert{...}
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_dbinsertop(Atom),
        !,
        ( N == 0 ->
            parsing_error(Ip,EXP_ARGS,Status)
        ; has_context(CONTEXT_PARSER_HYPOTHETICAL), is_nonlogical_updateop(Atom)
        ->
            parsing_error(Ip,DISALLOWED_UPDATE_IN_HYPOTHETICAL,Status)

        ; flobject_struct(Funct,FCode),
            parse_dbinsert(FCode,N,Args,DWS,Code,Status)
        ).

%% delete{...}
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_dbdeleteop(Atom),
        !,
        ( N == 0 ->
            parsing_error(Ip,EXP_ARGS,Status)
        ; has_context(CONTEXT_PARSER_HYPOTHETICAL), is_nonlogical_updateop(Atom)
        ->
            parsing_error(Ip,DISALLOWED_UPDATE_IN_HYPOTHETICAL,Status)

        ; flobject_struct(Funct,FCode),
            parse_dbdelete(FCode,N,Args,DWS,Code,Status)
        ).

%% newmodule{Module}
parse_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_NEWMODULE),
        !,
        flobject_struct(Funct,FCode),
        ( name_or_normvar(Arg,MCode)
        ->
          flnewmodule_struct(FCode,MCode,Code),
          Status = NO_ERRORS
        ;
            parsing_error(Ip,ERROR_WSNAME,Status)
        ).

%% erasemodule{Module}
parse_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_ERASEMODULE),
        !,
        flobject_struct(Funct,FCode),
        ( name_or_normvar(Arg,MCode)
        ->
          flerasemodule_struct(FCode,MCode,Code),
          Status = NO_ERRORS
        ;
          parsing_error(Ip,ERROR_WSNAME,Status)
        ).

%% caller{Module}
parse_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_CALLERMODULE),
        !,
        flobject_struct(Funct,FCode),
        (name_or_normvar(Arg,VCode)
        ->
            flcallermodule_struct(FCode,VCode,Code),
            Status = NO_ERRORS
        ;
            parsing_error(Ip,ERROR_WSNAME,Status)
        ).

%% \load(...)
parse_body_literal(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_LOAD),
        !,
        ( Args == [] ->
            flatom_struct(FL_INLINEMODULE,NO_INDEX,C1),
            fllist_struct([C1],[],If,C),
            Status = NO_ERRORS
        ;
          parse_loadlist(Args,[],Ip,C,Status)
        ),
        (Status == NO_ERRORS -> flload_struct(C,Code)
        ; true
        ).
%% load{...}
parse_body_literal(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_LOADPRIM),
        !,
        ( Args == [] ->
            flatom_struct(FL_INLINEMODULE,NO_INDEX,C1),
            fllist_struct([C1],[],If,C),
            Status = NO_ERRORS
        ;
          parse_loadlist(Args,[],Ip,C,Status)
        ),
        (Status == NO_ERRORS -> flload_struct(C,Code)
        ; true
        ).

%% \add(...)
parse_body_literal(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),_DWS,Code,Status) :-
        get_name(Funct,FL_ADD),
        !,
        ( Args == []
        ->
            flatom_struct(FL_INLINEMODULE,NO_INDEX,C1),
            fllist_struct([C1],[],If,C),
            Status = NO_ERRORS
        ;
          parse_loadlist(Args,[],Ip,C,Status)
        ),
        (Status == NO_ERRORS -> fladd_struct(C,Code)
        ; true
        ).
%% add{...}, addnew{...}
parse_body_literal(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),_DWS,Code,Status) :-
        (get_name(Funct,FL_ADDPRIM) ; get_name(Funct,FL_ADDNEWPRIM)),
        !,
        ( Args == []
        ->
            flatom_struct(FL_INLINEMODULE,NO_INDEX,C1),
            fllist_struct([C1],[],If,C),
            Status = NO_ERRORS
        ;
          parse_loadlist(Args,[],Ip,C,Status)
        ),
        (Status == NO_ERRORS ->
            (get_name(Funct,FL_ADDPRIM) -> fladd_struct(C,Code)
            ; fladdnew_struct(C,Code)
            )
        ; true
        ).

%% simple generic primitive like primName{Args}
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,_Ip),DWS,Code,Status) :-
        is_simple_primitive_obj(Funct,N,PrimitiveName),
        !,
        parse_simple_primitive(PrimitiveName,N,Args,DWS,Code,Status).

%% simple generic PREFIXED primitive like +/-primName{Args}
parse_body_literal(CANOTERM(PrefxFunct,1,FL_PARENTHESIS,[Prim],_If,_Ip),DWS,Code,Status) :-
        get_name(PrefxFunct,Prefix),
        Prim = CANOTERM(PrimFunct,N,FL_BRACE,Args,_,_),
        N1 is N+1,
        is_simple_primitive_obj(PrimFunct,N1,PrimitiveName),
        prefixable_simple_primitive(PrimitiveName,Prefix),
        !,
        parse_simple_primitive(PrimitiveName,N1,[PrefxFunct|Args],DWS,Code,Status).


%% insertrule_a{...}, insertrule_z{...}, deleterule_a{...},
%% deleterule_z{...}, or deleterule{...}
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
        get_name(Funct,Atom),
        is_ruleupdateop(Atom),
        !,
        ( N == 0
        ->
            parsing_error(Ip,EXP_ARGS,Status)
        ;
            flobject_struct(Funct,FCode),
            parse_ruleupdate(FCode,N,Args,DWS,Code,Status)
        ).

%% clause{[Mode,]Head, Body}
parse_body_literal(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),DWS,_Code,Status) :-
        get_name(Funct,Atom),
        is_clauseop(Atom),
        DWS \== NULL,
        \+has_context(CONTEXT_PARSER_REIFY),
        !,
        parsing_error(If,ERROR_CLAUSEMOD,Status).

%% clause{[Mode,]Head, Body}
%% Note: we ignore _DWS1 here and use DWS==NULL
parse_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_DWS1,Code,Status) :-
        get_name(Funct,Atom),
        is_clauseop(Atom),
        DWS=NULL,
        !,
        set_context(CONTEXT_PARSER_CLAUSE_CONSTRUCT),
        set_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        (   %% when clause{...} has descriptors then it is parsed either as a
            %% single argument [DescrHeadBodyTerm] or [Mode,DescrHeadBodyTerm]
            (Args = [RulePattern], ModeCode = NULL
            ; Args = [Mode,RulePattern],
                flobject_struct(Mode,ModeCode),
                is_flatom_struct(ModeCode,ModeAtom),
                valid_clause_mode(ModeAtom)
            ),
            get_statement_descriptors(RulePattern,Descriptors,Statement),
            Descriptors \== []
        ->
            parse_descriptor_list(Descriptors,true,DescrCode,S1),
            (S1 == NO_ERRORS
            ->
                Statement = CANOTERM(_F,_N,_Par,ClauseArgs,_,_),
                length(ClauseArgs,ClN),
                NewStatement = CANOTERM(Funct,ClN,FL_BRACE,ClauseArgs,If,Ip),
                parse_body_literal(NewStatement,DWS,Code1,Status),
                (Status == NO_ERRORS
                -> 
                    (flclause_struct(H,B,Code1)
                    -> flclause_with_descriptor_struct(DescrCode,ModeCode,H,B,Code)
                    ; flclause_struct(ModeCode,H,B,Code1)
                    -> flclause_with_descriptor_struct(DescrCode,ModeCode,H,B,Code)
                    )
                ; true
                )
            ; Status = S1
            )
        ; N==2 ->
            Args = [Head,Body],
            comma_separated_canoterm_to_list(Head,HeadList),
            %% NULL here means that error will be issued, if HeadList
            %% has disjunction, quantifier, etc.
            parse_dbliteral_list_conjunctless(FLCLS,HeadList,DWS,HeadCodeList,NULL,S1),
            ( S1 == NO_ERRORS ->
                parse_rule_body(Body,DWS,DWS,BodyCode,Status),
                ( Status == NO_ERRORS ->
                    flclause_struct(HeadCodeList,BodyCode,Code)
                ;
                    true
                )
            ;
                Status = S1
            )
        ; N==3 ->
            Args = [Mode,Head,Body],
            flobject_struct(Mode,ModeCode),
            ( is_flatom_struct(ModeCode,ModeAtom),
                valid_clause_mode(ModeAtom)
            ->
                comma_separated_canoterm_to_list(Head,HeadList),
                %% NULL here means that error will be issued, if HeadList
                %% has disjunction, quantifier, etc.
                parse_dbliteral_list_conjunctless(FLCLS,HeadList,DWS,HeadCodeList,NULL,S1),
                ( S1 == NO_ERRORS
                ->
                    parse_rule_body(Body,DWS,DWS,BodyCode,Status),
                    ( Status == NO_ERRORS
                    ->
                        flclause_struct(ModeCode,HeadCodeList,BodyCode,Code)
                    ;
                        true
                    )
                ;
                    Status = S1
                )
            ;
                parsing_error(Ip,ERROR_CLAUSE,Status)
            )
        ;
            parsing_error(Ip,ERROR_CLAUSE,Status)
        ),
        clear_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        clear_context(CONTEXT_PARSER_CLAUSE_CONSTRUCT).

valid_clause_mode(STATIC_CLAUSE) :- !.
valid_clause_mode(DYNAMIC_CLAUSE) :- !.
valid_clause_mode(DYNA_CLAUSE) :- !.
valid_clause_mode(DYNZ_CLAUSE) :- !.

%% :=:
parse_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_OBJEQL),
        !,
        parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,[LCode,RCode],Status),
        (Status == NO_ERRORS ->
            flobjeql_struct(LCode,RCode,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true
        ).

parse_body_literal(CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        flora_reserved_symbol_not_literal(F,N),
        !,
        parsing_error(If, ERROR_BDLITERAL, Status).

parse_body_literal(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        !,
        parse_body_term(Funct,N,Args,ALLOW_TRANS,DWS,TCode,Stat1),
        (nonvar(TCode), is_flnumber_struct(TCode), Stat1 == NO_ERRORS ->
            parsing_error(If,ERROR_BDLITERAL,Status)
        ; Stat1 == NO_ERRORS ->
            Status = Stat1,
            /*
              Previously we had here that nowsp predicates would simply ignore
              the module, but this is not very good. For instance, we want
              the module to propagate to  propagate the module to
              (aaa.bbb = c.m)@foo and (aaa.bbb < c.m)@foo. So, we don't check
              for flora_nowsp/2 here. All these predicates are either Prolog
              or treated specially elsewhere, so flora_nowsp/2 may not
              actually be that useful any more.
              NOW: no longer checking flora_nowsp(F,N) here.
            */
            (%% get_atom(Funct,F), flora_nowsp(F,N) -> Code = TCode
            %%;
                is_fllist_struct(TCode) -> Code = TCode
            ;
                flora_get_module_from_spec(DWS,ModuleType,Module),
                flmodule_struct(ModuleType,TCode,Module,Code)
            )
        ; Status = Stat1
        ).

%% obj[...]
parse_body_literal(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_body_objspec(Funct,N,Args,DWS,NONINHERITABLE,TCode,Status),
        (Status == NO_ERRORS ->
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true
        ).
%% obj[|...|]
parse_body_literal(CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_body_objspec(Funct,N,Args,DWS,INHERITABLE,TCode,Status),
        (Status == NO_ERRORS ->
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true
        ).

%% case of ?- []. or ?- [files] Inline file
parse_body_literal(CANOLIST(L,T,_N,I,_Ib),_DWS,Code,Status) :-
        !,
        %% Inline file. Encoded as '|', since this symbol can't occur in a file.
        ( L == [] ->
            flatom_struct(FL_INLINEMODULE,I,C1),
            fllist_struct([C1],[],I,C),
            Status = NO_ERRORS
        ;
          parse_loadlist(L,T,I,C,Status)
        ),
        (Status == NO_ERRORS -> flload_struct(C,Code)
        ; true
        ).

%% {...} at the top level -- constraint
parse_body_literal(CANOBRACE(L,_N,I),DWS,Code,Status) :-
        !,
        (L == []
        %% {} at the top level with nothing inside
        -> parsing_error(I, ERROR_BDLITERAL, Status)
        ;
            set_context(CONTEXT_PARSER_CLP_CONSTRAINT),
            parse_constraint_list(L,DWS,Code,Status),
            clear_context(CONTEXT_PARSER_CLP_CONSTRAINT)
        ).

parse_body_literal(CANOEMPTYTERM(I),_DWS,_Code,Status) :-
        !,
        %% () at the top level with nothing inside
        parsing_error(I, ERROR_BDLITERAL, Status).

parse_body_literal(CanoniTerm,DWS,Code,Status) :-
        get_atom(CanoniTerm,A),
        !,
        ( A == FL_CUT ->
            Status = NO_ERRORS,
            get_index(CanoniTerm,I),
            flcut_struct(I,Code)
        ; \+is_valid_term_name(A) ->
            parsing_error(CanoniTerm,ERROR_TERM_NAME, Status)
        ;
            Status = NO_ERRORS,
            flobject_struct(CanoniTerm,TCode),
            ( flora_nowsp(A,0) -> Code = TCode
            ; flora_get_module_from_spec(DWS,ModuleType,Module),
                flmodule_struct(ModuleType,TCode,Module,Code)
            )
        ).

parse_body_literal(CanoniTerm,DWS,Code,Status) :-
        get_transactionalatom(CanoniTerm,Atom),
        !,
        (\+is_valid_term_name(Atom) ->
            parsing_error(CanoniTerm,ERROR_TERM_NAME, Status)
        ; fltransactionalobject_struct(CanoniTerm,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code),
            Status = NO_ERRORS
        ).

parse_body_literal(CanoniTerm,DWS,Code,Status) :-
        get_flvar_struct(CanoniTerm,C),
        !,
        ( has_context(CONTEXT_PARSER_REIFY), DWS==NULL
        ->
            %% implicit reification is when we reify because of an
            %% argument declaration FL_BODYFORMULA
            (has_context(CONTEXT_PARSER_IMPLICIT_REIFICATION) ->
                Code = C, Status = NO_ERRORS
            ;   %% seems more useful to not issue this error and to allow
                %% things like ${?v} and ${\neg ?v} than to issue error
                %%parsing_error(CanoniTerm,NO_REIFY_VAR,Status)
                Code = C, Status = NO_ERRORS
            )
        /*
        %% This happens when we have a predicate with a variable in an argument
        %% declared as FL_BODYLITERAL. Do NOT issue an error in this case.
        ; has_context(CONTEXT_PARSER_FACT) ->
            parsing_error(CanoniTerm,NO_PRED_VAR,Status)
        */
        ;   Status = NO_ERRORS,
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,C,Module,Code)
        ).

parse_body_literal(CanoniTerm,DWS,Code,Status) :-
        get_fltransactionalvar_struct(CanoniTerm,C),
        !,
        (has_context(CONTEXT_PARSER_CLAUSE_CONSTRUCT)
        -> is_anonymous_flvar_struct(ModVar),
            Status = NO_ERRORS,
            flmodule_struct(FLORAUSERMOD,C,ModVar,Code)
        ; DWS==NULL ->
            is_anonymous_flvar_struct(ModVar),
            Status = NO_ERRORS,
            flmodule_struct(FLORAUSERMOD,C,ModVar,Code)
            %%% It seems useless & unjustified to ban standalone transactional
            %%% vars when non-transactional standalones are allowed.
            %%%parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
        /*
        %% This happens when we have a predicate with a variable in an argument
        %% declared as BODYLITERAL. Do NOT issue an error in this case.
        ; has_context(CONTEXT_PARSER_FACT) ->
            parsing_error(CanoniTerm,NO_PRED_VAR,Status)
        */
        ; flora_get_module_from_spec(DWS,ModuleType,Module),
          flmodule_struct(ModuleType,C,Module,Code),
          Status = NO_ERRORS
        ).
        
parse_body_literal(CanoniTerm,_DWS,_Code,Status) :-
        !,
        parsing_error(CanoniTerm,ERROR_BDLITERAL,Status).

/****************************************************************************
  parse_body_template_list(+List,-CodeList,-Status)
  %% body templates appear in ignore_depchk directives
****************************************************************************/
parse_body_template_list([],[],NO_ERRORS) :- !.
parse_body_template_list([H|T],[HCode|TCode],Status) :- 
        parse_body_template(H,HCode,S),
        (S == NO_ERRORS ->
            parse_body_template_list(T,TCode,Status)
        ;
            Status = S
        ).


/****************************************************************************
  parse_body_template(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
parse_body_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_AT),
        workspace_template(R,RCode,S),
        ( S == NO_ERRORS ->
            parse_body_literal_template(L,RCode,LCode,Status),
            (Status == NO_ERRORS -> 
                flora_get_module_from_spec(RCode,ModuleType,Module),
                flmodule_struct(ModuleType,LCode,Module,Code)
            ; 
                true
            )
        ; 
            Status = S
        ).

parse_body_template(CanoniTerm,Code,Status) :-
        parse_body_literal_template(CanoniTerm,Code,Status).

/****************************************************************************
  workspace_template(+CanoniTerm,-Code,-Status)

  Note: There are no prolog modules in export templates
        Module variables can be only anonymous
****************************************************************************/
%% atomic
workspace_template(CanoniTerm,FLORAUSERMOD(MCode),NO_ERRORS) :-
        get_flname_struct(CanoniTerm,MCode),
        !.

%% anonymous variable as module
workspace_template(CanoniTerm,FLORAUSERMOD(MCode),NO_ERRORS) :-
        get_flvar_struct(CanoniTerm,MCode),
        is_anonymous_flvar_struct(MCode),
        !.

%% \@ as module
workspace_template(CanoniTerm,FLORAUSERMOD(MCode),NO_ERRORS) :-
        get_spectoken(CanoniTerm,FL_THISMODULE),
        !,
        flobject_struct(CanoniTerm,MCode).

%% system module specification @\prolog
workspace_template(CanoniTerm,PROLOGMODULE,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(CanoniTerm,NVCode),
        is_flatom_struct(NVCode,FL_PLIB),
        !.

workspace_template(CANOTERM(Mod,1,FL_PARENTHESIS,[M],_Ifu,_Ipa),PROLOGMODULE(MCode),NO_ERRORS) :-
        get_flbuiltin_identifier_struct(Mod,NVCode),
        is_flatom_struct(NVCode,FL_PLIB),
        !,
        ( get_flname_struct(M,MCode) -> Status = NO_ERRORS
        ; parsing_error(M,ERROR_WSNAME,Status)
        ).


%% system module specification @\module
workspace_template(CanoniTerm,FLORASYSMOD(MCode),Status) :-
        get_flbuiltin_identifier_struct(CanoniTerm,MCode),
        is_flatom_struct(MCode,ModuleName),
        !,
        ( flora_system_module(ModuleName) -> Status = NO_ERRORS
        ; parsing_error(CanoniTerm,UNREG_SYSMOD,Status)
        ).

%% system module specification @\module
workspace_template(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),FLORASYSMOD(MCode),Status) :-
        get_flbuiltin_identifier_struct(Mod,MCode),
        is_flatom_struct(MCode,ModuleName),
        !,
        ( flora_system_module(ModuleName) -> Status = NO_ERRORS
        ; parsing_error(Mod,UNREG_SYSMOD,Status)
        ).

workspace_template(CanoniTerm,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_WSNAME,Status).


/****************************************************************************
  parse_body_literal_template(+CanoniTerm,-Code,-Status)
****************************************************************************/
%% transactional vars as literals can appear only with module specifications
parse_body_literal_template(CanoniTerm,_WS,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,Code),
        !,
        (is_fltransactionalvar_struct(Code),
            \+ is_anonymous_fltransactionalvar_struct(Code)
        ->
            parsing_error(CanoniTerm,ERROR_NAMEDVAR,Status)
        ;
            Status = NO_ERRORS
        ).

parse_body_literal_template(CanoniTerm,_WS,Code,Status) :-
        parse_body_literal_template(CanoniTerm,Code,Status).
        
%% :(_,_), ::(_,_)
parse_body_literal_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
        get_atom(Funct,F),
        is_birelop(F),
        !,
        ( get_flvar_struct(L,LCode), is_anonymous_flvar_struct(LCode) ->
            term_template(R,DISALLOW_TRANS,RCode,Status),
            (Status == NO_ERRORS -> flbirelate_struct(LCode,F,RCode,Code); true)
        ;
            parsing_error(L,EXP_ANONYVAR,Status)
        ).

%% TODO: Need to allow load{...} and rule insert/delete ops
%% insert{...} or delete{...}
parse_body_literal_template(CANOTERM(Funct,N,FL_BRACE,Args,_If,_Ip),Code,Status) :-
        get_name(Funct,Atom),
        (is_dbinsertop(Atom),Type=FL_INSERT
        ;
         is_dbdeleteop(Atom),Type=FL_DELETE
        ),
        !,
        flobject_struct(Funct,FCode),
        ( N == 1,
            Args = [CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_Ifb,_Ipb)],
            get_atom(Bar,FL_BAR)
        ->
            comma_separated_canoterm_to_list(L,LList),
            anonymous_varlist(LList,LCode,Status),
            (Status == NO_ERRORS ->
                ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                    (Type==FL_INSERT ->
                        flinsert_struct(FCode,LCode,RCode,Code)
                    ;
                        fldelete_struct(FCode,LCode,RCode,Code)
                    )
                ;
                    parsing_error(R,EXP_ANONYVAR,Status)
                )
            ;
                true
            )
        ;
            anonymous_varlist(Args,LCode,Status),
            (Status == NO_ERRORS ->
                (Type==FL_INSERT ->
                    flinsert_struct(FCode,LCode,Code)
                ;
                    fldelete_struct(FCode,LCode,Code)
                )
            ;
                true
            )
        ).

%% obj[...]
parse_body_literal_template(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),Code,Status) :-
        !,
        ( get_flvar_struct(Funct,OCode), is_anonymous_flvar_struct(OCode) ->
            ( N == 0 ->
                SpecCode = [],
                Status = NO_ERRORS
            ;
                Args=[Spec],
                parse_body_attmeth_template(Spec,NONINHERITABLE,SpecCode,Status)
            ),
            (Status == NO_ERRORS -> flobjspec_struct(OCode,SpecCode,NONINHERITABLE,Code)
            ; true
            )
        ;
            parsing_error(Funct,EXP_ANONYVAR,Status)
        ).
%% obj[|...|]
parse_body_literal_template(CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),Code,Status) :-
        !,
        ( get_flvar_struct(Funct,OCode), is_anonymous_flvar_struct(OCode) ->
            ( N == 0 ->
                SpecCode = [],
                Status = NO_ERRORS
            ;
                Args=[Spec],
                parse_body_attmeth_template(Spec,INHERITABLE,SpecCode,Status)
            ),
            (Status == NO_ERRORS -> flobjspec_struct(OCode,SpecCode,INHERITABLE,Code); true)
        ;
            parsing_error(Funct,EXP_ANONYVAR,Status)
        ).

parse_body_literal_template(CANOLIST([Term],[],_N,I,_Ib),Code,Status) :-
        !,
        ( Term = CANOTERM(F,2,FL_PARENTHESIS,Args,_,_)
        ->
            ( get_name(F,FL_RIGHTTO)
            ->
                anonymous_varlist(Args,AList,Status),
                (Status == NO_ERRORS
                ->
                    flobject_struct(F,FCode),
                    flterm_struct(FCode,2,AList,TCode),
                    fllist_struct([TCode],[],I,LCode),
                    flload_struct(LCode,Code)
                ;
                    true
                )
            ;
                parsing_error(Term,ERROR_TEMPLATE,Status)
            )
        ;
            anonymous_varlist([Term],AList,Status),
            ( Status == NO_ERRORS
            ->
                fllist_struct(AList,[],I,LCode),
                flload_struct(LCode,Code)
            ; 
                true
            )
        ).

%% a stand-alone %? is not allowed
parse_body_literal_template(CanoniTerm,_Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        is_fltransactionalvar_struct(C),
        !,
        parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status).
        
%% term
parse_body_literal_template(CanoniTerm,Code,Status) :-
        term_template(CanoniTerm,ALLOW_TRANS,Code,Status),
        !.

parse_body_literal_template(CanoniTerm,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_TEMPLATE,Status).


/****************************************************************************
  parse_body_attmeth_template(+CanoniTerm,+Type,-Code,-Status)
  methods and attributes can be term templates, and all other arguments must
  be anonymous variables
  Type -  INHERITABLE/NONINHERITABLE
****************************************************************************/
parse_body_attmeth_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Type,Code,Status) :-
        get_atom(Funct,F),
        ( is_mvdattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                term_template(L,DISALLOW_TRANS,LCode,Status),
                %% TODO: check if needs [RCode] instead of RCode
                (Status == NO_ERRORS -> flmvdattspec_struct(LCode,F,[RCode],Type,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

        ; is_sigattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                term_template(L,DISALLOW_TRANS,LCode,Status),
                (Status == NO_ERRORS -> flsigattspec_struct(LCode,F,RCode,Type,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

        ; is_incattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                term_template(L,DISALLOW_TRANS,LCode,Status),
                (Status == NO_ERRORS -> flincattspec_struct(LCode,F,RCode,Type,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

        ; is_tolistattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                term_template(L,DISALLOW_TRANS,LCode,Status),
                (Status == NO_ERRORS -> fltolistattspec_struct(LCode,F,RCode,Type,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )
        ),
        !.

parse_body_attmeth_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),Type,Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        ( (get_flname_struct(R,RCode)
          ;
              get_flvar_struct(R,RCode),
              is_anonymous_flvar_struct(RCode)
          )
        ->
            parse_body_attmeth_template(L,Type,LCode,S),
            ( S == NO_ERRORS ->
                ( ( is_flattspec_struct(LCode,_)
                  ; is_passthru_struct(LCode)
                  )
                ->
                      parsing_error(L,NO_WORKSPACE,Status)
                ;
                    flmethspec_struct(C,Type,LCode),
                    ( is_flworkspace_struct(C) ->
                        parsing_error(If,NO_WSNESTING,Status)
                    ;
                        flmodule_struct(FLORAUSERMOD,C,RCode,W),
                        flmethspec_struct(W,Type,Code),
                        Status = NO_ERRORS
                    )
                )
            ;
                Status = S
            )
        ;
            parsing_error(R,ERROR_WSNAME,Status)
        ).

parse_body_attmeth_template(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),Type,Code,Status) :-
        get_atom(Funct,F),
        is_boolsigop(F),
        !,
        term_template(A,DISALLOW_TRANS,ACode,S1),
        (S1 == NO_ERRORS ->
            flboolsig_struct(ACode,F,Type,Code),
            Status = NO_ERRORS
        ;
            %% passing NONINHERITABLE so as to not a get an error about
            %% inheriitable default transactions, ERROR_TRANS_DEFAULT_VALUE
            parse_body_attmeth_template(A,NONINHERITABLE,ACode2,S2),
            (S2 == NO_ERRORS ->
                %% use _T, not Type here, since ACode2 has a type inside of it
                (fltranspec_struct(ATemp,_T,ACode2) -> 
                    fltransig_struct(ATemp,F,Type,Code),
                    Status = NO_ERRORS
                ;
                    parsing_error(A,ERROR_BOOLSIG,Status)
                )
            ;
                parsing_error(A,ERROR_BOOLSIG,Status)
            )
        ),
        !.

parse_body_attmeth_template(CanoniTerm,Type,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        (is_fltransactionalvar_struct(C),
            \+ is_anonymous_fltransactionalvar_struct(C)
        ->
            parsing_error(CanoniTerm,ERROR_NAMEDVAR,Status)
        ; Type == INHERITABLE ->
            parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
        ;
            fltranspec_struct(C,Type,Code),
            Status = NO_ERRORS
        ).
 
parse_body_attmeth_template(CanoniTerm,Type,Code,Status) :-
        term_template(CanoniTerm,ALLOW_TRANS,C,S1),
        (S1 == NO_ERRORS -> 
            ((is_fltransactionalterm_struct(C)
             ; is_fltransactionalobject_struct(C)
             ; is_fltransactionalatom_struct(C)
             )
            -> (Type == INHERITABLE ->
                   parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
               ; fltranspec_struct(C,Type,Code),
                   Status = NO_ERRORS
               )
            ;
                flmethspec_struct(C,Type,Code),
                Status = NO_ERRORS
            )
        ;
            Status = S1
        ).

/****************************************************************************
  term_template(+CanoniTerm,+TransFlag,+AllowVarArgsNum,-Code,-Status)
  Term template can be defined recursively:
    1) primitive structures except named variables are all term templates
    2) Term(_,_,...) is a term template if Term is a term template

    +AllowVarArgsNumn - allow terms with variable number of arguments
****************************************************************************/
term_template(CanoniTerm,TransFlag,Code,Status) :-
        term_template(CanoniTerm,TransFlag,DISALLOW_TERM_VARARGS,Code,Status).

term_template(CANOTERM(Funct,1,FL_PARENTHESIS,[Term],_If,_Ip),_TransFlag,AllowVarArgsNum,Code,Status) :-
        (get_name(Funct,FL_LOAD); get_name(Funct,FL_ADD)),
        !,
        flobject_struct(Funct,FunctCode),
        ( Term = CANOTERM(F,2,FL_PARENTHESIS,Args,_,_)
        ->
            ( get_name(F,FL_RIGHTTO)
            ->
                anonymous_varlist(Args,AllowVarArgsNum,AList,S1),
                (S1 == NO_ERRORS
                ->
                    flobject_struct(F,FCode),
                    flterm_struct(FCode,2,AList,TCode),
                    flterm_struct(FunctCode,1,[TCode],Code),
                    Status = NO_ERRORS
                ;
                    Status = S1
                )
            ;
                parsing_error(Term,ERROR_TEMPLATE,Status)
            )
        ;
            anonymous_varlist([Term],AllowVarArgsNum,AList,Status),
            ( Status == NO_ERRORS
            ->
                flterm_struct(FunctCode,1,AList,Code)
            ;
                true
            )
        ).

term_template(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,_AllowVarArgsNum,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        %% we call with DWS=NULL here, if no explicit WS
        parse_curi(Args,TransFlag,NULL,Code,Status).

term_template(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,_AllowVarArgsNum,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        parse_body_term(Funct,2,Args,TransFlag,NULL,Code,Status).
                
term_template(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,AllowVarArgsNum,Code,Status) :-
        !,
        term_template(Funct,TransFlag,F,S),
        ( S == NO_ERRORS ->
            anonymous_varlist(Args,AllowVarArgsNum,AList,Status),
            (Status == NO_ERRORS -> 
                ((is_fltransactionalobject_struct(F)
                 ; is_fltransactionalterm_struct(F)
                 ; is_fltransactionalatom_struct(F)
                 )
                ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
        ;
          Status = S
        ).

term_template(ObjectTerm,_TransFlag,_AllowVarArgsNum,Code,Status) :-
%%  primitive structures except named variables
        flobject_struct(ObjectTerm,Code),
        !,
        ( is_flvar_struct(Code), \+ is_anonymous_flvar_struct(Code)
        ->
            parsing_error(ObjectTerm,ERROR_NAMEDVAR,Status)
        ;
            Status = NO_ERRORS
        ).

term_template(ObjectTerm,ALLOW_TRANS,_AllowVarArgsNum,Code,Status) :-
        fltransactionalobject_struct(ObjectTerm,Code),
        !,
        (is_fltransactionalvar_struct(Code),
            \+ is_anonymous_fltransactionalvar_struct(Code)
        ->
            parsing_error(ObjectTerm,ERROR_NAMEDVAR,Status)
        ;
            Status = NO_ERRORS
        ).

term_template(CanoniTerm,_TransFlag,_AllowVarArgsNum,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_TEMPLATE,Status).

/****************************************************************************
  anonymous_varlist(+List,+AllowVarArgsNum,-CodeList,-Status)
  parse a list of anonymous variables
****************************************************************************/
anonymous_varlist(List,CodeList,Status) :-
        anonymous_varlist(List,DISALLOW_TERM_VARARGS,CodeList,Status).
anonymous_varlist([],_AllowVarArgsNum,[],NO_ERRORS) :- !.
anonymous_varlist([H|L],AllowVarArgsNum,[HCode|LCode],Status) :-
        ( get_flvar_struct(H,HCode), is_anonymous_flvar_struct(HCode) ->
            anonymous_varlist(L,AllowVarArgsNum,LCode,Status)
        ; get_atom(H,HAtom), HAtom==FL_STAR, flobject_struct(H,HCode) ->
            anonymous_varlist(L,AllowVarArgsNum,LCode,Status)
        ;
            parsing_error(H,EXP_ANONYVAR,Status)
        ).

/****************************************************************************
   make_pred_arity_pair_list(+Args,-ArgCode,-Status)
   make_pred_arity_slash_list(+Args,-ArgCode,-Status)

   Parses a list of pred/arity, pred/arity, ...
   This is parsed directly into the prolog form and executed
   Used by the :- prolog directive

   make_pred_arity_pair_list parses pred/arity into (pred,arity)
   make_pred_arity_slash_list parses pred/arity into pred/arity

****************************************************************************/
make_pred_arity_pair_list([],[],NO_ERRORS) :- !.
make_pred_arity_pair_list([Spec|SpecList],[SpecCode|SpecListCode],Status) :-
        make_one_pred_arity_pair(Spec,SpecCode,S1),
        (S1 == NO_ERRORS -> make_pred_arity_pair_list(SpecList,SpecListCode,Status)
        ;  S1 = Status
        ).

make_pred_arity_slash_list([],[],NO_ERRORS) :- !.
make_pred_arity_slash_list([Spec|SpecList],[(Pred/Arity/Idx)|SpecListCode],Status) :-
        make_one_pred_arity_pair(Spec,(Pred,Arity,Idx),S1),
        (S1 == NO_ERRORS -> make_pred_arity_slash_list(SpecList,SpecListCode,Status)
        ;  S1 = Status
        ).

make_one_pred_arity_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[Pred,Arity],_If,_Ip),(PredName,Int,Idx),Status) :-
        get_name(Funct,FL_SLASH),
        get_atom(Pred,PredName,Idx),
        get_integer(Arity,Int),
        (is_contextually_disallowed_reserved_builtin(PredName,Int)
        -> parsing_error(Pred,ERROR_RESERVED_SYMBOL,Status)
        ; Status = NO_ERRORS
        ),
        !.

%% :- usesensor allows pred@prologmodule/Arity
%% No IRIs or curies for Prolog stuff
make_one_pred_arity_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[PredAtModCanoTerm,Arity],_If,_Ip),((PredName,ModName),Int,Idx),Status) :-
        has_context(CONTEXT_PARSER_USESENSOR_DIRECTIVE),
        get_name(Funct,FL_SLASH),
        get_integer(Arity,Int),
        PredAtModCanoTerm = CANOTERM(ModConnective,2,FL_PARENTHESIS,[Pred,Mod],_If1,_Ip1),
        get_name(ModConnective,FL_AT),
        get_name(Pred,PredName,Idx),
        get_name(Mod,ModName),
        (is_contextually_disallowed_reserved_builtin(PredName,Int)
        -> parsing_error(Pred,ERROR_RESERVED_SYMBOL,Status)
        ; Status = NO_ERRORS
        ),
        !.

%% case when predicate is defined via a curi
make_one_pred_arity_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[Pred,Arity],_If,_Ip),(PredName,Int,Ifp),Status) :-
        get_name(Funct,FL_SLASH),
        parse_curi_canoterm(Pred,DISALLOW_TRANS,NULL,PredNameCode,Status1),
        get_integer(Arity,Int),
        is_flatom_struct(PredNameCode,PredName,Ifp),
        (Status1==NO_ERRORS,
            is_contextually_disallowed_reserved_builtin(PredName,Int)
        -> parsing_error(Pred,ERROR_RESERVED_SYMBOL,Status)
        ; Status = Status1
        ),
        !.

%% case when predicate is defined as a full IRI
make_one_pred_arity_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[Pred,Arity],_If,_Ip),(PredName,Int,Ifp),Status) :-
        get_name(Funct,FL_SLASH),
        Pred = CANOTERM(Funct2,2,FL_PARENTHESIS,Args,Ifp,_Ipp),
        %% Funct2 is a datatype definition symbol ^^
        get_atom(Funct2,F2),
        is_datatypeop(F2),
        parse_composer_datatype(Args,Ifp,_WS,PrefixCode,Status1),
        is_flatom_struct(PrefixCode,PredName),
        get_integer(Arity,Int),
        (Status1==NO_ERRORS,
            is_contextually_disallowed_reserved_builtin(PredName,Int)
        -> parsing_error(Pred,ERROR_RESERVED_SYMBOL,Status)
        ; Status = Status1
        ),
        !.

/*
%% the case of ?[Attr->?].
%% Produces (frame(MethodCode),3,Status) - for frames translated as Prolog
make_one_pred_arity_pair(CANOTERM(Obj,1,FL_BRACKET,[AttMethSpec],If,_Ip),(FL_FRAME(PredCode),3,If),Status) :-
        get_flvar_struct(Obj,ObjCode), is_anonymous_flvar_struct(ObjCode),
        AttMethSpec = CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_,_),
        get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode),
        get_atom(Funct,FName),
        is_mvdattspecop(FName),
        term_template(L,DISALLOW_TRANS,PredCode,Status),
        !.
*/

make_one_pred_arity_pair(CANOTERM(_,_,_,_,If,_Ip),_,Status) :-
        !,
        parsing_error(If,ERROR_PRED_ARITY_PAIR,Status).


/****************************************************************************
  parse_loadlist(+ListPrefix,+ListTail,+Index,-FLLIST,-Status)
****************************************************************************/
parse_loadlist([],[],Index,T,NO_ERRORS) :-
        !,
        fllist_struct([],[],Index,T).

parse_loadlist(L,T,Index,Code,Status) :-
        loaditemlist(L,LCode,S),
        ( S == NO_ERRORS ->
            ( T == [] ->
                TCode = [],
                Status = NO_ERRORS

            ; T=CANOLIST(List,Tail,_N,I,_Ib) ->
                parse_loadlist(List,Tail,I,TCode,Status)

            ; get_flvar_struct(T,TCode) ->
                Status = NO_ERRORS
            ;
              parsing_error(T,ERROR_LOADLIST,Status)
            ),
            (Status == NO_ERRORS -> fllist_struct(LCode,TCode,Index,Code); true)
        ;
          Status = S
        ).


loaditemlist([],[],NO_ERRORS) :- !.

loaditemlist([T|L],[TCode|LCode],Status) :-
        loaditem(T,TCode,S),
        (S == NO_ERRORS -> loaditemlist(L,LCode,Status); Status = S).

%% ?- [>>module] - inline load into module
loaditem(CANOTERM(Funct,1,FL_PARENTHESIS,[R],If,_Ip),Code,Status) :-
        get_atom(Funct,FL_RIGHTTO),
        flobject_struct(Funct,FCode),
        !,
        flatom_struct(FL_INLINEMODULE,If,LCode),
        (name_or_normvar(R,RCode) ->
           flterm_struct(FCode,2,[LCode,RCode],Code),
           Status=NO_ERRORS
        ; get_spectoken(R,Tok), Tok \= FL_NEWOID, Tok \= FL_SPECIAL_VAR_TOKEN ->
            Status=NO_ERRORS,
            flobject_struct(R,RCode),
            flterm_struct(FCode,2,[LCode,RCode],Code)
        %% allow curis
        ; parse_curi_canoterm(R,DISALLOW_TRANS,NULL,RCode,Status) ->
            flterm_struct(FCode,2,[LCode,RCode],Code)
        %% allow modules like "..."^^\iri
        ; is_datatype_canoterm(R,IRI,TypeCode,Idx),
            get_name(TypeCode,TypeName),
            flora_synonymous_type_names(TypeName,FL_IRI)
        ->
            parse_composer_datatype([IRI,TypeCode],Idx,NULL,RCode,Status),
            flterm_struct(FCode,2,[LCode,RCode],Code)
        ;
            parsing_error(R,ERROR_WSNAME,Status)
        ). 

%% ?- [file>>module] - load to module
%% ?- [+file>>module] - addition to module
%% ?- [+ >>module] - inline addition to module
loaditem(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_RIGHTTO),
        flobject_struct(Funct,FCode),
        !,
        ( name_or_normvar(R,RCode) ->
            flterm_struct(FCode,2,[LCode,RCode],Code),
            RStatus=NO_ERRORS
        ; get_spectoken(R,Tok), Tok \= FL_NEWOID, Tok \= FL_SPECIAL_VAR_TOKEN ->
            RStatus=NO_ERRORS,
            flobject_struct(R,RCode),
            flterm_struct(FCode,2,[LCode,RCode],Code)
        %% allow curis
        ; parse_curi_canoterm(R,DISALLOW_TRANS,NULL,RCode,RStatus) ->
            flterm_struct(FCode,2,[LCode,RCode],Code)
        %% allow modules like "..."^^\iri
        ; is_datatype_canoterm(R,IRI,TypeCode,Idx),
            get_name(TypeCode,TypeName),
            flora_synonymous_type_names(TypeName,FL_IRI)
        ->
            parse_composer_datatype([IRI,TypeCode],Idx,NULL,RCode,RStatus),
            flterm_struct(FCode,2,[LCode,RCode],Code)
        ;
            parsing_error(R,ERROR_WSNAME,RStatus)
        ),
        %% Now construct the LCode
        (RStatus == NO_ERRORS ->
            (name_or_normvar(L,LCode) -> Status = NO_ERRORS
            ; get_flbuiltin_identifier_struct(L,LCode) -> Status = NO_ERRORS
            ; parse_urlfile(L,LCode,Status) -> true
            %% support for adding files to modules
            ; parse_addfile(L,LCode,Status) -> true
            ;
                parsing_error(L,ERROR_LOADFILE,Status)
            )
        ; Status = RStatus
        ).

loaditem(CanoniTerm,Code,Status) :-
        (get_flbuiltin_identifier_struct(CanoniTerm,Code) -> Status = NO_ERRORS
        ; name_or_normvar(CanoniTerm,Code) -> Status = NO_ERRORS
        ; parse_urlfile(CanoniTerm,Code,Status) -> true
        ;
            parse_addfile(CanoniTerm,Code,Status)
        ),
        !.

loaditem(CanoniTerm,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_LOADITEM,Status).


name_or_normvar(CanoniTerm,Code) :-
        ( get_flname_struct(CanoniTerm,Code)
        ;
          get_flvar_struct(CanoniTerm,Code),
          \+ is_anonymous_flvar_struct(Code)
        ),
        !.

name_or_var(CanoniTerm,Code) :-
        ( get_flname_struct(CanoniTerm,Code)
        ;
            get_flvar_struct(CanoniTerm,Code)
        ),
        !.

parse_term_or_var(CanoniTerm,Code,Status) :-
        ( get_flname_struct(CanoniTerm,Code) -> Status = NO_ERRORS
        ; get_flvar_struct(CanoniTerm,Code) -> Status = NO_ERRORS
        ; is_spectoken(CanoniTerm) ->
            flobject_struct(CanoniTerm,Code), 
            Status = NO_ERRORS
        ; CanoniTerm = CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip) ->
            parse_body_term(Funct,N,Args,DISALLOW_TRANS,NULL,Code,Status) 
        ; CanoniTerm = CANOLIST(L,T,_N,If,_Ip) ->
            parse_list(L,T,If,NULL,Code,Status)
        ),
        !.


%% support for adding files
%% the case of a normal file: [+file ...]
parse_addfile(CANOTERM(Funct,1,FL_PARENTHESIS,[L],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_PLUS),
        !,
        flatom_struct(FL_PLUS,NO_INDEX,FCode),
        ( name_or_normvar(L,LCode) -> LStatus = NO_ERRORS
        ; get_flbuiltin_identifier_struct(L,LCode) -> LStatus = NO_ERRORS
        ; parse_urlfile(L,LCode,LStatus)
        ),
        (LStatus == NO_ERRORS ->
            flterm_struct(FCode,1,[LCode],Code),
            Status=LStatus
        ;
            parsing_error(L,ERROR_ADDFILE,Status)
        ).

%% the case of ?- [+>> module] - inline file
parse_addfile(CANOTERM(Funct,1,FL_PARENTHESIS,[R],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_ALLINARROW),
        !,
        flatom_struct(FL_PLUS,NO_INDEX,PlusCode),
        flatom_struct(FL_INLINEMODULE,NO_INDEX,LCode),
        flterm_struct(PlusCode,1,[LCode],FileCode),
        (name_or_normvar(R,RCode) ->
            flatom_struct(FL_RIGHTTO,NO_INDEX,ToModCode),
            flterm_struct(ToModCode,2,[FileCode,RCode],Code),
            Status = NO_ERRORS
        ; parsing_error(R,ERROR_WSNAME,Status)
        ).

%% the case of ?- [+ >> module] - inline file
parse_addfile(Canoterm,Code,NO_ERRORS) :-
        get_atom(Canoterm,FL_PLUS),
        !,
        flatom_struct(FL_PLUS,NO_INDEX,FCode),
        flatom_struct(FL_INLINEMODULE,NO_INDEX,LCode),
        flterm_struct(FCode,1,[LCode],Code).

%% file name specified as url('http://...')
parse_urlfile(CANOTERM(Funct,1,FL_PARENTHESIS,[L],_If,_Ip),Code,Status) :-
        get_atom(Funct,FL_URL),
        !,
        CanoniTerm = CANOTERM(Funct,1,FL_PARENTHESIS,[L],_If,_Ip),
        parse_prlgterm(CanoniTerm,_DWS,Code,Status).


/*
thismodule_token(CanoniTerm,ThisModToken) :-
        get_spectoken(CanoniTerm,FL_THISMODULE),
        flobject_struct(CanoniTerm,ThisModToken). % this always succeeds
*/


/****************************************************************************
    parse_constraint_list(+L,+DWS,-Code,-Status)
    Add brace to delineate constraints
****************************************************************************/

parse_constraint_list(L,DWS,Code,Status) :-
        parse_body_literal_list(L,DWS,Lcode,Status),
        flconstraint_struct(Lcode,Code).

parse_body_literal_list([L],DWS,Code,Status) :-
        !,
        parse_body_literal(L,DWS,Code,Status).

parse_body_literal_list([L|Lits],DWS,Code,Status) :-
        parse_body_literal(L,DWS,Lcode,S),
        (S == NO_ERRORS
        -> parse_body_literal_list(Lits,DWS,LitsCode,Status),
            (Status == NO_ERRORS -> flconjunct_struct(Lcode,LitsCode,Code); true)
        ; Status = S
        ).


/****************************************************************************
  parse_prlgterm(+CanoniTerm,+DWS,-Code,-Status)

  This predicate is called to parse a Prolog predicate or prolog term.
  Its arguments can be F-logic molecules and path expressions, so the arguments
  are not parsed as Prolog terms.

  This is using DWS workspace because the term args can be Flora-2 molecules.
****************************************************************************/
parse_prlgterm(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        !,
        ( get_atom(Funct,FAtom) ->
            ( FAtom == FL_AT, N == 2 ->
                parsing_error(If,NO_WSNESTING,Status)
            ;
                parse_body_term(Funct,N,Args,DISALLOW_TRANS,DWS,Code,Status)
            )
        ;
            parsing_error(If,ERROR_PRLGLIT,Status)
        ).

parse_prlgterm(CanoniTerm,_DWS,Code,NO_ERRORS) :-
        get_flname_struct(CanoniTerm,Code),
        !.

parse_prlgterm(CanoniTerm,_DWS,Code,NO_ERRORS) :-
        get_flbuiltin_identifier_struct(CanoniTerm,Code),
        !.

parse_prlgterm(CanoniTerm,_DWS,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_PRLGLIT,Status).


/****************************************************************************
  parse_body_term(+Funct,+Arity,+Args,+TransFlag,+DWS,-Code,-Status)

  Parse a term Funct-spec(Args). Arguments are parsed according to
  the argument spec in flora_argdef. The final parsed term is composed
  using flterm_struct

****************************************************************************/
parse_body_term(Funct,N,_Args,_TransFlag,_DWS,_Code,Status) :-
        get_atom(Funct,FAtom),
        %% reserved builtins are redefinable, but since they are reserved we
        %% don't want to allow the user to define these builtins with any other
        %% arity. For instance, \opposes/2 & \opposes/4 are reserved for
        %% specific uses, but we don't want the user to define, say, \opposes/5.
        is_disallowed_reserved_builtin(FAtom,N),
        !,
        parsing_error(Funct,ERROR_RESERVED_ARITY,Status).


%% Handles =(Expr) in the body
parse_body_term(Funct,1,[Arg],TransFlag,DWS,Code,Status) :-
	get_atom(Funct,FAtm),
	memberchk(FAtm,[FL_EVALEXPR,FL_EVALEXPR2]),
	!,
	parse_body_pathexp(Arg,TransFlag,DWS,PURE_PATHEXPS_ONLY,Code1,Status),
	flevalexpr_struct(Code1,Code).

%% Handles the feature =(Expr) in insert/delete statements
parse_db_term(Mode,Context,Funct,1,[Arg],TransFlag,DWS,Code,Status) :-
	get_atom(Funct,FAtm),
	memberchk(FAtm,[FL_EVALEXPR,FL_EVALEXPR2]),
	!,
	(Context == DB_LITERAL ->
	    ( Mode == FLINS -> parsing_error(If,ERROR_INSERT,Status)
	    ; Mode == FLDEL -> parsing_error(If,ERROR_DELETE,Status)
	    ; Mode == FLREF -> parsing_error(If,ERROR_REFRESH,Status)
	    ; Mode == FLCLS -> parsing_error(If,ERROR_CLAUSELIT,Status)
	    )
	; parse_db_pathexp(Mode,Arg,TransFlag,DWS,PURE_PATHEXPS_ONLY,Code1,Status),
	    flevalexpr_struct(Code1,Code)
	).


parse_body_term(Funct,_N,_Args,_TransFlag,_DWS,_Code,Status) :-
        get_atom(Funct,FAtom),
        FAtom == FL_UDFF,
        !,
        parsing_error(Funct,ERROR_UDF_LIT,Status).

parse_body_term(Funct,N,Args,_TransFlag,DWS,Code,Status) :-
        get_atom(Funct,FAtom),
        flora_argdef(FAtom,N,ArgTypes,DWS),
        !, 
        (\+ is_valid_term_name(FAtom) ->
            parsing_error(Funct,ERROR_TERM_NAME, Status)
        ;
            flobject_struct(Funct,F),
            parse_body_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status)
        ),
        ( Status == NO_ERRORS
        -> flterm_struct(F,N,AList,Code)
        ;
            true
        ).

parse_body_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
        fltransactionalobject_struct(Funct,F),
        !,
        (get_transactionalatom(Funct,FAtom),
            \+is_valid_term_name(FAtom) ->
            parsing_error(Funct,ERROR_TERM_NAME, Status)
        ; TransFlag == ALLOW_TRANS ->
            (get_transactionalatom(Funct,FAtom),
                flora_argdef(FAtom,N,ArgTypes,DWS)
            -> parse_body_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ;
                parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ),
            (Status == NO_ERRORS -> fltransactionalterm_struct(F,N,AList,Code) ; true)
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

parse_body_term(Funct,_N,Args,_TransFlag,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        get_index(Funct,If),
        parse_composer_datatype(Args,If,DWS,Code,Status).

parse_body_term(Funct,2,Args,TransFlag,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,TransFlag,DWS,Code,Status).

parse_body_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
        parse_body_pathexp(Funct,TransFlag,DWS,PURE_PATHEXPS_ONLY,F,S),
        (TransFlag==ALLOW_TRANS,
            get_atom(Funct,FAtom), \+is_valid_term_name(FAtom) ->
            parsing_error(Funct,ERROR_TERM_NAME, Status)
        ; S == NO_ERRORS ->
            parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,AList,Status),
            (Status == NO_ERRORS -> 
                ((is_fltransactionalterm_struct(F)
                 ; is_fltransactionalatom_struct(F)
                 )
                ->
                        fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ; true
            )
        ;
          Status = S
        ).

/****************************************************************************
  parse_pure_term(+Canoterm,+DWS,-Code,-Status)

  Parse a term Funct-spec(Args). Arguments are parsed as terms as well.
  No molecules are allowed, except reified molecules under ${...} and
  those apearing in meta-arguments.
****************************************************************************/
%% reification ${...}
parse_pure_term(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),DWS,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        (list_to_canoterm_conjunct(Args,Conjunct,If,Ip) ->
            parse_reify(Conjunct,DWS,Code,Status)
        ;  parsing_error(Ip,EXP_ARGS,Status)
        ).

parse_pure_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FAtom),
        flora_argdef(FAtom,N,ArgTypes,DWS),
        !,
        flobject_struct(Funct,F),
        parse_pure_term_list_with_argdefs(Args,ArgTypes,DWS,AList,Status),
        (Status == NO_ERRORS
        -> flterm_struct(F,N,AList,Code)
        ;
            true
        ).

parse_pure_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        flobject_struct(Funct,F),
        !,
        parse_pure_term_list(Args,DWS,AList,Status),
        (Status == NO_ERRORS
        -> flterm_struct(F,N,AList,Code)
        ;
            true
        ).

parse_pure_term(CANOLIST(L,T,_N,Index,_Ib),DWS,Code,Status) :-
        !,
        parse_pure_term_list(L,DWS,LCode,LStatus),
        (LStatus == NO_ERRORS ->
            ( T == [] -> TCode = [], Status = NO_ERRORS
            ;
                parse_pure_term(T,DWS,TCode,Status)
            ),
            (Status == NO_ERRORS -> fllist_struct(LCode,TCode,Index,Code)
            ; true
            )
        ;
          Status=LStatus
        ).

parse_pure_term(CanoniTerm,_DWS,Code,NO_ERRORS) :-
        flobject_struct(CanoniTerm,Code),
        !.

parse_pure_term(CanoniTerm,_DWS,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_TERM_FOR_CONTEXT,Status).


%% parse list of pure terms
parse_pure_term_list([],_DWS,[],NO_ERRORS) :- !.
parse_pure_term_list([Arg|Args], DWS,[ArgCode|ArgCodeList], Status) :-
        parse_pure_term(Arg,DWS,ArgCode,Status1),
        (Status1 == NO_ERRORS
        -> parse_pure_term_list(Args,DWS,ArgCodeList,Status)
        ; Status = Status1
        ).

%% parse list of pure terms taking into account argument definitions
%% in which these terms occur (FL_OID or FL_BODYFORMULA)
parse_pure_term_list_with_argdefs([],_,_DWS,[],NO_ERRORS) :- !.
parse_pure_term_list_with_argdefs([Arg|Args],[FL_OID|ArgsDefs],DWS,[ArgCode|ArgCodeList], Status) :-
        parse_pure_term(Arg,DWS,ArgCode,Status1),
        (Status1 == NO_ERRORS
        -> parse_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
        ; Status = Status1
        ).
parse_pure_term_list_with_argdefs([Arg|Args],[FL_BODYFORMULA|ArgsDefs],DWS,[RArgCode|ArgCodeList], Status) :-
        set_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        parse_rule_body(Arg,DWS,DWS,ArgCode,Status1),
        clear_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        (Status1 == NO_ERRORS
        -> 
            flreify_struct(ArgCode,RArgCode),
            parse_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
        ; Status = Status1
        ).
parse_pure_term_list_with_argdefs([Arg|Args],[FL_ARITH|ArgsDefs],DWS,[ArithArgCode|ArgCodeList], Status) :-
        parse_pure_term(Arg,DWS,ArgCode,Status1),
        flarith_struct(ArgCode,ArithArgCode),
        (Status1 == NO_ERRORS
        -> parse_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
        ; Status = Status1
        ).
parse_pure_term_list_with_argdefs([Arg|Args],[FL_PROLOG|ArgsDefs],DWS,[ArgCode|ArgCodeList], Status) :-
        parse_pure_term(Arg,DWS,ArgCode1,Status1),
        (is_fllist_struct(ArgCode1) -> ArgCode = ArgCode1
        ; flplib_struct(ArgCode1,ArgCode)
        ),
        (Status1 == NO_ERRORS
        -> parse_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
        ; Status = Status1
        ).


/***************************************************************************
    Prolog term with no F-logic - not even reification
    parse_pure_prolog_term(+Canoterm,+PrologModule,-Code,-VarNameList,Status)
    parse_pure_prolog_arglist(+Varlist,-VarListCode,-VarNameList,-Status)

    VarNameList - list of names of vars. Used for consistency checking
    We don't grok lists here.
***************************************************************************/
parse_pure_prolog_term(Canoterm,_PrlgMod,Code,_,NO_ERRORS) :-
        get_flvar_struct(Canoterm,Code),
        !.
parse_pure_prolog_term(Canoterm,_PrlgMod,Code,_,NO_ERRORS) :-
        flobject_struct(Canoterm,Code),
        !.
%% allow reified terms
parse_pure_prolog_term(CANOTERM(Funct,_N,FL_BRACE,[Arg|Rest],If,Ip),_PrlgMod,Code,_,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        list_to_canoterm_conjunct([Arg|Rest], Conjunct, If, Ip),
        parse_reify(Conjunct,NULL,Code,Status).
%% allow simple primitives as args
parse_pure_prolog_term(CANOTERM(Funct,N,FL_BRACE,Args,_If,_Ip),_PrlgMod,Code,_,Status) :-
        is_simple_primitive_obj(Funct,N,PrimitiveName),
        !,
        %% the DWS arg is NULL here
        parse_simple_primitive(PrimitiveName,N,Args,NULL,Code,Status).
parse_pure_prolog_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),PrlgMod,Code,VarNameList-Tail,Status) :-
        get_name(Funct,_),
        !,
        flobject_struct(Funct,F),
        parse_pure_prolog_arglist(Args,PrlgMod,AList,VarNameList-Tail,Status),
        (Status == NO_ERRORS
        -> flterm_struct(F,N,AList,Goal),
            (PrlgMod == usermod -> flplib_struct(Goal,Code)
            ; flmodule_struct(PROLOGMODULE,Goal,PrlgMod,Code)
            )
        ;
            true
        ).
%% if Funct is an IRI or some kind of other thing convertible into an atom
parse_pure_prolog_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),PrlgMod,Code,VarNameList-Tail,Status) :-
        parse_head_literal(Funct,NULL,DTcode,_),
        is_flatom_struct(DTcode,F,Idx),
        !,
        flatom_struct(F,Idx,FObj),
        parse_pure_prolog_arglist(Args,PrlgMod,AList,VarNameList-Tail,Status),
        (Status == NO_ERRORS
        -> flterm_struct(FObj,N,AList,Goal),
            (PrlgMod == usermod -> flplib_struct(Goal,Code)
            ; flmodule_struct(PROLOGMODULE,Goal,PrlgMod,Code)
            )
        ;
            true
        ).
parse_pure_prolog_term(CANOTERM(_,_,_,_,_If,Ip),_,_,_,Status) :-
        parsing_error(Ip,INVALID_CANONICAL_TERM,Status).

%% parse_pure_prolog_arglist(+ArgList,+PrlgModule,-ParsedArgs,-VarNames,-Status)
parse_pure_prolog_arglist([],_,[],X-X,NO_ERRORS) :- !.
parse_pure_prolog_arglist([Arg|ArgList],Mod,[Atom|ArgListCode],VarNames-T,Status) :-
        get_flname_struct(Arg,Atom),
        !,
        parse_pure_prolog_arglist(ArgList,Mod,ArgListCode,VarNames-T,Status).

parse_pure_prolog_arglist([Arg|ArgList],Mod,[Var|ArgListCode],[VarName|Tail]-T,Status) :-
        get_flvar_struct(Arg,Var),
        is_flvar_struct(Var,VarName,_),
        !,
        parse_pure_prolog_arglist(ArgList,Mod,ArgListCode,VarNameList-T,Status),
        Tail = VarNameList.
parse_pure_prolog_arglist([Arg|ArgList],Mod,[ArgCode|ArgListCode],Vars-T,Status) :-
        parse_pure_prolog_term(Arg,Mod,ArgCode,Vars-Tail,S1),
        !,
        (S1 == NO_ERRORS
        ->
            parse_pure_prolog_arglist(ArgList,Mod,ArgListCode,VarNameList-T,Status),
            Tail = VarNameList
        ; Status = S1
        ).
parse_pure_prolog_arglist([Arg|_],_,_,_,Status) :-
        !,
        get_index(Arg,I),
        parsing_error(I,INVALID_CANONICAL_ARGLIST,Status).


%% parse_varlist(+VarObjectList,-VarCodeList,-VarNameList,Status)
%% VarNameList is provided for the compiler so it could check that
%% quantification vars appear in the quantified formula
parse_varlist([],[],[],NO_ERRORS) :- !.
parse_varlist([Var|Args],[VarCode|ArgsCode],[VarName|ArgNames],Status) :-
        (get_flvar_struct(Var,VarCode),
            is_flvar_struct(VarCode,VarName,_)
        -> parse_varlist(Args,ArgsCode,ArgNames,Status)
        ; is_datatype_canoterm(Var,VarLit,TypeCode,Idx),
            %% quantified typed vars - in body only
            get_flvar_struct(VarLit,VarCodeNoDT),
            is_flvar_struct(VarCodeNoDT,VarName,_)
        ->
            (/*\+has_compiler_persistentoption(FL_QUANTTYPEDVARS) ->
                get_index(Var,I),
                parsing_error(I,NO_QUANTTYPEDVAR_ERROR,Status)
            ; */
            has_context(CONTEXT_PARSER_RULEHEAD),
                %% NOT issuing errors because head typed quantified vars can be
                %% useful in omnis e.g.: forall(?X^^foo)^p(?X,?Y) <== q(?Y).
                fail
            ->
                get_index(Var,I),
                parsing_error(I,HEAD_QUANT_TYPED_VAR,Status)
            ;
                parse_composer_datatype([VarLit,TypeCode],Idx,NULL,VarCode,Stat1),
                (Stat1==NO_ERRORS ->
                    parse_varlist(Args,ArgsCode,ArgNames,Status)
                ; Status = Stat1
                )
            )
        ;
            get_index(Var,I),
            parsing_error(I,VARLIST_ERROR,Status)
        ).


/****************************************************************************
  parse_list(+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)

  Index is for '['.
****************************************************************************/
parse_list([],[],Index,_DWS,T,NO_ERRORS) :-
        !,
        fllist_struct([],[],Index,T).

parse_list(L,T,Index,DWS,Code,Status) :-
        parse_body_pathexplist(L,DWS,PURE_PATHEXPS_ONLY,LCode,S),
        ( S == NO_ERRORS ->
            ( T == [] ->
                TCode = [],
                Status = NO_ERRORS
            ;
              parse_body_pathexplist([T],DWS,PURE_PATHEXPS_ONLY,[TCode],Status)
            ),
            (Status == NO_ERRORS -> fllist_struct(LCode,TCode,Index,Code); true)
        ;
          Status = S
        ).


/****************************************************************************
  parse_body_pathexplist(+ListOfCanoniTerms,+DWS,+TermArgMode,-ListOfPathExpressions,-Status)

  parses a list of path expressions that are supposed to represent oids.
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames

****************************************************************************/
parse_body_pathexplist([],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_body_pathexplist([T|L],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_body_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_body_pathexplist(L,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).

is_truthval_pathexp(Obj,PURE_PATHEXPS_ONLY) :-
        is_flobjspec(Obj,_,_,_),
        \+ has_context(CONTEXT_PARSER_NL_TEMPLATE_SENTENCE_PART).


/****************************************************************************
  parse_body_argpathexplist(+Terms,+ArgumentTypes,+DWS,+TermArgMode,-PathExpressions,-Status)

  parses a list of path expressions according to a list of argument
  specification directives.
  FL_OID means the oid represented by a path expression while
  FL_BODYFORMULA means the formula represented by a path expression.
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_body_argpathexplist([],[],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_body_argpathexplist([T|L],[FL_OID|Arguments],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_body_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_body_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).

parse_body_argpathexplist([T|L],[FL_BODYFORMULA|Arguments],DWS,TermArgMode,[RTCode|LCode],Status) :-
        set_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        (T = CANOBRACE(SetL,SetN,_SetI), SetN > 0 ->
            %% if this is a set-argument under FL_BODYFORMULA argument,
            %% it can be confused with constraint {...}. So, we decided
            %% that set arguments take precedence.
            %% If the user wants constraints in there then reify explicitly.
            list_same_value(SetN,FL_BODYFORMULA,SetArgTypes),
            parse_body_argpathexplist(SetL,SetArgTypes,DWS,TermArgMode,SetLCode,S),
            TCode = _,
            put_attr(TCode,SETARGATTRIBUTE,member(TCode,SetLCode)),
            ConvertedToSetarg = 1
        %% If T is a var, just translate as a var. Otherwise cases like
        %% foo(?X,...), where foo's ?X is of type FL_BODYFORMULA,
        %% will be translated weirdly. Eg, try 
        %% ?-  ?X = ${foo(?)@?M}, PRINTLN(?X)@\plg.
        %% where foo has flora_arguments_spec(foo,1,[FL_BODYFORMULA],_).
        ; is_variable(T,_,_) ->
            flobject_struct(T,TCode),
            S = NO_ERRORS
        ; protect_reification(parse_rule_body(T,DWS,DWS,TCode,S))
        ),
        clear_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        ( S == NO_ERRORS ->
            (var(ConvertedToSetarg), \+is_variable(T,_,_) ->
                flreify_struct(TCode,RTCode)
            ; RTCode = TCode
            ),
            parse_body_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = S
        ).

parse_body_argpathexplist([T|L],[FL_ARITH|Arguments],DWS,TermArgMode,[TACode|LCode],Status) :-
        parse_body_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        flarith_struct(TCode,TACode),
        ( PureTermTestStat == NO_ERRORS ->
            parse_body_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).

parse_body_argpathexplist([T|L],[FL_PROLOG|Arguments],DWS,TermArgMode,[TACode|LCode],Status) :-
        parse_pure_term(T,DWS,TCode,Status1),
        (is_fllist_struct(TCode) -> TACode = TCode
        ; flplib_struct(TCode,TACode)
        ),
        ( Status1 == NO_ERRORS ->
            parse_body_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = Status1
        ).


/****************************************************************************
  parse_body_pathexp(+CanoniTerm,+TransFlag,+DWS,+TermArgMode,-PathExpression,-Status)

  Parse path expression represented by CanoniTerm. A path expression is
  oid[molecule].oid[molecule]. ... .oid[molecule]
  (molecules are optional)
  Also term:term, term::term, and lists
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames

****************************************************************************/
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],If,_Ip),_TransFlag,DWS,TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        (is_birelop(F) ->
            (has_context(CONTEXT_PARSER_UDF_HEAD) ->
                parsing_error(If,ERROR_UDF_HEAD_ISA,Status)
            ; parse_body_pathexplist([Left,Right],DWS,TermArgMode,[LCode,RCode],Status)
            ),
            ( Status == NO_ERRORS -> flbirelate_struct(LCode,F,RCode,Code)
            ; true
            )
        ; is_objrefop(F) ->
            parse_body_pathexp(Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
            (S==NO_ERRORS ->
                parse_body_pathexplist([Right],DWS,TermArgMode,[RCode],Status)
            ; Status = S
            ),
            ( Status == NO_ERRORS ->
                %% previously we were incorrectly ignoring the module of
                %% path expressions like aaa.bbb.ccc
                %%flobjref_struct(F,LCode,RCode,Code)  %% OLD code
                %% NEW code below
                flobjref_struct(F,LCode,RCode,PreCode),
                flora_get_module_from_spec(DWS,ModuleType,Module),
                flmodule_struct(ModuleType,PreCode,Module,Code)
            ; true
            )
        ),
        !.

%% To handle CURI structure like prefix#suffix
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,TransFlag,DWS,Code,Status).

% To handle literal^^sort 
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        parse_composer_datatype([Left,Right],If,DWS,Code,Status1),
        (Status1 == NO_ERRORS,
            is_fltransactionalpredspec_struct(Code),
            TransFlag == DISALLOW_TRANS
        ->
            parsing_error(Left,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ; Status = Status1
        ).

%% This clause handles module specification @\prolog() and @\prologall()
%% in the argument position.
%% Note that @module (for Flora-2 modules) is illegal in the argument position.
%% But aggregate{ ... atom@module} and update{atom@module} are allowed.
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),TransFlag,DWS,TermArgMode,Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        parse_workspace(R,WSCode,S1),
        ( S1 == NO_ERRORS ->
            ( has_module_type(WSCode,PROLOGMODULE) ->
                parse_prlgterm(L,DWS,LCode,S2)
            
            ; has_module_type(WSCode,PROLOGALLMODULE) ->
                parse_pure_term(L,DWS,LCode,S2)

            ; %% aggregate{ ... atom@module} or update{atom@module}
              %% Others (e.g., p(foo@bar)) will be caught in the compiler
              has_module_type(WSCode,FLORAMODULE) ->
                %% TransFlag = ALLOW_TRANS causes failure in the composer
                parse_body_pathexp(L,TransFlag,WSCode,TermArgMode,LCode,S2)
            ),
            %% Check if the module specification is valid.
            ( S2 == NO_ERRORS ->
                ( nowspathexp(LCode) ->
                    Code=LCode, Status = NO_ERRORS
                ; is_flmodulespec_struct(LCode) ->
                    %% if nested @module, ignore the outer @module
                    Status = NO_ERRORS,
                    Code = LCode
                    %% maybe issue an error if we have ((abc.cde)@foo)@bar?
                    %% decided - NOT to issue, for now
                    %%parsing_error(_If,NO_WSNESTING,Status)
                ;
                  Status = NO_ERRORS,
                  ( WSCode = PROLOGMODULE ->
                      %% Covers: @\prolog
                      flplib_struct(LCode,Code)
                  
                  ; WSCode = PROLOGALLMODULE ->
                      %% Covers: @\prologall
                      flpliball_struct(LCode,Code)

                  %% Covers: @mod, @\mod, @\prolog(mod), @\prologall(mod)
                  ; flora_get_module_from_spec(WSCode,ModuleType,Mod),
                      flmodule_struct(ModuleType,LCode,Mod,Code)
                  )
                )
            ;
              Status = S2
            )
        ;
          Status = S1
        ).

parse_body_pathexp(CANOTERM(Funct,N,Paren,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_name(Funct,FAtom1),
        (flora_delayed_builtin_literal(FAtom1,N), Paren==FL_PARENTHESIS
        -> FAtom = FAtom1
        ; Paren==FL_BRACE
        -> flora_simple_delayed_primitive(FAtom1,N,FAtom),
            flora_delayed_builtin_literal(FAtom,N)
        ),
        %% If inside a CLP constraint, don't delay
        \+ has_context(CONTEXT_PARSER_CLP_CONSTRAINT),
        !,
        flatom_struct(FAtom,If,OpCode),
        (flora_argdef(FAtom,N,ArgTypes,DWS)
        -> parse_body_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,ACode,Status)
        ;  parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,ACode,Status)
        ),
        fllist_struct(ACode,[],Ip,ArgsCode),
        fldelayedliteral_struct(OpCode,ArgsCode,Code).

%% Parse the ~ meta predicate
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_name(Funct,FL_UNIVEQFORM),
        !,
        parse_body_univeqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),DWS,DWS,Code,Status).

%% Parse the !~ meta predicate
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_name(Funct,FL_NOTUNIVEQFORM),
        !,
        parse_body_notuniveqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),DWS,DWS,Code,Status).

%% :=:
parse_body_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,FL_OBJEQL),
        !,
        parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,[LCode,RCode],Status),
        (Status == NO_ERRORS ->
            flobjeql_struct(LCode,RCode,TCode),
            flora_get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(ModuleType,TCode,Module,Code)
        ; true
        ).

parse_body_pathexp(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_body_term(Funct,N,Args,TransFlag,DWS,Code,Status).

%% obj[...]
parse_body_pathexp(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_body_objspec(Funct,N,Args,DWS,NONINHERITABLE,Code,Status).
%% obj[|...|]
parse_body_pathexp(CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_body_objspec(Funct,N,Args,DWS,INHERITABLE,Code,Status).

parse_body_pathexp(CANOLIST(L,T,_N,I,_Ib),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_list(L,T,I,DWS,Code,Status).


%% ${...} - reification
parse_body_pathexp(CANOTERM(Funct,0,FL_BRACE,[],_If,Ip),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        parsing_error(Ip,EXP_ARGS,Status).

parse_body_pathexp(CANOTERM(Funct,_N,FL_BRACE,[Arg|Rest],If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        list_to_canoterm_conjunct([Arg|Rest], Conjunct, If, Ip),
        parse_reify(Conjunct,DWS,Code,Status).
        
parse_body_pathexp(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_aggregt(Funct,N,Args,If,Ip,DWS,Code,Status).

/*
%% We now allow \# in the body: it is a test if the arg matches a Skolem
parse_body_pathexp(ObjectTerm,_TransFlag,_DWS,_Code,Status) :-
        %% New oid symbol is only allowed in rule heads or reified formulas.
        get_spectoken(ObjectTerm,FL_NEWOID),
        \+ has_context(protecting_reification),
        !,
        parsing_error(ObjectTerm,ERROR_NEWOID,Status).
*/

parse_body_pathexp(ObjectTerm,_TransFlag,_DWS,_TermArgMode,Code,NO_ERRORS) :-
        flobject_struct(ObjectTerm,Code),
        !.

parse_body_pathexp(CANOBRACE(L,N,I),_TransFlag,DWS,TermArgMode,Code,Status) :-
        N>0,
        !,
        (L = [First|_], is_canobrace(First,_,_,_) ->
            %% might use {{ ... }} in the future
            parsing_error(I,ERROR_SETNOTE,Status)
        ;
            parse_body_pathexplist(L,DWS,TermArgMode,SetLCode,Status),
            Code = _,
            put_attr(Code,SETARGATTRIBUTE,member(Code,SetLCode))
        ).

parse_body_pathexp(CANOBRACE([],0,I),_TransFlag,_DWS,_TermArgMode,Code,NO_ERRORS) :-
        flatom_struct('{}',I,Code),
        !.
parse_body_pathexp(CANOBRACE(_L,_N,I),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        !,
        parsing_error(I,ERROR_SETNOTE,Status).

parse_body_pathexp(CanoniTerm,_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        !,
        parsing_error(CanoniTerm,ERROR_PATHEXP,Status).

%% Define which type of arguments should not have module specification.
nowspathexp(S) :- is_fllist_struct(S), !.
nowspathexp(S) :- is_flaggregt_struct(S), !.
nowspathexp(S) :- is_flreify_struct(S), !.
nowspathexp(S) :- is_flnumber_struct(S), !.
nowspathexp(S) :- is_flstring_struct(S), !.
nowspathexp(S) :- is_fldatatype_struct(S), !.
%%nowspathexp(S) :- is_flbuiltin_identifier_struct(S), !.

nowspathexp(S) :-
        is_flatom_struct(S,FAtom),
        flora_nowsp(FAtom,0),
        !.

nowspathexp(S) :-
        flterm_struct(Funct,N,_Args,S),
        is_flatom_struct(Funct,FAtom),
        flora_nowsp(FAtom,N),
        !.


/****************************************************************************
  parse_body_objspec(+Obj,+Arity,+Args,+DWS,+InherType,-Code,-Status)
  parse_body_objspec(+CanoniTerm,+DWS,-Code,-Status)

  parses ObjectSpecification as described in the BNF grammar at the
  beginning of this file.
  Args here is what's inside the brackets ...[Args]
  InherType: INHERITABLE/NONINHERITABLE
****************************************************************************/
%% parse_body_objspec/7
parse_body_objspec(Obj,N,Args,DWS,Type,Code,Status) :-
        parse_body_pathexp(Obj,DISALLOW_TRANS,DWS,ANY_PATHEXP,O,S),
        ( S == NO_ERRORS ->
            ( N == 0 ->
                Spec = [],
                Status = NO_ERRORS
            ;
                Args=[Body],
                parse_body_objspec(Body,DWS,Type,Spec,Status)
            ),
            (Status == NO_ERRORS -> flobjspec_struct(O,Spec,Type,Code)
            ; true
            )
        ;
          Status = S
        ).

%% parse_body_objspec/5
parse_body_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        (F == FL_AND_CONNECTIVE; F == FL_OR_CONNECTIVE),
        !, %% conjunction or disjunction
        parse_body_objspec(L,DWS,Type,LCode,S),
        ( S == NO_ERRORS ->
            parse_body_objspec(R,DWS,Type,RCode,Status),
            ( Status == NO_ERRORS ->
                ( F == FL_AND_CONNECTIVE ->
                    flconjunct_struct(LCode,RCode,Code)
                ;
                  fldisjunct_struct(LCode,RCode,Code)
                )
            ;
              true
            )
        ;
          Status = S
        ).

%% This parses obj[naf foo->bar], obj[naf foo], obj[\+foo->bar], or obj[\+foo] 
%% in object specifications
%% parse_body_objspec/5
parse_body_objspec(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F); is_negop(F)),
        !, %% negation
        %% NEG is not a default negation
        ( (is_plgnafop(F) ; is_rulelognafop(F))
        -> set_context(CONTEXT_PARSER_DEFAULT_NEGATION)
        ; true
        ),
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_body_objspec(Conjunct,DWS,Type,C,Status),
        ( Status == NO_ERRORS ->
            (is_plgnafop(F) -> flprlgnaf_struct(C,Code)
            ; is_rulelognafop(F) -> flrulelognaf_struct(C,Code)
            ; flneg_struct(C,If,Code)
            )
        ; true
        ),
        clear_context(CONTEXT_PARSER_DEFAULT_NEGATION).

%% existantial quantifier under default negation in
%% obj[\naf exists(?X,?Y)^goo->bar]
%% parse_body_objspec/5
parse_body_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,Vars,_,_),Goal],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QuantIdx),
        is_logicalquantifier(QuantAtom,QuantAtomCanon),
        has_context(CONTEXT_PARSER_DEFAULT_NEGATION),
        !,
        (\+is_existentialquant(QuantAtomCanon)
        -> parsing_error(QuantIdx,ONLY_EXISTENTIALS,S1)
        ; S1 = NO_ERRORS
        ),
        %% Vars = '*' means all vars in the quantified formula
        (Vars = [StarObj], get_atom(StarObj,FL_STAR)
        -> VarNames=FL_STAR, S2 = NO_ERRORS
        ; parse_varlist(Vars,VarCodeList,VarNames,S2)
        ),
        parse_body_objspec(Goal,DWS,Type,GoalCode,S3),
        merge_status([S1,S2,S3],Status),
        ( Status == NO_ERRORS ->
            get_typed_var_code_from_list(VarCodeList,VarsCode),
            flquantifier_struct(QuantAtomCanon,VarNames,VarsCode,GoalCode,QuantIdx,Code)
        ;
          true
        ).

%% parse_body_objspec/5
parse_body_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,_Vars,_,_),_Goal],_If,_Ip),_DWS,_Type,_Code,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QuantIdx),
        is_logicalquantifier(QuantAtom,_QuantAtomCanon),
        !,
        parsing_error(QuantIdx,NO_LOG_QUANTIFIERS,Status).


%% parse_body_objspec/5
parse_body_objspec(CanoniTerm,DWS,Type,Code,Status) :-
        parse_body_attmethspec(CanoniTerm,DWS,Type,Code,Status).
        


/****************************************************************************
  parse_body_attmethspec(+CanoniTerm,+DWS,+Type,-Goal,-Status)
  parse_body_setexp(+CanoniTerm,+DWS,-CodeList,-Status)
  Type: INHERITABLE/NONINHERITABLE
****************************************************************************/
parse_body_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        ( is_mvdattspecop(F) ->
            parse_body_pathexp(L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
            (S == NO_ERRORS ->
                parse_body_setexp(R,DWS,RCode_pre,Status),
                (Status==NO_ERRORS -> process_passthru(RCode_pre,RCode)
                ; true
                )
            ; Status = S
            ),
            (Status == NO_ERRORS ->
                flmvdattspec_struct(LCode,F,RCode,Type,Code)
            ; true
            )
        ; is_sigattspecop(F) ->
            (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
                parse_sigconstr(Constr,DWS,CCode,S_C), 
                (S_C == NO_ERRORS ->
                    parse_body_pathexp(M,DISALLOW_TRANS,DWS,ANY_PATHEXP,MCode,S1),
                    (S1 == NO_ERRORS
                    %% The right hand side 
                    -> (is_emptyterm(R)
                       %% This is SIGDEF: occurs when we have a[b=> ()]
                       -> get_index(R,Ind),
                           emptyterm_struct(Ind,RCode_pre),
                           Status = NO_ERRORS
                       ;  parse_body_pathexp(R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode_pre,Status)
                       ),
                        process_passthru(RCode_pre,RCode)
                    ; Status = S1
                    )
                ;
                    Status = S_C
                ),
                (Status == NO_ERRORS ->
                    flsigattconspec_struct(MCode,CCode,F,RCode,Type,Code)
                ; true
                )
            ; L = CANOBRACE(_,_If2,Ip2) ->
                parsing_error(Ip2,ERROR_BOOLSIG,Status)
            ;
                parse_body_pathexp(L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S1),
                (S1 == NO_ERRORS
                %% The right hand side 
                -> (is_emptyterm(R)
                   -> get_index(R,Ind),
                       emptyterm_struct(Ind,RCode_pre),
                       Status = NO_ERRORS
                   ;  parse_body_pathexp(R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode_pre,Status)
                   ),
                    process_passthru(RCode_pre,RCode)
                ; Status = S1
                ),
                (Status == NO_ERRORS ->
                    flsigattspec_struct(LCode,F,RCode,Type,Code)
                ; true
                )
            )

        ; is_incattspecop(F) ->
            parse_body_pathexplist([L,R],DWS,ANY_PATHEXP,[LCode,RCode],Status),
            (Status == NO_ERRORS ->
                flincattspec_struct(LCode,F,RCode,Type,Code)
            ; true
            )

        ; is_tolistattspecop(F) ->
            parse_body_pathexplist([L,R],DWS,ANY_PATHEXP,[LCode,RCode],Status),
            (Status == NO_ERRORS ->
                fltolistattspec_struct(LCode,F,RCode,Type,Code)
            ; true
            )
        ),
        !.

parse_body_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        is_boolsigop(F),
        !,
        parse_body_pathexp(A,DISALLOW_TRANS,DWS,ANY_PATHEXP,ACode,S1),
        (S1 == NO_ERRORS ->
            flboolsig_struct(ACode,F,Type,Code),
            Status = NO_ERRORS
        ;
            %% passing NONINHERITABLE so as to not get an error about
            %% inheriitable default transactions, ERROR_TRANS_DEFAULT_VALUE
            parse_body_attmethspec(A,DWS,NONINHERITABLE,ACode2,S2),
            (S2 == NO_ERRORS ->
                %% use _T, not Type here, since ACode2 has a type inside of it
                (fltranspec_struct(ATemp,_T,ACode2) -> 
                    fltransig_struct(ATemp,F,Type,Code),
                    Status = NO_ERRORS
                ;
                    parsing_error(A,ERROR_BOOLSIG,Status)
                )
            ;
                parsing_error(A,ERROR_BOOLSIG,Status)
            )
        ),
        !.


parse_body_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),_DWS,Type,Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        ( name_or_var(R,RCode) ->
            parse_workspace(R,WSCode,SWS),
            parse_body_attmethspec(L,WSCode,Type,LCode,S),
            ( S == NO_ERRORS, SWS == NO_ERRORS ->
                ( ( is_flattspec_struct(LCode,_)
                  ; is_passthru_struct(LCode)
                  )
                ->
                      parsing_error(L,NO_WORKSPACE,Status)
                ;
                    flmethspec_struct(C,Type,LCode),
                    ( is_flworkspace_struct(C) ->
                        parsing_error(If,NO_WSNESTING,Status)
                    ;
                        flmodule_struct(FLORAUSERMOD,C,RCode,W),
                        flmethspec_struct(W,Type,Code),
                        Status = NO_ERRORS
                    )
                )
            ; SWS == NO_ERRORS -> Status = S
            ; Status = SWS
            )
        ;
            parsing_error(R,ERROR_WSNAME,Status)
        ).

parse_body_attmethspec(CanoniTerm,_DWS,Type,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        (flora_get_flatom_name(C,CAtom), \+is_valid_term_name(CAtom) ->
            parsing_error(CanoniTerm,ERROR_TERM_NAME, Status)
        ; Type == INHERITABLE ->
            parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
        ; fltranspec_struct(C,Type,Code),
            Status = NO_ERRORS
        ).

%% Transactional method spec. Possibly with a prefix macro.
parse_body_attmethspec(CanoniTerm,DWS,Type,Code,Status) :-
        parse_body_pathexp(CanoniTerm,ALLOW_TRANS,DWS,ANY_PATHEXP,C,S1),
        (is_fltransactionalterm_struct(C)
        ; is_fltransactionalpredspec_struct(C)
        ; is_fltransactionalatom_struct(C)
        ),
        !,
        (S1 == NO_ERRORS ->
            (Type == INHERITABLE ->
                   parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
            ; fltranspec_struct(C,Type,Code),
                Status = NO_ERRORS
            )
        ; %% error
            Status = S1
        ).
        
parse_body_attmethspec(CanoniTerm,DWS,Type,Code,Status) :-
        parse_body_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,ANY_PATHEXP,C,Status1),
        (flora_get_flatom_name(C,CAtom), \+is_valid_term_name(CAtom) ->
            parsing_error(CanoniTerm,ERROR_TERM_NAME,Status)
        ; Status1 == NO_ERRORS ->
            parse_body_attmethspec_aux(C,Status,Type,Code)
        ; Status = Status1
        ).

%% Obj[\true], Obj[\false], Obj[!] - interpreted as true, false, !
parse_body_attmethspec_aux(C,NO_ERRORS,_Type,Code) :-
        (is_flatom_struct(C,Atom)
        ; is_flbuiltin_identifier_struct(C,Atom)
        ),
        passthru_atom(Atom),
        !,
        flpassthru_struct(C,Code).

%% Obj[X>Y], Obj[X=Y], etc. -- should give an error
parse_body_attmethspec_aux(C,Status,_Type,_Code) :-
        is_passthru_term(C,If),
        !,
        parsing_error(If,ERROR_UNALLOWED_PROP,Status).

parse_body_attmethspec_aux(C,NO_ERRORS,_Type,Code) :-
        is_flreify_struct(C,Cunreif),
        (is_flworkspace(Cunreif,NoWSNoReif,_WS) -> true
        ; is_flmodulespec_struct(Cunreif,NoWSNoReif,_WS) -> true
        ; NoWSNoReif = Cunreif
        ),
        %% unwrap fl-reification
        (is_passthru_term(NoWSNoReif,_) -> Cstripped = NoWSNoReif
        ; is_delayed_passthru_term(NoWSNoReif,Cstripped,_)
        ),
        !,
        flpassthru_struct(Cstripped,Code).
parse_body_attmethspec_aux(C,NO_ERRORS,_Type,Code) :-
        is_delayed_passthru_term(C,Cstripped,_),
        !,
        flpassthru_struct(Cstripped,Code).
parse_body_attmethspec_aux(C,NO_ERRORS,_Type,Code) :-
        is_passthru_other_term(C),
        !,
        flpassthru_struct(C,Code).


parse_body_attmethspec_aux(C,NO_ERRORS,Type,Code) :-
        flmethspec_struct(C,Type,Code).


parse_body_setexp(CANOBRACE(L,_N,_I),DWS,Code,Status) :-
        !,
        parse_body_pathexplist(L,DWS,ANY_PATHEXP,Code,Status).

parse_body_setexp(CanoniTerm,DWS,[Code],Status) :-
        parse_body_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,ANY_PATHEXP,Code,Status).

        
parse_sigconstr(CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_RANGE),
        !,
        parse_body_pathexplist([Lower,Upper],DWS,PURE_PATHEXPS_ONLY,[LowerCode,UpperCode],S),
        ( S == NO_ERRORS ->
            ( not(valid_lower_sigconstr(LowerCode)) -> Lower = OBJECT(_,If),
                parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
            ;
                ( not(valid_upper_sigconstr(UpperCode)) -> Upper = OBJECT(_,If),
                    parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
                ;
                    Status = NO_ERRORS
                )
            )
        ;
            Status = S
        ),
        flsigconstr_struct(LowerCode,UpperCode,Code). 
        
parse_sigconstr(CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
        parsing_error(If,ERROR_SIGCONSTR,Status).
        

valid_upper_sigconstr(UpperCode):- % H in c[m{L:H}=>v] should be a variable or a non-negative integer or '*'
        is_flatom_struct(UpperCode,UpperAtom),
        UpperAtom == FL_STAR

        ; UpperCode = FLNUMBER(N,_), integer(N),N >= 0

        ; is_flvar_struct(UpperCode)

        ; is_anonymous_flvar_struct(UpperCode)

        ; is_fltransactionalvar_struct(UpperCode)

        ; is_anonymous_fltransactionalvar_struct(UpperCode)
        .

valid_lower_sigconstr(LowerCode):-
        %% L in c[m{L:H}=>v] should be a variable or an integer
        LowerCode = FLNUMBER(N,_),integer(N)
        ; is_flvar_struct(LowerCode)
        ; is_anonymous_flvar_struct(LowerCode)
        ; is_fltransactionalvar_struct(LowerCode)
        ; is_anonymous_fltransactionalvar_struct(LowerCode).
        

/****************************************************************************
  parse_aggregt(+Funct,+Arity,+Args,+IndxFunct,+IndxBrace,-Code,-Status)
  aggregt_vars(+CanoniTerm,-Var,-GroupVars,-Status)
  var_list(+List,-GroupVars,-Status)
****************************************************************************/
parse_aggregt(Funct,N,Args,If,_Ip,DWS,Code,Status) :-
        ( get_name(Funct,FAtom),
            is_aggregtop(FAtom)
        ->
            flobject_struct(Funct,F),
            (N == 1,
                Args=[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_Il,_Ir)],
                get_atom(Bar,FL_BAR)
            ->
                aggr_vars_and_sortspec(FAtom,L,Var,GroupVars,SortSpec,S1),
                ( S1 == NO_ERRORS,
                    (is_sortable_aggregop(FAtom)
                    ; is_uniq_aggregop(FAtom)
                    ; SortSpec == NULL)
                ->
                    parse_rule_body(R,DWS,DWS,Conds,Status),
                    ( Status == NO_ERRORS
                    ->
                        flaggregt_struct(F,Var,GroupVars,SortSpec,Conds,Code)
                    ;
                        true
                    )
                ;
                    parsing_error(If,UNEXP_SORTSPEC,S2),
                    merge_status([S1,S2],Status)
                )
            ;
                parsing_error(If,ERROR_AGGREGT,Status)
            )

        ; get_name(Funct,FAtom),
            (is_dbinsertop(FAtom); is_dbdeleteop(FAtom); is_ruleupdateop(FAtom))
        ->
            parsing_error(If,ERROR_UPDATEOP,Status)
        ;
            parsing_error(If,UNKNOWN_BRACE_BUILTIN,Status)
        ).

%% case of no grouping vars
aggr_vars_and_sortspec(AggOp,CANOTERM(AggVarGrpTerm,1,FL_PARENTHESIS,[ResultSortSpec],_If,_Ip),Var,[],TypeCode,Status) :-
        is_sortable_aggregop(AggOp),
        aggregt_vars(AggVarGrpTerm,Var,[],Status1),
        parse_sort_spec(ResultSortSpec,ResTypeCode,Status2),
        flatom_struct(FL_COMMA,NO_INDEX,Comma),
        flterm_struct(Comma,2,[ResTypeCode,ResTypeCode],TypeCode),
        merge_status([Status1,Status2],Status),
        !.
%% Case of grouping vars with only one sort spec: asc or desc
aggr_vars_and_sortspec(AggOp,CANOTERM(AggVarGrpTerm,1,FL_PARENTHESIS,[ResultSortSpec],_If,_Ip),Var,GroupVars,TypeCode,Status) :-
        is_sortable_aggregop(AggOp),
        aggregt_vars(AggVarGrpTerm,Var,GroupVars,Status1),
        get_name(ResultSortSpec,Name),
        (Name == asc ; Name = desc),
        parse_sort_spec(ResultSortSpec,ResTypeCode,ResStat),
        flatom_struct(FL_COMMA,NO_INDEX,Comma),
        flterm_struct(Comma,2,[ResTypeCode,ResTypeCode],TypeCode),
        merge_status([Status1,ResStat],Status),
        !.
%% case of grouping vars with separate specs for result and grouping
aggr_vars_and_sortspec(AggOp,CANOTERM(AggVarGrpTerm,2,FL_PARENTHESIS,[ResultSortSpec,GrpSortSpec],_If,_Ip),Var,GroupVars,TypeCode,Status) :-
        is_sortable_aggregop(AggOp),
        aggregt_vars(AggVarGrpTerm,Var,GroupVars,Status1),
        ( GroupVars == []
        -> parsing_error(GrpSortSpec,EXP_AGGRRESSORT,Status2)
        ;
            parse_sort_spec(ResultSortSpec,ResTypeCode,ResStat),
            parse_sort_spec(GrpSortSpec,GrpTypeCode,GrpStat),
            flatom_struct(FL_COMMA,NO_INDEX,Comma),
            flterm_struct(Comma,2,[ResTypeCode,GrpTypeCode],TypeCode),
            merge_status([ResStat,GrpStat],Status2)
        ),
        merge_status([Status1,Status2],Status),
        !.

%% case of uniquification variables, no grouping
aggr_vars_and_sortspec(AggOp,CANOTERM(AggVarGrpTerm,_,FL_PARENTHESIS,UniquifySpec,_If,_Ip),Var,[],UniquifyCode,Status) :-
        is_uniq_aggregop(AggOp),
        aggregt_vars(AggVarGrpTerm,Var,[],Status1),
        parse_uniquify_spec(UniquifySpec,UniquifyCode,Status2),
        merge_status([Status1,Status2],Status),
        !.

%% case of uniquification variables and grouping
aggr_vars_and_sortspec(AggOp,CANOTERM(AggVarGrpTerm,_,FL_PARENTHESIS,UniquifySpec,_If,_Ip),Var,GroupVars,UniquifyCode,Status) :-
        is_uniq_aggregop(AggOp),
        aggregt_vars(AggVarGrpTerm,Var,GroupVars,Status1),
        parse_uniquify_spec(UniquifySpec,UniquifyCode,ResStat),
        merge_status([Status1,ResStat],Status),
        !.

%% Case without any sort specs
aggr_vars_and_sortspec(_AggOp,Term,Var,GroupVars,NULL,Status) :-
        aggregt_vars(Term,Var,GroupVars,Status),
        !.
aggr_vars_and_sortspec(AggOp,CanoniTerm,_V,_GV,_SortSpec,Status) :-
        is_sortable_aggregop(AggOp),
        !,
        parsing_error(CanoniTerm,EXP_AGGRSORTSPC,Status).
aggr_vars_and_sortspec(AggOp,CanoniTerm,_V,_GV,_SortSpec,Status) :-
        is_uniq_aggregop(AggOp),
        !,
        parsing_error(CanoniTerm,EXP_AGGRUNIQSPC,Status).


aggregt_vars(Term,Var,[],NO_ERRORS) :-
        get_flvar_struct(Term,Var),
        !.
aggregt_vars(CANOTERM(Funct,N,FL_BRACKET,L,If,_Ip),Var,GroupVars,Status) :-
        !,
        ( get_flvar_struct(Funct,Var) ->
            ( N == 0 ->
                GroupVars = [],
                Status = NO_ERRORS
            ;
              L=[T],
              var_list(T,GroupVars,Status)
            )
        ;
          parsing_error(If,EXP_AGGREGVAR,Status)
        ).
aggregt_vars(CanoniTerm,_V,_GV,Status) :-
        parsing_error(CanoniTerm,EXP_AGGRGRPVAR,Status).


var_list(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),[Var|GV],Status) :-
        get_atom(Funct,F),
        !,
        ( F == FL_COMMA ->
            ( get_flvar_struct(L,Var) ->
                var_list(R,GV,Status)
            ;
              parsing_error(L,EXP_VARIABLE,Status)
            )

        ; F == FL_BAR ->
            parsing_error(If,NO_LISTTAIL,Status)

        ;
          parsing_error(If,EXP_VARIABLE,Status)
        ).

var_list(CanoniTerm,[Var],Status) :-
        ( get_flvar_struct(CanoniTerm,Var) ->
            Status = NO_ERRORS
        ;
          parsing_error(CanoniTerm,EXP_VARIABLE,Status)
        ).

%% sorting specification in aggregates
parse_sort_spec(SortSpec,TypeCode,NO_ERRORS) :-
        get_name(SortSpec,Name),
        (Name == asc ; Name = desc),
        !,
        flobject_struct(SortSpec,TypeCode).
parse_sort_spec(CANOLIST(L,_T,_N,I,_Ib),TypeCode,Status) :-
        parse_sort_spec_list(L,TypeCodeList,Status),
        fllist_struct(TypeCodeList,[],I,TypeCode).

parse_sort_spec_list([],[],NO_ERRORS) :- !.
parse_sort_spec_list([Speclet|Rest],[SpecletCode|RestCode],Status) :-
        parse_one_sort_speclet(Speclet,SpecletCode,Status1),
        (Status1 == NO_ERRORS -> parse_sort_spec_list(Rest,RestCode,Status)
        ; Status = Status1
        ).

parse_one_sort_speclet(CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],_If,_Ip),TypeCode,NO_ERRORS) :-
        get_name(Funct,Name),
        (Name == asc ; Name = desc),
        get_integer(Arg,Val),
        Val>0,
        !,
        flobject_struct(Funct,F),
        get_index(Arg,Idx),
        flnumber_struct(Val,Idx,A),
        flterm_struct(F,1,[A],TypeCode1),
        flplib_struct(TypeCode1,TypeCode).
parse_one_sort_speclet(CanoniTerm,_,Status) :-
        !,
        parsing_error(CanoniTerm,EXP_AGGRSORTSPC,Status).

parse_uniquify_spec(Varlist,UniqSpecCode,Status) :-
        parse_varlist(Varlist,UniqSpecCode,_VarNameList,Status).



/****************************************************************************
  parse_head_term(+Funct,+Arity,+Args,+TransFlag,+DWS,-Code,-Status)

  This predicate is called to parse a term in a rule head. Parsing of its
  arguments is adjusted according to its arguments mode definition.
****************************************************************************/
parse_head_term(Funct,N,_Args,_TransFlag,_DWS,_Code,Status) :-
        get_atom(Funct,FAtom),
        %% reserved builtins are redefinable, but since they are reserved we
        %% don't want to allow the user to define these builtins with any other
        %% arity. For instance, \opposes/2 & \opposes/4 are reserved for
        %% specific uses, but we don't want the user to define, say, \opposes/5.
        is_disallowed_reserved_builtin(FAtom,N),
        !,
        parsing_error(Funct,ERROR_RESERVED_ARITY,Status).


%% Handles = Expr in the head
flevalexpr_struct(Formula,FLEVALEXP(Formula)).

parse_head_term(Funct,1,[Arg],TransFlag,DWS,Code,Status) :-
	get_atom(Funct,FAtm),
	memberchk(FAtm,[FL_EVALEXPR,FL_EVALEXPR2]),
	!,
	parse_head_pathexp(Arg,TransFlag,DWS,PURE_PATHEXPS_ONLY,Code1,Status),
	flevalexpr_struct(Code1,Code).


parse_head_term(Funct,N,_Args,_TransFlag,_DWS,_Code,Status) :-
        get_atom(Funct,FAtom),
        \+has_context(CONTEXT_PARSER_REIFY),
        flora_reserved_symbol_not_as_term(FAtom,N),
        !,
        parsing_error(Funct,ERROR_RESERVED_SYMBOL_CONTEXT,Status).
parse_head_term(Funct,N,Args,_TransFlag,DWS,Code,Status) :-
        get_atom(Funct,FAtom),
        flora_argdef(FAtom,N,ArgTypes,DWS),
        !,
        flobject_struct(Funct,F),
        parse_head_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status),
        (Status == NO_ERRORS
        ->
            flterm_struct(F,N,AList,Code)
        ;
            true
        ).

parse_head_term(Funct,_N,[Left,Right],_TransFlag,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        get_index(Funct,If),
        parse_composer_datatype([Left,Right],If,DWS,Code,Status).

parse_head_term(Funct,2,Args,TransFlag,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,TransFlag,DWS,Code,Status).

parse_head_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
        fltransactionalobject_struct(Funct,F),
        !,
        (TransFlag == ALLOW_TRANS ->
            (get_transactionalatom(Funct,FAtom),
                flora_argdef(FAtom,N,ArgTypes,DWS)
            -> parse_head_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ;
                parse_head_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ),
            (Status == NO_ERRORS -> fltransactionalterm_struct(F,N,AList,Code) ; true)
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

parse_head_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
        parse_head_pathexp(Funct,TransFlag,DWS,PURE_PATHEXPS_ONLY,F,S),
        ( S == NO_ERRORS ->
            parse_head_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,AList,Status),
            (Status == NO_ERRORS -> 
                ( is_fltransactionalterm_struct(F) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
        ;
          Status = S
        ).


/****************************************************************************
 parse_head_list(+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)
****************************************************************************/
parse_head_list([],[],Index,_DWS,T,NO_ERRORS) :-
        !,
        fllist_struct([],[],Index,T).

parse_head_list(L,T,Index,DWS,Code,Status) :-
        parse_head_pathexplist(L,DWS,PURE_PATHEXPS_ONLY,LCode,S),
        ( S == NO_ERRORS ->
            ( T == [] ->
                TCode = [],
                Status = NO_ERRORS
            ;
              parse_head_pathexp(T,DISALLOW_TRANS,DWS,PURE_PATHEXPS_ONLY,TCode,Status)
            ),
            (Status == NO_ERRORS -> fllist_struct(LCode,TCode,Index,Code); true)
        ;
          Status = S
        ).


/****************************************************************************
  parse_head_argpathexplist(+Terms,+ArgumentTypes,+DWS,+TermArgMode,-PathExpressions,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_head_argpathexplist([],[],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_head_argpathexplist([T|L],[FL_OID|Arguments],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_head_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_head_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).

parse_head_argpathexplist([T|L],[FL_BODYFORMULA|Arguments],DWS,TermArgMode,[RTCode|LCode],Status) :-
        set_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        (T = CANOBRACE(SetL,SetN,_SetI), SetN > 0 ->
            %% if this is a set-argument under FL_BODYFORMULA argument,
            %% it can be confused with constraint {...}. So, we decided
            %% that set arguments take precedence.
            %% If the user wants constraints in there then reify explicitly.
            list_same_value(SetN,FL_BODYFORMULA,SetArgTypes),
            parse_body_argpathexplist(SetL,SetArgTypes,DWS,TermArgMode,SetLCode,S),
            TCode = _,
            put_attr(TCode,SETARGATTRIBUTE,member(TCode,SetLCode)),
            ConvertedToSetarg = 1
        ; parse_rule_body(T,DWS,DWS,TCode,S)
        ),
        clear_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        ( S == NO_ERRORS ->
            (var(ConvertedToSetarg) -> flreify_struct(TCode,RTCode)
            ; RTCode = TCode
            ),
            parse_head_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = S
        ).

%% treat arithmetics in rule head as a normal term
parse_head_argpathexplist([T|L],[FL_ARITH|Arguments],DWS,TermArgMode,[TACode|LCode],Status) :-
        parse_head_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        flarith_struct(TCode,TACode),
        ( PureTermTestStat == NO_ERRORS ->
            parse_head_argpathexplist(L,Arguments,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).


/****************************************************************************
  parse_head_pathexplist(+ListOfCanoniTerms,+DWS,+TermArgMode,-ListOfPathExpressions,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_head_pathexplist([],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_head_pathexplist([T|L],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_head_pathexp(T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_head_pathexplist(L,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).


/****************************************************************************
  parse_head_pathexp(+CanoniTerm,+TransFlag,+DWS,+TermArgMode,-HeadPathExpression,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_head_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],If,_Ip),TransFlag,DWS,TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        !,
        ( is_birelop(F) ->
            %% embedded :/:: in rule heads are permitted only in expert mode
            %% (or in facts and templates)
            %% The restriction on embedded :/:: does not apply in ErgoText:
            %% Too much work to get it handle compiler_options and one can say
            %% that whoever does ErgoText is expert enough.
            ((has_compiler_persistentoption(FL_EXPERT)
             ; has_context(CONTEXT_PARSER_FACT)
             ; has_context(CONTEXT_PARSER_NL_TEMPLATES)
             ; has_context(CONTEXT_PARSER_USING_NL_TEMPLATE)
             )
            ->
                parse_head_pathexplist([Left,Right],DWS,TermArgMode,[LCode,RCode],Status)
            ; parsing_error(If,ERROR_EXPERT_SYNTAX_ISA,Status)
            ),
            ( Status == NO_ERRORS -> flbirelate_struct(LCode,F,RCode,Code)
            ; true
            )

        ; is_objrefop(F) -> 
            parse_head_pathexp(Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
            (S==NO_ERRORS ->
                parse_head_pathexplist([Right],DWS,TermArgMode,[RCode],Status)
            ; Status = S
            ),
            ( Status == NO_ERRORS -> flobjref_struct(F,LCode,RCode,Code)
            ; true
            )

        %% @\prolog as an argument in head
        ; F == FL_AT, get_name(Right,FL_PLIB) ->
            parse_prlgterm(Left,DWS,LCode,Status),
            flplib_struct(LCode,Code1),
            flreify_struct(Code1,Code)

        %% foo@mod as argument without explicit reification braces ${...}
        %% not allowed in the head
        ; F == FL_AT -> parsing_error(If,NO_WSINRULEHEAD,Status)

        ; is_curi_op(F) -> parse_curi([Left,Right],TransFlag,DWS,Code,Status)

        ; is_datatypeop(F) ->
            parse_composer_datatype([Left,Right],If,DWS,Code,Status1),
            (Status1 == NO_ERRORS,
                is_fltransactionalpredspec_struct(Code),
                TransFlag == DISALLOW_TRANS
            ->
                parsing_error(Left,ERROR_TRANSACTIONAL_SYMBOL,Status)
            ; Status = Status1
            )
        ;
            parse_head_term(Funct,2,[Left,Right],TransFlag,DWS,Code,Status)
        ).

parse_head_pathexp(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_head_term(Funct,N,Args,TransFlag,DWS,Code,Status).

%% Head pathexp a[...]
parse_head_pathexp(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_head_objspec_top(Funct,N,Args,DWS,NONINHERITABLE,Code,Status).
%% Head pathexp a[|...|]
parse_head_pathexp(CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_head_objspec_top(Funct,N,Args,DWS,INHERITABLE,Code,Status).

parse_head_pathexp(CANOLIST(L,T,_N,I,_Ib),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_head_list(L,T,I,DWS,Code,Status).

%% If ObjectTerm is non-transactional
parse_head_pathexp(ObjectTerm,_TransFlag,_DWS,_TermArgMode,Code,NO_ERRORS) :-
        flobject_struct(ObjectTerm,Code),
        !.

%% ${...} - reification
parse_head_pathexp(CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        (list_to_canoterm_conjunct(Args,Conjunct,If,Ip) ->
            parse_reify(Conjunct,DWS,Code,Status)
        ;  parsing_error(Ip,EXP_ARGS,Status)
        ).

parse_head_pathexp(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_aggregt(Funct,N,Args,If,Ip,DWS,Code,Status).

parse_head_pathexp(CANOBRACE(L,N,_I),_TransFlag,DWS,TermArgMode,Code,Status) :-
        N>0,
        !,
        parse_head_pathexplist(L,DWS,TermArgMode,SetLCode,Status),
        Code = _, %% NOTE: a prolog var, since we'll be macro-expanding
        put_attr(Code,SETARGATTRIBUTE,member(Code,SetLCode)).

parse_head_pathexp(CANOBRACE([],0,I),_TransFlag,_DWS,_TermArgMode,Code,NO_ERRORS) :-
        flatom_struct('{}',I,Code),
        !.
parse_head_pathexp(CANOTERM(_Funct,_N,FL_BRACE,_Args,_If,Ip),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        !,
        parsing_error(Ip,UNKNOWN_PRIMITIVE_HEAD,Status).

parse_head_pathexp(CANOBRACE(_L,_N,I),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        !,
        parsing_error(I,ERROR_SETNOTE,Status).

parse_head_pathexp(CanoniTerm,_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        (fltransactionalobject_struct(CanoniTerm,_) ->
            parsing_error(CanoniTerm,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ; parsing_error(CanoniTerm,ERROR_EXPINHEAD,Status)
        ).


/****************************************************************************
  parse_head_objspec(+Obj,+Arity,+Args,+DWS,+Type,-Code,-Status)
  parse_head_objspec(+CanoniTerm,+DWS,-Code,+Type,-Status)
  Type: INHERITABLE/NONINHERITABLE for a[...] and a[|...|], respectively
****************************************************************************/
parse_head_objspec_top(Funct,N,Args,DWS,Type,Code,Status) :-
        parse_head_objspec(Funct,N,Args,DWS,Type,TCode,S),
        (S == NO_ERRORS ->
            %% NO NEED TO CALL to_TNF here or else TNF will be done twice
            %% for frames!
            %%get_index(Funct,Idx),
            %%to_TNF_list([TCode],Idx,[Code],PARSER_TNF_FLAG,Status)
            TCode = Code, Status = S
        ; Status = S
        ).

parse_head_objspec(Obj,N,Args,DWS,Type,Code,Status) :-
        parse_head_pathexp(Obj,DISALLOW_TRANS,DWS,ANY_PATHEXP,O,S),
        ( S == NO_ERRORS ->
            ( N == 0 ->
                Spec = [],
                Status = NO_ERRORS
            ;
              Args=[Body],
              parse_head_objspec(Body,DWS,Type,Spec,Status)
            ),
            (Status == NO_ERRORS -> flobjspec_struct(O,Spec,Type,Code)
            ; true
            )
        ; Status = S
        ).


parse_head_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,FL_AND_CONNECTIVE),
        !,
        parse_head_objspec(L,DWS,Type,LCode,S),
        ( S == NO_ERRORS ->
            parse_head_objspec(R,DWS,Type,RCode,Status),
            (Status == NO_ERRORS -> flconjunct_struct(LCode,RCode,Code)
            ; true
            )
        ; Status = S
        ).

parse_head_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,FL_OR_CONNECTIVE),
        !,
        parse_head_objspec(L,DWS,Type,LCode,S),
        ( S == NO_ERRORS ->
            parse_head_objspec(R,DWS,Type,RCode,Status),
            (Status == NO_ERRORS -> fldisjunct_struct(LCode,RCode,Code)
            ; true
            )
        ; Status = S
        ).

parse_head_objspec(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        %% explicit negation inside frame
        is_negop(F),
        !,
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_head_objspec(Conjunct,DWS,Type,ArgCode,Status),
        (Status == NO_ERRORS -> flneg_struct(ArgCode,If,Code)
        ; true
        ).

parse_head_objspec(CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_Type,_Code,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F)),
        !,
        parsing_error(If,NO_NEGATION,Status).

parse_head_objspec(CanoniTerm,DWS,Type,Code,Status) :-
        parse_head_attmethspec(CanoniTerm,DWS,Type,Code,Status).


/****************************************************************************
  parse_head_attmethspec(+CanoniTerm,+DWS,+Type,-Goal,-Status)
  parse_head_setexp(+CanoniTerm,+DWS,-CodeList,-Status)
  Type: INHERITABLE/NONINHERITABLE
****************************************************************************/
parse_head_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        ( is_mvdattspecop(F) ->
            parse_head_pathexp(L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
            (S == NO_ERRORS -> parse_head_setexp(R,DWS,RCode,Status)
            ; Status = S
            ),
            (Status == NO_ERRORS -> flmvdattspec_struct(LCode,F,RCode,Type,Code)
            ; true
            )

        ; is_sigattspecop(F) ->
            (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
                parse_head_sigconstr(Constr,DWS,CCode,S_C),
                (S_C == NO_ERRORS ->
                    parse_head_pathexp(M,DISALLOW_TRANS,DWS,ANY_PATHEXP,MCode,S1),
                    (S1 == NO_ERRORS ->
                        %% The right hand side
                        (is_emptyterm(R) ->
                            get_index(R,Ind),
                            emptyterm_struct(Ind,RCode),
                            Status = NO_ERRORS
                        ;  parse_head_pathexp(R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
                        )
                    ; Status = S1
                    )
                ; Status = S_C
                ),
                (Status == NO_ERRORS ->
                    flsigattconspec_struct(MCode,CCode,F,RCode,Type,Code)
                ; true
                )
            ; L = CANOBRACE(_,_If2,Ip2) ->
                parsing_error(Ip2,ERROR_BOOLSIG,Status)
            ;
                flsigconstr_struct(FLNUMBER(0,NO_INDEX),FLATOM(FL_STAR,NO_INDEX),CCode),
                parse_head_pathexp(L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S1),
                ( S1 == NO_ERRORS ->
                    %% The right hand side 
                    (is_emptyterm(R) ->
                        get_index(R,Ind),
                        emptyterm_struct(Ind,RCode),
                        Status = NO_ERRORS
                    ; 
                        parse_head_pathexp(R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
                    )
                 ; Status = S1
                 ),
                (Status == NO_ERRORS ->
                    flsigattconspec_struct(LCode,CCode,F,RCode,Type,Code)
                ; true
                )
            )

        ; (is_incattspecop(F); is_tolistattspecop(F)) ->
            parsing_error(If,ERROR_HDLITERAL,Status)

        ; F == FL_AT, get_name(R,FL_PLIB) ->
            parse_prlgterm(L,DWS,LCode,Status),
            flplib_struct(LCode,Code1),
            flreify_struct(Code1,Code2),
            flmethspec_struct(Code2,Type,Code)

        ;
          F == FL_AT,
          parsing_error(If,NO_WSASRULEHEAD,Status)
        ),
        !.

parse_head_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        is_boolsigop(F),
        !,
        parse_head_pathexp(A,DISALLOW_TRANS,DWS,ANY_PATHEXP,ACode,S1),
        (S1 == NO_ERRORS ->
            flboolsig_struct(ACode,F,Type,Code),
            Status = NO_ERRORS
        ;
            %% passing NONINHERITABLE so as to not get an error about
            %% inheriitable default transactions, ERROR_TRANS_DEFAULT_VALUE
            parse_head_attmethspec(A,DWS,NONINHERITABLE,ACode2,S2),
            (S2 == NO_ERRORS ->
                %% use _T, not Type here, since ACode2 has a type inside of it
                (fltranspec_struct(ATemp,_T,ACode2) -> 
                    fltransig_struct(ATemp,F,Type,Code),
                    Status = NO_ERRORS
                ;
                    parsing_error(A,ERROR_BOOLSIG,Status)
                )
            ;
                parsing_error(A,ERROR_BOOLSIG,Status)
            )
        ),
        !.

parse_head_attmethspec(CanoniTerm,_DWS,Type,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        (Type == INHERITABLE ->
            parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
        ; fltranspec_struct(C,Type,Code),
            Status = NO_ERRORS
        ).
        
parse_head_attmethspec(CanoniTerm,DWS,Type,Code,Status) :-
        parse_head_pathexp(CanoniTerm,ALLOW_TRANS,DWS,ANY_PATHEXP,C,S1),
        (S1 == NO_ERRORS -> 
            (is_fltransactionalterm_struct(C) ->
                (Type == INHERITABLE ->
                    parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
                ; fltranspec_struct(C,Type,Code),
                    Status = NO_ERRORS
                )
            ;
                flmethspec_struct(C,Type,Code),
                Status = NO_ERRORS
            )
        ;
            Status = S1
        ).

parse_head_setexp(CANOBRACE(L,_N,_I),DWS,CodeList,Status) :-
        !,
        parse_head_pathexplist(L,DWS,ANY_PATHEXP,CodeList,Status).

parse_head_setexp(CanoniTerm,DWS,[Code],Status) :-
        parse_head_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,ANY_PATHEXP,Code,Status).


parse_head_sigconstr(CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_RANGE),
        !,
        parse_head_pathexplist([Lower,Upper],DWS,PURE_PATHEXPS_ONLY,[LowerCode,UpperCode],S),
        ( S == NO_ERRORS ->
            ( not(valid_lower_sigconstr(LowerCode)) ->
                Lower = OBJECT(_,If),
                parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
            ;
                ( not(valid_upper_sigconstr(UpperCode)) ->
                        Upper = OBJECT(_,If),
                        parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
                ;
                    Status = NO_ERRORS
                )
            )
        ;
            Status = S
        ),
        flsigconstr_struct(LowerCode,UpperCode,Code). 

parse_head_sigconstr(CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
        parsing_error(If,ERROR_SIGCONSTR,Status).
        

/****************************************************************************
  parse_tablerefresh(+ArgsList,+DWS,-Code,-Status)
****************************************************************************/

parse_tablerefresh(Args,DWS,Code,Status) :-
        %% NULL here means that error will be issued, if HeadList
        %% has disjunction, quantifier, etc.
        set_context(CONTEXT_PARSER_REFRESH),
        parse_dbliteral_list_conjunctless(FLREF,Args,DWS,CodeList,NULL,Status),
        clear_context(CONTEXT_PARSER_REFRESH),
        (Status == NO_ERRORS
        -> flrefresh_struct(CodeList,Code)
        ; true
        ).


/****************************************************************************
  parse_dbinsert(+OpCode,+N,+ArgsList,+DWS,-Code,-Status)
****************************************************************************/
parse_dbinsert(OpCode,1,[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_If,_Ip)],DWS,Code,Status) :-
        get_atom(Bar,FL_BAR),
        !,
        comma_separated_canoterm_to_list(L,LList),
        %% No disjunction/quantifiers in Head in insert{Head|...}
        parse_dbliteral_list_conjunctless(FLINS,LList,DWS,LCodeList,NULL,S),
        ( S == NO_ERRORS -> parse_rule_body(R,DWS,DWS,RCode,Status),
            (Status == NO_ERRORS -> flinsert_struct(OpCode,LCodeList,RCode,Code)
            ; true
            )
        ;
          Status = S
        ).

parse_dbinsert(OpCode,_N,Args,DWS,Code,Status) :-
        parse_dbliteral_list(FLINS,Args,DWS,LitCodeList,FlagList,Status),
        (Status == NO_ERRORS ->
            postprocess_db_literals(LitCodeList,FlagList,FL_INSERTRULE_Z,DWS,PostLitCodeList),
            flinsert_struct(OpCode,PostLitCodeList,Code)
        ; true
        ).


/****************************************************************************
  parse_dbdelete(+OpCode,+N,+Args,+DWS,-Code,-Status)
****************************************************************************/
parse_dbdelete(OpCode,1,[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_If,_Ip)],DWS,Code,Status) :-
        get_atom(Bar,FL_BAR),
        !,
        comma_separated_canoterm_to_list(L,LList),
        %% No disjunction/quantifiers in Head in delete{Head|...}
        parse_dbliteral_list_conjunctless(FLDEL,LList,DWS,LCodeList,NULL,S),
        ( S == NO_ERRORS -> parse_rule_body(R,DWS,DWS,RCode,Status),
            (Status == NO_ERRORS -> fldelete_struct(OpCode,LCodeList,RCode,Code)
            ; true
            )
        ;
          Status = S
        ).

parse_dbdelete(OpCode,_N,Args,DWS,Code,Status) :-
        parse_dbliteral_list(FLDEL,Args,DWS,LitCodeList,FlagList,Status),
        (Status == NO_ERRORS ->
            postprocess_db_literals(LitCodeList,FlagList,FL_DELETERULE,DWS,PostLitCodeList),
            fldelete_struct(OpCode,PostLitCodeList,Code)
        ; true
        ).

/****************************************************************************
  parse_dbliteral_list(+Mode,+ArgsList,+DWS,-CodeList,-FlagList,-Status)

  parse_dbliteral_list/6 is for both insert and delete literals. The
  value of Mode can be either FLINS (insert) or FLDEL (delete). The
  difference between insert and delete literals is that insert literals
  cannot contain multivalued reference whereas delete literals can.

  FlagList: list of flags to indicate if there is a disjunction in the
  respective head in CodeList. If so, give an error.
****************************************************************************/
parse_dbliteral_list(_Mode,[],_DWS,[],Flags,NO_ERRORS) :-
        !,
        (var(Flags) -> Flags = []
        ; true
        ).

parse_dbliteral_list(Mode,[H|T],DWS,CodeList,FlagList,Status) :-
        !,
        parse_dbliteral(Mode,H,DWS,HCLpre,S),
        ( S == NO_ERRORS ->
            get_index(H,Idx),
            multiply_setarg_code_list(HCLpre,HCL),
            (FlagList==NULL ->
                to_TNF_list(HCL,Idx,HTNF,NULL,S2),
                TFlags = NULL
            ; to_TNF_list(HCL,Idx,HTNF,HFlags,S2)
            ),
            (S2 == NO_ERRORS ->
                parse_dbliteral_list(Mode,T,DWS,TCL,TFlags,Status),
                (Status == NO_ERRORS ->
                    append(HTNF,TCL,CodeList),
                    (FlagList==NULL -> true
                    ; append(HFlags,TFlags,FlagList)
                    )
                ; true
                )
            ; Status = S2
            )
        ;
          Status = S
        ).

%% this one splits flconjuncts into lists
parse_dbliteral_list_conjunctless(Mode,Head,DWS,ConjunctlessCodeList,FlagList,Status) :-
        parse_dbliteral_list(Mode,Head,DWS,CodeList,FlagList,Status),
        (Status == NO_ERRORS ->
            flconjunct_list2list(CodeList,ConjunctlessCodeList)
        ; true
        ).


/****************************************************************************
  parse_dbliteral(+Mode,+CanoniTerm,+DWS,-CodeList,-Status)

  Mode can be either FLINS (insert) or FLDEL (delete).
  Note: Module names are allowed in insert/delete literals.
****************************************************************************/
%% parse_dbliteral/5 does not do TNF. This is important and is used in the
%% parse of the descriptors.
parse_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_DWS,CodeList,Status) :-
        %% db literals under (....)@WS
        get_atom(Funct,FL_AT),
        !,
        ( parse_workspace(R,RCode,[]),
            (
              flora_get_module_from_spec(RCode,FLORAUSERMOD,_)
            ; flora_get_module_from_spec(RCode,FLORASYSMOD,_)
            )
        -> comma_separated_canoterm_to_list(L,LList),
            %% important to NOT do TNF here or else descriptor frames will
            %% be dragged through TNF but the compiler relies on the fact that
            %% descriptor frames are not broken and stay as one whole OBJSPEC
            parse_dbliteral_list_no_TNF(Mode,LList,RCode,CodeList,Status)
        ; % illegal module name
          parsing_error(R,ERROR_WSNAME,Status)
        ).

parse_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,CodeList,Status) :-
        get_atom(Funct,FL_COMMA),
        !,
        parse_dbliteral(Mode,L,DWS,LCode,S),
        (S == NO_ERRORS ->
            parse_dbliteral(Mode,R,DWS,RCode,Status),
            append(LCode,RCode,CodeList)
        ; Status = S
        ).

parse_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,[Code],Status) :-
        get_atom(Funct,FL_OR_CONNECTIVE),
        !,
        parse_dbliteral(Mode,L,DWS,LCode,S),
        parse_list2flconjunct(LCode,LCodeConj),
        (S == NO_ERRORS ->
            parse_dbliteral(Mode,R,DWS,RCode,Status),
            parse_list2flconjunct(RCode,RCodeConj),
            fldisjunct_struct(LCodeConj,RCodeConj,Code)
        ; Status = S
        ).

parse_dbliteral(Mode,CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),DWS,[Code],Status) :-
        get_atom(Funct,F),
        is_negop(F),
        !,
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_dbliteral(Mode,Conjunct,DWS,ArgCode,Status),
        parse_list2flconjunct(ArgCode,ArgCodeConj),
        (Status == NO_ERRORS -> flneg_struct(ArgCodeConj,If,Code)
        ; true
        ).

%% no quantifiers in the head
parse_dbliteral(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[CANOTERM(Quant,_N,FL_PARENTHESIS,_Vars,_,_),_Goal],_If,_Ip),_DWS,_CodeList,Status) :-
        get_atom(Funct,FL_QUANTVARCONNECTOR),
        get_atom(Quant,QuantAtom,QuantIdx),
        is_logicalquantifier(QuantAtom,_QuantAtomCanon),
        !,
        parsing_error(QuantIdx,NO_LOG_QUANTIFIERS,Status).

        
parse_dbliteral(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,[Code],Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,ALLOW_TRANS,DWS,CuriCode,Status),
        flora_get_module_from_spec(DWS,ModuleType,Module),
        flmodule_struct(ModuleType,CuriCode,Module,Code).

parse_dbliteral(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,_Ip),DWS,[Code],Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        parse_composer_datatype(Args,If,DWS,Code,Status).

%% reify op ${...} that occurs as a formula
parse_dbliteral(Mode,CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        set_context(CONTEXT_PARSER_REIFY),
        parse_dbliteral_list(Mode,Args,DWS,Code,_Flags,Status),
        clear_context(CONTEXT_PARSER_REIFY).

%% Update with stealth literals: make them invisible to incremental tables
%% For non-incremental tables, stealth literals make no diffeence.
parse_dbliteral(Mode,CANOTERM(Funct,_N,FL_BRACE,Args,If,_Ip),DWS,CodeList,Status) :-
	get_atom(Funct,FL_STEALTHLIT),
	!,
	%% NULL as FlagList here indicates we only allow simple literals
	%% in stealth update ops
	parse_dbliteral_list(Mode,Args,DWS,CodeLits,Flags,Status1),
	(is_list(Flags), memberchk(1,Flags) -> %% has omnis
	    parsing_error(If,NO_DISJUNCTION_STEALTH,Status2)
	; Status2 = Status1
	),
	(Status2 == NO_ERRORS ->
	    stealth_wrap_list(CodeLits,CodeList,Status)
	; Status = Status2
	).

stealth_wrap_list([],[],NO_ERRORS) :- !.
stealth_wrap_list([H|Rest],[WH|WList],Status) :-
	(is_flworkspace(H,StrippedH,WS),
	    (is_fltransactionalterm_struct(StrippedH) ;
		is_fltransactionalobjspec_struct(StrippedH))
	->
	    flstealth_struct(StrippedH,WrappedH),
	    flmodule_struct(FLORAUSERMOD,WrappedH,WS,WH),
	    Status1 = NO_ERRORS
	; (is_fltransactionalterm_struct(H) ;
	      is_fltransactionalobjspec_struct(H))
	->
	    flstealth_struct(H,WH),
	    Status1 = NO_ERRORS
	;
	    flrcompiler:approx_flindex(H,Idx),
	    parsing_error(Idx,ONLY_TRANSACTIONAL_IN_STEALTH,Status1)
	),
	(Status1 == NO_ERRORS -> stealth_wrap_list(Rest,WList,Status)
	; Status = Status1
	).

flstealth_struct(H,FLSTEALTHLIT(H)).
is_fltransactionalobjspec_struct(S) :-
	is_flobjspec(S,_,MethSpec,_),
	is_fltranspec(MethSpec,_,_).

parse_dbliteral(Mode,CanoniTerm,DWS,[Code],Status) :-
        %% now the literal is stripped of commas and workspaces - do
        %% the main processing of db literal
        parse_stripped_dbliteral(Mode,CanoniTerm,DWS,TCode,Status),
        %% In delete, %?Var is converted to %?Var@?
        (Mode==FLDEL, DWS == NULL, is_fltransactionalvar_struct(TCode) ->
            is_anonymous_flvar_struct(Module)
        ; flora_get_module_from_spec(DWS,ModuleType,Module)
        ),
        flmodule_struct(ModuleType,TCode,Module,Code).


/****************************************************************************
        parse_reify(+Arg,+DWS,-Code,-Status)
        Handle reification, ${...}
****************************************************************************/
parse_reify(Arg,DWS,Code,Status) :-
        set_context(CONTEXT_PARSER_REIFY),
        protect_reification(parse_rule_body(Arg,DWS,DWS,ArgCode,Status)),
        clear_context(CONTEXT_PARSER_REIFY),
        (Status == NO_ERRORS ->
            to_LT(ArgCode,ArgCodeLT),
            flreify_struct(ArgCodeLT,Code)
        ; true
        ).


/****************************************************************************
        parse_catch(Goal,Error,Handler,DWS,Code,Status)
        Handle catch{Goal,Error,Handler}
****************************************************************************/
parse_catch(Goal,Error,Handler,DWS,Code,Status) :-
        parse_rule_body(Goal,DWS,DWS,GoalCode,GoalStatus),
        (GoalStatus == NO_ERRORS
        -> parse_pure_term(Error,DWS,ErrorCode,ErrorStatus),
            (ErrorStatus == NO_ERRORS
            -> parse_rule_body(Handler,DWS,DWS,HandlerCode,Status),
                (Status == NO_ERRORS
                -> flcatch_struct(GoalCode,ErrorCode,HandlerCode,Code)
                ; true
                )
            ; Status = ErrorStatus
            )
        ; Status = GoalStatus
        ).

/****************************************************************************
        parse_throw(Error,DWS,Code,Status)
        Handle throw{Error}
****************************************************************************/
parse_throw(Error,DWS,Code,Status) :-
        parse_pure_term(Error,DWS,ErrCode,Status),
        (Status == NO_ERRORS -> flthrow_struct(ErrCode,Code)
        ; true
        ).

/****************************************************************************
        parse_p2h(Prolog,Hilog,DWS,Code,Status)
        Handle p2h{Prolog,Hilog}
****************************************************************************/
parse_p2h(Prolog,Hilog,DWS,Code,Status) :-
        parse_pure_term(Prolog,DWS,PrlgCode,PrlgStatus),
        %%(PrlgStatus == NO_ERRORS -> parse_pure_term(Hilog,DWS,HlgCode,Status),
        (PrlgStatus == NO_ERRORS -> parse_term_or_var(Hilog,HlgCode,Status),
            (Status == NO_ERRORS -> flp2h_struct(PrlgCode,HlgCode,Code)
            ; true
            )
        ; Status = PrlgStatus
        ).

/****************************************************************************
    parsing simple primitives
****************************************************************************/

parse_simple_primitive(PrimitiveName,N,Args,DWS,Code,Status) :-
        (flora_prim_argdef(PrimitiveName,N,ArgTypes) -> 
            parse_body_argpathexplist(Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,ArgCode,Status)
        ; parse_body_pathexplist(Args,DWS,PURE_PATHEXPS_ONLY,ArgCode,Status)
        ),
        flsimpleprimitive_struct(PrimitiveName,ArgCode,Code).


/****************************************************************************
   The following check_update_* statements make sure that builtins
   and other inappropriate things don't occur in update statements.
****************************************************************************/

/****************************************************************************
  check_update_builtin(+Mode,+CanoniTerm,-Status)
****************************************************************************/
check_update_builtin(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_atom(Funct,F),
        flora_nodefp(F,N),
        \+flora_nodefp_exception(F,N),
        ( Mode == FLINS -> parsing_error(If,NO_INSERT,Status)
        ; Mode == FLDEL -> parsing_error(If,NO_DELETE,Status)
        ; 
            parsing_error(If,ERROR_BUILTIN,Status)
        ).


/****************************************************************************
  check_update_ifthenelse(+CanoniTerm,-Status)
****************************************************************************/
/*
check_update_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_IF),
        !,
        parsing_error(If,NO_UPDATEIF,Status).

check_update_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_THEN),
        !,
        parsing_error(If,NO_UPDATETHEN,Status).

check_update_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_ELSE),
        !,
        parsing_error(If,NO_UPDATEELSE,Status).
*/


/****************************************************************************
  parse_stripped_dbliteral(+Mode,+CanoniTerm,+DWS,-Code,-Status)

  This is called to process a single db literal after it was stripped from
  negation (NEG), commas, and workspaces.
****************************************************************************/
parse_stripped_dbliteral(Mode,CanoniTerm,_DWS,_Code,Status) :-
        check_update_builtin(Mode,CanoniTerm,Status),
        !.

parse_stripped_dbliteral(Mode,CanoniTerm,DWS,Code,Status) :-
        CanoniTerm = CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),
        (get_atom(Funct,FL_IMPLYOP)
        ; is_annotated_statement(CanoniTerm,_,_)
        ),
        !,
        (Mode == FLINS -> flatom_struct(FL_INSERTRULE_Z,If,OpCode)
        ; Mode == FLDEL -> flatom_struct(FL_DELETERULE,If,OpCode)
        ; flora_error_line('Parser bug: Invalid update mode, ~w', [Mode]),
            throw(FLORA_TOP_LEVEL)
        ),
        parse_dynrule(CanoniTerm,DWS,CodeList,Status),
        (Status == NO_ERRORS -> flupdaterule_struct(OpCode,CodeList,Code)
        ; true
        ).

parse_stripped_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,F),
        is_birelop(F),
        !,
        parse_db_pathexplist(Mode,Args,DWS,ANY_PATHEXP,[LCode,RCode],Status),
        (Status == NO_ERRORS -> flbirelate_struct(LCode,F,RCode,Code)
        ; true
        ).

parse_stripped_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
        get_atom(Funct,F),
        is_objrefop(F),
        !,
        ( Mode == FLINS -> parsing_error(If,ERROR_INSERT,Status)
        ; Mode == FLDEL -> parsing_error(If,ERROR_DELETE,Status)
        ; Mode == FLREF -> parsing_error(If,ERROR_REFRESH,Status)
        ; Mode == FLCLS -> parsing_error(If,ERROR_CLAUSELIT,Status)
        ).

%% :=: as fact
parse_stripped_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_OBJEQL),
        !,
        parse_db_pathexplist(Mode,Args,DWS,PURE_PATHEXPS_ONLY,[LCode,RCode],Status),
        (Status == NO_ERRORS -> flobjeql_struct(LCode,RCode,Code)
        ; true
        ).


parse_stripped_dbliteral(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
        !,
        ( get_atom(Funct,F),
            (flora_prlgdef(F,N)
            ; flora_prlgdef(F,N,_) 
            ; flora_prlgdef_repl(F,N,_,_)
            )
        ->
            parsing_error(If,NO_PROLOG,Status)
        ;
            parse_db_term(Mode,DB_LITERAL,Funct,N,Args,ALLOW_TRANS,DWS,Code,Status)
        ).

%% obj[...]
parse_stripped_dbliteral(Mode,CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_db_objspec(Mode,Funct,N,Args,DWS,NONINHERITABLE,Code,Status).
%% obj[|...|]
parse_stripped_dbliteral(Mode,CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),DWS,Code,Status) :-
        !,
        parse_db_objspec(Mode,Funct,N,Args,DWS,INHERITABLE,Code,Status).

parse_stripped_dbliteral(Mode,CanoniTerm,_DWS,Code,Status) :-
        get_atom(CanoniTerm,A),
        !,
        ( flora_nodefp(A,0) ->
            ( Mode == FLINS -> parsing_error(CanoniTerm,NO_INSERT,Status)
            ;
                Mode == FLDEL,
                parsing_error(CanoniTerm,NO_DELETE,Status)
            ;
                parsing_error(CanoniTerm,ERROR_BUILTIN,Status)
            )

        ; (flora_prlgdef(A,0)
          ; flora_prlgdef(A,0,_)
          ; flora_prlgdef_repl(A,0,_,_)
          )
        ->
            parsing_error(CanoniTerm,NO_PROLOG,Status)
        ;
          flobject_struct(CanoniTerm,Code),
            Status = NO_ERRORS
        ).

parse_stripped_dbliteral(_Mode,CanoniTerm,_DWS,Code,NO_ERRORS) :-
        get_transactionalatom(CanoniTerm,_A),
        !,
        fltransactionalobject_struct(CanoniTerm,Code).

%% Anonymous vars are not allowed in DB literals except in clause{...}
parse_stripped_dbliteral(Mode,CanoniTerm,_DWS,Code,NO_ERRORS) :-
        get_flvar_struct(CanoniTerm,Code),
        %% Allow anon vars for the clause statement
        (Mode == FLCLS -> true
        ; \+ is_anonymous_flvar_struct(Code)
        ).

parse_stripped_dbliteral(Mode,CanoniTerm,DWS,Code,Status) :-
        get_fltransactionalvar_struct(CanoniTerm,Code1),
        (Mode == FLCLS, DWS == NULL
        -> Status = NO_ERRORS,
            %% If it is a clause{...} statement and we get a transactional var,
            %% assume that it has a variable module
            is_anonymous_flvar_struct(ModVar),
            flmodule_struct(FLORAUSERMOD,Code1,ModVar,Code)
        ; Mode \== FLDEL, DWS == NULL ->
            %% this allows standalone transactional vars in delete.
            parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
        ;
            \+ is_anonymous_fltransactionalvar_struct(Code1),
            Code = Code1,
            Status = NO_ERRORS
        ), 
        !.

parse_stripped_dbliteral(Mode,CanoniTerm,_DWS,_Code,Status) :-
        !,
        ( Mode == FLINS -> parsing_error(CanoniTerm,ERROR_INSERT,Status)
        ; Mode == FLDEL -> parsing_error(CanoniTerm,ERROR_DELETE,Status)
        ; Mode == FLREF -> parsing_error(CanoniTerm,ERROR_REFRESH,Status)
        ; Mode == FLCLS -> parsing_error(CanoniTerm,ERROR_CLAUSELIT,Status)
        ).


/****************************************************************************
 parse_db_term(+Mode,+Context,+Funct,+Arity,+Args,+TransFlag,+DWS,-Code,-Status)

 Context: DB_LITERAL/DB_PATHEXP
****************************************************************************/

parse_db_term(Mode,_Context,Funct,N,Args,_TransFlag,DWS,Code,Status) :-
        get_atom(Funct,FAtom),
        flora_argdef(FAtom,N,ArgTypes,DWS),
        !, 
        flobject_struct(Funct,F),
        parse_db_argpathexplist(Mode,Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status),
        ( Status == NO_ERRORS -> flterm_struct(F,N,AList,Code)
        ;
            true
        ).

parse_db_term(Mode,_Context,Funct,N,Args,TransFlag,DWS,Code,Status) :-
        fltransactionalobject_struct(Funct,F),
        !,
        ( TransFlag == ALLOW_TRANS ->
            (get_transactionalatom(Funct,FAtom),
                flora_argdef(FAtom,N,ArgTypes,DWS)
            -> parse_db_argpathexplist(Mode,Args,ArgTypes,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ;
                parse_db_pathexplist(Mode,Args,DWS,PURE_PATHEXPS_ONLY,AList,Status)
            ),
            (Status == NO_ERRORS -> fltransactionalterm_struct(F,N,AList,Code)
            ; true
            )
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

parse_db_term(Mode,_Context,Funct,N,Args,TransFlag,DWS,Code,Status) :-
        parse_db_pathexp(Mode,Funct,TransFlag,DWS,PURE_PATHEXPS_ONLY,F,S),
        ( S == NO_ERRORS ->
            parse_db_pathexplist(Mode,Args,DWS,PURE_PATHEXPS_ONLY,AList,Status),
            (Status == NO_ERRORS -> 
                ( is_fltransactionalterm_struct(F) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
        ;
          Status = S
        ).


/**********************************************.*****************************
  parse_db_list(+Mode,+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)
****************************************************************************/
parse_db_list(_Mode,[],[],Index,_DWS,T,NO_ERRORS) :-
        !,
        fllist_struct([],[],Index,T).

parse_db_list(Mode,L,T,Index,DWS,Code,Status) :-
        parse_db_pathexplist(Mode,L,DWS,PURE_PATHEXPS_ONLY,LCode,S),
        ( S == NO_ERRORS ->
            ( T == [] ->
                TCode = [],
                Status = NO_ERRORS
            ;
              parse_db_pathexp(Mode,T,DISALLOW_TRANS,DWS,PURE_PATHEXPS_ONLY,TCode,Status)
            ),
            (Status == NO_ERRORS -> fllist_struct(LCode,TCode,Index,Code); true)
        ;
          Status = S
        ).


/****************************************************************************
  parse_db_pathexplist(+Mode,+ListOfCanoniTerms,+DWS,+TermArgMode,-ListOfPathExpressions,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_db_pathexplist(_Mode,[],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_db_pathexplist(Mode,[T|L],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_db_pathexp(Mode,T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_db_pathexplist(Mode,L,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).


/****************************************************************************
  parse_db_argpathexplist(+Mode,+ListOfCanoniTerms,+ArgTypes,+DWS,+TermArgMode,-ListOfPathExpressions,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_db_argpathexplist(_Mode,[],[],_DWS,_TermArgMode,[],NO_ERRORS) :- !.

parse_db_argpathexplist(Mode,[T|L],[FL_OID|ArgTypes],DWS,TermArgMode,[TCode|LCode],Status) :-
        parse_db_pathexp(Mode,T,DISALLOW_TRANS,DWS,TermArgMode,TCode,S),
        (S==NO_ERRORS,
            %% No longer allow truth-valued path expressions pathexp[...]
            %% as arguments to preds and terms
            is_truthval_pathexp(TCode,TermArgMode)
        -> parsing_error(T,ERROR_PURE_PATHEXP_ONLY,PureTermTestStat)
        ; PureTermTestStat = S
        ),
        ( PureTermTestStat == NO_ERRORS ->
            parse_db_argpathexplist(Mode,L,ArgTypes,DWS,TermArgMode,LCode,Status)
        ;
          Status = PureTermTestStat
        ).

parse_db_argpathexplist(Mode,[T|L],[FL_BODYFORMULA|ArgTypes],DWS,TermArgMode,[RTCode|LCode],Status) :-
        set_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        (T = CANOBRACE(SetL,SetN,_SetI), SetN > 0 ->
            %% if this is a set-argument under FL_BODYFORMULA argument,
            %% it can be confused with constraint {...}. So, we decided
            %% that set arguments take precedence.
            %% If the user wants constraints in there then reify explicitly.
            list_same_value(SetN,FL_BODYFORMULA,SetArgTypes),
            parse_db_argpathexplist(Mode,SetL,SetArgTypes,DWS,TermArgMode,SetLCode,S),
            TCode = _,
            put_attr(TCode,SETARGATTRIBUTE,member(TCode,SetLCode)),
            ConvertedToSetarg = 1
        ; parse_rule_body(T,DWS,DWS,TCode,S)
        ),
        clear_context(CONTEXT_PARSER_IMPLICIT_REIFICATION),
        ( S == NO_ERRORS ->
            (var(ConvertedToSetarg) -> flreify_struct(TCode,RTCode)
            ; RTCode = TCode
            ),
            parse_db_argpathexplist(Mode,L,ArgTypes,DWS,TermArgMode,LCode,Status)
        ; Status = S
        ).


/****************************************************************************
  parse_db_pathexp(+Mode,+CanoniTerm,+TransFlag,+DWS,+TermArgMode,-InsertPathExpression,-Status)
  TermArgMode: PURE_PATHEXPS_ONLY/ANY_PATHEXP
               whether to allow only object-valued arguments or also frames
****************************************************************************/
parse_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),_TransFlag,DWS,TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        is_birelop(F),
        !,
        parse_db_pathexplist(Mode,[Left,Right],DWS,TermArgMode,[LCode,RCode],Status),
        (Status == NO_ERRORS -> flbirelate_struct(LCode,F,RCode,Code); true).

parse_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],_If,_Ip),_TransFlag,DWS,TermArgMode,Code,Status) :-   
         get_atom(Funct,F),      
         is_objrefop(F),         
         !,
         (has_context(CONTEXT_PARSER_REFRESH) ->
             parse_db_pathexp(Mode,Left,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
             (S==NO_ERRORS ->
                 parse_db_pathexplist(Mode,[Right],DWS,TermArgMode,[RCode],Status)
             ; Status = S
             )
         ; parsing_error(Funct,ERROR_REFOP_IN_DB,Status)
         ),
         (Status == NO_ERRORS -> flobjref_struct(F,LCode,RCode,Code)
         ; true
         ).

%% To handle CURI structure like prefix#suffix
parse_db_pathexp(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,TransFlag,DWS,Code,Status).

parse_db_pathexp(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,F),
        is_datatypeop(F),
        !,
        parse_composer_datatype([L,R],If,DWS,Code,Status1),
        (Status1 == NO_ERRORS,
            is_fltransactionalpredspec_struct(Code),
            TransFlag == DISALLOW_TRANS
        ->
            parsing_error(L,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ; Status = Status1
        ).

parse_db_pathexp(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        parsing_error(If,NO_WSNESTING_IN_IO,Status).

/*
%% This handles arguments to inserted literals that have a workspace in them.
%% Since such arguments must be reified, the insertion will be rejected by
%% the previous case.
parse_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),TransFlag,_DWS,TermArgMode,Code,Status) :-
        get_atom(Funct,FL_AT),
        !,
        ( %%(name_or_var(R,RCode) ; thismodule_token(R,RCode)) ->
            parse_workspace(R,RCode,[]) ->
            parse_db_pathexp(Mode,L,TransFlag,RCode,TermArgMode,LCode,S),
            ( S == NO_ERRORS ->
                ( is_flworkspace_struct(LCode) ->
                    parsing_error(If,NO_WSNESTING_IN_IO,Status)

                ; nowspathexp(LCode) -> Code=LCode, Status = NO_ERRORS
                ;
                  flmodule_struct(FLORAUSERMOD,LCode,RCode,Code),
                  Status = NO_ERRORS
                )
            ;
              Status = S
            )
        ;
          parsing_error(R,ERROR_WSNAME,Status)
        ).
*/

parse_db_pathexp(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_db_term(Mode,DB_PATHEXP,Funct,N,Args,TransFlag,DWS,Code,Status).

%% obj[...]
parse_db_pathexp(Mode,CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_db_objspec(Mode,Funct,N,Args,DWS,NONINHERITABLE,Code,Status).
%% obj[|...|]
parse_db_pathexp(Mode,CANOTERM(Funct,N,FL_BRACKBAR,Args,_If,_Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_db_objspec(Mode,Funct,N,Args,DWS,INHERITABLE,Code,Status).

%% Reification in insert/delete seems to be blocked elsewhere.
%% This clause is here in case we decide to unblock later.
parse_db_pathexp(_Mode,CANOTERM(Funct,_N,FL_BRACE,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        get_atom(Funct,Atom),
        is_reifyop(Atom),
        !,
        (list_to_canoterm_conjunct(Args,Conjunct,If,Ip) ->
            parse_reify(Conjunct,DWS,Code,Status)
        ;  parsing_error(Ip,EXP_ARGS,Status)
        ).

parse_db_pathexp(_Mode,CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_aggregt(Funct,N,Args,If,Ip,DWS,Code,Status).

parse_db_pathexp(Mode,CANOLIST(L,T,_N,I,_Ib),_TransFlag,DWS,_TermArgMode,Code,Status) :-
        !,
        parse_db_list(Mode,L,T,I,DWS,Code,Status).


%% Anonymous oid IS allowed in insert/delete
parse_db_pathexp(_Mode,ObjectTerm,_TransFlag,_DWS,_TermArgMode,Code,NO_ERRORS) :-
        flobject_struct(ObjectTerm,Code),
        !.

parse_db_pathexp(Mode,CANOBRACE(L,N,_I),_TransFlag,DWS,TermArgMode,Code,Status) :-
        N>0,
        !,
        parse_db_pathexplist(Mode,L,DWS,TermArgMode,SetLCode,Status),
        Code = _, %% NOTE: a prolog var, since we'll be macro-expanding
        put_attr(Code,SETARGATTRIBUTE,member(Code,SetLCode)).

parse_db_pathexp(_Mode,CANOBRACE(_L,_N,I),_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        !,
        parsing_error(I,ERROR_SETNOTE,Status).

parse_db_pathexp(Mode,CanoniTerm,_TransFlag,_DWS,_TermArgMode,_Code,Status) :-
        ( Mode == FLINS -> parsing_error(CanoniTerm,ERROR_EXPINSERT,Status)
        ; Mode == FLDEL -> parsing_error(CanoniTerm,ERROR_EXPDELETE,Status)
        ; Mode == FLREF -> parsing_error(CanoniTerm,ERROR_EXPREFRESH,Status)
        ; Mode == FLCLS -> parsing_error(CanoniTerm,ERROR_EXPCLAUSE,Status)
        ).


/****************************************************************************
  parse_db_objspec(+Mode,+Obj,+Arity,+Args,+DWS,+Type,-Code,-Status)
  parse_db_objspec(+Mode,+CanoniTerm,+DWS,+Type,-Code,-Status)
  Type: INHERITABLE/NONINHERITABLE
****************************************************************************/
parse_db_objspec(Mode,Obj,N,Args,DWS,Type,Code,Status) :-
        parse_db_pathexp(Mode,Obj,DISALLOW_TRANS,DWS,ANY_PATHEXP,OCode,S),
        ( S == NO_ERRORS ->
            ( N == 0 ->
                Spec = [],
                Status = NO_ERRORS
            ;
                Args=[Body],
                parse_db_objspec(Mode,Body,DWS,Type,Spec,Status)
            ),
            (Status == NO_ERRORS -> flobjspec_struct(OCode,Spec,Type,Code)
            ; true
            )
        ;
          Status = S
        ).


parse_db_objspec(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,FL_AND_CONNECTIVE),
        !,
        parse_db_objspec(Mode,L,DWS,Type,LCode,S),
        ( S == NO_ERRORS ->
            parse_db_objspec(Mode,R,DWS,Type,RCode,Status),
            (Status == NO_ERRORS -> flconjunct_struct(LCode,RCode,Code)
            ; true
            )
        ;
            Status = S
        ).

parse_db_objspec(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,FL_OR_CONNECTIVE),
        !,
        parse_db_objspec(Mode,L,DWS,Type,LCode,S),
        ( S == NO_ERRORS ->
            parse_db_objspec(Mode,R,DWS,Type,RCode,Status),
            (Status == NO_ERRORS -> fldisjunct_struct(LCode,RCode,Code)
            ; true
            )
        ; Status = S
        ).


%% something like a[neg p->q] or a[ neg p] in a db update
parse_db_objspec(Mode,CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        is_negop(F),
        !,
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_db_objspec(Mode,Conjunct,DWS,Type,GCode,Status),
        ( Status == NO_ERRORS -> flneg_struct(GCode,If,Code)
        ; true
        ).



parse_db_objspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_Type,_Code,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F)),
        !,
        ( Mode == FLINS -> parsing_error(If,NO_INSERTNEG,Status)
        ; Mode == FLDEL -> parsing_error(If,NO_DELETENEG,Status)
        ; Mode == FLREF -> parsing_error(If,ERROR_REFRESH,Status)
        ; Mode == FLCLS -> parsing_error(If,ERROR_CLAUSELIT,Status)
        ).

parse_db_objspec(Mode,CanoniTerm,DWS,Type,Code,Status) :-
        parse_db_attmethspec(Mode,CanoniTerm,DWS,Type,Code,Status).


/****************************************************************************
  parse_db_attmethspec(+Mode,+CanoniTerm,+DWS,+Type,-Goal,-Status)
  parse_db_setexp(+Mode,+CanoniTerm,+DWS,-CodeList,-Status)
  Type: INHERITABLE/NONINHERITABLE
****************************************************************************/
parse_db_attmethspec(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        ( is_mvdattspecop(F) ->
            parse_db_pathexp(Mode,L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S),
            (S == NO_ERRORS -> parse_db_setexp(Mode,R,DWS,RCode,Status); Status = S),
            (Status == NO_ERRORS -> flmvdattspec_struct(LCode,F,RCode,Type,Code); true)

        ; is_sigattspecop(F) ->
            (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
               parse_db_sigconstr(Mode,Constr,DWS,CCode,S_C), 
                (S_C == NO_ERRORS ->
                    parse_db_pathexp(Mode,M,DISALLOW_TRANS,DWS,ANY_PATHEXP,MCode,S1),
                    (S1 == NO_ERRORS ->
                        %% The right hand side
                        (is_emptyterm(R) ->
                            %% This is SIGDEF: occurs when we have a[b=> ()]
                            get_index(R,Ind),
                            emptyterm_struct(Ind,RCode),
                            Status = NO_ERRORS
                        ;  parse_db_pathexp(Mode,R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
                        )
                    ; Status = S1
                    )
                ; Status = S_C
                ),
                (Status == NO_ERRORS ->
                    flsigattconspec_struct(MCode,CCode,F,RCode,Type,Code)
                ; true
                )
            ; L = CANOBRACE(_,_If2,Ip2) ->
                parsing_error(Ip2,ERROR_BOOLSIG,Status)
            ;
                parse_db_pathexp(Mode,L,DISALLOW_TRANS,DWS,ANY_PATHEXP,LCode,S1),
                (S1 == NO_ERRORS
                %% The right hand side 
                -> (is_emptyterm(R)
                   %% This is SIGDEF: occurs when we have a[b=> ()]
                   -> get_index(R,Ind),
                       emptyterm_struct(Ind,RCode),
                       Status = NO_ERRORS
                   ;  parse_db_pathexp(Mode,R,DISALLOW_TRANS,DWS,ANY_PATHEXP,RCode,Status)
                   )
                ; Status = S1
                ),
                (Status == NO_ERRORS ->
                    flsigattspec_struct(LCode,F,RCode,Type,Code)
                ; true
                )
            )

        ; (is_incattspecop(F); is_tolistattspecop(F)) ->
            ( Mode == FLINS -> parsing_error(If,ERROR_INSERT,Status)
            ; Mode == FLDEL -> parsing_error(If,ERROR_DELETE,Status)
            ; Mode == FLREF -> parsing_error(If,ERROR_REFRESH,Status)
            ; Mode == FLCLS -> parsing_error(If,ERROR_CLAUSELIT,Status)
            )
        ; F == FL_AT -> parsing_error(If,NO_WORKSPACE,Status)
        ),
        !.

parse_db_attmethspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Type,Code,Status) :-
        get_atom(Funct,F),
        is_boolsigop(F),
        !,
        parse_db_pathexp(Mode,A,DISALLOW_TRANS,DWS,ANY_PATHEXP,ACode,S1),
        (S1 == NO_ERRORS ->
            flboolsig_struct(ACode,F,Type,Code),
            Status = NO_ERRORS
        ;
            %% passing NONINHERITABLE so as to not a get an error about
            %% inheriitable default transactions, ERROR_TRANS_DEFAULT_VALUE
            parse_db_attmethspec(Mode,A,DWS,NONINHERITABLE,ACode2,S2),
            (S2 == NO_ERRORS ->
                %% use _T, not Type here, since ACode2 has a type inside of it
                (fltranspec_struct(ATemp,_T,ACode2) -> 
                    fltransig_struct(ATemp,F,Type,Code),
                    Status = NO_ERRORS
                ;
                    parsing_error(A,ERROR_BOOLSIG,Status)
                )
            ;
                parsing_error(A,ERROR_BOOLSIG,Status)
            )
        ),
        !.

parse_db_attmethspec(_Mode,CanoniTerm,_DWS,Type,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        (Type == INHERITABLE ->
            parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
        ; fltranspec_struct(C,Type,Code),
            Status = NO_ERRORS
        ).

parse_db_attmethspec(Mode,CanoniTerm,DWS,Type,Code,Status) :-
        parse_db_pathexp(Mode,CanoniTerm,ALLOW_TRANS,DWS,ANY_PATHEXP,C,S1),
        (S1 == NO_ERRORS -> 
            (is_fltransactionalterm_struct(C) ->
                (Type == INHERITABLE ->
                    parsing_error(CanoniTerm,ERROR_TRANS_DEFAULT_VALUE,Status)
                ; 
                    fltranspec_struct(C,Type,Code),
                    Status = NO_ERRORS
                )
            ;
                flmethspec_struct(C,Type,Code),
                Status = NO_ERRORS
            )
        ;
            Status = S1
        ).

parse_db_setexp(Mode,CANOBRACE(L,_N,_I),DWS,CodeList,Status) :-
        !,
        parse_db_pathexplist(Mode,L,DWS,ANY_PATHEXP,CodeList,Status).

parse_db_setexp(Mode,CanoniTerm,DWS,[Code],Status) :-
        parse_db_pathexp(Mode,CanoniTerm,DISALLOW_TRANS,DWS,ANY_PATHEXP,Code,Status).

parse_db_sigconstr(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
        get_atom(Funct,FL_RANGE),
        !,
        parse_db_pathexplist(Mode,[Lower,Upper],DWS,PURE_PATHEXPS_ONLY,[LowerCode,UpperCode],S),
        ( S == NO_ERRORS ->
            ( not(valid_lower_sigconstr(LowerCode)) ->
                Lower = OBJECT(_,If),
                parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
            ;
                ( not(valid_upper_sigconstr(UpperCode)) ->
                        Upper = OBJECT(_,If),
                        parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
                ;
                    Status = NO_ERRORS
                )
            )
        ;
            Status = S
        ),
        flsigconstr_struct(LowerCode,UpperCode,Code). 

parse_db_sigconstr(_Mode,CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
        parsing_error(If,ERROR_SIGCONSTR,Status).


/****************************************************************************
  parse_ruleupdate(+OpCode,+N,+ArgsList,+DWS,-Code,-Status)
****************************************************************************/
parse_ruleupdate(OpCode,_N,Args,DWS,Code,Status) :-
        parse_dynrule_list(Args,DWS,CodeList,Status),
        (Status == NO_ERRORS -> flupdaterule_struct(OpCode,CodeList,Code)
        ; true
        ).

/****************************************************************************
  parse_dynrule_list(+RuleList,+DWS,-CodeList,-Status)
****************************************************************************/
parse_dynrule_list([],_DWS,[],NO_ERRORS) :- !.
parse_dynrule_list([H|T],DWS,CodeList,Status) :-
        !,
        parse_dynrule(H,DWS,HCL,S),
        ( S == NO_ERRORS ->
            parse_dynrule_list(T,DWS,TCL,Status),
            (Status == NO_ERRORS -> append(HCL,TCL,CodeList); true)
        ;
            Status = S
        ).

/****************************************************************************
  parse_dynrule(+CanoniTerm,+DWS,-CodeList,-Status)
****************************************************************************/
parse_dynrule(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_DWS,CodeList,Status) :-
        %% insertion of ((rule), ..., (rule))@module
        get_atom(Funct,FL_AT),
        !,
        ( parse_workspace(R,RCode,[]),
            (
              flora_get_module_from_spec(RCode,FLORAUSERMOD,_)
            ; flora_get_module_from_spec(RCode,FLORASYSMOD,_)
            )
        ->
            comma_separated_canoterm_to_list(L,LList),
            parse_dynrule_list(LList,RCode,CodeList,Status)
        ; % illegal module name
          parsing_error(R,ERROR_WSNAME,Status)
        ).

parse_dynrule(CanoniTerm,DWS,Code,Status) :-
        %% insert a rule without workspace, [] is initial descriptor code
        parse_dynrule_no_module(CanoniTerm,DWS,[],DynruleCode,Status),
        %% If DynruleCode is a reification, Code is returned as a list of rules.
        %% Otherwise, Code is a singleton rule.
        (is_list(DynruleCode) -> Code = DynruleCode
        ; Code = [DynruleCode]
        ).


/****************************************************************************
  parse_dynrule_no_module(+CanoniTerm,+DWS,+Descriptors,-Code,-Status)
****************************************************************************/
parse_dynrule_no_module(CanoniTerm,DWS,Descriptors,Code,Status) :-
        ( is_rule(CanoniTerm,Head,Body) ->
            parse_dynhead_top(Head,DWS,HCL,S),
            ( S == NO_ERRORS ->
                parse_rule_body(Body,DWS,DWS,BodyCode,Status),
                fldynrule_struct(HCL,BodyCode,Descriptors,RuleCode),
                %% add default workspace, if any
                flora_get_module_from_spec(DWS,_ModuleType,Module),
                flmodule_struct(FLORARULEWORKSPACE,RuleCode,Module,Code)
            ;
                Status = S
            )

        %% a fact
        ; is_rule_or_fact(CanoniTerm), Descriptors \== [] ->
            %% means: it is an annotated fact, since the previous cond failed
            parse_dynhead_top(CanoniTerm,DWS,HCL,Status),
            ( Status == NO_ERRORS ->
                %% convert annotated fact to rule by adding ":- true"
                trueconst_obj(TruePredObject),
                flobject_struct(TruePredObject,BodyCode),
                fldynrule_struct(HCL,BodyCode,Descriptors,RuleCode),
                %% add default workspace, if any
                flora_get_module_from_spec(DWS,_ModuleType,Module),
                flmodule_struct(FLORARULEWORKSPACE,RuleCode,Module,Code)
            ;
                true
            )

        ; is_latent_query(CanoniTerm,IC) ->
            flora_parse_latent_query(IC,ICCode,Status),
            fldynrule_struct(NULL,ICCode,Descriptors,RuleCode),
            %% add default workspace, if any
            flora_get_module_from_spec(DWS,_ModuleType,Module),
            flmodule_struct(FLORARULEWORKSPACE,RuleCode,Module,Code)

        ; get_statement_descriptors(CanoniTerm,NewDescriptors,Statement),
            NewDescriptors \== []
        ->
            parse_descriptor_list(NewDescriptors,true,NewDescriptorsCodeList,S),
            (S == NO_ERRORS ->
                set_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT),
                parse_dynrule_no_module(Statement,DWS,NewDescriptorsCodeList,Code,Status),
                clear_context(CONTEXT_PARSER_ANNOTATED_CONSTRUCT)
            ;
                Status = S
            )
        ; is_reification(CanoniTerm,Args,_N,_Ip) ->
            %% this is the only case when parse_dynrule_no_module returns
            %% Code as list: a bit unclean, but simple
            parse_dynrule_list(Args,DWS,Code,Status)

        ;
            get_flvar_struct(CanoniTerm,Code) -> Status = NO_ERRORS
        ;
            parsing_error(CanoniTerm, EXP_RULES, Status) 
        ).


/****************************************************************************
  parse_dynhead_top(+CanoTerm,+DWS,-CodeList,-Status) :-
  parse_dynhead(+CanoniTerm,+DWS,-CodeList,-Status)

  Similar to parse_head, but each element of the conjuction may be a
  normal variable or a head_literal
****************************************************************************/
parse_dynhead_top(CanoTerm,DWS,ConjunctlessList,Status) :-
        parse_dynhead(CanoTerm,DWS,HCLpre,S),
        (S == NO_ERRORS ->
            get_index(CanoTerm,Idx),
            multiply_setarg_code_list(HCLpre,HCL),
            to_TNF_list(HCL,Idx,CodeList,PARSER_TNF_FLAG,Status),
            (Status == NO_ERRORS ->
                flconjunct_list2list(CodeList,ConjunctlessList)
            ; true
            )
        ; Status = S
        ).
        
parse_dynhead(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,CodeList,Status) :-
        get_atom(Funct,FL_COMMA),
        !,
        parse_dynhead(L,DWS,LCodeList,S),
        ( S == NO_ERRORS -> parse_dynhead(R,DWS,RCodeList,Status),
            ( Status == NO_ERRORS -> append(LCodeList,RCodeList,CodeList)
            ; true
            )
        ; Status = S
        ).

parse_dynhead(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,[Code],Status) :-
        get_atom(Funct,FL_OR_CONNECTIVE),
        !,
        parse_dynhead(L,DWS,LCodeList,S),
        parse_list2flconjunct(LCodeList,LCodeConj),
        ( S == NO_ERRORS ->
            parse_dynhead(R,DWS,RCodeList,Status),
            parse_list2flconjunct(RCodeList,RCodeConj),
            ( Status == NO_ERRORS -> fldisjunct_struct(LCodeConj,RCodeConj,Code)
            ; true
            )
        ; Status = S
        ).

%% @Module in rule head is prohibited.
parse_dynhead(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_CL,Status) :-
        get_atom(Funct,FL_AT),
        !,
        parsing_error(If,NO_WSASRULEHEAD,Status).

parse_dynhead(CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_CodeList,Status) :-
        get_atom(Funct,F),
        (is_plgnafop(F); is_rulelognafop(F)),
        !,
        parsing_error(If,NO_NEGATION,Status).

parse_dynhead(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,If,Ip),DWS,[Code],Status) :-
        get_atom(Funct,F),
        is_negop(F),
        !,
        list_to_canoterm_conjunct(Args,Conjunct,If,Ip),
        parse_dynhead(Conjunct,DWS,ArgCode,Status),
        parse_list2flconjunct(ArgCode,ArgCodeConj),
        (Status == NO_ERRORS -> flneg_struct(ArgCodeConj,If,Code)
        ; true
        ).


parse_dynhead(CanoniTerm,DWS,[Code],Status) :-
        ( get_flvar_struct(CanoniTerm, C) ->
            ( is_anonymous_flvar_struct(C,I) ->
                parsing_error(I,ERROR_ANONVAR_HEAD,Status)
            ;
                Status = NO_ERRORS,
                flora_get_module_from_spec(DWS,ModuleType,Module),
                flmodule_struct(ModuleType,C,Module,Code)
            )
        ; get_fltransactionalvar_struct(CanoniTerm,Code) ->
            ( is_anonymous_fltransactionalvar_struct(Code,I) ->
                parsing_error(I,ERROR_HDLITERAL,Status)
            ;
                %% short circuit and use anonvar module to allow standalone 
                %% transactional vars??
                %% Maybe -- in some cases: we are unsure which exact syntactic
                %% contexts we are dealing with here. Seems like it is
                %% insert{%?P :- kkk} & insertrule{%?P :- kkk}.
                %% In these cases we do not want standalone vars, however.
                (DWS == NULL ->
                    parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
                ;
                    flora_get_module_from_spec(DWS,ModuleType,Module),
                    flmodule_struct(ModuleType,C,Module,Code),
                    Status = NO_ERRORS
                )
            )
        ;
            parse_head_literal(CanoniTerm,DWS,Code,Status)
        ).

%%% semantics directive
parse_semantics_directive_args(_,[],[],NO_ERRORS) :- !.

parse_semantics_directive_args(AllowVariables,[CANOTERM(F,2,FL_PARENTHESIS,[OptObj,ValsSum],_If,_Ip)|Rest],HCode,Status) :-
        get_atom(F,FL_UNIVEQ),
        sum_canoterm_to_list(ValsSum,Vals),
        parse_one_semantics_directive_option(AllowVariables,OptObj,Vals,HCode-RestCode,S1),
        !,
        (S1 == NO_ERRORS ->
            parse_semantics_directive_args(AllowVariables,Rest,RestCode,Status)
        ;
            Status = S1
        ).

parse_semantics_directive_args(AllowVariables, [Arg|_], _, Status) :-
        get_index(Arg,Ind),
        !,
        (AllowVariables == ALLOW_VARIABLES ->
            parsing_error(Ind,ERROR_SEMOPT,Status)
        ;
            parsing_error(Ind,ERROR_SETSEMOPT,Status)
        ).

parse_one_semantics_directive_option(_,_OptObj,[],Tail-Tail,NO_ERRORS) :- !.
parse_one_semantics_directive_option(AllowVariables,OptObj,[ValObj|Args],[OptCode|OtherOptsCode]-Tail,Status) :-
        get_atom(OptObj,Opt),
        flobject_struct(ValObj,Val),
        is_valid_semantics_direct_option(AllowVariables,Opt,Val),
        !,
        get_index(ValObj,Ind),
        (parse_prlgterm(CANOTERM(OptObj,1,FL_PARENTHESIS,[ValObj],Ind,_Ip),NULL,CodeHilog,S1),
            %% Check if S1 can be a var here. Then, we could replace S1 with []
            S1 == NO_ERRORS
        ->
            flplib_struct(CodeHilog,OptCode),
            parse_one_semantics_directive_option(AllowVariables,OptObj,Args,OtherOptsCode-Tail,Status)
        ;
            (AllowVariables == ALLOW_VARIABLES ->
                parsing_error(Ind,ERROR_SEMOPT,Status)
            ;
                parsing_error(Ind,ERROR_SETSEMOPT,Status)
            )
        ).
parse_one_semantics_directive_option(AllowVariables,F,[ValObj|_Args],_,Status) :-
        get_atom(F,FAtom),
        flobject_struct(ValObj,Val),
        \+ is_valid_semantics_direct_option(AllowVariables,FAtom,Val),
        !,
        parsing_error(ValObj,ERROR_SETSEMOPT,Status).
parse_one_semantics_directive_option(_AllowVariables,F,_Args,_,Status) :-
        get_atom(F,FAtom),
        executable_only_semantics_direct_opt_name(FAtom),
        !,
        parsing_error(F,ERROR_EXECUTABLE_DIRECTIVE_ONLY,Status).


is_valid_semantics_direct_option(ALLOW_VARIABLES,Opt,Val) :-
        !,
        valid_semantics_direct_opt_name(Opt),
        ( is_flvar_struct(Val), !
        ; is_flatom_struct(Val,Atom),
            valid_semantics_direct_option(Opt,Atom)
        ).
is_valid_semantics_direct_option(DISALLOW_VARIABLES,Opt,Val) :-
        !,
        valid_semantics_direct_opt_name(Opt),
        is_flatom_struct(Val,Atom),
        valid_semantics_direct_option(Opt,Atom).


executable_only_semantics_direct_opt_name(FL_SUBCLASSING).
executable_only_semantics_direct_opt_name(FL_CLASS_EXPRESSIONS).

valid_semantics_direct_opt_name(FL_EQUALITY).
valid_semantics_direct_opt_name(FL_INHERITANCE).
valid_semantics_direct_opt_name(FL_TABLING).
valid_semantics_direct_opt_name(FL_SUBCLASSING) :-
        \+has_context(static_setsemantics_directive).
valid_semantics_direct_opt_name(FL_CLASS_EXPRESSIONS) :-
        \+has_context(static_setsemantics_directive).
valid_semantics_direct_opt_name(FL_CUSTOM).
valid_semantics_direct_option(FL_EQUALITY,NONE).
valid_semantics_direct_option(FL_EQUALITY,BASIC).
%%valid_semantics_direct_option(FL_EQUALITY,FLOGIC).
valid_semantics_direct_option(FL_INHERITANCE,NONE).
valid_semantics_direct_option(FL_INHERITANCE,FLOGIC).
valid_semantics_direct_option(FL_INHERITANCE,MONOTONIC).
valid_semantics_direct_option(FL_TABLING,FL_SUBSUMPTIVE).
valid_semantics_direct_option(FL_TABLING,FL_VARIANT).
valid_semantics_direct_option(FL_TABLING,FL_INCREMENTAL).
valid_semantics_direct_option(FL_TABLING,FL_NONINCREMENTAL).
valid_semantics_direct_option(FL_SUBCLASSING,STRICT_SUB).
valid_semantics_direct_option(FL_SUBCLASSING,NONSTRICT_SUB).
valid_semantics_direct_option(FL_CLASS_EXPRESSIONS,FL_ON).
valid_semantics_direct_option(FL_CLASS_EXPRESSIONS,FL_OFF).
valid_semantics_direct_option(FL_CLASS_EXPRESSIONS,NONE).
valid_semantics_direct_option(FL_CUSTOM,NONE).
valid_semantics_direct_option(FL_CUSTOM,X) :- atom(X).


%%% Misc
protect_reification(Call) :-
        set_context(protecting_reification),
        call(Call),
        clear_context(protecting_reification).


%% Used for reading Flora-2 terms (incl. reified formulas) from within
%% Flora-2 programs
%% Only body path expressions
flora_parse_term_external(ComposerTerm,ParsedTerm,Status) :-
        canonical_form(ComposerTerm,CanoniTerm),
        parse_body_pathexp(CanoniTerm,ALLOW_TRANS,NULL,PURE_PATHEXPS_ONLY,ParsedTerm_pre,Status),
        multiply_setarg_code(ParsedTerm_pre,ParsedTerm_pre_list),
        parse_list2flcommalist(ParsedTerm_pre_list,ParsedTerm),
        !.

get_statement_descriptors(CanoTerm,[Descriptor1|RestDescriptors],Statement) :-
        is_annotated_statement(CanoTerm,Descriptor1,RestStatement),
        !,
        get_statement_descriptors(RestStatement,RestDescriptors,Statement).
get_statement_descriptors(CanoTerm,[],CanoTerm).

%% Parse descriptors
%% VarsOK = true: variables as rule Ids are allowed; false - not allowed
parse_descriptor_list([],_,[],NO_ERRORS) :- !.
parse_descriptor_list([Descr|RestDescr],VarsOK,[Code1|RestCode],Status) :-
        parse_descriptor(Descr,VarsOK,Code1,S1),
        (S1 == NO_ERRORS
        -> parse_descriptor_list(RestDescr,VarsOK,RestCode,Status)
        ; Status = S1
        ).
parse_descriptor(CANOTERM(Funct,_N,DelimType,Args,If,_Ip),VarsOK,Code,Status) :-
        DelimType = FL_BRACE,
        !,
        get_atom(Funct,FName),
        set_context(CONTEXT_PARSER_DESCRIPTOR),
        parse_descriptor_aux(FName,Args,If,VarsOK,Code,Status),
        clear_context(CONTEXT_PARSER_DESCRIPTOR).
parse_descriptor(CANOTERM(_Funct,_N,_DelimType,_Args,If,_Ip),_VarsOK,_Code,Status) :-
        parsing_error(If,INVALID_RULE_DESCRIPTOR,Status).

parse_descriptor_aux(FL_RULEID_OP,[Descr],If,VarsOK,[Code],Status) :-
        !,
        %% The compiler relies on the fact that descritor frames are not broken
        %% into conjunctions. This requires that here we don't drag those
        %% frames through TNF. 
        %% parse_dbliteral_list_no_TNF/5 and parse_head_literal_list/5 do not 
        %% do TNF - important
        ( VarsOK,
            parse_dbliteral_list_no_TNF(FLCLS,[Descr],NULL,PreCode,Status),
            Status == NO_ERRORS
        -> annotation_struct(PreCode,FLRULEID,If,Code)
        ; parse_head_literal_list([Descr],NULL,PreCode,Status),
            Status == NO_ERRORS
        -> annotation_struct(PreCode,FLRULEID,If,Code)
        ; get_integer(Descr,_)
        -> flobject_struct(Descr,PreCode),
            annotation_struct([PreCode],FLRULEID,If,Code),
            Status = NO_ERRORS
        ; get_flvar_struct(Descr,PreCode),
            has_context(CONTEXT_PARSER_NL_TEMPLATES)
        ->
            annotation_struct([PreCode],FLRULEID,If,Code),
            Status = NO_ERRORS
        ;
            parsing_error(If,INVALID_ID_DESCRIPTOR,Status)
        ).
parse_descriptor_aux(FL_RULEID_OP,_Args,If,_,_,Status) :-
        !,
        parsing_error(If,INVALID_ID_DESCRIPTOR,Status).
parse_descriptor_aux(FL_BOOL_DESCR_OP,[Descr],If,VarsOK,[Code],Status) :-
        !,
        ((get_name(Descr,_) ; get_spectoken(Descr,FL_NEWOID))
        %% element in list is atom
        ->
            flobject_struct(Descr,PreCode),
            annotation_struct(PreCode,FLBOOLDESCRIPTOR,If,Code),
            Status = NO_ERRORS
        ; %% or a term
            is_term_struct(Descr,Func,Arity,Args)
        ->
            parse_body_term(Func,Arity,Args,DISALLOW_TRANS,NULL,PreCode,Status),
            annotation_struct(PreCode,FLBOOLDESCRIPTOR,If,Code)
        ; %% VarsOK is true if we are parsing clause{@{@?Var,...} ...}
            (VarsOK ; has_context(CONTEXT_PARSER_NL_TEMPLATES)),
            get_flvar_struct(Descr,PreCode)
        ->
            annotation_struct(PreCode,FLBOOLDESCRIPTOR,If,Code),
            Status = NO_ERRORS
        ;
            parsing_error(If,INVALID_BOOL_DESCRIPTOR,Status)
        ).
parse_descriptor_aux(FL_BOOL_DESCR_OP,_,If,_,_,Status) :-
        !,
        parsing_error(If,INVALID_BOOL_DESCRIPTOR,Status).
parse_descriptor_aux(FL_DESCRIPTOROP,[],_If,_VarsOK,[],NO_ERRORS) :- !.
parse_descriptor_aux(FL_DESCRIPTOROP,[First|Rest],If,VarsOK,[FirstCode|RestCode],Status) :-
        ((get_name(First,_) ; get_spectoken(First,FL_NEWOID) ; get_integer(First,_))
        ->
            %% First element in list is a tag const
            flobject_struct(First,PreCode),
            annotation_struct(PreCode,FLTAG,If,FirstCode),
            Stat1 = NO_ERRORS
        ; %% or a term
            is_term_struct(First,Func,Arity,Args)
        ->
            parse_body_term(Func,Arity,Args,DISALLOW_TRANS,NULL,PreCode,Stat1),
            annotation_struct(PreCode,FLTAG,If,FirstCode)
        ; %% VarsOK is true if we are parsing clause{@{?Var,...} ...}
            (VarsOK ; has_context(CONTEXT_PARSER_NL_TEMPLATES)),
            get_flvar_struct(First,PreCode)
        ->
            annotation_struct(PreCode,FLTAG,If,FirstCode),
            Stat1 = NO_ERRORS
        ;
            parsing_error(If,INVALID_TAG_DESCRIPTOR,Stat1)
        ),
        (Stat1 == NO_ERRORS
        -> parse_descriptor_aux(FL_DESCRIPTOROP,Rest,If,VarsOK,RestCode,Status)
        ; Status = Stat1
        ).

%% like parse_dbliteral_list/6, but no TNF conversion
parse_dbliteral_list_no_TNF(_Mode,[],_DWS,[],NO_ERRORS) :- !.
parse_dbliteral_list_no_TNF(Mode,[H|T],DWS,CodeList,Status) :-
        !,
        parse_dbliteral(Mode,H,DWS,HCL,S),
        ( S == NO_ERRORS ->
            parse_dbliteral_list_no_TNF(Mode,T,DWS,TCL,Status),
            (Status == NO_ERRORS -> append(HCL,TCL,CodeList)
            ; true
            )
        ; Status = S
        ).

%% FL_IRIs are treated as atoms. We only parse them to check for errors
parse_composer_datatype(Args,If,DWS,Code,Status) :-
        Args = [LiteralIn,TypeIn],
        (flobject_struct(LiteralIn,LitCode) -> Status1=NO_ERRORS
        ; fltransactionalobject_struct(LiteralIn,LitCode) -> Status1=NO_ERRORS
        ; is_curi_canoterm(LiteralIn,Curi) ->
            parse_curi(Curi,_TransFlag,DWS,LitCode,Status1)
        ; is_canolist(LiteralIn,List,[],IdxL) ->
            parse_list(List,[],IdxL,DWS,LitCode,Status1)
        ; parsing_error(If,ERROR_DATATYPE_LITERAL,Status1)
        ),
        (flobject_struct(TypeIn,TypeCode) -> Status2 = NO_ERRORS
        ; parse_body_pathexp(TypeIn,DISALLOW_TRANS,DWS,PURE_PATHEXPS_ONLY,TypeCode,Status2)
        ),
        (Status1 == NO_ERRORS -> Status3 = Status2
        ; Status3 = Status1
        ),
        %% convert to canonical TypeCode/Name
        (flora_get_flatom_name(TypeCode,SyntaxType,TypeName,TypeIdx),
            flora_canonical_type_name(TypeName,CanonTypeName)
            %% flora_get_flatom_name used in reverse direction here
        -> flora_get_flatom_name(TypeCodeCanon,SyntaxType,CanonTypeName,TypeIdx)
        %% Allow terms here if literal is a variable
        ; is_flvar_struct(LitCode,_,_) -> TypeCodeCanon = TypeCode
        ),
        (Status3 == NO_ERRORS ->
            ((is_flstring_struct(LitCode,Literal,Idx)
             %% the flcharlist case occurs in ErgoText because of
             %% the way flobject_struct_aux is defined.
             ; is_flcharlist_struct(LitCode,Literal,Idx)
             )
            ->
                %% special treatment of FL_IRI
                (flora_synonymous_type_names(TypeName,FL_IRI) ->
                    atom_codes(LitAtm,Literal),
                    flora_concat_atoms([FL_IRI_TYPE_PREFIX,LitAtm],IRI_atom),
                    flatom_struct(IRI_atom,If,Code),
                    flora_parse_datatype(DATATYPE(FL_IRI,Literal),If,_,Status)
                %% special treatment of \list
                ; CanonTypeName == FL_LISTTYPE ->
                    atom_codes(LitAtm,Literal),
                    flora_concat_atoms([LitAtm,' .'],LitAtmSrc),
                    flora_read_then_parse_term_string(LitAtmSrc,Code,ErrCodes),
                    (is_fllist_struct(Code) ->
                        memberchk(lexer(Sl),ErrCodes),
                        memberchk(composer(Sc),ErrCodes),
                        memberchk(parser(Sp),ErrCodes),
                        append_lists([Sl,Sc,Sp],Status)
                    ;  parsing_error(Idx,ERROR_LISTTYPE,Status)
                    )
                %% special treatment of \charlist datatype: will be compiled as
                %% FLSTRING. But we keep the distinction until the compiler.
                %% FLSTRINGs are allowed only in the expert mode
                ; CanonTypeName == FL_CHARLIST ->
                    flcharlist_struct(Literal,Idx,Code),
                    Status = NO_ERRORS
                %% special treatment of \symbol datatype: compiled as  atom
                ; CanonTypeName == FL_SYMBOL ->
                    atom_codes(LitAtm,Literal),
                    ('\\issymbol'(LitAtm) ->
                        flatom_struct(LitAtm,Idx, Code),
                        Status = NO_ERRORS
                    ; parsing_error(Idx,ERROR_SYMBOL,Status)
                    )
                ; CanonTypeName == FL_STRING ->
                    atom_codes(LitAtm,Literal),
                    atom_codes(LitAtm,Literal),
                    flora_concat_atoms([FL_STRING_TYPE_PREFIX,LitAtm],StringAtm),
                    flatom_struct(StringAtm,If,Code),
                    Status = NO_ERRORS
                ; CanonTypeName == FL_BOOL ->
                    atom_codes(LitAtm,Literal),
                    (bool_constant(LitAtm,BoolConst) ->
                        flatom_struct(BoolConst,Idx, Code),
                        Status = NO_ERRORS
                    ; parsing_error(Idx,ERROR_BOOLEAN,Status)
                    )
                %% special treatment of \integer, \real, \long, \short
                ; is_number_charlist(CanonTypeName,Literal,Idx,Number,Status) ->
                    flnumber_struct(Number,Idx,Code)
                ; fldatatype_struct(TypeCodeCanon,Literal,Idx,Code),
                    Status = NO_ERRORS
                )
            ; is_fltransactionalstring_struct(LitCode,Literal,Idx) -> 
                (flora_synonymous_type_names(TypeName,FL_IRI)
                -> atom_codes(LitAtm,Literal),
                    flora_concat_atoms([FL_IRI_TYPE_PREFIX,LitAtm],IRI_atom),
                    fltransactionalatom_struct(IRI_atom,If,Code),
                    flora_parse_datatype(DATATYPE(TypeName,Literal),If,_,Status)
                ; fldatatype_struct(TypeCodeCanon,Literal,Idx,Code1),
                    fltransactionalqname_struct(Code1,Code),
                    Status = NO_ERRORS
                )
            ; is_flvar_struct(LitCode,_,Idx) ->
                %% Not treating IRIs specially here: CHECK!
                fldatatype_struct(TypeCodeCanon,LitCode,Idx,Code),
                Status = NO_ERRORS
            %% In datatype lists allow only explicit enumerations, no [...|...]
            ; is_fllist_struct(LitCode, FrontCode, [], Idx)
            %% Not treating IRIs specially here: CHECK!
            ->
                fldatatype_listvalue_struct(FrontCode,FrontCodeListval),
                fldatatype_struct(TypeCodeCanon,FrontCodeListval,Idx,Code),
                Status = NO_ERRORS
            ;
                parsing_error(If,ERROR_DATATYPE_LITERAL,Status)
            )
        ; Status = Status3
        ),
        !.

parse_composer_datatype(_Args,If,_DWS,_Code,Status) :-
        parsing_error(If,ERROR_DATATYPE_NAME,Status).


%% Serves to remove special cases out of the local name
%% Currently converts everything to quoted atoms
fixup_object(Object,Atomobj) :-
        (is_obj_ascii_string_struct(Object)
        -> convert_to_quoted_atomobj(Object,Atomobj)
        ; is_obj_quoted_atom_struct(Object) -> Atomobj = Object
        ; (is_obj_identifier_struct(Object)
          ; is_obj_builtin_identifier_struct(Object,_,_)
          )
        -> %% convert to regular identifier
            get_atom(Object,Atm,Index),
            is_obj_quoted_atom_struct(Atomobj,Atm,Index)
        ; atom(Object) -> is_obj_quoted_atom_struct(Atomobj,Object,NO_INDEX)
        ).

%% Fix for curi
%% To handle CURI structure like prefix#suffix in a canoterm
parse_curi_canoterm(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,Code,Status) :-
        get_atom(Funct,F),
        is_curi_op(F),
        !,
        parse_curi(Args,TransFlag,DWS,Code,Status).

% To handle literal^^sort 
parse_curi([Prefix,LocalName],TransFlag,DWS,Code,Status) :-
        get_index(Prefix,Index_Prefix),
        ( fixup_object(LocalName,LocalName1)
        -> %% localname (part after '#') must be string/quotedAtm/identifier
            get_atom(LocalName1,LocalNameAtm),
            (get_transactionalatom(Prefix,_), TransFlag == ALLOW_TRANS,
                transactional_to_regular(Prefix,PrefixRegular) ->
                get_atom(PrefixRegular,PrefixName),
                Stat1 = NO_ERRORS
            ; get_transactionalatom(Prefix,_), TransFlag == DISALLOW_TRANS
            -> parsing_error(Index_Prefix,ERROR_PATHEXP,Stat1)
            ; get_atom(Prefix,PrefixName) -> Stat1 = NO_ERRORS
            ; parsing_error(Index_Prefix,ERROR_CURI_PREFIX,Stat1)
            )
        ; get_index(LocalName,Index_LocalName),
              parsing_error(Index_LocalName,ERROR_CURI_LOCAL,Stat1)
        ),
        (Stat1 == NO_ERRORS ->
            %% we call with DWS=NULL here, if no explicit WS
            (DWS == NULL -> Mod = FLORA_DEFAULT_WORKSPACE, Stat2 = NO_ERRORS
            ; 
                flora_get_module_from_spec(DWS,_,ModuleAtmCode),
                (is_flvar_struct(ModuleAtmCode,_,_Var_Idx)
                %% If issue an error, then won't be able to write foo#bar@?Mod.
                %% Better assume that current module is used for expansion then.
                %%-> parsing_error(_Var_Idx,INVALID_MOD_CURI,Stat2)
                -> Mod = FLORA_DEFAULT_WORKSPACE, Stat2 = NO_ERRORS
                ; is_flatom_struct(ModuleAtmCode,Mod), Stat2 = NO_ERRORS
                )
            )
        ; Stat2 = NO_ERRORS
        ),
        ( Stat1 == NO_ERRORS, Stat2 == NO_ERRORS,
            ( 
              flora_compiletime_uriprefix_expansion(PrefixName,Def) -> true
            ; flora_runtime_uriprefix_expansion(FLORA_DEFAULT_WORKSPACE,PrefixName,Def) -> true
            ; flora_runtime_uriprefix_expansion(Mod,PrefixName,Def)
            )
        ->  %% expansion found
            Status = NO_ERRORS,
            flora_concat_items([Def,LocalNameAtm],PredName),
            (get_transactionalatom(Prefix,_)
            -> 
                fltransactionalatom_struct(PredName,Index_Prefix,Code)
            ;   flatom_struct(PredName,Index_Prefix,Code)
            )
        ; Stat1 \== NO_ERRORS -> Status = Stat1
        ; Stat2 \== NO_ERRORS -> Status = Stat2
        ;
            parsing_error(Index_Prefix,FILE_NODEFPREFIX,Status)
        ).

merge_status([],[]) :- !.
merge_status([S|Rest],T) :-
        (S == NO_ERRORS -> merge_status(Rest,T)
        ; T = S
        ).

%% arrangements for making include-dependencies
FLORA_INCLUDE_DEPENDENCY_CLOSURE(X,Y) :- FLORA_INCLUDE_DEPENDENCY(X,Y).
FLORA_INCLUDE_DEPENDENCY_CLOSURE(X,Y) :-
        FLORA_INCLUDE_DEPENDENCY(X,Z),
        FLORA_INCLUDE_DEPENDENCY_CLOSURE(Z,Y).

FLORA_PROJECT_DEPENDENCY(X,Y) :- FLORA_INCLUDE_DEPENDENCY_CLOSURE(X,Y).
FLORA_PROJECT_DEPENDENCY(X,Y) :- FLORA_TEMPLATE_DEPENDENCY(X,Y).

%% If arity is supplied then check if the args refer to a reserved
%% builtin of the reserved arity.
%% Else, check if the name is a name of a reserved builtin.
is_disallowed_reserved_builtin(Atom) :- is_disallowed_reserved_builtin(Atom,_).
is_disallowed_reserved_builtin(Atom,Arity) :-
        (number(Arity) ->
            %% wrong builtin arity
            flora_reserved_builtin(Atom,_),
            \+flora_reserved_builtin(Atom,Arity)
        %% disallowed builtin altogether
        ; flora_reserved_builtin(Atom,_)
        ).
%% like is_disallowed_reserved_builtin/2, but also checks the context
%% "restrict_reserved_keywords_arity"
is_contextually_disallowed_reserved_builtin(Atom,Arity) :-
        (number(Arity), has_context(restrict_reserved_keywords_arity) -> 
            %% wrong builtin arity
            flora_reserved_builtin(Atom,_),
            \+flora_reserved_builtin(Atom,Arity)
        %% disallowed builtin altogether
        ; flora_reserved_builtin(Atom,_)
        ).

%% creates a list of length N of elements all of which are Val.
%% list_same_value(+N,+Val,-List)
list_same_value(0,_,[]) :- !.
list_same_value(N,Val,[Val|Tail]) :-
        N > 0,
        N1 is N-1,
        list_same_value(N1,Val,Tail).


get_typed_var_code_from_list([H],Out) :-
        !,
        take_datatype(H,Out).
get_typed_var_code_from_list([H|T],Out) :-
        take_datatype(H,Code),
        get_typed_var_code_from_list(T,TOut),
        flconjunct_struct(Code,TOut,Out).

take_datatype(FLDATATYPE(Sort,Lit,I),FLDATATYPE(Sort,Lit,I)) :- !.
take_datatype(_,NULL).



%% TNF
%% push head-negation through disj and conj
%% we need this in order to know how to parse insert{complex-fact}
%% as well as to know if to issue parsing errors when neg is in the head
dual_quantifier(FL_FORALL,FL_EXISTS).
dual_quantifier(FL_EXISTS,FL_FORALL).
dual_quantifier(FL_EXIST,FL_FORALL).

/******************* pushing neg through in the head *************************/
%%#define TNFDBG

#if exists("extensions/flrparser_TNF.P")
#include "extensions/flrparser_TNF.P"
#endif


%% to_TNF_list(+Headlist,+Index,-TNF,-FlagList,-Status)
to_TNF_list([],_If,[],Flags,NO_ERRORS) :-
        !,
        (var(Flags) -> Flags = []
        ; true
        ).
%% If FlagList==NULL, pass NULL to to_TNF_top to indicate strict error rules
to_TNF_list([H|Rest],If,[TNF|RestTNF],FlagList,Status) :-
        (FlagList==NULL ->
            to_TNF_top(H,If,TNF,NULL,S),
            RestFlags = NULL
        ; to_TNF_top(H,If,TNF,HasOmni,S),
            FlagList = [HasOmni|RestFlags]
        ),
        (S == NO_ERRORS -> to_TNF_list(Rest,If,RestTNF,RestFlags,Status)
        ; Status = S
        ).

%% HasOmni is a Boolean 0/1. Indicates if the result of a push is a disjunction
%%         We perform \/ on HasOmni's, so 0/1 is essential.
%% Note: In Ergo this clause is overridded in flrparser_TNF.P
to_TNF_top(Head,If,TNF,OmniFlag,Status) :-
#ifdef TNFDBG
        DBGOUTLN('***TNF_IN '=OmniFlag+Head),
#endif
        to_TNF(Head,TNF,HasOmni),
        (var(OmniFlag) -> OmniFlag = HasOmni
        ; true
        ),
#ifdef TNFDBG
        DBGOUTLN('***TNF_OUT'=OmniFlag+TNF),
#endif
        (HasOmni == 1 -> parsing_error(If,NO_DISJUNCTION,Status)
        ; Status = NO_ERRORS
        ).


%% HasOmni is a Boolean 0/1. Indicates if the result of a push is a disjunction
%%         We perform \/ on HasOmni's, so 0/1 is essential.
to_TNF(Head,TNF,HasOmni) :-
        is_flneg(Head,Goal,Idx),
        !,
        ( %% a frame: pull conj and disj out, then push
            is_flworkspace(Goal,BareHead,WS),
            is_flobjspec(BareHead,Obj,Spec,_Type)
        ->
            get_frame_object(Obj,WS,RealObj,ObjCode,_),
            push_obj_to_objspec(RealObj,Spec,WS,_,PushedSpec),
            flconjunct_struct(PushedSpec,ObjCode,PushedGoal),
            propagate_neg(PushedGoal,Idx,TNF,HasOmni)
        %% conjunction, disjunction, quant, neg
        ; propagate_neg(Goal,Idx,TNF,HasOmni)
        ).
%% Not a neg -> descend recursively
to_TNF(Head,TNF,HasOmni) :-
        is_flconjunct(Head,L,R),
        !,
        to_TNF(L,LC,HasOmni1),
        to_TNF(R,RC,HasOmni2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(LC,RC,TNF).
to_TNF(Head,TNF,1) :-
        is_fldisjunct(Head,L,R),
        !,
        to_TNF(L,LC,_),
        to_TNF(R,RC,_),
        fldisjunct_struct(LC,RC,TNF).
to_TNF(Head,TNF,HasOmni) :-
        is_flworkspace(Head,BareHead,WS),
        is_flobjspec(BareHead,Obj,Spec,_Type),
        !,
        get_frame_object(Obj,WS,RealObj,ObjCode,HasOmni2),
        push_obj_to_objspec(RealObj,Spec,WS,HasOmni1,PushedSpec),
        flconjunct_struct(PushedSpec,ObjCode,TNF),
        HasOmni is HasOmni1\/HasOmni2.
to_TNF(Head,Head,0).


%% conj(a,b) --> disj(neg a ; neg b)
%% disj(a;b) --> conj(neg a , neg b)
%% propagate_neg(+Head,+Idx,-Result,-Flag)
%% Flag: whether the head-expression contains a disjunction, which isn't allowed
propagate_neg(Goal,Idx,Result,1) :-
        is_flconjunct(Goal,L,R),
        !,
        flneg_struct(L,Idx,NegL),
        flneg_struct(R,Idx,NegR),
        to_TNF(NegL,LC,_),
        to_TNF(NegR,RC,_),
        fldisjunct_struct(LC,RC,Result).
propagate_neg(Goal,Idx,Result,HasOmni) :-
        is_fldisjunct(Goal,L,R),
        !,
        flneg_struct(L,Idx,NegL),
        flneg_struct(R,Idx,NegR),
        to_TNF(NegL,LC,HasOmni1),
        to_TNF(NegR,RC,HasOmni2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(LC,RC,Result).
propagate_neg(Goal,_Idx,Result,HasOmni) :-
        is_flneg(Goal,PGoal,_),
        !,
        to_TNF(PGoal,Result,HasOmni).
propagate_neg(Goal,Idx,Result,0) :-
        flneg_struct(Goal,Idx,Result).

%% Spec is the frame part of an F-molecule.
%% It can be a conjunction or a disjunction. Individual atomic specs can
%% also have neg. No naf or quantifiers, since this is in the head
%% Does the following:
%%    Obj,conj(spec1,spec2),WS --> conj(Obj[spec1]@WS,Obj[Spec2]@WS)
%%    Obj,disj(spec1,spec2),WS --> disj(Obj[spec1]@WS,Obj[Spec2]@WS)
%%    Otherwise: Obj,spec,WS   --> Obj[spec]@WS
%% HasOmni is a Boolean 0/1. Indicates if the result of a push is a disjunction
%%         We perform \/ on HasOmni's, so 0/1 is essential.
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        is_flobjspec(Obj,ObjObj,Spec2,_ObjType),
        !,
        get_frame_object(ObjObj,WS,RealObj,ObjCode,HasOmni3),
        push_obj_to_objspec(RealObj,Spec,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,ObjCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        is_flconjunct(Spec,L,R),
        !,
        push_obj_to_objspec(Obj,L,WS,HasOmni1,GL),
        push_obj_to_objspec(Obj,R,WS,HasOmni2,GR),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(GL,GR,Goal).
push_obj_to_objspec(Obj,Spec,WS,1,Goal) :-
        is_fldisjunct(Spec,L,R),
        !,
        push_obj_to_objspec(Obj,L,WS,_,GL),
        push_obj_to_objspec(Obj,R,WS,_,GR),
        fldisjunct_struct(GL,GR,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        is_flneg(Spec,Pspec,Idx),
        !,
        push_obj_to_objspec(Obj,Pspec,WS,_,PushedGoal),
        propagate_neg(PushedGoal,Idx,Goal,HasOmni).

%% METH,  a[meth]
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[m:n]
        is_flmethspec(Spec,Meth,SpecType),
        is_flbirelate(Meth,_Obj1,_RelType,_Obj2),
        !,
        get_frame_object(Meth,WS,MethObj,MethCode,HasOmni1),
        flmethspec_struct(MethObj,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni2,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,MethCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[obj2[...]]
        is_flmethspec(Spec,Meth,SpecType),
        is_flobjspec(Meth,Obj2,Spec2,_MType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        flmethspec_struct(RealObj2,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).
/*
%% TRANSPEC
%% The cases of obj[%m:n] and obj[%obj2[...]] are invalid:
%% since %m:n is invalid and so is %obj[...]
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[%m:n]
        is_fltranspec(Spec,Meth,SpecType),
        is_flbirelate(Meth,_Obj1,_RelType,_Obj2),
        !,
        get_frame_object(Meth,WS,MethObj,MethCode,HasOmni1),
        (transactional_to_regular(MethObj,RegMethObj) -> true
        ; RegMethObj = MethObj
        ),
        fltranspec_struct(RegMethObj,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni2,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,MethCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[%obj2[...]]
        is_fltranspec(Spec,Meth,SpecType),
        is_flobjspec(Meth,Obj2,Spec2,_MType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        (transactional_to_regular(RealObj2,RegRealObj2) -> true
        ; RegRealObj2 = RealObj2
        ),
        fltranspec_struct(RegRealObj2,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RegRealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).
*/

%% BOOLSIG, a[=>meth]
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[=>m:n]
        is_flboolsig(Spec,Meth,Arrow,SpecType),
        is_flbirelate(Meth,_Obj1,_RelType,_Obj2),
        !,
        get_frame_object(Meth,WS,MethObj,MethCode,HasOmni1),
        flboolsig_struct(MethObj,Arrow,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni2,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,MethCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[=>obj2[...]]
        is_flboolsig(Spec,Meth,Arrow,SpecType),
        is_flobjspec(Meth,Obj2,Spec2,_MType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        flboolsig_struct(RealObj2,Arrow,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).

%% FLTRANSIG, a[=>%meth]
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[=>%m:n]
        is_fltransig(Spec,Meth,Arrow,SpecType),
        is_flbirelate(Meth,_Obj1,_RelType,_Obj2),
        !,
        get_frame_object(Meth,WS,MethObj,MethCode,HasOmni1),
        fltransig_struct(MethObj,Arrow,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni2,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,MethCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% boolean frame component METH obj[=>%obj2[...]]
        is_fltransig(Spec,Meth,Arrow,SpecType),
        is_flobjspec(Meth,Obj2,Spec2,_MType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        fltransig_struct(RealObj2,Arrow,SpecType,Meth2),
        push_obj_to_objspec(Obj,Meth2,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).

push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% att-val pair MVD: obj[attr->obj2[...]]
        is_flmvdattspec(Spec,Att,Arrow,ValList,SpecType),
        !,
        get_frame_object(Att,WS,RealAtt,AttCode,HasOmni2),
        push_mvdattspeclist(ValList,Obj,RealAtt,Arrow,SpecType,WS,HasOmni1,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,AttCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% att-val pair MVDSIG: obj[attr=>obj2[...]]
        %% head occurrences of this seem to be only in insert{...}
        is_flsigattspec(Spec,Att,Arrow,Val,SpecType),
        !,
        get_frame_object(Att,WS,RealAtt,AttCode,HasOmni2),
        push_sigattspec(Val,Obj,RealAtt,Arrow,SpecType,WS,HasOmni1,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,AttCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,HasOmni,Goal) :-
        %% att-val pair MVDSIG/iMVDSIG: obj[attr{...}=>obj2[...]]
        is_flsigattconspec(Spec,Att,Constr,Arrow,Val,SpecType),
        !,
        get_frame_object(Att,WS,RealAtt,AttCode,HasOmni2),
        push_sigattconspec(Val,Obj,RealAtt,Constr,Arrow,SpecType,WS,HasOmni1,Goal1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,AttCode,Goal).
push_obj_to_objspec(Obj,Spec,WS,0,Goal) :-
        get_spectype(Spec,Type),
        flobjspec_struct(Obj,Spec,Type,Frame),
        flmodule_struct(FLORAUSERMOD,Frame,WS,Goal).

%% push_mvdattspeclist/8
%% push_mvdattspec/8
push_mvdattspeclist([],Obj,Att,Arrow,Type,WS,0,Goal) :-
        !,
        %% also the case of a[b->{}]
        flmvdattspec_struct(Att,Arrow,[],Type,AttValSpec),
        flobjspec_struct(Obj,AttValSpec,Type,Frame),
        flmodule_struct(FLORAUSERMOD,Frame,WS,Goal).
push_mvdattspeclist([Val],Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        !,
        push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal).
push_mvdattspeclist([Val|List],Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni1,Goal1),
        push_mvdattspeclist(List,Obj,Att,Arrow,Type,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,Goal2,Goal).

push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        %% Obj[Att->Val] here Val is a single spec, not a list
        is_flobjspec(Val,Obj2,Spec2,_ValType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        flmvdattspec_struct(Att,Arrow,[RealObj2],Type,AttSpec),
        push_obj_to_objspec(Obj,AttSpec,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).
push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,1,Goal) :-
        is_fldisjunct(Val,V1,V2),
        !,
        push_mvdattspec(V1,Obj,Att,Arrow,Type,WS,_,Goal1),
        push_mvdattspec(V2,Obj,Att,Arrow,Type,WS,_,Goal2),
        fldisjunct_struct(Goal1,Goal2,Goal).
push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        is_flconjunct(Val,V1,V2),
        !,
        push_mvdattspec(V1,Obj,Att,Arrow,Type,WS,HasOmni1,Goal1),
        push_mvdattspec(V2,Obj,Att,Arrow,Type,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,Goal2,Goal).
push_mvdattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        get_frame_object(Val,WS,RealVal,ValCode,HasOmni),
        flmvdattspec_struct(Att,Arrow,[RealVal],Type,AttValSpec),
        flobjspec_struct(Obj,AttValSpec,Type,Frame),
        flmodule_struct(FLORAUSERMOD,Frame,WS,Goal1),
        flconjunct_struct(Goal1,ValCode,Goal).

%% push_sigattspec/8
push_sigattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        %% Obj[Att=> Val] here Val is a single object, not a list
        is_flobjspec(Val,Obj2,Spec2,_ValType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        flsigattspec_struct(Att,Arrow,RealObj2,Type,AttSpec),
        push_obj_to_objspec(Obj,AttSpec,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).
push_sigattspec(Val,Obj,Att,Arrow,Type,WS,1,Goal) :-
        is_fldisjunct(Val,V1,V2),
        !,
        push_sigattspec(V1,Obj,Att,Arrow,Type,WS,_,Goal1),
        push_sigattspec(V2,Obj,Att,Arrow,Type,WS,_,Goal2),
        fldisjunct_struct(Goal1,Goal2,Goal).
push_sigattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        is_flconjunct(Val,V1,V2),
        !,
        push_sigattspec(V1,Obj,Att,Arrow,Type,WS,HasOmni1,Goal1),
        push_sigattspec(V2,Obj,Att,Arrow,Type,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,Goal2,Goal).
push_sigattspec(Val,Obj,Att,Arrow,Type,WS,HasOmni,Goal) :-
        get_frame_object(Val,WS,RealVal,ValCode,HasOmni),
        flsigattspec_struct(Att,Arrow,RealVal,Type,AttValSpec),
        flobjspec_struct(Obj,AttValSpec,Type,Frame),
        flmodule_struct(FLORAUSERMOD,Frame,WS,Goal1),
        flconjunct_struct(Goal1,ValCode,Goal).

%% push_sigattconspec/8
push_sigattconspec(Val,Obj,Att,Constr,Arrow,Type,WS,HasOmni,Goal) :-
        %% Obj[Att=> Val] here Val is a single object, not a list
        is_flobjspec(Val,Obj2,Spec2,_ValType),
        !,
        get_frame_object(Obj2,WS,RealObj2,Obj2Code,HasOmni3),
        flsigattconspec_struct(Att,Constr,Arrow,RealObj2,Type,AttSpec),
        push_obj_to_objspec(Obj,AttSpec,WS,HasOmni1,Goal1),
        push_obj_to_objspec(RealObj2,Spec2,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2\/HasOmni3,
        flconjunct_struct(Goal1,Goal2,Goal3),
        flconjunct_struct(Goal3,Obj2Code,Goal).
push_sigattconspec(Val,Obj,Att,Constr,Arrow,Type,WS,1,Goal) :-
        is_fldisjunct(Val,V1,V2),
        !,
        push_sigattconspec(V1,Obj,Att,Constr,Arrow,Type,WS,_,Goal1),
        push_sigattconspec(V2,Obj,Att,Constr,Arrow,Type,WS,_,Goal2),
        fldisjunct_struct(Goal1,Goal2,Goal).
push_sigattconspec(Val,Obj,Att,Constr,Arrow,Type,WS,HasOmni,Goal) :-
        is_flconjunct(Val,V1,V2),
        !,
        push_sigattconspec(V1,Obj,Att,Constr,Arrow,Type,WS,HasOmni1,Goal1),
        push_sigattconspec(V2,Obj,Att,Constr,Arrow,Type,WS,HasOmni2,Goal2),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Goal1,Goal2,Goal).
push_sigattconspec(Val,Obj,Att,Constr,Arrow,Type,WS,HasOmni,Goal) :-
        get_frame_object(Val,WS,RealVal,ValCode,HasOmni),
        flsigattconspec_struct(Att,Constr,Arrow,RealVal,Type,AttValSpec),
        flobjspec_struct(Obj,AttValSpec,Type,Frame),
        flmodule_struct(FLORAUSERMOD,Frame,WS,Goal1),
        flconjunct_struct(Goal1,ValCode,Goal).

%% get_frame_object/5
%% If frame or flbirelate, extract pure object and
%% return either the object spec or NULL
get_frame_object(Frame,WS,Obj,Code,HasOmni) :-
        is_flobjspec(Frame,Obj1,Spec,Type),
        !,
        get_frame_object(Obj1,WS,Obj,Code2,HasOmni2),
        flobjspec_struct(Obj,Spec,Type,SpecCode),
        flmodule_struct(FLORAUSERMOD,SpecCode,WS,SpecCodeWS),
        to_TNF(SpecCodeWS,Code1,HasOmni1),
        HasOmni is HasOmni1\/HasOmni2,
        flconjunct_struct(Code1,Code2,Code).
%% HasOmni=0
get_frame_object(Frame,WS,Obj1,Code,0) :-
        is_flbirelate(Frame,Obj1,_RelType,_Obj2),
        !,
        flmodule_struct(FLORAUSERMOD,Frame,WS,Code).
get_frame_object(Frame,_DWS,Obj,Code,HasOmni) :-
        is_flworkspace(Frame,Bare,WS),
        !,
        get_frame_object(Bare,WS,Obj,Code1,HasOmni),
        flmodule_struct(FLORAUSERMOD,Code1,WS,Code).
%% HasOmni=0
get_frame_object(Frame,_,Frame,NULL,0).

%%flconjunct2list(Conjunct,CodeList) :- flconjunct2list(Conjunct,CodeList,[]).
flconjunct2list(ConjunctCode,CodeList,ListTail) :-
        is_flconjunct(ConjunctCode,C1,C2),
        !,
        flconjunct2list(C1,CodeList,T1),
        flconjunct2list(C2,T1,ListTail).
flconjunct2list(Code,[Code|ListTail],ListTail) :- !.

%% takes a list and replaces flconjuncts with lists
flconjunct_list2list(List,Result) :- flconjunct_list2list(List,Result,[]).
flconjunct_list2list([],T,T) :- !.
flconjunct_list2list([L|List],Result,Tail) :-
        !,
        flconjunct2list(L,Result,Tail1),
        flconjunct_list2list(List,Tail1,Tail).
flconjunct_list2list(Elt,[Elt|ListTail],ListTail) :- !.
%% these are for testing
%%:- export flconjunct_list2list/2.
%%:- export flconjunct2list/2.

/******************************************************************************
**                     The Lloyd-Topor transform
**
**    Stage 1:
**      neg-and       ->  or-neg
**      neg-or        ->  and-neg
**      neg-exists    ->  forall-neg
**      neg-forall    ->  exists-neg
**      neg neg       ->  nothing: cancels out 
**      X==>Y         ->  neg X or Y  (this is done earlier, part of parsing)
**
**      naf-and       ->  or-naf  (if the conjuncts don't share variables)
**      naf-or        ->  and-naf
**      naf-exists    ->  forall-naf
**      naf-forall    ->  exists-naf
**      naf naf       ->  nothing: cancels out 
**      naf ifthen(X,Y)       ->  X , naf Y
**      naf ifthenelse(X,Y,Z) ->  (X, naf Y) or (naf X, naf Z)
**
**    Stage 2:
**      forall                  -> naf-exists-naf
**                                 then push the inner naf
**      exists (not naf(exists...) -> rename quantified vars and drop the exists
**
**    Stage 3:
**      neg naf                 -> error, if left at the end of the transform
**      This stage is done by the compiler, not here
**      There are many other cases when neg-something is an error. For instance,
**      builtins, delay quantifiers
*******************************************************************************/

%%#define LTDBG

%% TODO: Add Status argument to to_LT and push_quantifiers
%%       so that we'll be able to issue warnings when a quant variable
%%       is not in formula. The compiler does it but only for the quantifiers
%%       that survive push_quantifiers, so need to do it here as well.
to_LT(In,Out) :-
        push_negations(In,PushedNeg),
#ifdef LTDBG
        DBGOUTLN(pushedNeg=PushedNeg),
#endif
        push_quantifiers(PushedNeg,PushedQuantifier),
#ifdef LTDBG
        DBGOUTLN(pushQuant=PushedQuantifier),
#endif
        convert_forall(PushedQuantifier,Out),
#ifdef LTDBG
        DBGOUTLN(converted=Out),
#endif
        !.
%% push_negations/2
push_negations(In,Pushed) :-
        is_flconjunct(In,L,R),
        !,
        push_negations(L,LP),
        push_negations(R,RP),
        flconjunct_struct(LP,RP,Pushed).
push_negations(In,Pushed) :-
        is_fldisjunct(In,L,R),
        !,
        push_negations(L,LP),
        push_negations(R,RP),
        fldisjunct_struct(LP,RP,Pushed).
push_negations(In,Pushed) :-
        is_fllogicquantifier(In,Quant,Vars,VarsCode,Formula,Idx),
        !,
        push_negations(Formula,FP),
        flquantifier_struct(Quant,Vars,VarsCode,FP,Idx,Pushed).
push_negations(In,Pushed) :-
        is_flneg(In,Goal,Idx),
        !,
        push_neg(Goal,Idx,Pushed).
push_negations(In,Pushed) :-
        is_flrulelognaf(In,Goal),
        !,
        push_naf(Goal,Pushed).
push_negations(In,In).


%% push_neg/3
push_neg(Goal,Idx,Pushed) :-
        is_flconjunct(Goal,L,R),
        !,
        push_neg(L,Idx,LP),
        push_neg(R,Idx,RP),
        fldisjunct_struct(LP,RP,Pushed).
push_neg(Goal,Idx,Pushed) :-
        is_fldisjunct(Goal,L,R),
        !,
        push_neg(L,Idx,LP),
        push_neg(R,Idx,RP),
        flconjunct_struct(LP,RP,Pushed).
push_neg(Goal,Idx,Pushed) :-
        is_fllogicquantifier(Goal,Quant,Vars,VarsCode,Formula,Idx2),
        !,
        push_neg(Formula,Idx,FP),
        dual_quantifier(Quant,DualQuant),
        flquantifier_struct(DualQuant,Vars,VarsCode,FP,Idx2,Pushed).
push_neg(Goal,_Idx,Pushed) :-
        is_flneg(Goal,PosGoal,_),
        !,
        %% double-neg
        push_negations(PosGoal,Pushed).
push_neg(Goal,Idx,Pushed) :-
        is_flrulelognaf(Goal,_),
        !,
        push_negations(Goal,Pushed1),
        (Goal = Pushed1 -> flneg_struct(Goal,Idx,Pushed)
        ; push_neg(Pushed1,Idx,Pushed)
        ).
%% basis of recursion
push_neg(Goal,Idx,Pushed) :-
        flneg_struct(Goal,Idx,Pushed).

%% push_naf/2
push_naf(Goal,Pushed) :-
        %% if conjunction with common free vars then don't push
        is_flconjunct(Goal,L,R),
        flrcompiler:collect_flvar_names(L,VL),
        flrcompiler:collect_flvar_names(R,VR),
        intersect(VL,VR,CommonV),
        %% delete do not care vars
        list_difference_eq(CommonV,[FL_ANON_VAR],CommonVClean),
        CommonVClean \= [],
        !,
        flrulelognaf_struct(Goal,Pushed).
push_naf(Goal,Pushed) :-
        is_flconjunct(Goal,L,R),
        !,
        push_naf(L,LP),
        push_naf(R,RP),
        fldisjunct_struct(LP,RP,Pushed).
push_naf(Goal,Pushed) :-
        is_fldisjunct(Goal,L,R),
        !,
        push_naf(L,LP),
        push_naf(R,RP),
        flconjunct_struct(LP,RP,Pushed).

/*
** Push past quantifiers.
** This is NOT redundant.
** Examples:
**   p({1,2}).
**   q({1,2,3}).
**   ?- \naf exists(?X)^(\naf(((\naf p(?X)) \or q(?X)))).
**
**   Push though exists: forall(?X)^(p(?X) ~~>q(?X))  -- true
**   No push: \naf exists(?X)^(p(?X) \and \naf q(?X)) -- undef due to \naf q(?X)
*/
push_naf(Goal,Pushed) :-
        is_fllogicquantifier(Goal,Quant,Vars,VarsCode,Formula,Idx),
        !,
        push_naf(Formula,FP),
        dual_quantifier(Quant,DualQuant),
        flquantifier_struct(DualQuant,Vars,VarsCode,FP,Idx,Pushed).

push_naf(Goal,Pushed) :-
        is_flneg(Goal,_,_),
        !,
        push_negations(Goal,Pushed1),
        (Goal = Pushed1 -> flrulelognaf_struct(Goal,Pushed)
        ; push_naf(Pushed1,Pushed)
        ).
push_naf(Goal,Pushed) :-
        is_flifthen(Goal,Cond,Then),
        !,
        push_naf(Then,ThenP),
        flconjunct_struct(Cond,ThenP,Pushed).
push_naf(Goal,Pushed) :-
        is_flifthenelse(Goal,Cond,Then,Else),
        !,
        push_naf(Cond,CondP),
        push_naf(Then,ThenP),
        push_naf(Else,ElseP),
        flconjunct_struct(Cond,ThenP,PushedThen),
        flconjunct_struct(CondP,ElseP,PushedElse),
        fldisjunct_struct(PushedThen,PushedElse,Pushed).
push_naf(Goal,Pushed) :-
        %% double-naf
        is_flrulelognaf(Goal,PosGoal),
        !,
        push_negations(PosGoal,Pushed).
push_naf(Goal,Pushed) :-
        %% basis of recursion
        flrulelognaf_struct(Goal,Pushed).

%% convert_forall/2
convert_forall(Goal,Out) :-
        is_fllogicquantifier(Goal,Quant,Vars,VarsCode,Formula,Idx),
        is_universalquant(Quant),
        !,
        push_naf(Formula,Pushed),
        convert_forall(Pushed,Converted),
        flquantifier_struct(FL_EXISTS,Vars,VarsCode,Converted,Idx,EFormula),
        flrulelognaf_struct(EFormula,Out).
convert_forall(Goal,Out) :-
        is_fllogicquantifier(Goal,Quant,Vars,VarsCode,Formula,Idx),
        is_existentialquant(Quant),
        !,
        convert_forall(Formula,Converted),
        flquantifier_struct(Quant,Vars,VarsCode,Converted,Idx,Out).

convert_forall(Goal,Out) :-
        is_flconjunct(Goal,L,R),
        !,
        convert_forall(L,LC),
        convert_forall(R,RC),
        flconjunct_struct(LC,RC,Out).
convert_forall(Goal,Out) :-
        is_fldisjunct(Goal,L,R),
        !,
        convert_forall(L,LC),
        convert_forall(R,RC),
        fldisjunct_struct(LC,RC,Out).
%% neg, naf should be fully pushed already, so no need to consider those cases
convert_forall(Goal,Goal).

/*******************************************************************************
    Push exists past OR; forall past AND
    Push exists past AND, if only one side is affected; same for forall past OR
*******************************************************************************/
%% push_quantifiers affects the test cases 1-4 in lt3.flr
push_quantifiers(Goal,Out) :-
        is_fldisjunct(Goal,L,R),
        !,
        push_quantifiers(L,LC),
        push_quantifiers(R,RC),
        fldisjunct_struct(LC,RC,Out).
push_quantifiers(Goal,Out) :-
        is_flconjunct(Goal,L,R),
        !,
        push_quantifiers(L,LC),
        push_quantifiers(R,RC),
        flconjunct_struct(LC,RC,Out).
push_quantifiers(Goal,Out) :-
        is_fllogicquantifier(Goal,Quant,QuantVarNs,VarsCode,Formula,Idx),
        is_existentialquant(Quant),
        !,
        (is_fldisjunct(Formula,Left,Right) ->
            push_exists_past_or(Left,Right,QuantVarNs,VarsCode,Idx,Out)
        ; is_flconjunct(Formula,Left,Right) ->
            push_exists_past_and(Left,Right,QuantVarNs,VarsCode,Idx,Out)
        ; is_flifthen(Formula,Cond,Then) ->
            collect_flvar_names(Cond,CondVarNames),
            collect_flvar_names(Then,ThenVarNames),
            %% If QuantVarNs are not disjoint from both Cond vars and Then vars
            %% Then do not push exists().
            (intersect(QuantVarNs,ThenVarNames,ThenQuantVarNs),
                intersect(QuantVarNs,CondVarNames,CondQuantVarNs),
                CondQuantVarNs \== [], ThenQuantVarNs \== []
            -> Out = Goal
            ;
                push_naf(Cond,CondP),
                push_exists_past_or(CondP,Then,QuantVarNs,VarsCode,Idx,Out)
            )
        ; push_quantifiers(Formula,PushedFormula),
            flquantifier_struct(Quant,QuantVarNs,VarsCode,PushedFormula,Idx,OutPre),
            %% if Formula was pushed, try to push Quant(PushedFormula) again
            ( \+(\+(Formula=PushedFormula)) -> Out = OutPre
            ; push_quantifiers(OutPre,Out)
            )
        ).
push_quantifiers(Goal,Out) :-
        is_fllogicquantifier(Goal,Quant,QuantVarNs,VarsCode,Formula,Idx),
        is_universalquant(Quant),
        !,
        (is_fldisjunct(Formula,Left,Right) ->
            push_forall_past_or(Left,Right,QuantVarNs,VarsCode,Idx,Out)
        ; is_flconjunct(Formula,Left,Right) ->
            push_forall_past_and(Left,Right,QuantVarNs,VarsCode,Idx,Out)
        ; is_flifthen(Formula,Cond,Then) ->
            push_naf(Cond,CondP),
            push_forall_past_or(CondP,Then,QuantVarNs,VarsCode,Idx,Out)
        ; push_quantifiers(Formula,PushedFormula),
            flquantifier_struct(Quant,QuantVarNs,VarsCode,PushedFormula,Idx,OutPre),
            %% if Formula was pushed, try to push Quant(PushedFormula) again
            ( \+(\+(Formula=PushedFormula)) -> Out = OutPre
            ; push_quantifiers(OutPre,Out)
            )
        ).
push_quantifiers(Goal,Goal).

/*****************************************************************************
    Push exists past AND
    Push exists past OR, if only one side is affected
*****************************************************************************/
%% no-op if can't push
push_exists_past_and(Left,Right,QuantVarNs,VarsCode,Idx,Pushed) :-
        collect_flvar_names(Left,LeftVarNames),
        list_difference_eq(QuantVarNs,LeftVarNames,RightQuantNs),
        (((RightQuantNs \== [],QuantVarNs \== FL_STAR) ; LeftVarNames==[]) ->
            flquantifier_struct(FL_EXISTS,RightQuantNs,VarsCode,Right,Idx,RightPushed1)
        ; RightPushed1 = Right
        ),
        collect_flvar_names(Right,RightVarNames),
        list_difference_eq(QuantVarNs,RightVarNames,LeftQuantNs),
        (((LeftQuantNs \== [],QuantVarNs \== FL_STAR) ; RightVarNames==[]) ->
            flquantifier_struct(FL_EXISTS,LeftQuantNs,VarsCode,Left,Idx,LeftPushed1)
        ; LeftPushed1 = Left
        ),
        push_quantifiers(LeftPushed1,LeftPushed),
        push_quantifiers(RightPushed1,RightPushed),
        flconjunct_struct(LeftPushed,RightPushed,PushedPre),
        list_difference_eq(QuantVarNs,RightQuantNs,QuantSansRightOnly),
        list_difference_eq(QuantSansRightOnly,LeftQuantNs,CommonQuantNs),
        (CommonQuantNs == [] -> Pushed = PushedPre
        ; flquantifier_struct(FL_EXISTS,CommonQuantNs,VarsCode,PushedPre,Idx,Pushed)
        ).

push_exists_past_or(Left,Right,QuantVarNs,VarsCode,Idx,Pushed) :-
        (QuantVarNs==FL_STAR ->
            LeftQuantVarNs = FL_STAR,
            RightQuantVarNs = FL_STAR
        ; collect_flvar_names(Left,LeftVarNames),
            collect_flvar_names(Right,RightVarNames),
            intersect(QuantVarNs,LeftVarNames,LeftQuantVarNs),
            intersect(QuantVarNs,RightVarNames,RightQuantVarNs)
        ),
        (LeftQuantVarNs==[] -> LeftPushed1 = Left
        ; flquantifier_struct(FL_EXISTS,LeftQuantVarNs,VarsCode,Left,Idx,LeftPushed1)
        ),
        (RightQuantVarNs==[] -> RightPushed1 = Right
        ; flquantifier_struct(FL_EXISTS,RightQuantVarNs,VarsCode,Right,Idx,RightPushed1)
        ),
        push_quantifiers(LeftPushed1,LeftPushed),
        push_quantifiers(RightPushed1,RightPushed),
        fldisjunct_struct(LeftPushed,RightPushed,Pushed).

/*****************************************************************************
    Push forall past AND
    Push forall past OR, if only one side is affected

    The question if to push something like
        forall(?X)^(r(?X,?Y) ~~> q(?Y,?Z))
    where ?Y is a common free var. The problem here is that forall (\naf) will
    disconnect ?Y in premise and consequent. But note that
        forall(?Y)^forall(?X)^(r(?X,?Y) ~~> q(?Y,?Z))
    is ok, as it results in 
        \naf (r(?X,?Y), \naf q(?Y,?Z))
    When the inner expression is evaluated, ?Y is bound positively in r/2, so
    it is not disconnected from q/2.
*****************************************************************************/
%% no-op if can't push
push_forall_past_or(Left,Right,QuantVarNs,VarsCode,Idx,Pushed) :-
        collect_flvar_names(Left,LeftVarNames),
        collect_flvar_names(Right,RightVarNames),
        list_difference_eq(QuantVarNs,LeftVarNames,RightQuantNs),
        list_difference_eq(QuantVarNs,RightVarNames,LeftQuantNs),
        (((RightQuantNs \== [],QuantVarNs \== FL_STAR) ; LeftVarNames==[]),
            \+ is_delayed_builtin_literal(Left)
        ->
            flquantifier_struct(FL_FORALL,RightQuantNs,VarsCode,Right,Idx,RightPushed1),
            RightChanged=true
        ; RightPushed1 = Right, RightChanged=fail
        ),
        (((LeftQuantNs \== [],QuantVarNs \== FL_STAR) ; RightVarNames==[]),
            \+ is_delayed_builtin_literal(Right)
         ->
            flquantifier_struct(FL_FORALL,LeftQuantNs,VarsCode,Left,Idx,LeftPushed1),
            LeftChanged=true
        ; LeftPushed1 = Left, LeftChanged=false
        ),
        RightOrLeftChanged = (RightChanged ; LeftChanged),
        push_quantifiers(LeftPushed1,LeftPushed),
        push_quantifiers(RightPushed1,RightPushed),
        fldisjunct_struct(LeftPushed,RightPushed,PushedPre),
        list_difference_eq(QuantVarNs,RightQuantNs,QuantSansRightOnly),
        (RightOrLeftChanged ->
            list_difference_eq(QuantSansRightOnly,LeftQuantNs,CommonQuantNs)
        ; CommonQuantNs = QuantVarNs
        ),
        (CommonQuantNs == [], RightOrLeftChanged
        -> Pushed = PushedPre
        ; flquantifier_struct(FL_FORALL,CommonQuantNs,VarsCode,PushedPre,Idx,Pushed)
        ).

push_forall_past_and(Left,Right,QuantVarNs,VarsCode,Idx,Pushed) :-
        (QuantVarNs==FL_STAR ->
            LeftQuantVarNs = FL_STAR,
            RightQuantVarNs = FL_STAR
        ; collect_flvar_names(Left,LeftVarNames),
            collect_flvar_names(Right,RightVarNames),
            intersect(QuantVarNs,LeftVarNames,LeftQuantVarNs),
            intersect(QuantVarNs,RightVarNames,RightQuantVarNs)
        ),
        (LeftQuantVarNs==[] -> LeftPushed1 = Left
        ; flquantifier_struct(FL_FORALL,LeftQuantVarNs,VarsCode,Left,Idx,LeftPushed1)
        ),
        (RightQuantVarNs==[] -> RightPushed1 = Right
        ; flquantifier_struct(FL_FORALL,RightQuantVarNs,VarsCode,Right,Idx,RightPushed1)
        ),
        push_quantifiers(LeftPushed1,LeftPushed),
        push_quantifiers(RightPushed1,RightPushed),
        flconjunct_struct(LeftPushed,RightPushed,Pushed).


%%% flwrite: Writes parsed terms in an easier to understand form.
%%% Does only minimal job, since this is used only to simplify debugging
%%% transforms and testing. Doesn't try to faithfully reconstruct Flora-2 syntax

:- export flwriteline/1, flwriteline_stderr/1, flwriteline_warn/1.
:- export
        is_ergotext_word_connector/1,
        is_prefixed_with_ergotext_word_connector/2.
is_ergotext_word_connector(Arg) :-
        is_flatom_struct(Arg,ERGOTEXT_WORD_CONNECTOR_FILLER).
is_prefixed_with_ergotext_word_connector(Arg,Second) :-
        is_flterm(Arg,Func,2,[First,Second]),
        is_flatom_struct(Func,FL_COMMA), 
        is_flatom_struct(First,ERGOTEXT_WORD_CONNECTOR_FILLER).

flwriteline(ParserTerm) :-
        flwrite(ParserTerm),
        nl.

flwrite(ParserTerm) :-
        has_context(CONTEXT_PARSER_NL_TEMPLATES),
        var(ParserTerm),
        !,
        write(ParserTerm).
flwrite(ParserTerm) :-
        %% we get variables here if parse error
        var(ParserTerm),
        !,
        write('Parse error').
flwrite(ParserTerm) :-
        is_flconjunct(ParserTerm,L,R),
        !,
        write('('),
        flwrite(L),
        write(', '),
        flwrite(R),
        write(')').
flwrite(ParserTerm) :-
        is_fldisjunct(ParserTerm,L,R),
        !,
        write('('),
        flwrite(L),
        write('; '),
        flwrite(R),
        write(')').
flwrite(ParserTerm) :-
        is_fllogicquantifier(ParserTerm,Quant,Vars,_VarsCode,Formula,_Idx),
        !,
        write(Quant),
        write('('),
        flora_write_varnames(Vars),
        write(')'),
        write('^('),
        flwrite(Formula),
        write(')').
flwrite(ParserTerm) :-
        is_fldelayquant(ParserTerm,Quant,Condition,Formula,_Idx),
        !,
        write(Quant),
        write('('),
        flwrite(Condition),
        write(')'),
        write('^('),
        flwrite(Formula),
        write(')').
flwrite(ParserTerm) :-
        is_flrulelognaf(ParserTerm,Pos),
        !,
        write('\\naf '),
        flwrite(Pos).
flwrite(ParserTerm) :-
        is_flneg(ParserTerm,Pos,_Idx),
        !,
        write('\\neg '),
        flwrite(Pos).
flwrite(ParserTerm) :-
        is_flifthenelse(ParserTerm,Cond,Then,Else),
        !,
        write('If ('),
        flwrite(Cond),
        write(') Then ('),
        flwrite(Then),
        write(') Else ('),
        flwrite(Else),
        write(')').
flwrite(ParserTerm) :-
        is_flifthen(ParserTerm,Cond,Then),
        !,
        write('If ('),
        flwrite(Cond),
        write(') Then ('),
        flwrite(Then),
        write(')').
flwrite(ParserTerm) :-
        is_flworkspace(ParserTerm,Formula,WS),
        !,
        flwrite(Formula),
        (WS==FL_THISMODULE -> true
        ; write('@'),
            flwrite(WS)
        ).
flwrite(ParserTerm) :-
        is_flruleworkspace(ParserTerm,Formula,WS),
        !,
        flwrite(Formula),
        (WS==FL_THISMODULE -> true
        ; write('@'),
            flwrite(WS)
        ).
/*
flwrite(ParserTerm) :-
        %% flsetarg is now done via SETARGATTRIBUTE
        is_flsetarg(ParserTerm,List,_),
        !,
        write('{'),
        flwritelist(List),
        write('}').
*/
flwrite(ParserTerm) :-
        is_flarith(ParserTerm,Term),
        !,
        flwrite(Term).
flwrite(ParserTerm) :-
        is_flannotated_construct(ParserTerm,DescriptorList,Rule),
        !,
        flatten(DescriptorList,Descriptor),
        flwritelist_noseparator(Descriptor),
        write(' '),
        flwrite(Rule).
flwrite(ParserTerm) :-
        is_fldescriptor(ParserTerm,Descr,Type,_),
        !,
        flwrite_descriptor(Type,Descr).
flwrite(ParserTerm) :-
        (is_fldelayedliteral(ParserTerm,Op,Args)
        ; is_fldelayedliteral(ParserTerm,Op,Args,_)
        ),
        !,
        is_fllist_struct(Args,ArgList,_Tail,_Idx),
        length(ArgList,N),
        flterm_struct(Op,N,ArgList,Term),
        flwrite(Term).
flwrite(ParserTerm) :-
        is_flobjspec(ParserTerm,Obj,Spec,Type),
        !,
        flwrite(Obj),
        (Type == NONINHERITABLE -> write('[')
        ; write('[|')
        ),
        flwrite(Spec),
        (Type == NONINHERITABLE -> write(']')
        ; write('|]')
        ).
flwrite(ParserTerm) :-
        is_flmethspec(ParserTerm,Meth,_),
        !,
        flwrite(Meth).
flwrite(ParserTerm) :-
        is_fltranspec(ParserTerm,Meth,_),
        !,
        write('%'),
        flwrite(Meth).
flwrite(ParserTerm) :-
        is_flmvdattspec(ParserTerm,Att,Arrow,Val,_),
        !,
        flwrite(Att),
        flwrite(Arrow),
        write('{'),
        flwritelist(Val),
        write('}').
flwrite(ParserTerm) :-
        is_flsigattspec(ParserTerm,Att,Arrow,Val,_),
        !,
        flwrite(Att),
        flwrite(Arrow),
        write('('),
        flwrite(Val),
        write(')').
flwrite(ParserTerm) :-
        is_flsigattconspec(ParserTerm,Att,Constr,Arrow,Val,_),
        flwrite(Att),
        write('{'),
        flwrite(Constr),
        write('}'),
        flwrite(Arrow),
        flwrite(Val).
flwrite(ParserTerm) :-
        is_flsigconstr(ParserTerm,Lower,Upper),
        flwrite(Lower),
        write(FL_RANGE),
        flwrite(Upper).
flwrite(ParserTerm) :-
        (is_flboolsig(ParserTerm,Meth,Arrow,_) ;
            is_fltransig(ParserTerm,Meth,Arrow,_)
        ),
        !,
        flwrite(Arrow),
        flwrite(Meth).
flwrite(ParserTerm) :-
        is_flterm(ParserTerm,Funct,2,[Left,Right]),
        is_flatom_struct(Funct,FuncAtm),
        memberchk(FuncAtm,[FL_UNIVEQ,FL_EQ,FL_UNIVEQFORM,FL_OBJEQL,FL_MATHEQ,
                           FL_LT,FL_EQLT,FL_GT,FL_EQGT,FL_UDFEQ,FL_RANGE,
                           FL_SLASH, FL_PLUS, FL_MINUS,
                           FL_PROLOG_MODULE_TIE]),
        !,
        flwrite(Left),
        write(' '),
        write(FuncAtm),
        write(' '),
        flwrite(Right).
flwrite(ParserTerm) :-
        is_flterm(ParserTerm,Funct,2,[Left,Right]),
        is_flatom_struct(Funct,FL_DESCRIPTORFUNC),
        !,
        flwrite(Left),
        flwrite(Right).
flwrite(ParserTerm) :-
        is_flterm(ParserTerm,Funct,2,[Left,Right]),
        has_context(CONTEXT_HUMAN_READABLE),
        is_flatom_struct(Funct,FunctAtm),
        memberchk(FunctAtm,[FL_COMMA,FL_SEMICOLON,ERGOTEXT_WORD_CONNECTOR]),
        !,
        flwrite(Left),
        /*
        %% postponed attempt to mark spaces in templates.
        %% See extensions/flrcomposertext.P for detailed comment
        (FunctAtm == FL_COMMA,
            \+is_ergotext_word_connector(Left),
            \+is_prefixed_with_ergotext_word_connector(Right,_)
        -> write(', ')
        ; FunctAtm == FL_SEMICOLON -> write('; ')
        ; \+is_ergotext_word_connector(Left) -> write(' ')
        ; true
        ),
        */
        (FunctAtm == FL_COMMA -> write(' ')
        ; write('; ')
        ),
        flwrite(Right).
flwrite(ParserTerm) :-
        is_flterm(ParserTerm,Funct,_Arity,Args),
        !,
        (is_flatom_struct(Funct,FuncAtm), FuncAtm == FL_COMMA -> true
        ; flwrite(Funct)
        ),
        (has_context(CONTEXT_HUMAN_READABLE) -> write(' ')
        ; true
        ),
        write('('),
        flwritelist(Args),
        write(')').
flwrite(ParserTerm) :-
        %% postponed attempt to mark spaces in templates.
        %% See extensions/flrcomposertext.P for detailed comment
        fail,
        is_flatom_struct(ParserTerm,ERGOTEXT_WORD_CONNECTOR_FILLER),
        !,
        (has_context(CONTEXT_HUMAN_READABLE) -> true
        ; write('_^_')  %% marks where the spaces were in the original template
        ).
flwrite(ParserTerm) :-
        (is_flatom_struct(ParserTerm,Name) ;
            is_flnumber_struct(ParserTerm,Name) ;
            is_flstring_struct(ParserTerm,Name,_) ;
            is_flbuiltin_identifier_struct(ParserTerm,Name)
        ),
        !,
        write(Name).
flwrite(ParserTerm) :-
        (is_fltransactionalatom(ParserTerm,Name) ;
            is_fltransactionalnumber(ParserTerm,Name) ;
            is_fltransactionalstring(ParserTerm,Name)
        ),
        !,
        write('%'),
        write(Name).
flwrite(ParserTerm) :-
        is_flstring_struct(ParserTerm,Str,_),
        !,
        write(Str).
flwrite(ParserTerm) :-
        is_flvar_struct(ParserTerm,Name,_),
        !,
        write('?'),
        write(Name).
flwrite(ParserTerm) :-
        (is_fltoken(ParserTerm,FL_NEWOID,Suffix,_)
        %% Like FL_NEWOID, but is a Skolem both in the body and in the head
        %% Generated by skolemization during the omni transform
        ; is_fltoken(ParserTerm,FLSPECIALSKOLEM,Suffix,_)
        ),
        !,
        write(FL_NEWOID),
        (number(Suffix)->write(Suffix)
        ; true
        ).
flwrite(ParserTerm) :-
        is_flplib(ParserTerm,Pterm),
        !,
        flwrite(Pterm).
flwrite(ParserTerm) :-
        is_fllist_struct(ParserTerm,Front,Tail,_),
        !,
        write('['),
        flwritelist(Front),
        (Tail==[] -> true
        ; write('|'),
            flwrite(Tail)
        ),
        write(']').
flwrite(ParserTerm) :-
        is_list(ParserTerm),
        !,
        write('['),
        flwritelist(ParserTerm),
        write(']').
flwrite(ParserTerm) :-
        (is_flinsert(ParserTerm,Op,List,Cond)
        ; is_fldelete(ParserTerm,Op,List,Cond)
        ),
        !,
        flwrite(Op),
        write('{'),
        flwritelist(List),
        write('|'),
        flwrite(Cond),
        write('}').
flwrite(ParserTerm) :-
        (is_flinsert(ParserTerm,Op,List)
        ; is_fldelete(ParserTerm,Op,List)
        ),
        !,
        flwrite(Op),
        write('{'),
        flwritelist(List),
        write('}').
flwrite(ParserTerm) :-
        is_flupdaterule(ParserTerm,Op,Rules),
        !,
        flwrite(Op),
        write('{'),
        flwritelist(Rules),
        write('}').
flwrite(ParserTerm) :-
        is_flbirelate(ParserTerm,Obj1,Rel,Obj2),
        !,
        flwrite(Obj1),
        write(' '),
        flwrite(Rel),
        write(' '),
        flwrite(Obj2).
flwrite(ParserTerm) :-
        is_flaggregate(ParserTerm,Op,V,GV,Sort,Goal),
        !,
        flwrite(Op), write('{'),
        flwrite(V),
        write('['), flwritelist(GV), write(']'),
        write('('),
        (Sort == NULL -> write(' ')
        ; flwrite(Sort)
        ),
        !,
        write(')'),
        write('|'),
        flwrite(Goal),
        write('}').
flwrite(ParserTerm) :-
        is_flobjref(ParserTerm,Object,Attribute,Type),
        !,
        (Type == NONINHERITABLE -> Connector = '.'
        ; Connector = '!'
        ),
        flwrite(Object),
        write(Connector),
        flwrite(Attribute).
flwrite(ParserTerm) :-
        is_flfact(ParserTerm,FactList),
        !,
        flwritelist(FactList).
flwrite(ParserTerm) :-
        is_flquery(ParserTerm,Body),
        !,
        write('?- '),
        flwrite(Body).
flwrite(ParserTerm) :-
        is_fllatent_query(ParserTerm,Body),
        !,
        write('!- '),
        flwrite(Body).
flwrite(ParserTerm) :-
        is_flrule(ParserTerm,Head,Body),
        !,
        flwritelist(Head),
        write(' :- '),
        flwrite(Body).
flwrite(ParserTerm) :-
        is_fldynrule(ParserTerm,Head,Body,_Descriptors),
        !,
        write('('),
        flwritelist(Head),
        write(' :- '),
        flwrite(Body),
        write(')').
flwrite(ParserTerm) :-
        is_flreify_struct(ParserTerm,Term),
        !,
        write('${'),
        flwrite(Term),
        write('}').
flwrite((ParserTerm1,ParserTerm2)) :-
        !,
        write('('),
        flwrite(ParserTerm1),
        write(', '),
        flwrite(ParserTerm2),
        write(')').
flwrite((ParserTerm1;ParserTerm2)) :-
        !,
        write('('),
        flwrite(ParserTerm1),
        write(' ; '),
        flwrite(ParserTerm2),
        write(')').
flwrite(ParserTerm) :-
        nonvar(ParserTerm),
        ParserTerm = '_$VAR'(VarName),
        !,
        write(VarName).

%% catch-all case
flwrite(ParserTerm) :-
        write(ParserTerm).

flwritelist([]) :- !.
flwritelist([H|T]) :-
        flwrite(H),
        (T==[] -> true
        ; write(', '),
            flwritelist(T)
        ).
flwritelist_noseparator([]) :- !.
flwritelist_noseparator([H|T]) :-
        flwrite(H),
        (T==[] -> true
        ; write(' '),
            flwritelist_noseparator(T)
        ).

flwrite_descriptor(FLRULEID,Descr) :-
        !,
        write('@!{'),
        (Descr = [D|_] -> true
        ; D = Descr
        ),
        flwrite(D),
        write('}').
flwrite_descriptor(FLTAG,Descr) :-
        !,
        write('@{'),
        flwrite(Descr),
        write('}').
flwrite_descriptor(FLBOOLDESCRIPTOR,Descr) :-
        !,
        write('@@{'),
        flwrite(Descr),
        write('}').

%% used in flrutils to write the result of parsing line by line.
%% used for testing
flwritelinelist([]) :- !.
flwritelinelist([H|T]) :-
        flwriteline(H),
        flwritelinelist(T).

flwriteline_stderr(X) :-
        tell(STDERR),
        flwrite(X),
        nl,
        told.
flwrite_stderr(X) :-
        tell(STDERR),
        flwrite(X),
        told.

flwritelinelist_stderr(X) :-
        tell(STDERR),
        flwritelinelist(X),
        told.

flwriteline_warn(X) :-
        tell(STDWARN),
        flwrite(X),
        nl,
        told.


/*******************************************************************************
    Handling attributed variables for set arguments multipliers.
*******************************************************************************/
:- install_verify_attribute_handler(SETARGATTRIBUTE,
                                    AttrVal,VarBinding,
                                    setarg_unify_handler(AttrVal,VarBinding)).
:- install_attribute_portray_hook(SETARGATTRIBUTE,Attr,write(Attr)).
%% we might not need to check if the attribute value is a list:
%% this is just a precaution against weird bindings
setarg_unify_handler(AttrVal,_VarBinding) :- is_list(AttrVal).
get_all_attrvars(CodeTerm,AttrVars) :-
        flrterm_vars_split(CodeTerm,_,AttrVars,0).

%% gets conjunction (member(Code1,SetargList1),member(Code2,SetargList2),...)
get_setarg_multiplier(CodeTerm,Multiplier) :-
        get_all_attrvars(CodeTerm,AttrVars),
        get_setarg_multiplier_from_list(AttrVars,Multiplier).

get_setarg_multiplier_from_list([],FL_TRUE) :- !.
get_setarg_multiplier_from_list([Var|Rest], (Membership,RestMems)) :-
        get_attr(Var,SETARGATTRIBUTE,Membership),
        !,
        del_attr(Var,SETARGATTRIBUTE),
        get_setarg_multiplier_from_list(Rest,RestMems).
get_setarg_multiplier_from_list([_|Rest], RestMems) :-
        get_setarg_multiplier_from_list(Rest,RestMems).

%% multiply the literal, if it has set arguments inside
multiply_setarg_code(Code,MultCode) :-
        get_setarg_multiplier(Code,Multiplier),
        (Multiplier == FL_TRUE -> MultCode = [Code]
        ; findall(Code,Multiplier,MultCode)
        ).

%% apply multiply_setarg_code/2 to each elt of list and append the results
multiply_setarg_code_list([],[]) :- !.
multiply_setarg_code_list([Code|RestCode],MultCodeList) :-
        multiply_setarg_code(Code,MultCode),
        multiply_setarg_code_list(RestCode,RestMultCode),
        append(MultCode,RestMultCode,MultCodeList).

/******************************************************************************/



#include "extensions/flrparser_cranial.P"


/* These are to silence the compiler. The respective predicates get
** eliminated by the precompiler in ergo, but not in flora. */
'_$_$flrparser_dummy_export' :-
        false, %% prevents elimination of the next call by the preprocessor
        is_fldynrule(_,_,_,_),
        is_flsigattconspec(_,_,_,_,_,_),
        is_flneg(_,_,_),
        is_flsigattspec(_,_,_,_,_),
        is_flrulelognaf(_,_),
        is_flmethspec(_,_,_),
        is_flruleworkspace(_,_,_),
        is_flconjunct(_,_,_),
        is_fldisjunct(_,_,_),
        is_flplib(_,_),
        is_fltoken(_,_,_,_),
        is_fltransig(_,_,_,_),
        is_flifthenelse(_,_,_,_),
        is_flmvdattspec(_,_,_,_,_),
        is_flrule(_,_,_),
        is_flterm(_,_,_,_),
        is_flupdaterule(_,_,_),
        is_flsigconstr(_,_,_),
        is_flifthen(_,_,_),
        is_fltranspec(_,_,_),
        is_flquery(_,_),
        is_flaggregt_struct(_),
        is_flreify_struct(_),
        is_flstring_struct(_),
        is_fldescriptor(_,_,_,_),
        is_flannotated_construct(_,_,_),
        is_flobjref(_,_,_,_),
        is_flarith(_,_),
        is_flaggregate(_,_,_,_,_,_),
        is_fldelayedliteral(_,_,_),
        is_fldelayedliteral(_,_,_,_),
        is_flboolsig(_,_,_,_),
        is_fldatatype_struct(_).
