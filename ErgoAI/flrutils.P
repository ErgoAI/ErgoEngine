/* File:      flrutils.P
**
** Author(s): Guizhen Yang
**            Michael Kifer
**
** Contact:   see  CONTACTS.txt
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2023;
**      Coherent Knowledge Systems, LLC, 2014-2023;
**      and Vulcan, Inc., 2009-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).
#mode standard Prolog

#include "standard.h"
#include "trie_defs.h"

#include "flora_characters.flh"
#include "flora_terms.flh"
#include "flora_tabling_methods.flh"
#include "flora_errors.flh"
#include "flora_porting.flh"
#include "flora_extensions.flh"
#include "flora_exceptions.flh"
#include "flora_status_codes.flh"
#include "flora_contexts.flh"

#if defined(FLORA_SUBSUMPTIVE_TABLING)
#define DEFAULT_SUBSUMPTIVE_SEMANTICS  FL_SUBSUMPTIVE
#else
#define DEFAULT_SUBSUMPTIVE_SEMANTICS  FL_VARIANT
#endif

#if defined(FLORA_NONINCREMENTAL_TABLING)
#define DEFAULT_INCREMENTAL_SEMANTICS  FL_NONINCREMENTAL
#else
#define DEFAULT_INCREMENTAL_SEMANTICS  FL_INCREMENTAL
#endif

#define FLORA_DEFAULT_SEMANTICS   [FL_EQUALITY(NONE),FL_INHERITANCE(FLOGIC),FL_CUSTOM(NONE),FL_TABLING(DEFAULT_SUBSUMPTIVE_SEMANTICS),FL_TABLING(DEFAULT_INCREMENTAL_SEMANTICS)]


?- flora_reset_compiler(file).


/*************************************************************************
  flora_compile_util(+File)
  Compiles user modules
*************************************************************************/
flora_compile_util(File) :-
        flora_compile_util(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_util(+File,+Module)
  Compiles user modules
  The OBJ file is renamed using the module name
******************************************************************************/
flora_compile_util(OrigFile,Module) :-
        flora_check_filename(OrigFile,File),
        valid_flora_module_name(Module),
        ( flora_locate_file(File,FLORA_FILE_EXT_ALT,FlrFile) ->
            parse_filename(FlrFile,CurrentDir,_,_),
            %% temp push the current dir onto the library_directory path list
            (CurrentDir == '.' ; CurrentDir == '' ; var(CurrentDir) -> true
            ; add_lib_dir(push(CurrentDir)),
                replace_flora_configuration(cwd,CurrentDir,OldCWD)
            ),
            %% ensure restoration of encoding after compile
            has_char_encoding(Enc),
            flora_compile_then_prolog_compile(FlrFile,Module),
            set_char_encoding(Enc),
            %% remove the temporary library directory, restore cwd
            restore_directory_configuration(CurrentDir,OldCWD)
        ;
            flrfilename_error(File,FLORA_FILE_EXT_ALT) -> fail
        ),
        !.


/*************************************************************************
  flora_compile_add(+File)
  Compiles flora files for adding into "main" module
*************************************************************************/
flora_compile_add(File) :-
        flora_compile_add(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_add(+File,+Module)
  Compiles flora files for adding into module
  The OBJ file is renamed using the module name
******************************************************************************/
flora_compile_add(OrigFile,Module) :-
        flora_check_filename(OrigFile,File),
        valid_flora_module_name(Module),
        ( flora_locate_file(File,FLORA_FILE_EXT_ALT,FlrFile) ->
            parse_filename(FlrFile,CurrentDir,_,_),
            %% temp push the current dir onto the library_directory path list
            (CurrentDir == '.' ; CurrentDir == '' ; var(CurrentDir) -> true
            ; add_lib_dir(push(CurrentDir)),
                replace_flora_configuration(cwd,CurrentDir,OldCWD)
            ),
            %% ensure restoration of encoding after compile/load/add
            has_char_encoding(Enc),
            flora_compile_then_prolog_compile_add(FlrFile,Module),
            set_char_encoding(Enc),
            %% remove the temporary library directory, restore cwd
            restore_directory_configuration(CurrentDir,OldCWD)
        ;
            flrfilename_error(File,FLORA_FILE_EXT_ALT) -> fail
        ),
        !.

/**********************************************************************
  flora_add_module_dyn(+File,+Module,+HostFile)
  File must be a Flora-2 file.
**********************************************************************/
%% standard variant:
flora_add_module_dyn(OrigInFile,Module,HostFile)  :- 
        flora_add_module_dyn(OrigInFile,Module,HostFile,print,_FileStatus,_ErrList).

%% variant for external applications
flora_add_module_dyn(OrigInFile,Module,HostFile,ReportingType,FileStatus,ErrList) :-
        flora_query_permitted_during_pause,
        flora_check_filename(OrigInFile,InFile),
        valid_flora_module_name(Module),
        (\+ '\\isloaded'(Module) -> 
            %% just create a module, if adding to a new module
            flloadtrailer([],Module)
        ; true
        ),
        get_user_program_maybe(InFile,File),
        ( flora_locate_file(File,FLORA_FILE_EXT_ALT,FlrFile) ->
            (ReportingType == print -> flora_fladd(FlrFile,Module,HostFile)
            ; flora_fladd(FlrFile,Module,HostFile,ReportingType,FileStatus,ErrList)
            )
        ;
            flrfilename_error(InFile,FLORA_FILE_EXT_ALT) -> fail
        ),
        (var(ErrList) -> ErrList = NO_ERRORS ; true),
        !.


/**********************************************************************
  flora_add_module_dyn(+File,+HostFile)
  File must be a Flora-2 file.
**********************************************************************/
flora_add_module_dyn(InFile,HostFile) :-
        flora_add_module_dyn(InFile,FLORA_DEFAULT_WORKSPACE,HostFile).


/**********************************************************************
  flora_load_module_util(+OrigInFile,+Module,+HostFile) :-
  flora_load_module_util(+OrigFile,+Module,+HostFile,+ReportingType
                         -FileStatus,-ErrList)
  ReportingType: expected print/list
  File must be a Flora-2 file.
  HostFile: file from which File is loaded.
            HostFile may be FL_SHELL_FICTITIOUS_FILENAME.
**********************************************************************/
%% standard variant:
flora_load_module_util(OrigInFile,Module,HostFile) :-
        flora_load_module_util(OrigInFile,Module,HostFile,print,_FileStatus,_ErrList).

%% variant for external applications
flora_load_module_util(OrigInFile,Module,HostFile,ReportingType,FileStatus,ErrList) :-
        (breakmode_loadable(OrigInFile,Module) -> true
        ; flora_query_permitted_during_pause
        ),
        flora_check_filename(OrigInFile,InFile),
        valid_flora_module_name(Module),
        get_user_program_maybe(InFile,File),
        ( flora_locate_file(File,FLORA_FILE_EXT_ALT,FlrFile) ->
            (ReportingType == print -> flora_flload(FlrFile,Module,HostFile)
            ; flora_flload(FlrFile,Module,HostFile,ReportingType,FileStatus,ErrList)
            )
        ;
            flrfilename_error(InFile,FLORA_FILE_EXT_ALT) -> fail
        ),
        (var(ErrList) -> ErrList = NO_ERRORS ; true),
        !.


/**********************************************************************
  flora_load_module_util(+File,+HostFile)

  HostFile: file from which File is loaded.
            HostFile may be FL_SHELL_FICTITIOUS_FILENAME.
  File may be a Flora-2 file, Prolog file, or OBJ file.
  This is why this predicate is more complicated than flora_load_module_util/3,
  which expects only Flora-2 files.
**********************************************************************/
flora_load_module_util(OrigInFile,HostFile) :-
        (breakmode_loadable(OrigInFile,FLORA_DEFAULT_WORKSPACE) -> true
        ; flora_query_permitted_during_pause
        ),
        flora_check_filename(OrigInFile,InFile),
        get_user_program_maybe(InFile,File),
        ( flora_locate_file(File,FLORA_FILE_EXT_ALT,FlrFile) ->
            %% Load Flora-2 file
            flora_flload(FlrFile,FLORA_DEFAULT_WORKSPACE,HostFile)

        %% Load Prolog file
        ; flora_locate_file(File,PROLOG_PFILE_EXT,PFile) ->
            %% don't reload flrshell.P - this will cause XSB to exit!
            (File == flrshell ->
                flora_warning_line('flrshell.P must not be re-loaded by the user'),
                fail
            ; true
            ),
            flora_loader_msg_nl,
            flora_loader_message('Consulting ~w',[PFile]),
            %% Note: when the loaded file has prolog extension, we don't know
            %% if this is a Prolog module or a Flora-2 compiled output.
            %% So, just in case we arrange the GPP options, but don't rename
            %% the .xwam file. Maybe we should use a different extension for
            %% the target of Flora-2 compilation?
            flora_set_xpp_options_for_prolog_compile(FLORA_DEFAULT_WORKSPACE),
            flora_add_xpp_options('-warninglevel 1 '),
            /*
            %% WHEN LOADING, DO NOT DEFINE FLORA_SUBSUMPTIVE_TABLING
            %% and FLORA_VARIANT_TABLING: the right definitions
            %% must already be in the included trailer.
            (subsumptive_tabling_in_effect(FLORA_DEFAULT_WORKSPACE)
            -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
            ; true
            ),
            
            %% WHEN LOADING, DO NOT DEFINE FLORA_INCREMENTAL_TABLING
            %% and FLORA_NONINCREMENTAL_TABLING: the right definitions
            %% must already be in the included trailer.
            (incremental_tabling_in_effect(FLORA_DEFAULT_WORKSPACE) -> 
                flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
            ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
            ),
            */
            consult(PFile),
            flora_clear_xpp_options

        %% Load OBJ file
        ; flora_locate_file(File,PROLOG_OBJFILE_EXT,OBJFile) ->
            flora_loader_msg_nl,
            flora_loader_message('Consulting ~w',[OBJFile]),
            consult(OBJFile)

        ; %% The error case
            flrfilename_error(File,[FLORA_FILE_EXT_ALT,PROLOG_PFILE_EXT,PROLOG_OBJFILE_EXT]) -> fail
        ),
        !.

flora_load_modularized_prolog(OrigInFile,Module) :-
        flora_check_filename(OrigInFile,InFile),
        get_user_program_maybe(InFile,File),
        (flora_locate_file(File,PFile) ->
            flora_loader_msg_nl,
            flora_loader_message('Consulting ~w',[PFile]),
            flora_set_xpp_options_for_prolog_compile(Module),
            flora_add_xpp_options('-warninglevel 1 '),
            compile(PFile),
            flora_clear_xpp_options,
            util_mainXWAM_filename(PFile,MainXWAMFile),
            util_WSXWAM_filename(PFile,Module,WSXWAMFile),
            util_rename_file(MainXWAMFile,WSXWAMFile),
            consult(WSXWAMFile)
        ; %% The error case
            flrfilename_error(File,[_]) -> fail
        ).


/**********************************************************************
  flloadtrailer(+TrailerOptions,+Module)
  flloadtrailer1(+TrailerOptions,+Module)
  TrailerOptions is a list
  [FL_EQUALITY(...),FL_INHERITANCE(...),FL_TABLING(...),FL_CUSTOM(...)]
  The FLOBJEQLDEF option is also possible.
  Maintains trailer registry.
  Won't load trailer if the workspace has a trailer with identical semantics.
**********************************************************************/
flloadtrailer1(TrailerOptions,Module) :-
        valid_flora_module_name(Module),
        %% Check trailer options
        get_trailer_options(Module,CurrentTrailerOptions),
        (CurrentTrailerOptions == []
        -> DefaultTrailerOptions = FLORA_DEFAULT_SEMANTICS
        ;
            DefaultTrailerOptions = CurrentTrailerOptions
        ),
        sort(DefaultTrailerOptions,SortedDefaultTrailerOptions),
        fixup_trailer_options(TrailerOptions,SortedDefaultTrailerOptions,NewTrailerOptions),
        \+loadable_option_conflict(TrailerOptions,abort), %% explicit options
        \+loadable_option_conflict(NewTrailerOptions,abort), %% explicit vs default
        sort(NewTrailerOptions,SortedNewTrailerOptions),
        (                       % requested opts = current default
            SortedDefaultTrailerOptions = SortedNewTrailerOptions,
            CurrentTrailerOptions \= [], % not a new module
            !
        ; % Requested trailer options are different from current options
            flora_slash(S),
            make_trailer_filename(SortedNewTrailerOptions,TrailerFileName),
            %% Get file names in user dir.
            flora_user_floradir(UserFloraDir),
            flora_concat_atoms([UserFloraDir,S,S,TrailerFileName],UserTrailerPFile),
            util_mainXWAM_filename(UserTrailerPFile,UserTrailerOBJFile),
            util_WSXWAM_filename(UserTrailerPFile,Module,UserTrailerWSXWAMFile),
            %% Copy the main file to user directory.
            (
              %% Would be good to do something more sophisticated here.
              %% E.g., comparing with files in ./closure/ and the custom file
              flora_file_op(exists,UserTrailerPFile) -> true
            ;
              telling(PreOutFile),
              tell(UserTrailerPFile),
              include_xpp_control_variables(['LOADABLETRAILER'|SortedNewTrailerOptions]),
              util_include_file([FLTRAILER],_FileStatus),
              /*
                  Must include FLHEADER2, which has static tabling definitions
                    :- table ...
                  Otherwise, dynamic tabling directives
                    ?- table ... as variant/subsumptive
                  do not seem to cause predicates to be tabled.
              */
            util_include_file([FLHEADER2,FLDYNDECLARE,FLINDEX_P],_FileStatus),
              told,
              tell(PreOutFile)
            ),
            check_custom_trailer_file(SortedNewTrailerOptions),
            ( util_file_newerthan(UserTrailerWSXWAMFile,UserTrailerPFile) ->
                true
            ; 
                flora_set_xpp_options_for_prolog_compile(Module),
                (subsumptive_tabling_requested(SortedNewTrailerOptions)
                -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
                ;  true
                ),
                (incremental_tabling_requested(SortedNewTrailerOptions) ->
                    flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
                ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
                ),
                %%compile(UserTrailerPFile,[optimize,spec_repr,ti_all]),
                compile(UserTrailerPFile,[optimize,ti_all]),
                util_rename_file(UserTrailerOBJFile,UserTrailerWSXWAMFile),
                flora_clear_xpp_options
            ),
            %% abolish tables before loading the trailer
            catch(flora_abolish_nonincremental_tables,
                  _,
                  flora_warning_line(WARN_TABLED_FLLOAD,
                                     [FL_SETSEMANTICS,'<internal trailer>',Module])
                 ),
            consult(UserTrailerWSXWAMFile)
        ),
        !,
        %% Check if the patch needs to be loaded.
        %% Patch (.xsb/flora-XXX/patch.P) is loaded only once per workspace
        %% and only into the flora shell. The flora_module_registry/1 guard
        %% ensures this and that patch rules are never loaded into the same
        %% module as compiled programs.
        (flora_module_registry(Module)
        ; flloadpatch(Module)
        ),
        !.
flloadtrailer(TrailerOptions,Module) :-
        call_cleanup(catch(flloadtrailer1(TrailerOptions,Module),Ball,true),
                     flloadtrailer_handler(Ball)).
flloadtrailer(_,_).

flloadtrailer_handler(Ball) :-
        nonvar(Ball),
        (Ball = option_conflict(Msg) ->
            flora_abort(Msg,FLORA_ABORT_NOTRACE)
        ; Ball = startup_failed(Msg,_Bt) ->
            flora_stderr_nl,
            flora_error_line('~w ~nExiting...~n',[Msg]),
            halt
        %% This one is:
        %%     Cannot abolish a predicate with active backtrack points:
        %%     use retractall
        ; Ball = error('[Abolish]',_) -> fail
        ;
            flora_error_line('A problem occurred while loading a trailer - a possible bug: ~w', [Ball]),
            fail
        ).


%% Unify TrailerOptions with the module semantics
fltrailersemantics(TrailerOptions,Module) :-
        valid_flora_module_name(Module),
        %% Check trailer options
        get_trailer_options(Module,CurrentTrailerOptions),
        fixup_trailer_options([],CurrentTrailerOptions,FixedTrailerOptions),
        unify_trailer_options(TrailerOptions,FixedTrailerOptions).

unify_trailer_options([],_FixedTrailerOptions).
unify_trailer_options([Opt|TrailerOptions],FixedTrailerOptions) :-
        member(Opt,FixedTrailerOptions),
        unify_trailer_options(TrailerOptions,FixedTrailerOptions).


/**********************************************************************
   flloadpatch(+Module)
   This is loaded only in the shell and only once per module.
   Compiled programs have their patch rules included by generate_Pfile/15,
   and they don't need flloadpatch/1. (In fact, compiled rules and patch
   rules clash and should never be loaded into the same workspace.
**********************************************************************/
flloadpatch(Module) :-
        user_patch_file(UserPatchPFile),
        util_mainXWAM_filename(UserPatchPFile,UserPatchOBJFile),
        util_WSXWAM_filename(UserPatchPFile,Module,UserPatchWSXWAMFile),
        %% Copy the main file to user directory.
        ( flora_file_op(exists,UserPatchPFile) -> true
        ;
            telling(PreOutFile),
            tell(UserPatchPFile),
            %% Creating .xsb/flora-XXX/patch.P
            util_include_file([FLHEADER],_),
            flora_current_out_line('#mode save\n#mode nocomment "%"'),
            flora_current_out_line('#define FLORA_THIS_FILENAME  ''~w''',[UserPatchPFile]),
            flora_current_out_line('#mode restore'),
            util_include_file([FLDEFINITION,FLHEADER2,FLPATCH,
                               FLDYNDECLARE, FLINDEX_P,
                               FLSTATICHEADLIB,
                               FLOPPOSESBASELIB,
                               FLPREDDEF,
                               FLREFRESHTABLE,FLDYN_CONNECTORS],
                              _FileStatus),
            told,
            tell(PreOutFile)
        ),
        ( util_file_newerthan(UserPatchWSXWAMFile,UserPatchPFile) -> true
        ;
            flora_set_xpp_options_for_prolog_compile(Module),
            (subsumptive_tabling_in_effect(Module)
            -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
            ;  true
            ),
            (incremental_tabling_in_effect(Module) ->
                flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
            ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
            ),
            compile(UserPatchPFile,[optimize,ti_all]),
            util_rename_file(UserPatchOBJFile,UserPatchWSXWAMFile),
            flora_clear_xpp_options
        ),
        consult(UserPatchWSXWAMFile),
        !.


util_user_tmpfile(Filename) :-
        flora_user_floradir(Dir),
        flora_slash(S),
        flora_concat_atoms([Dir,S,S,'tmp$user'],Filename).


/*************************************************************************
   util_rename_file(+F1,+F2)
   This is like flora_file_op(rename,F1,F2), but it issues an error when fails.
   The reason is that on Windows files sometimes fail to be renamed for 
   strange reasons, so we first delete F2, try to rename, and if failed,
   issue an error, which explains what happened.
   There is no point to continue after a failure, because Flora 
   will be in a broken state.
*************************************************************************/
util_rename_file(F1,F2) :-
        ( (flora_file_op(unlink,F2), ! ; true),
            flora_file_op(rename,F1,F2), !
        ;
            flora_abort(['something wrong -- cannot rename file ',F1,' to ',F2,
                         '. Aborting.'],
                        FLORA_ABORT_NOTRACE)
        ).



/*************************************************************************
  flora_compile_then_prolog_compile_add(+FlrFile,+Module)

  This predicate is called to compile either a Flora user module or a
  Flora system module. In the former case, the module name is an atom
  whereas in the latter case the module name looks like _name.
  It first calls the Flora-2 compiler and then Prolog compiler.
*************************************************************************/
flora_compile_then_prolog_compile_add(FlrFile,Module) :-
        util_addP_filename(FlrFile,AddPFile),
        util_addFDB_filename(FlrFile,FDBFile),
        util_addFLD_filename(FlrFile,FLDFile),
        %%util_addFLM_filename(FlrFile,FLMFile),
        util_addFLS_filename(FlrFile,FLSFile),
        util_addFLS2_filename(FlrFile,FLS2File),
        util_addFLT_filename(FlrFile,FLTFile),
        util_FTX_filename(FlrFile,FTXFile),
        util_remove_filelist_carefully([AddPFile,FDBFile,FLDFile,
                                        %%FLMFile,
                                        FLSFile,FLS2File,FLTFile,FTXFile]),
        util_addFSTRDB_filename(FlrFile,FSTRDBFile),
        util_remove_file_carefully(FSTRDBFile),
        util_compile_file_add(FlrFile,Module,AddPFile,FDBFile,FLDFile,
                              %%FLMFile,
                              FLSFile,FLS2File,FLTFile,FTXFile,Status),
        ( Status == FLORA_FAILURE ->
            flora_clear_xpp_options,
            !,
            fail
        ;
            util_addXWAM_filename(FlrFile,AddXWAMFile),
            flora_loader_message('Invoking XSB compiler'),
            (
              %% Issue only important preprocessor warnings
              %% to avoid warnings when atoms or strings have \n in them
              flora_set_xpp_options_for_prolog_compile(Module),
              flora_add_xpp_options('-warninglevel 1 '),
              (subsumptive_tabling_in_effect(Module)
              -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
              ;  true
              ),
              (incremental_tabling_in_effect(Module) ->
                  flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
              ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
              ),
              compile(AddPFile,[optimize,ti_all])
            ->
              flora_clear_xpp_options
            ;
              flora_clear_xpp_options,
              fail
            ),
            !,
            %% preprocess the data files.
            modularized_file_name(FDBFile,FDBFilePostGPP,Module),
            xpp_datafile_for_module_and_cache(FDBFile,FDBFilePostGPP,Module),
            modularized_file_name(FLDFile,FLDFilePostGPP,Module),
            xpp_datafile_for_module_and_cache(FLDFile,FLDFilePostGPP,Module),
            %%modularized_file_name(FLMFile,FLMFilePostGPP,Module),
            %%xpp_datafile_for_module_and_cache(FLMFile,FLMFilePostGPP,Module),
            %% No need to create FTXFilePostGPP: this file's contents
            %% does not depend on modules
            modularized_file_name(FLSFile,FLSFilePostGPP,Module),
            xpp_datafile_for_module_and_cache(FLSFile,FLSFilePostGPP,Module),
            modularized_file_name(FLS2File,FLS2FilePostGPP,Module),
            xpp_datafile_for_module_and_cache(FLS2File,FLS2FilePostGPP,Module),
            modularized_file_name(FLTFile,FLTFilePostGPP,Module),
            xpp_datafile_for_module_and_cache(FLTFile,FLTFilePostGPP,Module),

            flora_clear_xpp_options,
            flora_check_module_name(Module),
            util_addWSXWAM_filename(FlrFile,Module,WSXWAMFile),
            util_rename_file(AddXWAMFile,WSXWAMFile)
        ),
        !.


/*************************************************************************
  flora_compile_then_prolog_compile(+FlrFile,+Module)

  This predicate is called to compile either a Flora user module or a
  Flora system module. In the former case, the module name is an atom
  whereas in the latter case the module name looks like _name.
  It first calls the Flora-2 compiler and then Prolog compiler.
*************************************************************************/
flora_compile_then_prolog_compile(FlrFile,Module) :-
        util_mainP_filename(FlrFile,MPFile),
        util_FDB_filename(FlrFile,FDBFile),
        util_FLD_filename(FlrFile,FLDFile),
        util_FLM_filename(FlrFile,FLMFile),
        util_FLS_filename(FlrFile,FLSFile),
        util_FLS2_filename(FlrFile,FLS2File),
        util_FLT_filename(FlrFile,FLTFile),
        util_FTX_filename(FlrFile,FTXFile),
        util_remove_filelist_carefully([MPFile,FDBFile,FLDFile,FLMFile,FLSFile,
                                        FLS2File,FLTFile,FTXFile]),
        %% file name for structure DB
        util_FSTRDB_filename(FlrFile,FSTRDBFile),
        util_remove_file_carefully(FSTRDBFile),

        util_compile_file(FlrFile,Module,MPFile,FDBFile,FLDFile,
                          FLMFile,
                          FLSFile,FLS2File,FLTFile,FTXFile,Status),
        ( Status == FLORA_FAILURE ->
            flora_clear_xpp_options,
            !,
            fail
        ;
            util_mainXWAM_filename(FlrFile,MainXWAMFile),
            flora_loader_message('Invoking XSB compiler'),
            (
              %% Issue only important preprocessor warnings
              %% to avoid warnings when atoms or strings have \n in them
              flora_set_xpp_options_for_prolog_compile(Module),
              flora_add_xpp_options('-warninglevel 1 '),
              /*
              %% WHEN LOADING, DO NOT DEFINE FLORA_SUBSUMPTIVE_TABLING
              %% and FLORA_VARIANT_TABLING: the right definitions
              %% must already be in the included trailer.
              (subsumptive_tabling_in_effect(Module)
              -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
              ;  true
              ),

              %% WHEN LOADING, DO NOT DEFINE FLORA_INCREMENTAL_TABLING
              %% and FLORA_NONINCREMENTAL_TABLING: the right definitions
              %% must already be in the included trailer.
              (incremental_tabling_in_effect(Module) ->
                  flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
              ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
              ),
              */
              compile(MPFile,[optimize,ti_all]) -> flora_clear_xpp_options
            ;
              flora_clear_xpp_options,
              fail
            ),
            !,
            flora_clear_xpp_options,
            flora_check_module_name(Module),
            util_WSXWAM_filename(FlrFile,Module,WSXWAMFile),
            util_rename_file(MainXWAMFile,WSXWAMFile)
        ),
        !.


/******************************************************************************
  flora_compile_system_module(+File)

  Compile a Flora system module in the lib/ directory. 

  This predicate is used *ONLY* in the make file for simplicity.
******************************************************************************/
flora_compile_system_module(File) :-
        %% Get the system module ID from the base file name.
        flora_file_op(basename,File,BaseName),
        flora_sysmod_file(Module,BaseName,_SubDir),
        ( flora_locate_file(BaseName,FLORA_FILE_EXT_ALT,FlrFile) ->
            flora_check_module_name(Module),
            flora_compile_then_prolog_compile(FlrFile,Module)
        ;
            flrfilename_error(File,FLORA_FILE_EXT_ALT) -> fail
        ),
        !.


/*************************************************************************
  flora_load_system_module_by_file(+File)

  Loads a system module by file name.

  flora_load_system_module_util(+Module)

  Loads a Flora system module by module name.
*************************************************************************/
flora_load_system_module_by_file(File) :-
        flora_file_op(basename,File,BaseName),
        flora_sysmod_file(Module,BaseName,_SubDir),
        %% find out why flora_load_system_module causes unexported pred
        %% errors in write(foo)@\io.
        flora_load_system_module(Module).
flora_load_system_module_util(Module) :-
        ( atom(Module), flora_sysmod_file(Module,BaseName,SubDir) ->
            flora_check_module_name(Module),
            flrcompiler:expert_mode_setting(ExpertMode),
            %% Compute the Flora file name.
            has_flora_configuration_dir(installdir,FloraDir),
            flora_slash(S),
            flora_concat_atoms([FloraDir,S,SubDir,S,BaseName],BaseFile),
            (flora_locate_file(BaseFile,FLORA_FILE_EXT_ALT,FlrFile) -> true
            ;
                flrfilename_error('system',FlrFile,FLORA_FILE_EXT_ALT) -> fail
            ),
            util_mainP_filename(FlrFile,PFile),
            util_WSXWAM_filename(FlrFile,Module,WSXWAMFile),
            !,
            ( skip_recompile(FlrFile,PFile,Module) -> true
            ; flora_compile_then_prolog_compile(FlrFile,Module)
            ),
            !,
            %% Seems system modules are always prolog-compiled.
            %% Probably not necessary, but need to look into this.
            flora_loader_message('loading ~w system module `~w''',[FLSYSTEM,Module]),
            %% Issue only important preprocessor warnings
            %% to avoid warnings when atoms or strings have \n in them
            flora_set_xpp_options_for_prolog_compile(Module,
                                                     '-warninglevel 0 '),
            /*
            %% WHEN LOADING, DO NOT DEFINE FLORA_SUBSUMPTIVE_TABLING
            %% and FLORA_VARIANT_TABLING: the right definitions
            %% must already be in the included trailer.
            (subsumptive_tabling_in_effect(Module)
            -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
            ;  true
            ),

            %% WHEN LOADING, DO NOT DEFINE FLORA_INCREMENTAL_TABLING
            %% and FLORA_NONINCREMENTAL_TABLING: the right definitions
            %% must already be in the included trailer.
            (incremental_tabling_in_effect(Module) ->
                flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
            ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
            ),
            */
            update_load_registry(FlrFile,WSXWAMFile,Module,FL_SHELL_FICTITIOUS_FILENAME,load),
            has_char_encoding(EncConsult),
            catch(consult(WSXWAMFile),
                  Ball,
                  xsb_consult_handler(Ball,Module,FlrFile,load,_,_,EncConsult)),
            flrcompiler:set_expert_mode(ExpertMode),
            check_for_import_cyclicity,
            flora_clear_xpp_options
        ;
            flora_stderr_nl,
            flora_error_line('invalid system module ID ~w -- loading failed',
                             [Module]),
            !,
            fail
        ),
        !.


/*************************************************************************
  flora_fladd(+FlrFile,+Module,+HostFile)
  flora_fladd(+FlrFile,+Module,+HostFile,+ReportingType,-FileStatus,-ErrList)
  ReportingType: expected print/list

  Need to make sure the GPP options are cleared when this predicate is
  finished.
*************************************************************************/
flora_fladd(FlrFile,Module,HostFile) :-
        flora_fladd(FlrFile,Module,HostFile,print,_FileStatus,_ErrList).

flora_fladd(FlrFile,Module,HostFile,ReportingType,FileStatus,ErrList) :-
        parse_filename(FlrFile,CurrentDir,_,_),
        %% temporarily push the current dir onto the library_directory path list
        (CurrentDir == '.' ; CurrentDir == '' ; var(CurrentDir) -> true
        ; add_lib_dir(push(CurrentDir)),
            replace_flora_configuration(cwd,CurrentDir,OldCWD)
        ),
        util_addP_filename(FlrFile,AddPFile),
        util_addXWAM_filename(FlrFile,AddXWAMFile),
        util_addFDB_filename(FlrFile,FDBFile),
        %% support for undefinedness
        util_addFLD_filename(FlrFile,FLDFile),
        %%util_addFLM_filename(FlrFile,FLMFile),
        util_addFLS_filename(FlrFile,FLSFile),
        util_addFLS2_filename(FlrFile,FLS2File),
        util_addFLT_filename(FlrFile,FLTFile),
        util_FTX_filename(FlrFile,FTXFile),
        util_addWSXWAM_filename(FlrFile,Module,WSXWAMFile),
        !,
        disable_all_tripwires,
        has_char_encoding(Encoding),
        (skip_loading(FlrFile,AddPFile,WSXWAMFile,Module,add) ->
            SkipRest = true,
            flora_loader_message('~w has been added to module ~w earlier',[FlrFile,Module])
        ; skip_recompile(FlrFile,AddPFile,Module) -> flora_loader_msg_nl
        ;
            util_remove_filelist_carefully([AddPFile,AddXWAMFile,
                                            FDBFile,FLDFile,
                                            %%FLMFile,
                                            FLSFile, FLS2File,FLTFile,FTXFile]),
            util_addFSTRDB_filename(FlrFile,FSTRDBFile),
            util_remove_file_carefully(FSTRDBFile),

            %% ensure restoration of encoding after compile/load/add
            (ReportingType == print ->
                util_compile_file_add(FlrFile,Module,AddPFile,FDBFile,FLDFile,
                                      FLSFile,FLS2File,FLTFile,FTXFile,FileStatus)
            ; util_compile_file_add(FlrFile,Module,AddPFile,FDBFile,FLDFile,
                                    FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,ErrList)
            ),
            ( FileStatus == FLORA_FAILURE -> flora_clear_xpp_options,
                (ReportingType == print -> fail ; true)
            ;
                true
            )
        ),
        !,
        ( FileStatus == FLORA_FAILURE -> true %% ReportingType \== print
        ; SkipRest == true -> %% already added and uptodate
            ErrList = [],
            FileStatus = FLORA_SUCCESS
        ; ( %% FileStatus \== FLORA_FAILURE
              (var(FileStatus) -> FileStatus = FLORA_SUCCESS ; true),
              flora_loader_message('Adding ~w to module ~w',[FlrFile,Module]),
              ( util_file_newerthan(WSXWAMFile,AddPFile) -> true
              ; (
                  flora_set_xpp_options_for_prolog_compile(Module),
                  flora_add_xpp_options('-warninglevel 0 '),
                  (subsumptive_tabling_in_effect(Module)
                  -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
                  ;  true
                  ),
                  (incremental_tabling_in_effect(Module) ->
                      flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
                  ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
                  ),
                  compile(AddPFile,[optimize,ti_all])
                ->
                  flora_clear_xpp_options
                ;
                  flora_clear_xpp_options,
                  fail
                ),
                  util_rename_file(AddXWAMFile,WSXWAMFile)
              ),
              load_include_dependencies(FlrFile),
              update_load_registry(FlrFile,WSXWAMFile,Module,HostFile,add),
              flora_measure_time(
                                 catch(consult(WSXWAMFile),
                                       Ball,
                                       xsb_consult_handler(Ball,Module,FlrFile,add,CurrentDir,OldCWD,Encoding)),
                                 ['Done adding ', FlrFile, '. CPU time used:'],
                                 loaddone
                                ),
              check_for_import_cyclicity,
              flora_clear_xpp_options
          )
        ),
        set_char_encoding(Encoding),
        %% remove the temporary library directory restore cwd
        restore_directory_configuration(CurrentDir,OldCWD),
        flora_raise_update_flag,
        enable_all_tripwires,
        !.


/*************************************************************************
  flora_flload(+FlrFile,+Module,+HostFile,+ReportingType,-FileStatus,-Status)
  flora_flload(+FlrFile,+Module,+HostFile)
  Always succeeds, if there are errors FileStatus = FLORA_FAILURE
  ReportingType: print or list

  Need to make sure the GPP options are cleared when this predicate is
  finished.
*************************************************************************/
%% standard variant:
flora_flload(FlrFile,Module,HostFile) :-
        flora_flload(FlrFile,Module,HostFile,print,_FileStatus,_ErrList).

%% variant for external applications
flora_flload(FlrFile,Module,HostFile,ReportingType,FileStatus,ErrList) :-
        parse_filename(FlrFile,CurrentDir,_,_),
        %% temporarily push the current dir onto the library_directory path list
        (CurrentDir == '.' ; CurrentDir == '' ; var(CurrentDir) -> true
        ; add_lib_dir(push(CurrentDir)),
            replace_flora_configuration(cwd,CurrentDir,OldCWD)
        ),
        util_mainP_filename(FlrFile,MPFile),
        util_mainXWAM_filename(FlrFile,MainXWAMFile),
        util_FDB_filename(FlrFile,FDBFile),
        %% support for undefinedness
        util_FLD_filename(FlrFile,FLDFile),
        %% the file containing the queries
        util_FLM_filename(FlrFile,FLMFile),
        util_FLS_filename(FlrFile,FLSFile),
        util_FLS2_filename(FlrFile,FLS2File),
        util_FLT_filename(FlrFile,FLTFile),
        util_FTX_filename(FlrFile,FTXFile),
        util_WSXWAM_filename(FlrFile,Module,WSXWAMFile),

        !,
        disable_all_tripwires,
        has_char_encoding(Encoding),
        ( skip_loading(FlrFile,MPFile,WSXWAMFile,Module,load) ->
            SkipRest = true,
            flora_loader_message('~w has been loaded into module ~w earlier',[FlrFile,Module])
        ; skip_recompile(FlrFile,MPFile,Module) -> flora_loader_msg_nl
        ;
            util_remove_filelist_carefully([MPFile,MainXWAMFile,
                                            FDBFile,FLDFile,FLMFile,FLSFile,
                                            FLS2File,FLTFile,FTXFile]),

            util_FSTRDB_filename(FlrFile,FSTRDBFile),
            util_remove_file_carefully(FSTRDBFile),

        %% ensure restoration of encoding after compile/load/add
        (ReportingType == print ->
            util_compile_file(FlrFile,Module,MPFile,FDBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus)
        ; util_compile_file(FlrFile,Module,MPFile,FDBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,ErrList)
        ),
            ( FileStatus == FLORA_FAILURE ->
                flora_clear_xpp_options,
                (ReportingType == print -> fail ; true)
            ;
                true
            )
        ),
        !,
        
        (FileStatus == FLORA_FAILURE -> true %% ReportingType \== print
        ; SkipRest == true -> %% already loaded and uptodate
            ErrList = [],
            FileStatus = FLORA_SUCCESS
        ; ( %% FileStatus \== FLORA_FAILURE
              %% clean up the registry before loading, but not adding
              flora_cleanup_registry(Module),
              flora_cleanup_rule_metadata(Module),

              (var(FileStatus) -> FileStatus = FLORA_SUCCESS ; true),
              flora_loader_message('Loading ~w into module ~w',[FlrFile,Module]),
              ( util_file_newerthan(WSXWAMFile,MPFile) -> true
              ; (
                  flora_set_xpp_options_for_prolog_compile(Module),
                  flora_add_xpp_options('-warninglevel 0 '),
                  /*
                  %% WHEN LOADING, DO NOT DEFINE FLORA_SUBSUMPTIVE_TABLING
                  %% and FLORA_VARIANT_TABLING: the right definitions
                  %% must already be in the included trailer.
                  (subsumptive_tabling_in_effect(Module)
                  -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
                  ;  true
                  ),
                  
                  %% WHEN LOADING, DO NOT DEFINE FLORA_INCREMENTAL_TABLING
                  %% and FLORA_NONINCREMENTAL_TABLING: the right definitions
                  %% must already be in the included trailer.
                  (incremental_tabling_in_effect(Module) ->
                      flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
                  ; flora_add_xpp_options('-D FLORA_NONINCREMENTAL_TABLING ')
                  ),
                  */
                compile(MPFile,[optimize,ti_all]) ->
                  flora_clear_xpp_options
                ;
                  flora_clear_xpp_options,
                  fail
                ),
                util_rename_file(MainXWAMFile,WSXWAMFile)
              ),
              flora_call_hooks(Module,LOADTOMODULE,FlrFile,before,_ResultFromHooks,AroundHookLink),
              %% We clear out UDF preds before loading (NOT adding!) modules.
              %% See comment about this where flora_cleanup_udf/1 is defined.
              %% Note: cleaning up UDFs *cannot* be done from within
              %% flrdefinition.flh because then the call to flora_cleanup_udf/1
              %% would abolish the predicates that we've just loaded!
              %% This is why we do the cleanup here.
              flora_cleanup_udf(Module),
              %% Ditto with modular prolog: must abolish them
              %% before loading but not adding
              abolish_modular_prolog_predicates(Module),
              load_include_dependencies(FlrFile),
              update_load_registry(FlrFile,WSXWAMFile,Module,HostFile,load),
              flora_measure_time(
                                 catch(consult(WSXWAMFile),
                                       Ball,
                                       xsb_consult_handler(Ball,Module,FlrFile,load,CurrentDir,OldCWD,Encoding)),
                                 ['Done loading ', FlrFile, '.\n    CPU time used:'],
                                 loaddone
                                ),
              %% After loading, always set the module to unchanged
              %% Not enough to do it in update_load_registry/5.
              %% If we don't do it here, latent queries will change the module
              %% status to FL_CHANGED because FLLIBINSQUERYSIG/7 in flrdynrule.P
              %% always does so to reflect the fact that it asserts metafacts
              %% and adds a new rule (the latent query itself)
              retractall(flora_module_registry(Module,_,_)),
              assert(flora_module_registry(Module,FL_UNCHANGED,'NULL'())),
              check_for_import_cyclicity,
              flora_call_hooks(Module,LOADTOMODULE,FlrFile,after,_ResultFromHooks,AroundHookLink),
              flora_clear_xpp_options
          )
        ),
        set_char_encoding(Encoding),
        %% remove the temporary library directory, restore cwd
        restore_directory_configuration(CurrentDir,OldCWD),
        flora_raise_update_flag,
        enable_all_tripwires,
        !.

#include "extensions/flrutil_java.P"

/*****************************************************************************
  save_user_clauses(+FlrFile)
  Read user input and save it in the given file
*****************************************************************************/
#include "extensions/flrutil_scratchpad.P"

save_user_clauses(FlrFile) :-
        (flora_running_under(windows) -> CtlChar = 'Z' ; CtlChar = 'D'),
        flora_message_line('type statements into scratchpad below; Ctl-~w when done',
                           [CtlChar]),
        (\+flora_running_under(windows) ->
            seeing(In),
            %% This hack is for MacOS.
            %% If no cloning, MacOS will exit XSB undert the Mac.
            file_clone(In,InCopy,_),
            see(InCopy)
        ; true
        ),
        flora_copy_input(_,FlrFile),
        (\+flora_running_under(windows) ->
            seen,
            see(In)
        ; true
        ),
        flora_message_line('Program saved in file ~w', [FlrFile]).


/*************************************************************************
  get_user_program_maybe(+InFile,-File)
  If InFile = '' assume the user wants to input the program from the shell.
  Return the name of the tempfile that has the program.
*************************************************************************/
get_user_program_maybe(InFile,File) :-
        ( InFile == FL_INLINEMODULE ->
            util_user_tmpfile(File),
            flora_concat_atoms([File,'.',FLORA_FILE_PREFERRED_EXT],FlrFile),
            flora_disable_keyboard_interrupts,
            save_user_clauses(FlrFile),
            flora_enable_keyboard_interrupts
        ;
            File=InFile
        ).


/*************************************************************************
  flora_locate_file(+InFile,+ExtType,-ExtFile)

  InFile must have ExtType as extension or no extension (in this case,
  ExtType is appended).
  In case of a URL, copy the Web module into the Web cache directory
  $HOME/.xsb/flora-XXX/www_cache/
*************************************************************************/
flora_locate_file(FL_URL(InURL),ExtType,ExtFile) :-
        !,
        check_attach_extension(InURL,ExtType,ExtFileName),
        bring_webdoc_to_cache(ExtFileName,ExtFile).

flora_locate_file(InFile,ExtType,ExtFile) :-
        (check_attach_extension(InFile,ExtType,ExtFileName),
            flora_locate_file(ExtFileName,ExtFile),
            !
        ; %% if not found, look in the hidden directory
            util_hidden_aux_dir(InFile,HDir,Base),
            flora_concat_atoms([HDir,Base,'.',FLORA_HIDDEN_PROLOG_EXT],HiddenPFile),
            check_attach_extension(HiddenPFile,FLORA_HIDDEN_PROLOG_EXT,ExtFileName),
            flora_locate_file(ExtFileName,ExtFile)
        ),
        !.
%% ExtType can be a list of alternative extensions
check_attach_extension(InFile,ExtType,ExtFileName) :-
        parse_filename(InFile,_,_,Ext),
        ( %% InFile has a matching extension
            atom(ExtType), Ext == ExtType -> ExtFileName=InFile
        ; is_list(ExtType), member(Ext,ExtType) -> ExtFileName=InFile
        ; atom(ExtType), Ext == '' ->
            flora_concat_atoms([InFile,'.',ExtType],ExtFileName)
        ; is_list(ExtType), Ext == '' ->
            member(AltExt,ExtType),
            flora_concat_atoms([InFile,'.',AltExt],ExtFileName)
        ).

webdoc_not_found(Doc) :-
        (\+atom(Doc) -> true
        ; Doc == '' -> true
        ; flora_match_substring('Not Found</title>',Doc,_)
        ).


/*
     bring_webdoc_to_cache(+InURL,-OutFile)

     Bring the doc from InURL and place it in a local file OutFile in the cache.
     The cache file name, OutFile, is calculated from the input URL.
*/
bring_webdoc_to_cache(InURL,OutFile) :-
        %% for URLs we don't check for existence until the curl
        %% package stabilizes
        %% FixMe: In principle, we could first check the modtime of the URL
        %% and download it only if it is newer than OutFile
        curl:load_page(FL_URL(InURL),
                       %% decide which options make sense
                       [redirect(true),secure(false)],
                       [_Size,WebTime,_Redirect],
                       Document,
                       Warn),
        curl:encode_url(FL_URL(InURL),[DirEnc,FileBase,Suffix]),
        (\+webdoc_not_found(Document) -> true
        ; flora_abort(['the Web document ', InURL, ' is not found'],
                      FLORA_ABORT_NOTRACE)
        ),
        curl:www_cache_filename([redirect(true)],FileBase,Suffix,WWW_cache_Filename),
        (Warn==[] -> true
        ;
            flora_warning_line('while reading ~w: ~w', [InURL,Warn])
        ),
        flora_user_floradir(UserDir),
        flora_slash(S),
        %% $HOME/.xsb/flora-XXX//www_cache//
        %% Double slashes are for the windows case, since single \ is an escape
        flora_concat_atoms([UserDir,S,S,www_cache,S,S],UserWebCache),
        ( flora_file_op(exists,UserWebCache) -> true
        ;
            ( flora_file_op(mkdir,UserWebCache) -> true
            ;
                flora_abort(['cannot create the Web cache directory: ',
                             UserWebCache,
                             ' the HTTP interface is inoperational'],
                            FLORA_ABORT_NOTRACE)
            )
        ),
        flora_concat_atoms([UserWebCache,DirEnc],InURLCacheDirectory),
        ( flora_file_op(exists,InURLCacheDirectory) -> true
        ;
            ( flora_file_op(mkdir,InURLCacheDirectory) -> true
            ;
                flora_abort(['cannot create a Web cache subdirectory: ',
                             InURLCacheDirectory,
                             ' HTTP interface is nonoperational'],
                            FLORA_ABORT_NOTRACE)
            )
        ),
        %% $HOME/.xsb/flora-XXX/www_cache/encoded_web_directory/web_file
        flora_concat_atoms([InURLCacheDirectory,S,WWW_cache_Filename],OutFile),
        (flora_file_op(exists,OutFile)
        -> flora_file_op(modtime,OutFile,OutFileTime)
        ;  OutFileTime = -10000
        ),
        ( OutFileTime =< WebTime ->
            %% test: [url('http:/www.w3.org/TR/owl-guide/wine.rdf')].
            %% test: [url('http://www.cs.stonybrook.edu/~kifer/test/test.flr')].
            open(OutFile,write,Stream),
            write(Stream,Document),
            close(Stream)
        ;   true
        ).


/*************************************************************************
  flora_locate_file(+InFile,-LocatedFile)

  When it succeeds, it returns an absolute file name.
*************************************************************************/
flora_locate_file(In,In) :-
        flora_file_op(isabsolute,In),
        !,
        flora_file_op(exists,In).

flora_locate_file(In,Loc) :-
        flora_module_path_get(LibDir),
        flora_slash(S),
        flora_concat_atoms([LibDir,S,In],File),
        flora_file_op(expand,File,Loc),
        flora_file_op(exists,Loc),
        !.

flora_locate_file(In,Loc) :-
        flora_file_op(expand,In,Loc),
        !,
        flora_file_op(exists,Loc).


/*****************************************************************************
     flora_locate_file_basic(+InFile,-OutFile)

  This is used for non-Flora-2 files, like RDF, etc.
  Check if a local file exists.
  If the file is non-local, copy it to the chache directory
  $HOME/.xsb/flora-XXX/www_cache/
*****************************************************************************/
flora_locate_file_basic(FL_URL(InURL),OutFile) :-
        !,
        bring_webdoc_to_cache(InURL,OutFile).

flora_locate_file_basic(InFile,InFile) :-
        flora_file_op(exists,InFile).


/*************************************************************************
  util_file_newerthan(+File1,+File2)
  returns true if File1 exists and is newer than File2. File2 already exists.
*************************************************************************/
util_file_newerthan(File1,File2) :-
        flora_file_op(newerthan,File1,File2).


/*************************************************************************
   util_hidden_aux_dir(+File,-HiddenDir,-FileBase)
       Return directory for hidden auxiliary files:
       the directory of file plus .flora_aux_files/
   util_hidden_aux_file_base(+File,-AuxBase)
       Return the base for auxiliary files in the hidden aux diretory.
       For instance, if File is  /a/b/d/foo.flr then AuxBase would be
       /a/b/d/.flora_aux_files/foo
       This also checks if the hidden directory exists and creates it if not.
*************************************************************************/
util_hidden_aux_dir(File,HDir,Base) :-
        parse_filename(File,Dir,Base,_),
        flora_slash(S),
        flora_concat_atoms([Dir,FLORA_HIDDEN_DIR,S],HDir).

%% like util_get_hidden_aux_file_base/3 but also does checks,
%% creates the aux dir if missing
util_hidden_aux_file_base(File,AuxBase) :-
        util_hidden_aux_file_base_nocheck(File,AuxBase,AuxDir),
        %% create aux dir, if needed
        ( flora_file_op(exists,AuxDir) -> true
        ; flora_file_op(mkdir,AuxDir) -> true
        ;
            flora_file_op(cwd,CurDir),
            flora_abort(['while compiling file ', File,
                         ': cannot create the ',FLSYSTEM,
                         ' auxiliary folder ', AuxDir,
                         ' for storing compiled files; current directory: ', CurDir],
                        FLORA_ABORT_NOTRACE)
        ).

%% just get the base name for compiled file in the auxiliary dir
util_hidden_aux_file_base_nocheck(File,AuxBase,AuxDir) :-
        parse_filename(File,Dir,Base,Ext),
        flora_slash(S),
        (Dir == '', in_hidden_dir(HiddenCWD)
        %% Precaution (needed only if bug):
        %% if we are already in a hidden directory and Dir does not give
        %% a better alternative then don't create a nested hidden subdir
        -> AuxDir = HiddenCWD
        ; member(Ext,FLORA_FILE_EXT_ALT) ->
            flora_concat_atoms([Dir,FLORA_HIDDEN_DIR,S],AuxDir)
        ; AuxDir = Dir
        ),
        flora_concat_atoms([AuxDir,Base],AuxBase).

%% in_hidden_dir(-CWD)
%% succeeds if cwd is a hidden directory.
%% returns the hidden cwd
in_hidden_dir(CWD) :-
        cwd(CWD),
        parse_filename(CWD,_Parent,BaseCWD,_),
        BaseCWD == FLORA_HIDDEN_DIR.

/*************************************************************************
  util_addP_filename(+File,-AddPFile)
  util_addXWAM_filename(+File,-AddXWAMFile)
  util_addFDB_filename(+File,-FDBFile)
  util_addFLD_filename(+File,-FLDFile)
  %%util_addFLM_filename(+File,-FLMFile)
  util_addWSXWAM_filename(+File,+WS,-WSXWAMFile)
  util_addFLS_filename(+File,-FLSFile)
  util_addFLS2_filename(+File,-FLS2File)
  util_addFLT_filename(+File,-FLTFile)
  util_addFTX_filename(+File,-FTXFile)  -- textual info for graphics support
  util_addFPJ_filename(+File,-FPJFile)  -- #include file dependency
*************************************************************************/
util_addP_filename(File,AddPFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_SUFFIX,FLORA_HIDDEN_PROLOG_EXT],AddPFile).

util_addXWAM_filename(File,AddXWAMFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_SUFFIX,PROLOG_OBJFILE_EXT],AddXWAMFile).

util_addFDB_filename(File,FDBFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_SUFFIX,FLORA_FDB_EXT],FDBFile).

util_addFLD_filename(File,FLDFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_SUFFIX,FLORA_FLD_EXT],FLDFile).

/*
%% We never create FLM files for added rules
util_addFLM_filename(File,FLMFile) :-
        parse_filename(File,Dir,Base,_),
        flora_concat_atoms([Dir,Base,FLORA_FOR_ADD_SUFFIX,FLORA_FLM_EXT],FLMFile).
*/

%% File name for the object file with module name attached
util_addWSXWAM_filename(File,WS,WSFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        url_encode(WS,WS_enc),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_ENCODING_SUFFIX,WS_enc,'.',PROLOG_OBJFILE_EXT],
                           WSFile).

%% identical to util_FLS_filename
util_addFLS_filename(File,FLSFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLS_EXT],FLSFile).
%% identical to util_FLS2_filename
util_addFLS2_filename(File,FLS2File) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLS2_EXT],FLS2File).

util_addFLT_filename(File,FLTFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,FLORA_FOR_ADD_SUFFIX,FLORA_FLT_EXT],FLTFile).

/*
%% identical to util_FTX_filename
util_addFTX_filename(File,FTXFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FTX_EXT],FTXFile).        

%% identical to util_FPJ_filename
util_addFPJ_filename(File,FPJFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FPJ_EXT],FPJFile).        
*/


/*************************************************************************
util_mainP_filename(+File,-MPFile)
util_mainXWAM_filename(+File,-MainXWAMFile)
util_FDB_filename(+File,-FDBFile)
util_FLD_filename(+File,-FLDFile)
util_FLM_filename(+File,-FLMFile)
util_FLH_filename(+File,-FLHFile)
util_FLS_filename(+File,-FLSFile)
util_FLS2_filename(+File,-FLS2File)
util_FLT_filename(+File,-FLTFile)
util_WSXWAM_filename(+File,+WS,-WSXWAMFile)
util_dump_filename(+File,-DFile)
util_FTX_filename(+File,-FTXFile)  -- textual info for graphics support
util_FPJ_filename(+File,-FPJFile)  -- #include file dependency
*************************************************************************/
util_mainP_filename(File,MPFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_HIDDEN_PROLOG_EXT],MPFile).

util_mainXWAM_filename(File,MainXWAMFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',PROLOG_OBJFILE_EXT],MainXWAMFile).

util_FDB_filename(File,FDBFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FDB_EXT],FDBFile).

util_FLD_filename(File,FLDFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLD_EXT],FLDFile).

util_FLM_filename(File,FLMFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLM_EXT],FLMFile).

/*
util_FLH_filename(File,FLHFile) :-
        parse_filename(File,Dir,Base,_),
        flora_concat_atoms([Dir,Base,'.',FLORA_HEADER_EXT],FLHFile).
*/

%% File name for the object file with module name attached
util_WSXWAM_filename(File,WS,WSXWAMFile) :-
        util_WS_filename(File,WS,PROLOG_OBJFILE_EXT,WSXWAMFile).

util_WS_filename(File,WS,Extenstion,WSFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        url_encode(WS,WS_enc),
        flora_concat_atoms([AuxBase,'_',WS_enc,'.',Extenstion], WSFile).

util_dump_filename(File,DFile) :-
        parse_filename(File,_Dir,_Base,Ext),
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'_dump.',Ext],DFile).

util_FLS_filename(File,FLSFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLS_EXT],FLSFile).
util_FLS2_filename(File,FLS2File) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLS2_EXT],FLS2File).

util_FLT_filename(File,FLTFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FLT_EXT],FLTFile).

util_FTX_filename(File,FTXFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FTX_EXT],FTXFile).

util_FPJ_filename(File,FPJFile) :-
        util_hidden_aux_file_base(File,AuxBase),
        flora_concat_atoms([AuxBase,'.',FLORA_FPJ_EXT],FPJFile).

%% Here we use FLORA_FILE_PREFERRED_EXT because this is used only
%% for auxiliary purposes, never to actually locate Flora-2 program files
util_FLR_filename(File,FlrFile) :-
        parse_filename(File,_,Base_pre,_),
        (flora_match_substring(FLORA_FOR_ADD_SUFFIX_SANS_DOT,Base_pre,Pos) ->
            flrporting:flora_get_substring(Base_pre,0,Pos,Base)
        ; Base = Base_pre
        ),
        flora_concat_atoms([Base,'.',FLORA_FILE_PREFERRED_EXT],FlrFile).        

%% get the Flr file out of AuxFile (P,FTX,FDB, etc.). The Flr file
%% is either absolute or is relative to the same directory as the AuxFile
:- export util_FLR_filename_abs/2.
util_FLR_filename_abs(AuxFile,FlrFile) :-
        parse_filename(AuxFile,Dir,Base,_),
        flora_slash(Slash),
        %% The next 2 lines is a trick to get parent directory of Dir
        flora_concat_atoms([Dir,Slash,'.'],Dir1),
        flora_file_op(dirname,Dir1,FlrFileDir),
        (FlrFileDir == '' -> FlrFileDir1 = FlrFileDir
        ; flora_concat_atoms([FlrFileDir,Slash],FlrFileDir1)
        ),
        flora_concat_atoms([FlrFileDir1,Base,'.',FLORA_FILE_PREFERRED_EXT],FlrFilePre),
        (flora_running_under(windows) ->
            flora_double_backslash(FlrFilePre,FlrFile)
        ; FlrFile = FlrFilePre
        ).


/*************************************************************************
  flora_check_filename(+OrigFile,-OutFile): must be atom or url(File)
  OutFile is either = OrigFile or has the prolog form url(File)
*************************************************************************/
flora_check_filename(OrigFile,File) :-
        P2H_CONVERSION(File,OrigFile),
        (atom(File) -> true
        ; File = FL_URL(Atom), atom(Atom) -> true
        ; 
            flora_decode_oid_as_atom(OrigFile,OrigFileAtm),
            flora_stderr_nl,
            flora_error_line('invalid file name: ~w', [OrigFileAtm]),
            fail
        ).

%% tries to get absolute name
get_absolute_name(InFile,AbsFile) :-
        ( flora_file_op(isabsolute,InFile) -> AbsFile=InFile

        ; current_loaded_file(LoadedFile) ->
            flora_file_op(dirname,LoadedFile,FileDir),
            flora_concat_atoms([FileDir,InFile],AbsFile)
        ;
            AbsFile=InFile
        ).

%% given file name, gets its modularized name with _module attached
modularized_file_name(InFileName, ModularFileName,Module) :-
        parse_filename(InFileName,InDir,InBase,InExt),
        url_encode(Module,Module_enc),
        flora_concat_atoms([InDir,InBase,'_',Module_enc,'.',InExt],
                           ModularFileName).

/*************************************************************************
  gpp control utilities
*************************************************************************/
%% standard gpp options used by Flora.
%% Note: @ here is replaced with spaces by gpp.
%% The first @ is needed to get the non_newline.flr test go through
/*
%% for debugging: lets you see .flr file after the gpp preprocessing
xpp_standard_options_for_compile('-F -m -nostdinc -curdirinclast -includemarker "@'FLORA_GPP_MARKUP'.@'FLORA_GPP_MARKUP'(?,''?'',''?'')."') :-
        !,
        parse:set_xppdump_on.
*/
xpp_standard_options_for_compile('-F -m -nostdinc -curdirinclast -includemarker "@'FLORA_GPP_MARKUP'.@'FLORA_GPP_MARKUP'(?,''?'',''?'')."').
/*
    For prolog_compile DO NOT do FLORA_GPP_MARKUP because then every explicit
    load of a modified Prolog program, like ?- ['foo.P'], will insert the
    markups and result in multiple warnings like 
    ++Warning[XSB]: [Compiler] .../foo : Unused symbol .../flora_terms.flh/0
    if "flora_terms.flh" or some other file is #included by foo.P

%%xpp_standard_options_for_prolog_compile('-P -m -nostdinc -curdirinclast -includemarker "@'FLORA_GPP_MARKUP'.@'FLORA_GPP_MARKUP'(?,''?'',''?'')."') :- !.
*/
xpp_standard_options_for_prolog_compile('-P -m -nostdinc -curdirinclast').
xpp_standard_options_for_dump('-F -m -nostdinc -curdirinclast').
xpp_standard_options_for_read('-P -m -nostdinc -curdirinclast').

flora_set_xpp_options_for_compile :-
        flora_set_xpp_options_for_compile(FL_DUMMYMODULE).

flora_set_xpp_options_for_compile(FL_DUMMYMODULE) :-
        !,
        flora_set_xpp_options(compile).
flora_set_xpp_options_for_compile(Module) :-
        flora_set_xpp_options(compile,Module).
flora_set_xpp_options_for_compile(Module,ExtraOpts) :-
        flora_set_xpp_options(compile,Module,ExtraOpts).
flora_set_xpp_options_for_prolog_compile(Module) :-
        flora_set_xpp_options(prolog_compile,Module).
flora_set_xpp_options_for_prolog_compile(Module,ExtraOpts) :-
        flora_set_xpp_options(prolog_compile,Module,ExtraOpts).

flora_set_xpp_options_for_dump(Module,ExtraOpts) :-
        flora_set_xpp_options(dump,Module,ExtraOpts).


flora_set_xpp_options_for_read :- flora_set_xpp_options(read).
flora_set_xpp_options_for_read(Module) :-
        flora_set_xpp_options(read,Module).
flora_set_xpp_options_for_read(Module,ExtraOpts) :-
        flora_set_xpp_options(read,Module,ExtraOpts).


flora_set_xpp_options(Purpose) :-
        flora_clear_xpp_options,
        (Purpose==read -> xpp_standard_options_for_read(StandardOpt)
        ; Purpose==dump -> xpp_standard_options_for_dump(StandardOpt)
        ; Purpose==prolog_compile ->
            xpp_standard_options_for_prolog_compile(StandardOpt)
        ; xpp_standard_options_for_compile(StandardOpt)
        ),
        (nonvar(Purpose), memberchk(Purpose,[prolog_compile,read]) -> true
        ; %% don't increment counter when loading trailers of FLD/FDB/etc. files
            %% do increment it for compile/dump
            flora_increment_counter(FLORA_COMPILATION_COUNTER,1,_,_)
        ),
        flora_concat_items([StandardOpt,' '],Opt),
        flora_assert_xpp_options(Opt).


%% This is always called before invoking GPP.
%% If Module looks like a system module name (_module) then adds
%% extra options for compiling system modules.
%% Note: This predicate should not be called before a previous call to
%% flora_set_xpp_options finishes.
%% Purpose is either read or compile.
flora_set_xpp_options(Purpose,Module) :-
        flora_clear_xpp_options,
        flora_check_module_name(Module),
        (flora_is_system_module_name(Module) ->
            ExtraOpt='-D FLORA_COMPILE_SYSTEM_MODULE'
        ; flora_check_module_name(Module) -> ExtraOpt=''
        ; flora_module_name_error(Module)
        ),
        (Purpose==read -> xpp_standard_options_for_read(StandardOpt)
        ; Purpose==dump -> xpp_standard_options_for_dump(StandardOpt)
        ; Purpose==prolog_compile
        -> xpp_standard_options_for_prolog_compile(StandardOpt)
        ; xpp_standard_options_for_compile(StandardOpt)
        ),
        (nonvar(Purpose), memberchk(Purpose,[prolog_compile,read]) -> true
        ; %% don't increment counter when loading trailers of FLD/FDB/etc. files
            %% do increment it for compile/dump
            flora_increment_counter(FLORA_COMPILATION_COUNTER,1,_,_)
        ),
        %% If Module is a system module and has a \, we have to pull it through
        %% the system exec command and then through the Prolog reader.
        %% In Unix, the \ has to be quadrupled(!) but in Windows only doubled.
        %% This is because \ is not an escape symbol in the Windows shell, so
        %% in Windows we need to worry only about preserving \ in Prolog.
        (flora_running_under(windows) ->
            flora_double_backslash(Module,ModuleDbl2)
        ; flora_double_backslash(Module,ModuleDbl),
            flora_double_backslash(ModuleDbl,ModuleDbl2)
        ),
        flora_concat_items([StandardOpt,' -D FLORA_VAR_WORKSPACE="',ModuleDbl2,
                            '" ',ExtraOpt,' '],
                           Opt),
        flora_assert_xpp_options(Opt),
        !.


%% Purpose is either read or compile
flora_set_xpp_options(Purpose,Module,ExtraOpt) :-
        flora_set_xpp_options(Purpose,Module),
        flora_add_xpp_options(ExtraOpt).

%% Adds NewOpt to the existing XPP options
flora_add_xpp_options(NewOpt) :-
        xpp_options(XOpt),
        flora_clear_xpp_options,
        flora_concat_atoms([XOpt,' ',NewOpt],Opt),
        flora_assert_xpp_options(Opt).

flora_clear_xpp_options :-
        flora_retractall_substitute(xpp_options(_)).

flora_assert_xpp_options(Options) :- assert(xpp_options(Options)).

flora_replace_xpp_options(Options) :-
        flora_clear_xpp_options,
        flora_assert_xpp_options(Options).


/*************************************************************************
  insert_code_for_loaddyn_data(+FileName)

  Add static code to the compiled .P file for loading FDB and FLD files.
*************************************************************************/
insert_code_for_loaddyn_data(FileName) :-
        %% Output the base file name only. The full path will be taken
        %% care of by flora_loaddyn_data and consult.
        parse_filename(FileName,_Dir,Base_pre,Ext),
        escape_quotes(Base_pre,Base),
        ( Ext == FLORA_FDB_EXT, FileCat='FDB', StorCat='FDB'
        ; Ext == FLORA_FLD_EXT, FileCat='FLD', StorCat='FLD'
        ; Ext == FLORA_FLM_EXT, FileCat='FLM'
        ; Ext == FLORA_FLS_EXT, FileCat='FLS', StorCat='FLS'
        ; Ext == FLORA_FLS2_EXT, FileCat='FLS2', StorCat='FLS'
        ),
        %% The above choice of FLORA_FDB_FILENAME and FLORA_FLD_FILENAME,
        %% controls whether FLD, FDB, FLS, or FLM files are to be loaded.
        %% flora_loaddyn_data/3 is used to load dynamic data
        %% or directly flora_read_canonical_and_insert/2
        %% Normally FLORA_FDB_FILENAME/FLORA_FLD_FILENAME are not defined,
        %% so data is loaded using flora_loaddyn_data/3.
        %% However, when we are trying to produce a dump of the program (where all
        %% the preprocessor stuff is stripped), then we don't need 
        %% flora_loaddyn_data/3 (whose primary purpose is to invoke
        %% the preprocessor before invoking flora_read_canonical_and_insert/2).
        %% In this case, we put the .P file through the preprocessor with
        %% FLORA_FDB_FILENAME set to ''. The result is that in the dumped
        %% program only the call to flora_read_canonical_and_insert/2 will stay.
        flora_current_out_line(' '),
        flora_current_out_line('#if !defined(FLORA_~w_FILENAME)',[FileCat]),
        flora_current_out_line('#if !defined(FLORA_LOADDYN_DATA)'),
        flora_current_out_line('#define FLORA_LOADDYN_DATA'),
        flora_current_out_line('#endif'),
        flora_current_out_line('#mode save\n#mode nocomment "%"'),
        flora_current_out_line('#define FLORA_~w_FILENAME  ''~w.~w''', [FileCat,Base,Ext]),
        flora_current_out_line('#mode restore'),
        %%flora_current_out_line('#mode save\n#mode nostring "\\!#''"'),
        flora_current_out_line('?-(:(flrutils,flora_loaddyn_data(FLORA_~w_FILENAME,FLORA_THIS_MODULE_NAME,''~w''))).',[FileCat,Ext]),
        %%flora_current_out_line('#mode restore'),
        flora_current_out_line('#else'),
        flora_current_out_line('#if !defined(FLORA_READ_CANONICAL_AND_INSERT)'),
        flora_current_out_line('#define FLORA_READ_CANONICAL_AND_INSERT'),
        flora_current_out_line('#endif'),
        ( (Ext == FLORA_FLS_EXT ; Ext == FLORA_FLS2_EXT) ->
            flora_current_out_line('?-(:(flrutils,flora_read_symbols_canonical_and_insert(FLORA_~w_FILENAME,FLORA_THIS_~w_STORAGE,_SymbolErrNum))).',[FileCat,StorCat])
        ; Ext == FLORA_FLM_EXT ->
            flora_current_out_line('?-(:(flrutils,flora_read_descriptor_metafacts_canonical_and_insert(~w,_ErrNum))).',[Base])
        ;
            flora_current_out_line('?-(:(flrutils,flora_read_canonical_and_insert(FLORA_~w_FILENAME,FLORA_THIS_~w_STORAGE))).',[FileCat,StorCat])
        ),
        flora_current_out_line('#endif'),
        flora_current_out_nl.


/*************************************************************************
  util_include_file(+OptionList,-Status)
*************************************************************************/
util_include_file([],FLORA_SUCCESS) :- !.

util_include_file([Opt|OptList],Status) :-
        flora_include(Opt,File),
        !,
        has_flora_configuration_dir(installdir,FloraDir),
        flora_slash(S),
        flora_concat_atoms([FloraDir,S,File],FullName),
        ( flora_file_op(exists,FullName) ->
            flora_copy_input(FullName,_),
            util_include_file(OptList,Status)
        ;
            flora_error_line('the ~w system file ~w cannot be found',
                             [FLSYSTEM,FullName]),
            Status = FLORA_FAILURE
        ).

util_include_file(_OptList,FLORA_FAILURE) :-
        flora_error_line('system file corrupted').


/*************************************************************************
  flora_end_of_input(+Status)
  flora_not_end_of_input(+Status)
*************************************************************************/
flora_end_of_input(Status) :- memberchk(FLORA_EOF,Status), !.
flora_not_end_of_input(Status) :- memberchk(FLORA_NOT_EOF,Status), !.


/*************************************************************************
  reset_modules_for_file(+FullFileName)
  reset_modules_for_load(+FullFileName,Module)
  reset_modules_for_add(+FullFileName)
*************************************************************************/
reset_modules_for_file(FullFileName) :-
        flora_reset_composer,
        flora_reset_lexer(FullFileName),
        flora_reset_operator,
        flora_reset_prolog,
        flora_reset_parser,
        flora_reset_compiler(file),
        flora_clear_composer_context(CONTEXT_SHELL_MODE),
        retractall(flora_compiler_environment(_,_)),
        assert(flora_compiler_environment(file,FullFileName)),
        (retract(util_stop_merging(true)) ; true),
        !.

reset_modules_for_load(FullFileName,Module) :-
        reset_modules_for_file(FullFileName),
        flora_clear_runtime_uriprefixes(Module),
        %% If ergo_textit.P is not loadable - just ignore.
        %% This happens when compiling Flora-2/Ergo from makefiles.
        catch(ergo_textit:clear_ergo_textit_facts(Module),_,true),
        %% this resets modular prolog for the compiler,
        %% does not affect the modular prolog registry
        flora_reset_modular_prolog.

reset_modules_for_add(FullFileName) :-
        reset_modules_for_file(FullFileName).


/*************************************************************************
  reset_modules_for_shell/0
*************************************************************************/
reset_modules_for_shell :-
        flora_reset_composer,
        flora_reset_lexer,
        flora_reset_compiler(shell),
        flora_set_composer_context(CONTEXT_SHELL_MODE),
        retractall(flora_compiler_environment(_,_)),
        assert(flora_compiler_environment(file,FL_SHELL_FICTITIOUS_FILENAME)),
        (retract(util_stop_merging(true)) ; true),
        !.

/*************************************************************************
  util_compile_file_add(+InputFile,+Module,+OutPFile,+OutDBFile,+OutFLDFile,
                        %%+OutFLMFile,
                        +OutFLSFile,+OutFLS2File,+OutFLTFile,
                        +OutFTXFile,
                        -FileStatus,-ErrList)
  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.

  Appropriate GPP options must be set before this predicate is called.
*************************************************************************/
%% standard variant:
util_compile_file_add(InputFile,Module,PFile,DBFile,FLDFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus) :-
        util_compile_file_add(InputFile,Module,PFile,DBFile,FLDFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,ErrList),
        print_warnings(ErrList),
        print_errors(ErrList),
        !.      

%% This version returns errors to external applications, like Interprolog;
%% does not print them
util_compile_file_add(InputFile,Module,PFile,DBFile,FLDFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,RuleDepStatus) :-
        flora_maxerr(MaxErrNum),
        flora_loader_msg_nl,
        flora_loader_message('Compiling ~w for addition to modules',[InputFile]),
        flora_walltime(WT0),
        flora_cputime(T0),
        flora_set_xpp_options_for_compile(Module),
        seeing(PreInFile),
        %% Disable the compilation for Flora-2 template include file.
        %%flora_set_counter(flora_compile_include_file,0),
        reset_modules_for_add(InputFile),
        xpp_process_file(InputFile,XPP_process,IOportFromProc),
        see(IOportFromProc),
        flora_measure_time(
                           util_rpc_file_add(MaxErrNum,0,
                                             CompiledRuleList,CompiledFactList,
                                             CompiledQueryList,CompiledLatentQueryList,
                                             UDFPredsList,
                                             TextualInfoList,
                                             RuleStatus,CompileStatus),
                           ['<Compiler> Compile time for adding to module of ',
                            InputFile, ':'],
                           compiled
                          ),
        flora_clear_compilation_permaoptions,
        !,
        %% Wait so as to not leave zombies.
        check_xpp_process_status(InputFile,XPP_process,close_on_error),
        %% Release the file descriptor used to read from gpp.
        %%close(IOportFromProc),
        seen,
        flora_clear_xpp_options,
        see(PreInFile),
        ( CompileStatus == FLORA_FAILURE ->
            DepErrList = [],
            DepErrNum = 0,
            FileStatus = FLORA_FAILURE
        ;
            flora_get_compilation_liboptions(FileOptionList),
            extract_trailer_options(InputFile,FileOptionList,
                                    %% Default options
                                    FLORA_DEFAULT_SEMANTICS,
                                    StrippedFileOptions,TrailerOptions),
            (\+flora_warnings_level(nodependency)
            -> flora_measure_time(
                                  check_for_dependencies(CompiledRuleList,
                                                         DepErrList),
                                  'Dependency checking time:',
                                  depcheck
                                 )
            ;
                flora_loader_message('Dependency checking skipped')
            ),
            count_errors(DepErrList,DepErrNum),
            ( DepErrNum > 0 -> FileStatus = FLORA_FAILURE
            ;
                (check_custom_trailer_file(TrailerOptions)
                ->
                    generate_code_add(CompiledRuleList,CompiledFactList,
                                      CompiledQueryList,CompiledLatentQueryList,
                                      %%CompiledMetaFactList,
                                      UDFPredsList,
                                      TextualInfoList,
                                      StrippedFileOptions,TrailerOptions,
                                      PFile,DBFile,FLDFile,
                                      %%FLMFile,
                                      FLSFile,FLS2File,
                                      FLTFile,FTXFile,InputFile,FileStatus)
                ; 
                    FileStatus = FLORA_FAILURE
                )
            )
        ),
        !,
        add_to_status_list(RuleStatus,DepErrNum,[depend(DepErrList)],RuleDepStatus),
        flora_cputime(T1),
        flora_walltime(WT1),
        ( FileStatus == FLORA_FAILURE ->
            util_FPJ_filename(InputFile,FPJFile),
            util_WS_filename(PFile,FLORA_DEFAULT_WORKSPACE,PROLOG_OBJFILE_EXT,Main_XWAMfile),
            util_WS_filename(DBFile,FLORA_DEFAULT_WORKSPACE,FLORA_FDB_EXT,Main_DBfile),
            util_WS_filename(FLDFile,FLORA_DEFAULT_WORKSPACE,FLORA_FLD_EXT,Main_FLDfile),
            util_WS_filename(FLSFile,FLORA_DEFAULT_WORKSPACE,FLORA_FLS_EXT,Main_FLSfile),
            util_WS_filename(FLS2File,FLORA_DEFAULT_WORKSPACE,FLORA_FLS2_EXT,Main_FLS2file),
            util_remove_filelist_carefully([PFile,DBFile,FLDFile,
                                            %%FLMFile,
                                            FLSFile,FLS2File,FTXFile,FPJFile,
                                            Main_XWAMfile,Main_DBfile,
                                            Main_FLDfile,Main_FLSfile,
                                            Main_FLS2file])
        ;
            T is T1-T0,
            WT is WT1-WT0,
            fmt_write_string(Tatm,'%1.3f',f(T)),
            fmt_write_string(WTatm,'%1.3f',f(WT)),
            flora_loader_message('Done compilation & code generation for ~w. CPU time used: ~w seconds (elapsed time: ~w seconds)',[InputFile,Tatm,WTatm])
        ),
        !.

%% Catch a failure
util_compile_file_add(_InputFile,_Mod,_PFile,_DBFile,_FLDFile,
                      _FLSFile,_FLS2File,_FLTFile,_FTXFile,
                      FLORA_FAILURE,NO_ERRORS).

/*************************************************************************
  generate_code_add(+CompiledRuleList,+CompiledFactList,
                    +CompiledQueryList,+CompiledLatentQueryList,
                    %%+CompiledMetaFactList,
		    +UDFPredsList,+TextualInfoList,
		    +FileOptionList,+TrailerOptions,+PFile,+DBFile,+FLDFile,
		    %%+FLMFile,
		    +FLSFile,+FLS2File,+FLTFile,+FTXFile,+InputFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
generate_code_add(CompiledRuleList,CompiledFactList,CompiledQueryList,CompiledLatentQueryList,UDFPredsList,TextualInfoList,FileOptionList,TrailerOptions,PFile,DBFile,FLDFile,FLSFile,FLS2File,FLTFile,FTXFile,InputFile,FileStatus) :-
        %% Generate FLD file for undefinedness checking
        flora_debug_code(CompiledRuleList,CompiledFactList,FLDFile),
        %% Generate symbol file - fls
        util_symbol_context_info(FLSFile,FLS2File,InputFile),
        %% Generate file with tabled predicates - flt
        util_save_tabled_udf_predicates(FLTFile,UDFPredsList,FLTStatus),
        (FLTStatus = NULL -> FLTFileOrStatus = FLTStatus
        ; FLTFileOrStatus = FLTFile
        ),
        util_save_textual_info(TextualInfoList,FTXFile),
        util_save_include_file_info(InputFile),
        %%flora_divide_program(CompiledRuleList,RuleList,FactList),
        sort(FileOptionList,FileOptions),
        flora_measure_time(
                           generate_Pfile_add(PFile,
                                              FileOptions,TrailerOptions,
                                              CompiledRuleList,
                                              CompiledFactList,
                                              CompiledQueryList,
                                              CompiledLatentQueryList,
                                              %%CompiledMetaFactList,
                                              DBFile,FLDFile,
                                              %%FLMFile,
                                              FLSFile,FLS2File,
                                              FLTFileOrStatus,PFileStatus),
                           '<Coder> Generating .P file for adding to module',
                           codegen
                          ),
        ( PFileStatus == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
        ;
            ( CompiledFactList == [] -> FileStatus = FLORA_SUCCESS
            ;
                flora_measure_time(
                                   flora_generate_DBfile(DBFile,CompiledFactList,FileStatus),
                                   '<Coder> Generating data file',
                                   fdb
                                  )
            )
        ),
        !.


/*************************************************************************
  generate_Pfile_add(+PFileName,+FileOptionList,+TrailerOptions,
                       +RuleList,+FactList,+QueryList,
		       +LQList,
		       %%+MetaFactList,
                       +DBFile,+FLDFile,
		       %%+FLMFile,
		       +FLSFile,+FLS2File,+FLTFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib and sysmod loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
generate_Pfile_add(PFileName,FileOptionList,TrailerOptions,RuleList,FactList,QueryList,LQList,DBFile,FLDFile,FLSFile,FLS2File,FLTFile,FileStatus) :-
        telling(PreOutFile),
        tell(PFileName),
        %% these two must be member/2, not memberchk/2, as
        %% FLSYSLIB/FLSYSMOD may repeat!
        findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),SysLibOptionList),
        findall(ModOption,member(FLSYSMOD(ModOption),FileOptionList),SysModOptionList),
        append(SysLibOptionList,SysModOptionList,OptList),
        include_xpp_control_variables(TrailerOptions),
        (memberchk(FLNONTABLEDMOD_OPT,FileOptionList) ->
            flora_current_out_line('#define FLORA_NONTABLED_MODULE\n'),
            flora_current_out_line('#define FLORA_NONTABLED_DATA_MODULE\n')
        ; memberchk(FLNONTABLEDDATAMOD_OPT,FileOptionList) ->
            flora_current_out_line('#define FLORA_NONTABLED_DATA_MODULE\n')
        ; true
        ),
        %%flora_current_out_line(':-(compiler_options([spec_off])).\n'),
        util_include_file([FLHEADER,FLHEADER_PROG],FLHeaderStatus),
        flora_get_counter(FLORA_COMPILATION_COUNTER,CompId),
        flora_current_out_line('#define FLORA_COMPILATION_ID ~w~n',[CompId]),
        %% storing absolute file names in compiled .pl files
        %% makes the code unmovable and non-portable
        %%util_FLR_filename_abs(PFileName,FlrFile),
        util_FLR_filename(PFileName,FlrFile),
        flora_current_out_line('#mode save\n#mode nocomment "%"'),
        flora_current_out_line('#define FLORA_THIS_FILENAME  ''~w''',[FlrFile]),
        flora_current_out_line('#mode restore'),
        (FLTFile == NULL -> true
        ; flora_print_define_filename_statement(FLTFile,'FLORA_FLT_FILENAME')
        ),
        %% MUST include FLHEADER3 for all tabling definitions to be included
        %% FLHEADER3 is included only in added files. 
        %% Note: FLHEADER2 is EXcluded in added files
        util_include_file([FLHEADER3],FLHeaderStatus2),
        %% we must abolish tables when adding rules, since old tables
        %% may no longer be valid
        %% USE abolish_all_tables/0, NOT flora_abolish_nonincremental_tables/0
        %% since it we are not adding facts and rules one by one in an
        %% incremental fashion -- this would be too expensive
        flora_concat_atoms(['?-(catch(abolish_all_tables,_,flora_warning_line(''',
                           WARN_TABLED_FLLOAD,
                            ''', '],
                           AbolishCommand),
        flora_current_out_line(':-(import(from(/(flora_warning_line,1),flrprint))).'),
        flora_current_out_string(AbolishCommand),
        flora_current_out_string('[''\\\\add'', FLORA_THIS_FILENAME, FLORA_THIS_MODULE_NAME]'),
        flora_current_out_line('))).'),
        %%
        %%flora_print_include_statement(FLSFile),
        %%flora_print_include_statement(FLTFile),
        ( FLHeaderStatus == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
        ; FLHeaderStatus2 == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
        ;
            %% must be member/2, not memberchk
            findall((Arity,Pos),member(FLINDEX(Arity,Pos),FileOptionList),IndexList),
            write_index_directives(IndexList),
            util_include_file(OptList,HeaderStatus),
            ( HeaderStatus == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
            ;
                flora_current_out_line('#ifndef FLORA_TABLING_METHODS_INCLUDED'),
                flora_current_out_line('#include "flora_tabling_methods.flh"'),
                flora_current_out_line('#endif'),
                non_udf_user_modular_prlgdefs(ModularPlgPredLst),
                (ModularPlgPredLst \== [] ->
                    util_add_conditional_modular_prlg_bridge_rules(ModularPlgPredLst)
                ; true
                ),
                (FactList == [] -> true
                ; insert_code_for_loaddyn_data(DBFile)
                ),
                /*
                (MetaFactList == [] -> true
                ; insert_code_for_loaddyn_data(FLMFile)
                ),
                */
                insert_code_for_loaddyn_data(FLDFile),
                insert_code_for_loaddyn_data(FLSFile),
                flora_current_out_line('\n%%%%%%%%%%%%%%%%%%%%%%%%%%% Rule insertion statements %%%%%%%%%%%%%%%%%%%%%%%%%%'),
                flora_current_out_line('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'),
                flora_extern_code(RuleList,CoderStatus1),
                util_save_latent_query_signatures(LQList,LQStatus),
                util_save_query_code(QueryList,QueryStatus),
                %% FLS2File contains symbols to be checked AFTER loading
                %% (to allow any relevant declarations to be taken into account)
                insert_code_for_loaddyn_data(FLS2File),
                ( CoderStatus1 == NO_ERRORS,
                    LQStatus == NO_ERRORS,
                    QueryStatus == NO_ERRORS
                -> FileStatus = FLORA_SUCCESS
                ;
                    append_lists([CoderStatus1,LQStatus,QueryStatus],CoderStatus),
                    print_errors([coder(CoderStatus)]),
                    FileStatus = FLORA_FAILURE
                )
            )
        ),
        told,
        tell(PreOutFile),
        !.


/*************************************************************************
  util_compile_file(+InputFile,+Module,
                               +OutputPFile,+OutputDBFile,+OutputFLDFile,
                               +OutputFLMFile,
                               +OutputFLSFile,+OutputFLS2File,+OutputFLTFile,
			       +OutputFTXFile,
			       -FileStatus,-ErrList)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.

        The appropriate GPP options must be set before this predicate is called.
*************************************************************************/
%% Standard variant:
util_compile_file(InputFile,Module,PFile,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus) :-
        util_compile_file(InputFile,Module,PFile,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,ErrList),
        print_warnings(ErrList),
        print_errors(ErrList),
        !.

util_compile_file(InputFile,Module,PFile,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,FileStatus,RuleDepStatus) :-
        flora_maxerr(MaxErrNum),
        flora_loader_msg_nl,
        flora_loader_message('Compiling ~w',[InputFile]),
        flora_walltime(WT0),
        flora_cputime(T0),
        flora_set_xpp_options_for_compile(Module),
        seeing(PreInFile),
        %% Disable the compilation for Flora-2 template include file.
        %%flora_set_counter(flora_compile_include_file,0),
        reset_modules_for_load(InputFile,Module),
        xpp_process_file(InputFile,XPP_process,IOportFromProc),
        %%copyIOport(IOportFromProc,2), %% to see gpp output
        see(IOportFromProc),
        flora_measure_time(
                           util_rpc_file(MaxErrNum,0,
                                         CompiledRuleList,
                                         CompiledSigList,
                                         CompiledFactList,
                                         CompiledQueryList, CompiledLatentQueryList,
                                         CompiledMetaFactList,UDFPredsList,
                                         TextualInfoList,
                                         RuleStatus,CompileStatus),
                           ['<Compiler> Compile time for ', InputFile, ':'],
                           compiled
                          ),
        flora_clear_compilation_permaoptions,
        !,
        %% Wait so as to not leave zombies.
        check_xpp_process_status(InputFile,XPP_process,close_on_error),
        %% Release the file descriptor used to read from gpp.
        %%close(IOportFromProc),
        seen,
        flora_clear_xpp_options,
        see(PreInFile),
        ( CompileStatus == FLORA_FAILURE ->
            DepErrList = [],
            DepErrNum = 0,
            FileStatus = FLORA_FAILURE
        ;
            flora_get_compilation_liboptions(FileOptionList),
            extract_trailer_options(InputFile,FileOptionList,
                                    %% Default options
                                    FLORA_DEFAULT_SEMANTICS,
                                    StrippedFileOptions,TrailerOptions),
            (\+flora_warnings_level(nodependency) ->
                flora_measure_time(
                                   check_for_dependencies(CompiledRuleList,
                                                          DepErrList),
                                   'Dependency checking time:',
                                   depcheck
                                  )
            ;
                flora_loader_message('Dependency checking skipped')
            ),
            count_errors(DepErrList,DepErrNum),
            ( DepErrNum > 0 -> FileStatus = FLORA_FAILURE
            ;
                (check_custom_trailer_file(TrailerOptions) ->
                    generate_code(CompiledRuleList,CompiledSigList,
                                  CompiledFactList,
                                  CompiledQueryList, CompiledLatentQueryList,
                                  CompiledMetaFactList,UDFPredsList,
                                  TextualInfoList,
                                  StrippedFileOptions,TrailerOptions,
                                  PFile,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,
                                  FLTFile,FTXFile,InputFile,FileStatus)
                ; 
                    FileStatus = FLORA_FAILURE
                )
            )
        ),
        add_to_status_list(RuleStatus,DepErrNum,[depend(DepErrList)],RuleDepStatus),
        !,
        flora_cputime(T1),
        flora_walltime(WT1),
        ( FileStatus == FLORA_FAILURE ->
            util_FPJ_filename(InputFile,FPJFile),
            util_WS_filename(PFile,FLORA_DEFAULT_WORKSPACE,PROLOG_OBJFILE_EXT,Main_XWAMfile),
            util_WS_filename(DBFile,FLORA_DEFAULT_WORKSPACE,FLORA_FDB_EXT,Main_DBfile),
            util_WS_filename(FLDFile,FLORA_DEFAULT_WORKSPACE,FLORA_FLD_EXT,Main_FLDfile),
            util_WS_filename(FLMFile,FLORA_DEFAULT_WORKSPACE,FLORA_FLM_EXT,Main_FLMfile),
            util_WS_filename(FLSFile,FLORA_DEFAULT_WORKSPACE,FLORA_FLS_EXT,Main_FLSfile),
            util_WS_filename(FLS2File,FLORA_DEFAULT_WORKSPACE,FLORA_FLS2_EXT,Main_FLS2file),
            util_remove_filelist_carefully([PFile,DBFile,FLDFile,FLMFile,
                                            FLSFile,FLS2File,FTXFile,FPJFile,
                                            Main_XWAMfile,Main_DBfile,
                                            Main_FLDfile,Main_FLMfile,
                                            Main_FLSfile,Main_FLS2file])
        ;
            T is T1-T0,
            WT is WT1-WT0,
            fmt_write_string(Tatm,'%1.3f',f(T)),
            fmt_write_string(WTatm,'%1.3f',f(WT)),
            flora_loader_message('Done compilation & code generation for ~w. CPU time used: ~w seconds (elapsed time: ~w seconds)',[InputFile,Tatm,WTatm])
        ),
        !.

%% Catch a failure situation.
util_compile_file(_InputFile,_Mod,_PFile,_DBFile,_FLDFile,_FLMFile,_FLSFile,_FLS2File,_FLTFile,_FTXFile,FLORA_FAILURE,NO_ERRORS).


/*************************************************************************
  generate_code(+CompiledRuleList,+CompiledSigList,+CompiledFactList,+CompiledQueryList,+CompiledLatentQueryList,+CompiledMetaFactList,+UDFPredsList,+FileOptionList,+TrailerOptions,+PFile,+DBFile,+FLDFile,+FLMFile,+FLSFile,+FLS2File,+FLTFile,+FTXFile,+InputFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
generate_code(CompiledRuleList,CompiledSigList,CompiledFactList,CompiledQueryList,CompiledLatentQueryList,CompiledMetaFactList,UDFPredsList,TextualInfoList,FileOptionList,TrailerOptions,PFile,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,InputFile,FileStatus) :-
        %% Generate FLD file for undefinedness checking
        flora_measure_time(
                           flora_debug_code(CompiledRuleList,CompiledFactList,
                                            FLDFile),
                           '<Coder> Generating debuging information',
                           fld
                          ),
        %% Generate .flm containing meta predicates
        util_save_meta_info(CompiledMetaFactList,FLMFile,_MetaStatus),
        %% Generate symbol file - fls
        util_symbol_context_info(FLSFile,FLS2File,InputFile),
        %% Generate file with tabled predicates - flt
        util_save_tabled_udf_predicates(FLTFile,UDFPredsList,FLTStatus),
        (FLTStatus = NULL -> FLTFileOrStatus = FLTStatus
        ; FLTFileOrStatus = FLTFile
        ),
        util_save_textual_info(TextualInfoList,FTXFile),

        ((memberchk(ERGO_STRUCTURE_DB_OPTION,FileOptionList)
         ; flora_runtime_switch_registry(ERGO_STRUCTURE_DB_OPTION(on),_Mod)
         )
        -> util_save_structural_db(CompiledSigList,InputFile)
        ; true
        ),

        util_save_include_file_info(InputFile),
        sort(FileOptionList,FileOptions),
        flora_measure_time(
                           generate_Pfile(PFile,
                                          FileOptions,TrailerOptions,
                                          CompiledRuleList,
                                          CompiledSigList,
                                          CompiledFactList,
                                          CompiledQueryList,
                                          CompiledLatentQueryList,
                                          CompiledMetaFactList,
                                          DBFile,FLDFile,FLMFile,
                                          FLSFile,FLS2File,
                                          FLTFileOrStatus,PFileStatus),
                           '<Coder> Generating .P file',
                           codegen
                          ),
        ( PFileStatus == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
        ;
            ( CompiledFactList == [] -> FileStatus = FLORA_SUCCESS
            ;
                flora_measure_time(
                                   flora_generate_DBfile(DBFile,CompiledFactList,FileStatus),
                                   '<Coder> Generating data file',
                                   fdb
                                  )
            )
        ),
        !.


/*************************************************************************
  generate_Pfile(+PFileName,+FileOptionList,+TrailerOptions,
                       +RuleList,+SignList,+FactList,
		       +QueryList,
		       +LQList,
		       +MetaFactList,
                       +DBFile,+FLDFile,+FLMFile,
		       +FLSFile,+FLS2File,+FLTFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib and sysmod loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
generate_Pfile(PFileName,FileOptionList,TrailerOptions,RuleList,SigList,FactList,QueryList,LQList,MetaFactList,DBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FileStatus) :-
        telling(PreOutFile),
        tell(PFileName),
        %% these two must be member/2, not memberchk/2, as
        %% FLSYSLIB/FLSYSMOD may repeat!
        findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),SysLibOptionList),
        findall(ModOption,member(FLSYSMOD(ModOption),FileOptionList),SysModOptionList),
        append(SysLibOptionList,SysModOptionList,OptList),
        /*
        include_xpp_control_variables/1 should be before FLHEADER2
        so that the definitions of
        FLORA_SUBSUMPTIVE_TABLING, FLORA_NONINCREMENTAL_TABLING
        will affect the tabling definitions included from FLHEADER2
        */
        include_xpp_control_variables(TrailerOptions),
        (memberchk(FLNONTABLEDMOD_OPT,FileOptionList) ->
            flora_current_out_line('#define FLORA_NONTABLED_MODULE\n'),
            flora_current_out_line('#define FLORA_NONTABLED_DATA_MODULE\n')
        ; memberchk(FLNONTABLEDDATAMOD_OPT,FileOptionList) ->
            flora_current_out_line('#define FLORA_NONTABLED_DATA_MODULE\n')
        ; true
        ),
        %%flora_current_out_line(':-(compiler_options([spec_off])).\n'),
        util_include_file([FLHEADER,FLHEADER_PROG], FLHeaderStatus),
        flora_get_counter(FLORA_COMPILATION_COUNTER,CompId),
        flora_current_out_line('#define FLORA_COMPILATION_ID ~w~n',[CompId]),
        (FLTFile == NULL -> true
        ;
            flora_print_define_filename_statement(FLTFile,'FLORA_FLT_FILENAME')
        ),
        util_include_file([FLHEADER2,FLDYNDECLARE,FLINDEX_P], FLHeaderStatus2),
        %%flora_print_include_statement(FLSFile),
        %%flora_print_include_statement(FLTFile),
        ( (FLHeaderStatus == FLORA_FAILURE ; FLHeaderStatus2 == FLORA_FAILURE)
        -> FileStatus = FLORA_FAILURE
        ;
            %% storing absolute file names in compiled .pl files
            %% makes the code unmovable and non-portable
            %%util_FLR_filename_abs(PFileName,FlrFile),
            util_FLR_filename(PFileName,FlrFile),
            flora_current_out_line('#mode save\n#mode nocomment "%"'),
            flora_current_out_line('#define FLORA_THIS_FILENAME  ''~w''',[FlrFile]),
            flora_current_out_line('#mode restore'),
            %% Use member/2, not memberchk/2!
            findall((Arity,Pos),
                    member(FLINDEX(Arity,Pos),FileOptionList),
                    IndexList),
            util_include_file([FLDEFINITION,FLTRAILERREGISTRY,
                               FLREFRESHTABLE,FLDYN_CONNECTORS,
                               FLLIBIMPORTEDCALLS,
                               FLPATCH,
                               FLOPPOSESBASELIB,
                               %% *** FLSTATICHEADLIB must be before the user
                               %% code or else flrdyncleanup.fli (included in
                               %% FLSTATICHEADLIB) will wipe out the rules
                               %% inserted by the user code.
                               FLSTATICHEADLIB
                              |OptList],
                              HeaderStatus),
            write_index_directives(IndexList),
            ( HeaderStatus == FLORA_FAILURE -> FileStatus = FLORA_FAILURE
            ;
                udf_user_modular_prlgdefs(ModularPlgPredLst),
                (ModularPlgPredLst \== [] ->
                    util_add_modular_prlg_bridge_rules(ModularPlgPredLst,beginning)
                ; true
                ),
                (FactList == [] -> true
                ; insert_code_for_loaddyn_data(DBFile)
                ),
                (MetaFactList == [] -> true
                ; insert_code_for_loaddyn_data(FLMFile)
                ),
                insert_code_for_loaddyn_data(FLDFile),
                insert_code_for_loaddyn_data(FLSFile),
                flora_current_out_line('\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rules %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),
                flora_current_out_line('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'),
                flora_extern_code(RuleList,CoderStatus2),
                flora_current_out_line('\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Rule signatures %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),
                flora_current_out_line('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'),
                flora_extern_code(SigList,CoderStatus1),
                util_save_latent_query_signatures(LQList,LQStatus),
                util_save_query_code(QueryList,QueryStatus),
                %% FLS2File has symbol declarations to be checked AFTER loading
                %% (to allow any relevant declarations to be taken into account)
                insert_code_for_loaddyn_data(FLS2File),

                %% storing absolute file names in compiled .pl files
                %% makes the code unmovable and non-portable
                %%util_FLR_filename_abs(FLDFile,FlrFile),
                util_FLR_filename(FLDFile,FlrFile),
                flora_current_out_line('?-(:(flrutils,util_load_structdb(''~w'',FLORA_THIS_MODULE_NAME))).~n',[FlrFile]),

            ( CoderStatus1 == NO_ERRORS,
                CoderStatus2 == NO_ERRORS,
                LQStatus == NO_ERRORS,
                QueryStatus == NO_ERRORS
            ->
                util_include_file([FLTRAILER,FLPREDDEF],FileStatus),
                (ModularPlgPredLst \== [], FileStatus == FLORA_SUCCESS -> 
                    util_add_modular_prlg_bridge_rules(ModularPlgPredLst,end)
                ; true
                )
            ;
                append_lists([CoderStatus1,CoderStatus2,LQStatus,QueryStatus], CoderStatus),
                print_errors([coder(CoderStatus)]),
                FileStatus = FLORA_FAILURE
            )
            )
        ),
        told,
        tell(PreOutFile),
        !.

/*************************************************************************
  write_index_directives(+IndexList)
  For every pair (A,P) in the list, generate code (assuming A+1=A1,P+1=P1)
  :- index WRAP_NONTABLED_HILOG/A1-P1.
  ?- index(FLDYNAPREFIX(WRAP_NONTABLED_HILOG)/A1,P1).
  ?- index(FLDYNZPREFIX(WRAP_NONTABLED_HILOG)/A1,P1).
or
  :- index WRAP_TABLED_HILOG/A1-P1.
  ?- index(FLDYNAPREFIX(WRAP_TABLED_HILOG)/A1,P1).
  ?- index(FLDYNZPREFIX(WRAP_TABLED_HILOG)/A1,P1).
*************************************************************************/
write_index_directives([]) :- !.
write_index_directives([(A,P)|L]) :-
        ( A=FLTRANSACTIONALNUMBER(NA,_I) ->
            A1 is NA+1,
            Type=nontabled
        ;
            A1 is A+1,
            Type=tabled
        ),
        P1 is P+1,
        flora_write_atom(':-(index(''/''(FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
            flora_write_atom(WRAP_NONTABLED_HILOG)
        ;
            flora_write_atom(WRAP_TABLED_HILOG)
        ),
        flora_write_atom('),'),
        flora_current_out_string('~w',A1),
        flora_current_out_string('-'),
        flora_current_out_string('~w',P1),
        flora_current_out_string('))).'),
        flora_current_out_nl,
        flora_write_atom('?-(index(FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
            flora_write_atom(FLDYNAPREFIX(WRAP_NONTABLED_HILOG))
        ;
            flora_write_atom(FLDYNAPREFIX(WRAP_TABLED_HILOG))
        ),
        flora_write_atom(')/'),
        flora_current_out_string('~w',A1), flora_current_out_string(','),
        flora_current_out_string('~w',P1), flora_current_out_string('))'),
        flora_current_out_string('.'), flora_current_out_nl,
        flora_write_atom('?-(index(FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
            flora_write_atom(FLDYNZPREFIX(WRAP_NONTABLED_HILOG))
        ;
            flora_write_atom(FLDYNZPREFIX(WRAP_TABLED_HILOG))
        ),
        flora_write_atom(')/'),
        flora_current_out_string('~w',A1), flora_current_out_string(','),
        flora_current_out_string('~w',P1), flora_current_out_string('))'),
        flora_current_out_string('.'), flora_current_out_nl,
        write_index_directives(L).

/*************************************************************************
  flora_generate_DBfile(+DBFileName,+FactList,-FileStatus)

  Things it does:
  (1) include .flh file directive.
  (2) output header file.
  (3) factList from flora_compile/5 written directly to .fdb file
      using flora_extern_code/2
  
*************************************************************************/

flora_generate_DBfile(DBFileName,FactList,FileStatus) :-
        telling(PreOutFile),
        tell(DBFileName),
        %% Include Macro definitions.
        flora_current_out_line('#include "flrheader.flh"'),
        flora_get_counter(FLORA_COMPILATION_COUNTER,CompId),
        flora_current_out_line('#define FLORA_COMPILATION_ID ~w~n',[CompId]),
        flora_current_out_nl,
        flora_extern_code(FactList,CoderStatus),
        ( CoderStatus == NO_ERRORS -> FileStatus = FLORA_SUCCESS
        ;
            print_errors([coder(CoderStatus)]),
            FileStatus = FLORA_FAILURE
        ),
        told,
        tell(PreOutFile),
        !.


/*************************************************************************
  flora_loaddyn_data(+InFile,+Module,+Ext)

  This predicate reads a Flora DB/FLD/FLS/FLS2 file that contains facts
  in canonical form and inserts them into the storage trie for the module.
  The module can be either a Flora user module, or a Flora system module. In the
  latter case, it is structured term.
*************************************************************************/
flora_loaddyn_data(OrigInFile,Module,Ext) :-
        flora_check_filename(OrigInFile,InFile),
        get_absolute_name(InFile,InFileAbs),
        modularized_file_name(InFileAbs,PostGppFile,Module),
        !,
        ( flora_locate_file(InFileAbs,File) ->
            flora_loader_message('Dynamically loading ~w into module ~w',
                                 [File,Module]),
            ( Ext == FLORA_FDB_EXT,
                flora_fdb_storage_name(Module,StorageName)
            ; Ext == FLORA_FLD_EXT,
                flora_fld_storage_name(Module,StorageName)
            ; Ext == FLORA_FLS_EXT,
                flora_fls_storage_name(Module,StorageName)
            ; Ext == FLORA_FLS2_EXT,
                flora_fls_storage_name(Module,StorageName)
            ; true
            ),
            flora_walltime(WT0),
            flora_cputime(T0),
            seeing(PreInFile),
            (util_file_newerthan(PostGppFile,File) ->
                see(PostGppFile),
                ( (Ext == FLORA_FLS_EXT ; Ext == FLORA_FLS2_EXT) ->
                    flora_read_symbols_canonical_and_insert(StorageName,SymbolErrNum)
                ; Ext == FLORA_FLM_EXT ->
                    flora_read_descriptor_metafacts_canonical_and_insert(File,MetaErrNum)
                ;
                    flora_read_canonical_and_insert(StorageName)
                ),
                seen
            ;
                xpp_datafile_for_module_and_cache(File,PostGppFile,Module),
                %% Now insert data into trie
                see(PostGppFile),
                ( (Ext == FLORA_FLS_EXT ; Ext == FLORA_FLS2_EXT)
                ->
                    flora_read_symbols_canonical_and_insert(StorageName,SymbolErrNum)
                ; Ext == FLORA_FLM_EXT ->
                    flora_read_descriptor_metafacts_canonical_and_insert(File,MetaErrNum)
                ;
                    flora_read_canonical_and_insert(StorageName)
                ),
                seen,
                flora_clear_xpp_options
            ),
            see(PreInFile),
            flora_cputime(T1),
            flora_walltime(WT1),
            T is T1-T0,
            WT is WT1-WT0,
            fmt_write_string(Tatm,'%1.3f',f(T)),
            fmt_write_string(WTatm,'%1.3f',f(WT)),
            ((var(SymbolErrNum) ; SymbolErrNum == 0) ->
                flora_loader_message('Done loading ~w. CPU time used: ~w seconds (elapsed time: ~w seconds)',[File,Tatm,WTatm])
            ; %% abort loading
                flora_abort('conflicts in the use of predicate and function symbols found', FLORA_ABORT_NOTRACE)
            ),
            ((var(MetaErrNum) ; MetaErrNum == 0) -> true
            ; %% abort loading
                flora_abort('duplicate rule Ids found', FLORA_ABORT_NOTRACE)
            )
        %% FLS2 files are usually absent
        ; Ext == FLORA_FLS2_EXT -> true
        ;
            flora_concat_atoms(['file ',InFileAbs,' does not exist - recompile'], ErrMsg),
            flora_abort(ErrMsg,FLORA_ABORT_NOTRACE)
        ),
        !.


/*************************************************************************
  flora_read_canonical_and_insert(+StorageName)

  Read the current input in canonical form and insert all facts
  into the storage trie.
*************************************************************************/
flora_read_canonical_and_insert(StorageName) :-
        repeat,
        read_canonical(Term),
        ( Term == end_of_file -> true
        ;
            put_attr_and_insert_fact(StorageName,Term),
            fail
        ),
        flora_increment_update_counter.

/*************************************************************************
  flora_read_descriptor_metafacts_canonical_and_insert(+File,-ErrNm)

  Read the current input in canonical form and insert all facts
  into the storage trie.
*************************************************************************/
flora_read_descriptor_metafacts_canonical_and_insert(File,ErrNumFinal) :-
        flora_set_counter(flora_load_errors,0),
        flora_set_counter(flora_load_warnings,0),
        repeat,
        read_canonical(Term),
        ( Term == end_of_file, !
        ; functor(Term,FL_RULE_ENABLER,3),
            call(Term)
        ->
            arg(1,Term,RuleId),
            arg(2,Term,RFN),
            arg(3,Term,Module),
            parse_filename(File,_,Base,_),
            file_ext_printable_alternatives(FLORA_FILE_EXT_ALT,FileExtAlts),
            flora_concat_atoms([Base,'.',FileExtAlts],ErrFile),
            (RFN = FL_DYNRULE_FICTITIOUS_FILENAME(ShortFName) -> true
            ; ShortFName = RFN
            ),
            (flora_load_registry(LikelyPrevFile,Module,ShortFName,_,_,_,_)  ->
                PrevFilenameMsg = ':\n\t\t likely in file '
            ; PrevFilenameMsg = '', LikelyPrevFile = ''
            ),
            flora_decode_oid_as_atom(RuleId,RuleIdAtm),
            flora_concat_atoms(['another rule with Id (',
                                RuleIdAtm,',',RFN,',',Module,
                                ') already exists',
                                PrevFilenameMsg, LikelyPrevFile],
                               Mesg),
            util_load_metafact_error(ErrFile,Mesg),
            fail
        ;
            asserta(Term),
            fail
        ),
        !,
        flora_get_counter(flora_load_errors,ErrNumFinal),
        print_load_error_count(ErrNumFinal),
        flora_increment_update_counter.


/*************************************************************************
  flora_read_symbols_canonical_and_insert(+StorageName,ErrNum)

  Read the current input in canonical form and insert all facts
  into the storage trie. Checks for symbols usage
*************************************************************************/
flora_read_symbols_canonical_and_insert(StorageName,ErrNumFinal) :-
        flora_set_counter(flora_load_errors,0),
        flora_set_counter(flora_load_warnings,0),
        flora_fls_storage_name(CommonFLSstorage),
        repeat,
        read_canonical(Term),
        ( Term == end_of_file, !
        ; Term = symbol_warnings_flag(_Flag,FileName)->
            storage_insert_fact(StorageName,Term,_Inserted),
            fail
        ; Term = flora_symbol(SymbolName,SymbolArity,WS,SymbolIndex,SymbolLine,USE_UDF_SYMBOL,SymbolTransactional,FileName),
            %% Note: we are testing in the same storage name == same module.
            %% Therefore, the WS argument is unimportant
            \+ flora_storage_find_fact(StorageName,flora_symbol(SymbolName,SymbolArity,_WS,_UsedIndex,_UsedLine,UDF_SYMBOL,SymbolTransactional,_UsedFileName))
        ->
            compiling_error(SymbolIndex,ERROR_UDF_WITHOUT_DEFINITION,Stat),
            ContextStatus = [Stat],
            util_load_symbol_context_error(ContextStatus,SymbolLine,SymbolName,FileName,ErrNum),
            storage_insert_fact(StorageName,Term,_Inserted),
            fail
        ; Term = flora_symbol(SymbolName,SymbolArity,WS,SymbolIndex,SymbolLine,UDF_SYMBOL,SymbolTransactional,FileName),
            %% If there is another function definition for the same symbol/arity
            %% in a previous file, give an error
            flora_storage_find_fact(StorageName,flora_symbol(SymbolName,SymbolArity,_WS,_UsedIndex,UsedLine,UDF_SYMBOL,SymbolTransactional,UsedFileName)),
            %% \+ flora_storage_find_fact(StorageName,flora_nowarn_symbol(SymbolName,SymbolArity,_,UDF_SYMBOL,SymbolTransactional,FileName)),
            UsedFileName\=FileName
        ->
            compiling_error(SymbolIndex,
                            [ERROR_OVERRIDING_UDF,
                             ' (prior definition: file ',UsedFileName,', line ',UsedLine,')'],
                            Stat),
            ContextStatus = [Stat],
            util_load_symbol_context_error(ContextStatus,SymbolLine,SymbolName,FileName,ErrNum),
            storage_insert_fact(StorageName,Term,_Inserted),
            fail
        ; Term = flora_symbol(SymbolName,SymbolArity,WS,SymbolIndex,SymbolLine,UDF_SYMBOL,SymbolTransactional,FileName),
            %% If there is a hilog predicate of the same arity defined in a previous file, give an error
            flora_storage_find_fact(StorageName,flora_symbol(HILOG_SYMBOL_NAME,SymbolArity,_WS,_UsedIndex,UsedLine,FUNCTION_SYMBOL,SymbolTransactional,UsedFileName)),
            UsedFileName\=FileName
        ->
            compiling_error(SymbolIndex,
                            [ERROR_HILOG_UDF,
                             ' ',UsedFileName,', line ',UsedLine],
                            Stat),
            ContextStatus = [Stat],
            util_load_symbol_context_error(ContextStatus,SymbolLine,SymbolName,FileName,ErrNum),
            storage_insert_fact(StorageName,Term,_Inserted),
            fail
        ; Term = flora_symbol(SymbolName,SymbolArity,WS,SymbolIndex,SymbolLine,USE_SENSOR_SYMBOL,SymbolTransactional,FileName),
            \+ flora_storage_find_fact(CommonFLSstorage,flora_symbol(SymbolName,SymbolArity,_WS,_UsedIndex,_UsedLine,SENSOR_SYMBOL,SymbolTransactional,_UsedFileName))
        ->
            compiling_error(SymbolIndex,ERROR_SENSOR_WITHOUT_DEFINITION,Stat),
            ContextStatus = [Stat],
            util_load_symbol_context_error(ContextStatus,SymbolLine,SymbolName,FileName,ErrNum),
            storage_insert_fact(StorageName,Term,_Inserted),
            fail

        ; Term = flora_symbol(SymbolName,SymbolArity,WS,SymbolIndex,SymbolLine,SymbolContext,SymbolTransactional,FileName), SymbolName\=HILOG_SYMBOL_NAME,
            (flora_storage_find_fact(StorageName,flora_symbol(SymbolName,UsedArity,_,_UsedIndex,UsedLine,UsedContext,UsedTransactional,UsedFileName))
            ; flora_storage_find_fact(CommonFLSstorage,flora_symbol(SymbolName,UsedArity,_,_UsedIndex,UsedLine,UsedContext,UsedTransactional,UsedFileName))
            ),
            (UsedFileName\=FileName
            %% The temp file is allowed here as an exception to enable
            %% testing using the [_] program input method.
            %% This isn't always correct: might cause wrong warnings sometimes.
            %% However, we are not catering to the [_] and [+_] cases here.
            ; FileName == 'tmp$user.flr'
            )
        ->
            make_symbol_context_load_status(StorageName,UsedLine,UsedFileName,UsedContext,UsedTransactional,UsedArity,SymbolName,SymbolArity,WS,SymbolIndex,SymbolContext,SymbolTransactional,ContextStatus),
            util_load_symbol_context_error(ContextStatus,SymbolLine,SymbolName,FileName,ErrNum),
            util_load_symbol_context_warn(ContextStatus,SymbolLine,SymbolName,FileName,WarnNum),
            flora_increment_counter(flora_load_warnings,WarnNum,_,_),
            %% sensors are module-independent, so they go into common FLS tries
            (SymbolContext == SENSOR_SYMBOL
            -> storage_insert_fact(CommonFLSstorage,Term,_Inserted)
            ; storage_insert_fact(StorageName,Term,_Inserted)
            ),
            fail
        ; Term = flora_symbol(_,_,_,_,_,SENSOR_SYMBOL,_,_)
        -> %% sensors are module-independent, so they go into common FLS tries
            storage_insert_fact(CommonFLSstorage,Term,_Inserted),
            fail
        ;
            storage_insert_fact(StorageName,Term,_Inserted),
            fail
        ),
        flora_get_counter(flora_load_errors,ErrNumFinal),
        flora_get_counter(flora_load_warnings,WarnNumFinal),
        print_warn_count(WarnNumFinal),
        print_load_error_count(ErrNumFinal),
        flora_increment_update_counter.



/*************************************************************************
find_nowarn_any_symbol(+StorageName,+SymbolName,+SymbolArity,+SymbolWS,+SymbolContext,+SymbolTransactional)
Returns true if symbol was specified in a symbol_context directive
in another loaded file - either in a particular SymbolContext or in any context
(as Symbol/?)
*************************************************************************/

find_nowarn_any_symbol(StorageName,SymbolName,SymbolArity,SymbolWS,_SymbolContext,SymbolTransactional) :-
        flora_storage_find_fact(StorageName,flora_nowarn_symbol(SymbolName,SymbolArity,SymbolWS,ANY_SYMBOL_CONTEXT,SymbolTransactional,_)),
        !.

find_nowarn_any_symbol(StorageName,SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional) :-
        flora_storage_find_fact(StorageName,flora_nowarn_symbol(SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional,_)).

/*************************************************************************
find_nowarn_any_symbol_any_arity(+StorageName,+SymbolName,+SymbolArity,+SymbolWS,+SymbolContext,+SymbolTransactional)
Returns true if symbol was specified in a symbol_context directive
in another loaded file - either with SymbolContext or with ANY_SYMBOL_CONTEXT
and either with a constant SymbolArity or variable arity (?)
*************************************************************************/

find_nowarn_any_symbol_any_arity(StorageName,SymbolName,_SymbolArity,SymbolWS,SymbolContext,SymbolTransactional) :-
        find_nowarn_any_symbol(StorageName,SymbolName,FL_STAR,SymbolWS,SymbolContext,SymbolTransactional),
        !.

find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional) :-
        find_nowarn_any_symbol(StorageName,SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional).


/*************************************************************************
make_symbol_context_load_status(+StorageName,+UsedLine,+UsedFile,+UsedContext,+UsedTransactional,+UsedArity,+SymbolName,+SymbolArity,+WS,+SymbolIndex,+SymbolContext,+SymbolTransactional,+ContextStatus)
*************************************************************************/
%% This case is handled differently from the compiler (error instead of warning)
make_symbol_context_load_status(_StorageName,UsedLine,UsedFile,UDF_SYMBOL,_UsedTransactional,UsedArity,_SymbolName,SymbolArity,_WS,SymbolIndex,FUNCTION_SYMBOL,_SymbolTransactional,ContextStatus) :-
        UsedArity==SymbolArity,
        !,
        compiling_error(SymbolIndex,
                        [WARN_FUNC_UDF_SYMBOL,
                         ' on line ', UsedLine,
                         ' in file ', UsedFile],
                        Err),
        ContextStatus=[Err].

%% This case is handled differently from the compiler (error instead of warning)
make_symbol_context_load_status(_StorageName,UsedLine,UsedFile,FUNCTION_SYMBOL,_UsedTransactional,UsedArity,_SymbolName,SymbolArity,_WS,SymbolIndex,UDF_SYMBOL,_SymbolTransactional,ContextStatus) :-
        UsedArity==SymbolArity,
        !,
        compiling_error(SymbolIndex,
                        [WARN_UDF_FUNC_SYMBOL,
                         ' on line ', UsedLine,
                         ' in file ', UsedFile],
                        Err),
        ContextStatus=[Err].

%% this case is not covered by the compiler, so must be here
make_symbol_context_load_status(_StorageName,UsedLine,UsedFile,PROLOG_SYMBOL,_UsedTransactional,UsedArity,_SymbolName,SymbolArity,_WS,SymbolIndex,PREDICATE_SYMBOL,_SymbolTransactional,ContextStatus) :-
        UsedArity==SymbolArity,
        !,
        compiling_error(SymbolIndex,
                        [ERROR_PREDICATE_PROLOG_SYMBOL,
                         ' on line ', UsedLine,
                         ' in file ', UsedFile],
                        Err),
        ContextStatus=[Err].

make_symbol_context_load_status(StorageName,UsedLine,UsedFile,UsedContext,UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SymbolContext,SymbolTransactional,ContextStatus) :-
        flora_concat_atoms([' in file ',UsedFile],UsedFileMsg),
        symbol_context_warnings_off(StorageName,UsedLine,UsedFile,UsedContext,UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SymbolContext,SymbolTransactional),
        make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SymbolContext,SymbolTransactional,ContextStatus),
        clear_turnoff_symbol_warnings_flag.



/*************************************************************************
symbol_context_warnings_off(+StorageName,+UsedLine,+UsedFile,+UsedContext,+UsedTransactional,+UsedArity,+SymbolName,+SymbolArity,+WS,+SymbolIndex,+SymbolContext,+SymbolTransactional) :-
*************************************************************************/
%% MK: Need to add cases to warn about Prolog predicates and sensors!!!
symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,_SymbolName,_SymbolArity,_WS,_SymbolIndex,_SymbolContext,_SymbolTransactional) :-
        flora_storage_find_fact(StorageName,symbol_warnings_flag(Flag,_)),
        !,
        set_turnoff_symbol_warnings_flag(Flag).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,_WS,_SymbolIndex,FUNCTION_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,_,FUNCTION_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,_WS,_SymbolIndex,UDF_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,_,UDF_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,_WS,_SymbolIndex,PROLOG_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,_,PROLOG_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,_WS,_SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,StoredWS,PREDICATE_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF),
        %% If StoredWS is anonymous variable - then ignore warnings
        is_flvariable(StoredWS,VarName,_VarIndex),
        VarName == FL_UNDERSCORE.

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,NULL,_SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional):-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,NULL,PREDICATE_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,NULL,_SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,FL_THISMODULE,PREDICATE_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,SymbolName,SymbolArity,WS,_SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional) :-
        find_nowarn_any_symbol_any_arity(StorageName,SymbolName,SymbolArity,WS,PREDICATE_SYMBOL,SymbolTransactional),
        !,
        set_turnoff_symbol_warnings_flag(FLORA_WARNOFF).

symbol_context_warnings_off(_StorageName,_UsedLine,_UsedFile,_UsedContext,_UsedTransactional,_UsedArity,_SymbolName,_SymbolArity,_WS,_SymbolIndex,_SymbolContext,_SymbolTransactional).


%% Attach attribute FLSYSRULEUPDATE before inserting fact into trie
%% The only possible case is that there is FLSYSRULEUPDATE (ie, a rule)
%% in Term, which was inside a fact (as a reified rule).
%% After the attribute is attached, flora_db_insert_base is called so that
%% the fact will have an attributed var in it. If the corresponding rule
%% is ever asserted in the program, its vars will be checked for
%% singletons and safety.
put_attr_and_insert_fact(StorageName,','(var_val(Var,AttrName,Val),Term)) :-
        !,
        flora_put_attr(Var,AttrName,Val),
        put_attr_and_insert_fact(StorageName,Term).

put_attr_and_insert_fact(StorageName,Term) :-
        flora_db_insert_base_fast(StorageName,Term).


/*************************************************************************
  
  flora_save_module_util(+Module,+File)
  flora_save_module_util(+File)
  Purpose: -save Module into File
           -if Module is omitted, main by defaut
	   -high level, mainly locating the File[.flr]
  Comments: -if File[.flr|.ergo] already exists it will be replaced
                or a new File will be created
	   
*************************************************************************/

flora_save_module_util(Module,OrigFile) :-
        flora_check_filename(OrigFile,File),
        valid_flora_module_name(Module),
        
        ( flora_locate_file(File,FLORA_FILE_PREFERRED_EXT,FlrFile) ->
            flora_loader_message('replacing the old ~w', [FlrFile]),
            save_module_internal(Module,FlrFile)
        ; 
            util_FLR_filename(File,FlrFile),
            flora_loader_message('~w is created',[FlrFile]),
            save_module_internal(Module,FlrFile)
        ),      
        !.      

flora_save_module_util(File) :-
        flora_save_module_util(FLORA_DEFAULT_WORKSPACE,File).


/*************************************************************************
  
  save_module_internal(+Module,+FlrFile)
  Purpose: -save Module into FlrFile
           -I/O operation and time computation
	   -output comments in target FirFile
  Comments: none
	   
*************************************************************************/

save_module_internal(Module,FlrFile) :-
        flora_loader_message('Saving module ~w in file ~w', [Module, FlrFile]),
        flora_walltime(WT0),
        flora_cputime(T0),
        telling(PreInFile),
        tell(FlrFile),
        flora_current_out_line('/* Saved contents of module ~w */', [Module]),
        flora_fdb_storage_name(Module,StorageName),
        flora_current_out_nl,
        flora_current_out_line('/* Facts of module ~w */',[Module]),
        flora_current_out_nl,
        get_then_write_facts(StorageName), flora_current_out_nl,
        flora_current_out_line('/* Rules of module ~w */',[Module]),
        flora_current_out_nl,
        get_then_write_rules(Module),                
        told,
        tell(PreInFile),
        flora_cputime(T1),
        flora_walltime(WT1),
        T is T1-T0,
        WT is WT1-WT0,
        fmt_write_string(Tatm,'%1.3f',f(T)),
        fmt_write_string(WTatm,'%1.3f',f(WT)),
        flora_loader_message('Done saving module ~w. CPU time used: ~w seconds (elapsed time: ~w seconds)',[Module,Tatm,WTatm]),
        !.


/*************************************************************************
  
  get_then_write_facts(+Storage)
  Purpose: -retrieve all the facts in Storage and write them to file
           -use backtrack to retrieve all facts in the trie
  Comments: none
	   
*************************************************************************/

get_then_write_facts(StorageName) :-
        flora_storage_find_fact(StorageName,Term),
        flora_rename_vars_meaningfully(Term),
        flora_write_fact(Term),
        flora_current_out_line('.'),
        fail.

get_then_write_facts(_StorageName).     


/*************************************************************************
  
  get_then_write_rules(+Module)
  Purpose: -retrieve all the rules in the registry and write them to file
           -use backtracking to retrieve all rules in the registry
  Comments: none
	   
*************************************************************************/

get_then_write_rules(Module) :-
        
        %% need to take head-to-body into account!
        matching_rule_signature(Id,_FileName,_DescrVarTerm,_Prefix,Head,Body,Signature),
        rule_signature_member(module,Signature,SigModule),
	rule_signature_member(h2bsig,Signature,H2B),
        %% these two are not in the user surface syntax, so not written out.
        %%rule_signature_member(prebody,Signature,PreBody),
        %%rule_signature_member(postbody,Signature,PostBody),
        (SigModule==Module ->  
            %% may need to convert Head to head form, since signatures
            %% contain head in the body form
            flora_rename_vars_meaningfully((Id,Head,Body,H2B)),
            write_rule_id(Id),
            %% TODO: Need to dump other descriptor information!
            flora_write_rule_head(Head),
            flora_current_out_string(' :- '),
            (H2B \== null ->
                flora_write_rule_body(H2B),
                flora_current_out_string(', ')
            ; true
            ),
            flora_write_rule_body(Body),
            flora_current_out_line('.'),
            flora_current_out_nl        
        ),

        fail.

get_then_write_rules(_Module).  

write_rule_id(Id) :-
        flora_current_out_string(FL_RULEID_OP),
        put(CH_LBRACE),
        flora_write_oid(Id),
        put(CH_RBRACE),
        put(CH_SPACE).



/*************************************************************************
  flora_read_canonical_and_insert(+File,+StorageName)
  Same as flora_read_canonical_and_insert/1, but reads a file
*************************************************************************/
flora_read_canonical_and_insert(File,StorageName) :-
        flora_loader_message('Dynamically loading ~w into storage ~w',
                             [File,StorageName]),
        seeing(OldF),
        see(File),
        flora_read_canonical_and_insert(StorageName),
        seen,
        see(OldF).

/*************************************************************************
  flora_read_symbols_canonical_and_insert(+File,+StorageName,-ErrNum)
  Same as flora_read_symbols_canonical_and_insert/2, but reads a file
*************************************************************************/
flora_read_symbols_canonical_and_insert(File,_StorageName,0) :-
        \+flora_file_op(exists,File),
        !.
flora_read_symbols_canonical_and_insert(File,StorageName,ErrNum) :-
        flora_loader_message('Dynamically loading ~w into storage ~w',
                             [File,StorageName]),
        seeing(OldF),
        see(File),
        flora_read_symbols_canonical_and_insert(StorageName,ErrNum),
        seen,
        see(OldF).

/*************************************************************************
 Commit all backtrackable updates to Flora storage
**************************************************************************/

flora_commit_storage :-
        (flora_storage_registry(StorageName),
            flora_db_commit(StorageName),
            fail
        ; true).

/*************************************************************************
 Collect garbage in Flora storage tries
 Should be called only after it is certain that backtracking 
 over deleted facts cannot occur.
**************************************************************************/
flora_reclaim_storage_space :-
        (flora_storage_registry(StorageName),
            flora_db_reclaim_space(StorageName),
            fail
        ; true
        ).


/*************************************************************************
  util_rpc_file_add(+MaxErr,+ErrNum,-CompiledRuleList,-CompiledFactList,
                    -CompiledQueryList,+CompiledLatentQueryList,
                    -TextualInfoList,
                    -UDFPredsList,-RuleStatus,-FileStatus),

  util_rpc_file_add/8 calls the lexer/composer/parser/compiler rule-by-rule.
      Each time checks if there were errors. 
*************************************************************************/
util_rpc_file_add(MaxErr,ErrNum,CompiledRuleList,CompiledFactList,
                  CompiledQueryList,CompiledLatentQueryList,
                  UDFPredsList,
                  [TextualInfo|TextualInfoList],
                  RuleStatus,FileStatus) :-
        util_read_parse_compile_add(FLORA_FILE, Tokens,
                                    CompiledRuleList-RestCompiledRuleList,
                                    CompiledFactList-RestCompiledFactList,
                                    CompiledQueryList-RestCompiledQueryList,
                                    CompiledLatentQueryList-RestCompiledLatentQueryList,
                                    UDFPredsList-RestUDFPredsList,
                                    TextualInfo,
                                    RuleStatus1),
        !,
        memberchk(error(EN),RuleStatus1),
        NewErrNum is ErrNum+EN,
        ( EN > 0 -> %% errors found in the latest compiled rule
            ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
                FileStatus = FLORA_FAILURE,
                RuleStatus1 = [_|RuleStatusSansEOF],
                RuleStatus = [FLORA_EOF|RuleStatusSansEOF],
                %% throw away rest of file to prevent hanging on process-wait
                discard_tokens_EOF

            ; flora_rule_delimiter_struct(_,_,_,_,_,RuleDelimeterToken),
                flora_not_end_of_input(RuleStatus1),
                memberchk(RuleDelimeterToken,Tokens)
            ->
                util_rpc_file_add(MaxErr,NewErrNum,
                                  _CompiledRuleList,_CompiledFactList,
                                  _CompiledQueryList,_CompiledLatentQueryList,
                                  _UDFPredsList,
                                  _TexualInfoList,
                                  RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)

            ; flora_not_end_of_input(RuleStatus1), discard_tokens ->
                util_rpc_file_add(MaxErr,NewErrNum,
                                  _CompiledRuleList,_CompiledFactList,
                                  _CompiledQueryList,_CompiledLatentQueryList,
                                  _UDFPredsList,
                                  _TexualInfoList,
                                  RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
            ;
                FileStatus = FLORA_FAILURE,
                RuleStatus = RuleStatus1
            )
        ;
            ( flora_not_end_of_input(RuleStatus1)
            ->
                util_rpc_file_add(MaxErr,NewErrNum,
                                  RestCompiledRuleList,RestCompiledFactList,
                                  RestCompiledQueryList,RestCompiledLatentQueryList,
                                  RestUDFPredsList,
                                  TextualInfoList,
                                  RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
            ; %% end of file reached
                ( NewErrNum == 0 ->
                    RestCompiledRuleList=[],
                    RestCompiledFactList=[],
                    RestCompiledQueryList=[],
                    RestCompiledLatentQueryList=[],
                    %%RestCompiledMetaFactList=[],
                    FileStatus = FLORA_SUCCESS
                ;
                    FileStatus = FLORA_FAILURE
                ),
                RuleStatus = RuleStatus1
            )
        ),
        !.


/*************************************************************************
  util_read_parse_compile_add(+Option,-Tokens,-RulesCode,-FactsCode,
                              -QueryCode,-LQCode,
                              -MetaFacts,
                              -TextualInfo,
                              -UDFPredsCode,-OptionList,-Status)

  Note: This predicate can be used to read from both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        RulesCode is a difference list in the form of List-Tail,
        where Tail is the tail of List. Tail is unbound when this predicate
        returns and so it should be set to [] later accordingly to close
        the end of the list.
	FactsCode is the same for facts.
        TextualInfo = FL_TEXTUAL_INFO_PRED(StmtNum,ShortStmtFileSpec,BegL,BegCh,EndL,EndCh)
*************************************************************************/
util_read_parse_compile_add(Option,Tokens,RulesCode,FactsCode,QueryCode,LQCode,UDFPredsCode,TextualInfo,Status) :-
        disable_all_tripwires,
        %% get InputTokens
        flora_tokens(InputTokens,LexerStatus), 
        count_errors(LexerStatus,LexErrNum),
        count_warnings(LexerStatus,LexWarnNum),
        ( LexErrNum > 0 ->
            Tokens=InputTokens,
            RulesCode=R-R,
            FactsCode=F-F,
            QueryCode=Q-Q,
            LQCode=LQ-LQ,
            %%MetaFacts=MF-MF,
            UDFPredsCode=U-U,
            ErrNum=LexErrNum

        ; flora_blank_line(InputTokens) ->
            Tokens=InputTokens,
            RulesCode=R-R,
            FactsCode=F-F,
            QueryCode=Q-Q,
            LQCode=LQ-LQ,
            %%MetaFacts=MF-MF,
            UDFPredsCode=U-U,
            ErrNum = 0
        ;
            ( Option == FLORA_COMMANDLINE ->
                construct_query_term(InputTokens,Tokens)
            ;
                Tokens=InputTokens
            ),
            %% gpp directives confuse the studio.
            %% For Flora/Ergo it does not matter because 
            %% this predicate is called after gpp has already done its work
            strip_preprocessor_directive(Tokens,CleanTokens),
            flora_compose(CleanTokens,ComposerTerm,ComposerStatus),
            count_errors(ComposerStatus,CompoErrNum),
            ( CompoErrNum > 0 ->
                RulesCode=R-R,
                FactsCode=F-F,
                QueryCode=Q-Q,
                LQCode=LQ-LQ,
                %%MetaFacts=MF-MF,
                UDFPredsCode=U-U,
                ErrNum=CompoErrNum
            ;
                flora_parse(ComposerTerm,ParserTerm,ParserStatus),
                count_errors(ParserStatus,ParErrNum),
                ( ParErrNum > 0 ->
                    RulesCode=R-R,
                    FactsCode=F-F,
                    QueryCode=Q-Q,
                    LQCode=LQ-LQ,
                    %%MetaFacts=MF-MF,
                    UDFPredsCode=U-U,
                    ErrNum=ParErrNum
                ;
                    %% compile for addition, and get RulesCode
                    %% This call does not generate MetaFacts at compile time
                    flora_compile_add(ParserTerm,RulesCode,FactsCode,QueryCode,LQCode,UDFPredsCode,StmtNum+StmtFN,CompileStat),
                    count_errors(CompileStat,CompiErrN),
                    ErrNum=CompiErrN
                )
            )
        ),

        (var(ComposerStatus) -> ComposerStatus = NO_ERRORS ; true),
        (var(ParserStatus) -> ParserStatus = NO_ERRORS ; true),
        (var(CompileStat) -> CompileStat = NO_ERRORS ; true),
        (LexErrNum+LexWarnNum > 0 ->
            LexerInfo = lexer([(InputTokens,LexerStatus)])
        ; LexerInfo = lexer(NO_ERRORS)
        ),
        %% If TokenRange = NULL then this is not a rule
        %% StmtNum should be > 0, StmtFN nonvar and not NULL.
        %% RulesCode/FactsCode/LQCode/QueryCode have the form [_|_] - _ 
        %% If they are empty (ie, head is a var or ==[]) then skip textual info
        %% Latent queries are recorded.
        %% Queries will also be recorded, as the compiler gives them a StmtNum.
        %% Facts are recorded.
        extractTokenRange(Tokens,TokenRange),
        (
          ( %% in production mode, don't generate textual info and save time
              has_compiler_persistentoption(production_mode)
          ;
              ( %% For now, don't generate textual info for facts
                  %%FactsCode = FList - _, (var(FList) ; FList == []),
                  RulesCode = RList - _, (var(RList) ; RList == []),
                  LQCode = LQList - _,   (var(LQList) ; LQList == []),
                  QueryCode = QList - _, (var(QList) ; QList == [])
              )
          ;
              %% skip textual info for directives
              var(StmtNum) ; (integer(StmtNum), StmtNum =< 0) ;
              StmtFN == NULL ; is_fldirective(ParserTerm,_,_)
          )
        -> TextualInfo = NULL
        %% skip textual info for Prolog statements
        ; RulesCode = [QLit|_] - _, nonvar(QLit), is_prquery(QLit,PLit),
          (is_prologliblit(PLit,_,_,_) ; is_prologliblit(PLit,_,_,_,_))
        -> TextualInfo = NULL
        ; TokenRange = FL_TEXTUAL_INFO_PRED(StmtNum,StmtFN,_,_,_,_)
        -> TextualInfo = TokenRange
        ; TextualInfo = NULL
        ),
        enable_all_tripwires,
        EWS=[error(ErrNum),
             LexerInfo,
             composer(ComposerStatus),
             parser(ParserStatus),
             compiler(CompileStat)],
        ( flora_end_of_input(LexerStatus) ->
            Status=[FLORA_EOF|EWS]
        ;
            Status=[FLORA_NOT_EOF|EWS]
        ).



/*************************************************************************
  util_rpc_file(+MaxErr,+ErrNum,-CompiledRuleList,-CompiledSigList,-CompiledFactList,-CompiledQueryList,-CompiledLatentQueryList,-CompiledMetaFactList,-UDFPredsList,-TextualInfoList,-RuleStatus,-FileStatus)

  util_rpc_file/9 calls the lexer/composer/compiler rule-by-rule.
      Each time checks if there have been any errors. Collects options passed
      in by the compiler into a list. These options tell which libraries
      to load, how to compose the trailer, etc.
*************************************************************************/
util_rpc_file(MaxErr,ErrNum,CompiledRuleList,CompiledSigList,CompiledFactList,CompiledQueryList,CompiledLatentQueryList,CompiledMetaFactList,UDFPredsList,[TextualInfo|TextualInfoList],RuleStatus,FileStatus) :-
        util_read_parse_compile(FLORA_FILE,Tokens,
                                CompiledRuleList-RestCompiledRuleList,
                                CompiledSigList-RestCompiledSigList,
                                CompiledFactList-RestCompiledFactList,
                                CompiledQueryList-RestCompiledQueryList,
                                CompiledLatentQueryList-RestCompiledLatentQueryList,
                                CompiledMetaFactList-RestCompiledMetaFactList,
                                UDFPredsList-RestUDFPredsList,
                                TextualInfo,
                                RuleStatus1),
        !,
        memberchk(error(EN),RuleStatus1),
        NewErrNum is ErrNum+EN,
        !,
        ( EN > 0 -> %% errors found in the latest compiled rule
            ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
                FileStatus = FLORA_FAILURE,
                RuleStatus1 = [_|RuleStatusSansEOF],
                RuleStatus = [FLORA_EOF|RuleStatusSansEOF],
                %% throw away rest of file to prevent hanging on process-wait
                discard_tokens_EOF

            ; flora_rule_delimiter_struct(_,_,_,_,_,RuleDelimeterToken),
                flora_not_end_of_input(RuleStatus1),
                memberchk(RuleDelimeterToken,Tokens)
            ->
                %% continue collecting errors, ignore compiled code
                util_rpc_file(MaxErr,NewErrNum,
                              _CompiledRuleList,
                              _CompiledSigList,
                              _CompiledFactList,
                              _CompiledQueryList,
                              _CompiledLatentQueryList,
                              _CompiledMetaFactList,_UDFPredsList,
                              _TextualInfoList,
                              RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)

            ; flora_not_end_of_input(RuleStatus1), 
                discard_tokens ->
                %% continue collecting errors, ignore compiled code
                %% here we are reading next rule while ignoring compiled code
                util_rpc_file(MaxErr,NewErrNum,
                              _CompiledRuleList,
                              _CompiledSigList,
                              _CompiledFactList,
                              _CompiledQueryList,
                              _CompiledLatentQueryList,
                              _CompiledMetaFactList,_UDFPredsList,
                              _TextualInfoList,
                              RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
            ;
                FileStatus = FLORA_FAILURE,
                RuleStatus = RuleStatus1
            )
        ;
            ( flora_not_end_of_input(RuleStatus1) ->
                util_rpc_file(MaxErr,NewErrNum,
                              RestCompiledRuleList,
                              RestCompiledSigList,
                              RestCompiledFactList,
                              RestCompiledQueryList,
                              RestCompiledLatentQueryList,
                              RestCompiledMetaFactList,RestUDFPredsList,
                              TextualInfoList,
                              RuleStatus2,FileStatus),
                merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
            ; %% end of file reached
                ( NewErrNum == 0 ->
                    RestCompiledRuleList=[],
                    RestCompiledSigList=[],
                    RestCompiledFactList=[],
                    RestCompiledQueryList=[],
                    RestCompiledLatentQueryList=[],
                    FileStatus = FLORA_SUCCESS
                ;
                    FileStatus = FLORA_FAILURE
                ),
                RuleStatus = RuleStatus1
            )
        ),
        !.


/*************************************************************************
  discard_tokens/0
  Scan the input until a rule delimiter is found. Fails if eof.
*************************************************************************/
discard_tokens :-
        flora_stdwarn_nl,
        flora_warning_line('discarding tokens (rule delimiter `.'' or EOF expected)'),
        flora_stdwarn_nl,
        discard_tokens_silent.
discard_tokens_silent :-
        repeat,
        flora_tokens(Tokens,Status),
        flora_rule_delimiter_struct(_Txt,_LN1,_CN1,_LN2,_CN2,RuleDelimeterToken),
        /*
          Tokens = [] -> true is new. Handles cases like
          ergo_query('\\true@\foo.',[],?X,?Y,?Z)@\plg(flora2).
          Without this case, the above loops.
        */
        ( Tokens = [] -> true
        ; flora_end_of_input(Status) -> flrlexer:flora_end_file(1), fail
        ; memberchk(RuleDelimeterToken,Tokens) -> true
        ;
            fail
        ).

%% discard everything till end of file
discard_tokens_EOF :-
        flora_stdwarn_nl,
        flora_warning_line('Errors found: discarding the rest of the file'),
        flora_stdwarn_nl,
        repeat,
        flora_tokens(_Tokens,Status),
        ( flora_end_of_input(Status) -> flrlexer:flora_end_file(1)
        ;
            fail
        ).


/******************************************************************************
  util_read_parse_compile(+Option,-Tokens,-RuleCode,-SignCode,-FactCode,-QueryCode,-LQCode,-MetaFactCode,-UDFPredCode,-TextualInfo,-Status)

        Read file or command line, then parse and compile.

        This predicate can be used to read both from file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        RuleList is a difference list in the form of List-Tail,
        where Tail is the tail of List. Tail is unbound when this predicate
        returns and so it should be set to [] later accordingly to close
        the end of the list.
        TextualInfo = FL_TEXTUAL_INFO_PRED(StmtNum,ShortStmtFileSpec,BegL,BegCh,EndL,EndCh)
******************************************************************************/
util_read_parse_compile(Option,Tokens,RulesCode,SignCode,FactsCode,QueryCode,LQCode,MetaFacts,UDFPredsCode,TextualInfo,Status) :-
        disable_all_tripwires,
        flora_tokens(InputTokens,LexerStatus), 
        %% get InputTokens
        count_errors(LexerStatus,LexErrNum),
        count_warnings(LexerStatus,LexWarnNum),
        ( LexErrNum > 0 ->
            Tokens=InputTokens,
            RulesCode=R-R,
            SignCode=S-S,
            FactsCode=F-F,
            QueryCode=Q-Q,
            LQCode=LQ-LQ,
            MetaFacts=M-M,
            UDFPredsCode=U-U,
            ErrNum=LexErrNum

        ; flora_blank_line(InputTokens) ->
            Tokens=InputTokens,
            RulesCode=R-R,
            SignCode=S-S,
            FactsCode=F-F,
            QueryCode=Q-Q,
            LQCode=LQ-LQ,
            MetaFacts=M-M,
            UDFPredsCode=U-U,
            ErrNum = 0
        ;
            ( Option == FLORA_COMMANDLINE ->
                construct_query_term(InputTokens,Tokens)
            ;
                %% set Tokens from InputTokens
                Tokens=InputTokens
            ),
            %% gpp directives confuse the studio.
            %% For Flora/Ergo it does not matter because 
            %% this predicate is called after gpp has already done its work
            strip_preprocessor_directive(Tokens,CleanTokens),
            flora_compose(CleanTokens,ComposerTerm,ComposerStatus),
            %%DBGOUTLN('####################' = ComposerTerm+ComposerStatus),
            count_errors(ComposerStatus,CompoErrNum),
            ( CompoErrNum > 0 ->
                RulesCode=R-R,
                SignCode=S-S,
                FactsCode=F-F,
                QueryCode=Q-Q,
                LQCode=LQ-LQ,
                MetaFacts=M-M,
                UDFPredsCode=U-U,
                ErrNum=CompoErrNum
            ;
                %% parse
                flora_parse(ComposerTerm,ParserTerm,ParserStatus),
                count_errors(ParserStatus,ParErrNum),
                ( ParErrNum > 0 ->
                    RulesCode=R-R,
                    SignCode=S-S,
                    FactsCode=F-F,
                    QueryCode=Q-Q,
                    LQCode=LQ-LQ,
                    MetaFacts=M-M,
                    UDFPredsCode=U-U,
                    ErrNum=ParErrNum
                ;
                    %% compile, and get RulesCode,FactsCode
                    flora_compile(ParserTerm,RulesCode,SignCode,FactsCode,QueryCode,LQCode,MetaFacts,UDFPredsCode,StmtNum+StmtFN,CompileStat),
                    count_errors(CompileStat,CompiErrN),
                    ErrNum=CompiErrN
                )
            )
        ),
        (var(ComposerStatus) -> ComposerStatus = NO_ERRORS ; true),
        (var(ParserStatus) -> ParserStatus = NO_ERRORS ; true),
        (var(CompileStat) -> CompileStat = NO_ERRORS ; true),
        (LexErrNum+LexWarnNum > 0 ->
            LexerInfo = lexer([(InputTokens,LexerStatus)])
        ; LexerInfo = lexer(NO_ERRORS)
        ),
        %% If TokenRange = NULL then this is not a rule
        %% StmtNum should be > 0, StmtFN nonvar and not NULL.
        %% RulesCode/FactsCode/LQCode/QueryCode have the form [_|_] - _ 
        %% If they are empty (ie, head is a var or ==[]) then skip textual info
        %% Latent queries are recorded.
        %% Queries will also be recorded, as the compiler gives them a StmtNum.
        %% Facts are recorded.
        extractTokenRange(Tokens,TokenRange),
        (
          (
            %% in production mode, don't generate textual info and save time
            has_compiler_permaoption(production_mode)
          ;
            (
              %% For now, don't generate textual info for facts
              %% FactsCode = FList - _, (var(FList) ; FList == []),
              RulesCode = RList - _, (var(RList) ; RList == []),
              LQCode = LQList - _, (var(LQList) ; LQList == []),
              QueryCode = QList - _, (var(QList) ; QList == [])
            )
          ;
            %% skip textual info for directives
            var(StmtNum) ; (integer(StmtNum), StmtNum =< 0) ;
            StmtFN == NULL ; is_fldirective(ParserTerm,_,_)
          )
        -> TextualInfo = NULL
        ; RulesCode = [PLit|_] - _, nonvar(PLit),
          (is_prologliblit(PLit,_,_,_) ; is_prologliblit(PLit,_,_,_,_))
        -> TextualInfo = NULL
        ; TokenRange = FL_TEXTUAL_INFO_PRED(StmtNum,StmtFN,_,_,_,_)
        -> TextualInfo = TokenRange
        ; TextualInfo = NULL
        ),
        enable_all_tripwires,
        EWS=[error(ErrNum),
             LexerInfo,
             composer(ComposerStatus),
             parser(ParserStatus),
             compiler(CompileStat)],
        ( flora_end_of_input(LexerStatus) ->
            Status=[FLORA_EOF|EWS]
        ;
            Status=[FLORA_NOT_EOF|EWS]
        ).


/*************************************************************************
  flora_read_then_parse_term(-ParserTerm,-Status)
  flora_read_then_parse_term(-InputTokens,-ParserTerm,-Status)

        THIS IS USED ONLY FOR PARSING DATATYPES IN flrparser.P.
        It is similar to flora_read_then_parse/2,3 but is limited
	to path expressions only.
        Generally, the user should use flora_read_then_parse/2,3
	rather than flora_read_then_parse_term/2,3.

        Read standard input (one line) then compose and parse as term
	(body pathexp).

        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        The output is ParserTerm.
        InputTokens is the list of tokens after tokenization.
        Provided because it is sometimes useful.

        flora_read_then_parse_term/2 is like flora_read_then_parse_term/3,
	but discards InputTokens.

*************************************************************************/
flora_read_then_parse_term(ParserTerm,Status) :-
        flora_read_then_parse_term(_InputTokens,ParserTerm,Status).
flora_read_then_parse_term(InputTokens,ParserTerm,Status) :-
        %% get InputTokens
        flora_tokens(InputTokens,LexerStatus), 
        count_errors(LexerStatus,LexErrNum),
        count_warnings(LexerStatus,LexWarnNum),
        ( LexErrNum > 0 -> ErrNum=LexErrNum
        ; flora_blank_line(InputTokens) -> ErrNum = 0
        ; %% compose
            flora_compose(InputTokens,ComposerTerm,ComposerStatus),
            count_errors(ComposerStatus,CompoErrNum),
            ( CompoErrNum > 0 -> ErrNum=CompoErrNum
            ; %% parse
                flora_parse_term_external(ComposerTerm,ParserTerm,ParserStatus),
                count_errors(ParserStatus,ParErrNum),
                ( ParErrNum > 0 -> ErrNum=ParErrNum
                ; ErrNum = 0
                )
            )
        ),
        (var(ComposerStatus) -> ComposerStatus = [] ; true),
        (var(ParserStatus) -> ParserStatus = [] ; true),
        (LexErrNum+LexWarnNum > 0 ->
            LexerInfo = lexer([(InputTokens,LexerStatus)])
        ; LexerInfo = lexer(NO_ERRORS)
        ),

        EWS=[error(ErrNum),
             LexerInfo,
             composer(ComposerStatus),
             parser(ParserStatus) ],
        print_warnings(EWS),
        print_errors(EWS),

        ( flora_end_of_input(LexerStatus) -> Status=[FLORA_EOF|EWS]
        ; Status=[FLORA_NOT_EOF|EWS]
        ).


#include "extensions/flrutil_extensions.P"
#include "extensions/flrutil_debug.P"


/*************************************************************************
  flora_read_then_parse(-ParserTerm,-Status)
  flora_read_then_parse(-InputTokens,-ParserTerm,-Status)

        Read standard input (one line) then parse (don't compile)
	This can be used to dump parsed Flora-2 code to XML and other formats.

        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        The parser output is ParserTerm.
        InputTokens is the list of tokens after tokenization.
        Provided because it is sometimes useful.

        flora_read_then_parse/2 is like flora_read_then_parse/3,
	but discards InputTokens.

*************************************************************************/
flora_read_then_parse(ParserTerm,Status) :-
        flora_read_then_parse(_InputTokens,ParserTerm,Status).
flora_read_then_parse(InputTokens,ParserTerm,Status) :-
        %% get InputTokens
        flora_tokens(InputTokens,LexerStatus), 
        count_errors(LexerStatus,LexErrNum),
        count_errors(LexerStatus,LexWarnNum),
        ( LexErrNum > 0 -> ErrNum=LexErrNum
        ; flora_blank_line(InputTokens) -> ErrNum = 0
        ; %% compose
            flora_compose(InputTokens,ComposerTerm,ComposerStatus),
            count_errors(ComposerStatus,CompoErrNum),
            ( CompoErrNum > 0 -> ErrNum=CompoErrNum
            ; %% parse
                flora_parse(ComposerTerm,ParserTerm,ParserStatus),
                count_errors(ParserStatus,ParErrNum),
                ( ParErrNum > 0 -> ErrNum=ParErrNum
                ; ErrNum = 0
                )
            )
        ),
        (var(ComposerStatus) -> ComposerStatus = [] ; true),
        (var(ParserStatus) -> ParserStatus = [] ; true),
        (LexErrNum+LexWarnNum > 0 ->
            LexerInfo = lexer([(InputTokens,LexerStatus)])
        ; LexerInfo = lexer(NO_ERRORS)
        ),

        EWS=[error(ErrNum),
             LexerInfo,
             composer(ComposerStatus),
             parser(ParserStatus) ],
        %%print_warnings(EWS),
        %%print_errors(EWS),

        ( flora_end_of_input(LexerStatus) -> Status=[FLORA_EOF|EWS]
        ; Status=[FLORA_NOT_EOF|EWS]
        ).

%% used mostly for testing
util_read_then_parse_file([ParserTerm|RestParsedTermList],NewStatus) :-
        flora_read_then_parse(Tokens,ParserTerm1,Status),
        !,
        ( flora_blank_line(Tokens), flora_not_end_of_input(Status),
            var(ParserTerm1) ->
            ParserTerm = '',
            util_read_then_parse_file(RestParsedTermList,RestStatusList)
        ; flora_end_of_input(Status), var(ParserTerm1) ->
            ParserTerm = '',
            RestParsedTermList = [], RestStatusList = []
        ; ParserTerm1 == [NULL] ->
            ParserTerm = '',
            util_read_then_parse_file(RestParsedTermList,RestStatusList)
        ; flora_rule_delimiter_struct(_,_,_,_,_,RuleDelimeterToken),
            flora_not_end_of_input(Status),
            memberchk(RuleDelimeterToken,Tokens)
        -> util_read_then_parse_file(RestParsedTermList,RestStatusList),
            ParserTerm = ParserTerm1
        ; flora_not_end_of_input(Status), discard_tokens_silent
        -> util_read_then_parse_file(RestParsedTermList,RestStatusList),
            ParserTerm = ParserTerm1
        ; RestParsedTermList = [], RestStatusList = [], ParserTerm = ParserTerm1
        ),
        merge_status_lists(Status,RestStatusList,NewStatus).

%% used only for testing
flora_read_then_parse_file(InputFile,ParserList) :-
        flora_read_then_parse_file(InputFile,ParserList,StatusList),
        print_warnings(StatusList),
        print_errors(StatusList).
flora_read_then_parse_file(InputFile,ParserList,StatusList) :-
        seeing(PreInFile),
        reset_modules_for_load(InputFile,FLORA_DEFAULT_WORKSPACE),
        xpp_process_file(InputFile,XPP_process,IOportFromProc),
        %%copyIOport(IOportFromProc,2), %% to see gpp output
        see(IOportFromProc),
        util_read_then_parse_file(ParserList,StatusList),
        flora_clear_compilation_permaoptions,
        !,
        %% Wait so as to not leave zombies.
        check_xpp_process_status(InputFile,XPP_process,close_on_error),
        %% Release the file descriptor used to read from gpp.
        %%close(IOportFromProc),
        seen,
        flora_clear_xpp_options,
        see(PreInFile).


/*************************************************************************
  flora_read_then_parse_string(+String,-ParserTerm,-Status)

      Uses flora_read_then_parse/3 to read and parse from string.
      This predicate is mostly for debugging.

*************************************************************************/
flora_read_then_parse_string(String,ParserTerm,Status) :-
        see_source(atom(String),IOPort,OldStdin),
        !,
        flora_read_then_parse(ParserTerm,Status),
        seen_source(IOPort,OldStdin).

flora_read_then_parse_term_string(String,ComposerTerm,Status) :-
        see_source(atom(String),IOPort,OldStdin),
        !,
        (flora_get_charpos(LN,CN) -> true ; true),
        flora_read_then_parse_term(ComposerTerm,Status),
        (integer(LN), integer(CN) -> flora_set_charpos(LN,CN)
        ; true
        ),
        seen_source(IOPort,OldStdin).

flora_read_from_source(Source,Term) :-
        see_source(Source,IOPort,OldStdin),
        catch(read(IOPort,Term),_,(seen_source(IOPort,OldStdin),fail)),
        seen_source(IOPort,OldStdin).


/*************************************************************************
  construct_query_term(+InputTokens,-Tokens)

  Construct a query term from the shell command line input. Two extra
  pairs of parentheses are added to enclose the input. This is to prevent
  the query term from being intepreted as having arity other than one.
*************************************************************************/
construct_query_term(InputTokens,Tokens) :-
        flora_symbol_token_struct("?-",1,0,1,0,QueryOpToken),
        flora_symbol_token_struct("(",1,0,1,0,LPToken),
        Tokens=[QueryOpToken,LPToken,LPToken|L],
        construct_rest_query_term(InputTokens,L).


construct_rest_query_term([T],[RPToken,RPToken,T]) :-
        !,
        %% This last one from the input tokens is the rule delimiter.
        flora_symbol_token_struct(")",1,0,1,0,RPToken).

construct_rest_query_term([T|Ts],[T|L]) :-
        construct_rest_query_term(Ts,L).


/*************************************************************************
  flora_shell_command_line(-Code,-Options,-Status)
*************************************************************************/
flora_shell_command_line(Code,Options,Status) :-
        reset_modules_for_shell,
        util_read_parse_compile(FLORA_COMMANDLINE,Tokens,
                                Rules-[],Signatures-[],Facts-[],
                                Queries-[],_LQs-[],
                                _MetaFacts-[],
                                _UDFPredsCode,
                                _TextualInfo,
                                RuleStatus),
        !,
        %% Trailer options will always be empty list in the shell
        flora_get_compilation_liboptions(RuleOptions),
        strip_indices_from_options_and_split(RuleOptions,StrippedOptions,_TrailerOptions),
        sort(StrippedOptions,Options),
        memberchk(error(ErrNum),RuleStatus),
        !,
        ( ErrNum > 0 ->
            ( flora_end_of_input(RuleStatus) ->
                InputStatus = FLORA_EOF

            ; flora_rule_delimiter_struct(_,_,_,_,_,RuleDelimeterToken),
                memberchk(RuleDelimeterToken,Tokens) ->
                InputStatus = FLORA_NOT_EOF

            ; discard_tokens -> InputStatus = FLORA_NOT_EOF
            ; InputStatus = FLORA_EOF
            ),
            Status=[InputStatus,FLORA_FAILURE]
        ; %% ErrNum > 0  end
            ( Rules == [], Facts == [], Queries == [] ->
                CommandStatus = FLORA_NOOP
            ;
                append_lists([Signatures,Rules,Facts,Queries],CmdLineProg),
                %% The below is ErrNum = 0 and CmdLineProg \= []
                flora_intern_code(CmdLineProg,FLORA_DEFAULT_WORKSPACE,Code,CoderStatus),
                %% get Code from CmdLineProg
                ( CoderStatus == NO_ERRORS ->
                    CommandStatus = FLORA_SUCCESS
                ;
                    print_errors([coder(CoderStatus)]),
                    CommandStatus = FLORA_FAILURE
                )
            ),
            ( flora_end_of_input(RuleStatus) ->
                Status=[FLORA_EOF,CommandStatus]
            ;
                Status=[FLORA_NOT_EOF,CommandStatus]
            )
        ),
        print_warnings(RuleStatus),
        print_errors(RuleStatus),
        !.


/*************************************************************************
  flrfilename_error(+Message,+FileName,+Extension)

  This predicate is called when search for a Flora file is failed. The
  failure may be due to incorrect file name extension or non-existence.
*************************************************************************/
flrfilename_error(File,Extension) :-
        flrfilename_error(file,File,Extension).
flrfilename_error(MesgIn,FileIn,Extension) :-
        (FileIn = FL_URL(File) -> Mesg = 'Web document', SuffixMsg = ''
        ; File = FileIn, Mesg = MesgIn,
            flora_file_op(cwd,CWDir),
            flora_concat_atoms(['; current folder=',CWDir], SuffixMsg)
        ),

        parse_filename(File,_,_BaseName,Ext),
        (atom(Extension) -> ExtList = Extension, FullExtList = ['',ExtList]
        ; flatten(Extension,ExtList), FullExtList = [''|ExtList]
        ),

        flora_stderr_nl,
        file_ext_printable_alternatives(ExtList,AltExts),
        (\+member(Ext,FullExtList) ->
            flora_error_line('~w: ~w name extension must be ~w',
                             [File,Mesg,AltExts])
        ; Ext \== '' -> flora_error_line('~w ~w is not found~w',[Mesg,File,SuffixMsg])
        ;
            %%flora_error_line('~w ~w.~w is not found~w',[Mesg,_BaseName,AltExts,SuffixMsg])
            flora_error_line('~w ~w.~w is not found~w',[Mesg,File,AltExts,SuffixMsg])
        ),
        !.

file_ext_printable_alternatives(Ext,Ext) :-
        atom(Ext),
        !.
file_ext_printable_alternatives(Ext,AltAtm) :-
        is_list(Ext),
        !,
        list_to_alternatives(Ext,Alts),
        (length(Ext,Len), Len>1 ->
            flora_concat_atoms(['{',Alts,'}'],AltAtm)
        ; AltAtm = Alts
        ).

list_to_alternatives([],'') :- !.
list_to_alternatives([Elt|Rest],Alt) :-
        list_to_alternatives(Rest,RestAlts),
        (RestAlts == '' -> Alt = Elt
        ; flora_concat_atoms([Elt,'|',RestAlts],Alt)
        ).


/*************************************************************************
  utilities
*************************************************************************/
print_error_count(0) :- !.
print_error_count(ErrNum) :-
        flora_stderr_nl,
        ( ErrNum == 1 -> flora_stderr_string('++1 error')
        ; flora_stderr_string('++~w errors',[ErrNum])
        ),
        flora_stderr_nl, flora_stderr_nl,
        flora_stderr_string('++compilation aborted'),
        flora_send_abnormality_ctl_chars(error),
        flora_stderr_nl,
        flora_stderr_nl.

print_load_error_count(0) :- !.
print_load_error_count(ErrNum) :-
        flora_stderr_nl,
        ( ErrNum == 1 -> flora_stderr_string('++1 error')
        ; flora_stderr_string('++~w errors',[ErrNum])
        ),
        flora_stderr_nl, flora_stderr_nl,
        flora_stderr_string('++loading aborted'),
        flora_send_abnormality_ctl_chars(load),
        flora_stderr_nl,
        flora_stderr_nl.

print_warn_count(0) :- !.
print_warn_count(WarnNum) :-
        flora_stdwarn_nl,
        ( WarnNum == 1 -> flora_stdwarn_string('++1 warning')
        ; flora_stdwarn_string('++~w warnings',[WarnNum])
        ),
        %%flora_send_abnormality_ctl_chars(warning),
        flora_stdwarn_nl,
        flora_stdwarn_nl.


%% StatusList is a list of error/warnings from lexer,composer,compiler,coder
print_warnings(_StatusList) :-
        flora_warnings_level(nocompiler),
        !.
print_warnings(StatusList) :-
        flora_maxwarn(MaxWarn),
        (memberchk(lexer(LexerList),StatusList) ->
            (count_warnings(LexerList,0), ! ; flora_stdwarn_nl),
            util_lexer_warn(LexerList,LexerNum)
        ; LexerNum = 0
        ),
        (memberchk(composer(ComposerList),StatusList) ->
            (count_warnings(ComposerList,0), ! ; flora_stdwarn_nl),
            util_composer_warn(ComposerList,ComposerNum)
        ; ComposerNum = 0
        ),
        (memberchk(parser(ParserList),StatusList) ->
            (count_warnings(ParserList,0), ! ; flora_stdwarn_nl),
            util_parser_warn(ParserList,ParserNum)
        ; ParserNum = 0
        ),
        (memberchk(compiler(CompilerList),StatusList) -> 
            count_warnings(CompilerList,CompilerNum),
            ((CompilerNum == 0 ; ComposerNum > 0), !
            ; flora_stdwarn_nl
            ),
            SkippedCompilerWarns is CompilerNum-MaxWarn,
            util_compiler_warn(CompilerList,MaxWarn,SkippedCompilerWarns)
        ; CompilerNum = 0
        ),
        (memberchk(depend(DependList),StatusList) ->
            ((count_warnings(DependList,0) ; ComposerNum > 0 ; CompilerNum > 0),
                !
            ; flora_stdwarn_nl),
            check_for_dependencies_warn(DependList,DependNum)
        ; DependNum = 0
        ),
        NewNum is LexerNum+ComposerNum+ParserNum+CompilerNum+DependNum,
        print_warn_count(NewNum).

%% StatusList is a list of error/warnings from lexer,composer,compiler,coder
print_errors(StatusList) :-
        memberchk(error(0),StatusList),
        !.
print_errors(StatusList) :-
        flora_stderr_nl,
        (memberchk(lexer(LexerList),StatusList)
        -> util_lexer_error(LexerList,LexerNum)
        ; LexerNum = 0
        ),
        (memberchk(composer(ComposerList),StatusList)
        -> util_composer_error(ComposerList,ComposerNum)
        ; ComposerNum = 0
        ),
        (memberchk(parser(ParserList),StatusList)
        -> util_parser_error(ParserList,ParserNum)
        ; ParserNum = 0
        ),
        (ParserNum == 0,
            memberchk(compiler(CompilerList),StatusList)
        -> util_compiler_error(CompilerList,CompilerNum)
        ; CompilerNum = 0
        ),
        (ParserNum == 0, CompilerNum == 0,
            memberchk(coder(CoderList),StatusList)
        -> flora_coder_error(CoderList),
            length(CoderList,CoderNum)
        ; CoderNum = 0
        ),
        (ParserNum == 0, CompilerNum == 0, CoderNum == 0,
            memberchk(depend(DependList),StatusList)
        -> check_for_dependencies_error(DependList,DependNum)
        ; DependNum = 0
        ),
        NewNum is LexerNum+ComposerNum+ParserNum+CompilerNum+CoderNum+DependNum,
        print_error_count(NewNum).


count_in_list(_TestList,[],0) :- !.
count_in_list(TestList,[H|T],Num) :-
        term_psc(H,PSC),
        term_new(PSC,HH),
        memberchk(HH,TestList), % use a copy of H to avoid binding
        !,
        count_in_list(TestList,T,Num1),
        Num is Num1+1.
count_in_list(TestList,[_|T],Num) :- count_in_list(TestList,T,Num).

count_warnings([],0) :- !.      %% to guard against variables
count_warnings(List,Num) :-
        count_in_list([warning(_),warning(_,_),warning(_,_,_)], List, Num).
count_errors([],0) :- !.        %% to guard against variables
count_errors(List,Num) :-
        count_in_list([error(_),error(_,_),error(_,_,_)], List, Num).

%% A status list has the form [EOF/NOT_EOF,Type1(List1), Type2(List2), ...]
%% Lists must have same length, and Type1, Type2, etc., are in same order.
:- dynamic util_stop_merging/1.
:- index(util_stop_merging/1,0).
merge_status_lists(L,[],L) :- !.
merge_status_lists(L1,L2,L) :-
        util_stop_merging(true),
        ( memberchk(error(N),L2), N>0 -> L = L2
        ; memberchk(error(N),L1), N>0 -> merge_status_lists1(L1,L2,L)
        ; L = L2
        ),
        !.
merge_status_lists(L1,L2,L) :-
        merge_status_lists1(L1,L2,L).

merge_status_lists1([],[],[]) :- !.
merge_status_lists1([FLORA_NOT_EOF|T1],[FLORA_NOT_EOF|T2],[FLORA_NOT_EOF|T3]) :-
        !,
        merge_status_lists1(T1,T2,T3).
merge_status_lists1([FLORA_EOF|T1],[_|T2],[FLORA_EOF|T3]) :-
        !,
        merge_status_lists1(T1,T2,T3).
merge_status_lists1([_|T1],[FLORA_EOF|T2],[FLORA_EOF|T3]) :-
        !,
        merge_status_lists1(T1,T2,T3).
merge_status_lists1([error(N1)|T1],[error(N2)|T2],[error(N3)|T3]) :-
        !,
        N3 is N1 + N2,
        merge_status_lists1(T1,T2,T3).
merge_status_lists1([warning(N1)|T1],[warning(N2)|T2],[warning(N3)|T3]) :-
        !,
        N3 is N1 + N2,
        merge_status_lists1(T1,T2,T3).
%% Note: when the error/warning list becomes > than 2*(MaxWarn+MaxErrNum) = 28,
%%       we start ignoring the rest of the errors/warnings.s
%%       This somehow results in 30 warnings and errors max (check why not 28,
%%       but it does not matter much)
merge_status_lists1([H1|T1], [H2|T2], Out) :-
        %% this seems a bit faster than =..
        functor(H1,F,_),
        functor(H2,F,_),
        arg(1,H1,A1),
        arg(1,H2,A2),
        !,
        length(A2,LenA2),
        flora_maxwarn(MaxWarn),
        flora_maxerr(MaxErrNum),
        ((LenA2 =< 2*(MaxWarn+MaxErrNum)
         ; memberchk(error(_EN),A1)
         )
        ->
            append(A1,A2,A3),
            H3 =.. [F|[A3]],
            Out =  [H3|T3],
            merge_status_lists1(T1,T2,T3)
        ; Out = [H2|T2], assert(util_stop_merging(true))
        ).
merge_status_lists1(L1,L2,_) :-
        flora_abort([FLSYSTEM, ' internal bug (please report): ',
                     'merge_status_lists/3 with an invalid argument:\n',
                     L1,'\n',L2]).

%% add_to_status_list(+ErrList,+NumOfAddlErrors,+AddedList,-Result)
%%    Add partial status list (with errors of only one kind, eg, depend([...]))
%%    to a full status list
%%    ErrList = [FileStatus,error(N)|Rest]. 
%%    Rest is [lexer([...]),parser([...]), etc.
%%    AddedList - same structure as Rest.
add_to_status_list([FileStat,error(N)|ErrList],NumOfAddlErrors,AddedList,Result) :-
        N1 is N+NumOfAddlErrors,
        Result = [FileStat,error(N1)|Merge],
        append(ErrList,AddedList,Merge).


/*************************************************************************
  util_lexer_error(+Tokens,+LexerStatus,-ErrNum)
*************************************************************************/
util_lexer_error([],0) :- !.

util_lexer_error([(Tokens,LexerStatus)|Rest],ErrNum) :-
        ( memberchk(error(FileName,Msg),LexerStatus) ->
            util_last_element(Tokens,Tk),
            flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
            ( atom(FileName) ->
                flora_error_line('[~w] <Lexer> near line(~w)/char(~w) `~s''',
                                [FileName,ELN,ECN,TextStr])
            ;
                flora_error_line('<Lexer> near line(~w)/char(~w) `~s''',
                                [ELN,ECN,TextStr])
            ),
            flora_error_indentline,
            flora_error_line_noheader('~w',[Msg]),
            ErrNum1 = 1
        ;
            ErrNum1 = 0
        ),
        util_lexer_error(Rest,ErrNum2),
        ErrNum is ErrNum1 + ErrNum2.
util_lexer_error([],0) :- !.

util_lexer_warn([(Tokens,LexerStatus)|Rest],WarnNum) :-
        ( memberchk(warning(FileName,Msg),LexerStatus) ->
            util_last_element(Tokens,Tk),
            flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
            ( atom(FileName) ->
                flora_warning_line('[~w] <Lexer> near line(~w)/char(~w) `~s''',
                                [FileName,ELN,ECN,TextStr])
            ;
                flora_warning_line('<Lexer> near line(~w)/char(~w) `~s''',
                                  [ELN,ECN,TextStr])
            ),
            flora_warning_indentline,
            flora_warning_line_noheader('~w',[Msg]),
            WarnNum1 = 1
        ;
            WarnNum1 = 0
        ),
        util_lexer_warn(Rest,WarnNum2),
        WarnNum is WarnNum1 + WarnNum2.
util_lexer_warn([],0) :- !.


util_last_element([T],T) :- !.
util_last_element([_|L],T) :- util_last_element(L,T).


/*************************************************************************
  util_composer_error(+ComposerStatus,-ErrNum)
  util_composer_warn(+ComposerStatus,-WarnNum)
*************************************************************************/
util_composer_error([],0) :- !.

util_composer_error([error(Indx,Msg)|L],ErrNum) :-
        !,
        flora_nth_token(Indx,Tk),
        A = '_',
        ( (Tk = variable(A,_)) ->
            %% in error reporting, output ? for anonymous variable
            %% (vars are stored as variable(_,...))
            TextStr=[CH_QUESTION],
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(Indx,FileName) ->
            flora_error_line('[~w] <Composer> near line(~w)/char(~w) `~s''',
                            [FileName,BLN,BCN,TextStr])
        ;
            flora_error_line('<Composer> near line(~w)/char(~w) `~s''',
                            [BLN,BCN,TextStr])
        ),
        flora_error_indentline,
        flora_error_line_noheader('~w',[Msg]),
        util_composer_error(L,EN),
        ErrNum is EN+1.

util_composer_error([error(I1,I2,Msg)|L],ErrNum) :-
        !,
        flora_nth_token(I1,Tk1),
        flora_nth_token(I2,Tk2),
        %%atom_codes(A,[CH_UNDERSCORE]),
        A = '_',
        ( (Tk1 = variable(A,_)) ->
            %% in error reporting, prepend ? to anonymous variable _
            TextStr1=[CH_QUESTION],
            flora_token_text(Tk1,_TextStr1,BLN1,BCN1,_ELN1,_ECN1)
        ;
            flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1)
        ),
        ( (Tk2 = variable(A,_)) ->
            %% prepend ? to anonymous variable _
            TextStr2=[CH_QUESTION],
            flora_token_text(Tk2,_TextStr2,BLN2,BCN2,_ELN2,_ECN2)
        ;
            flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2)
        ),
        ( flora_compile_filename_by_token(I1,FileName) ->
            flora_error_line('[~w] <Composer> near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
                            [FileName,BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
        ;
            flora_error_line('<Composer> near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
                            [BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
        ),
        flora_error_indentline,
        flora_error_line_noheader('~w',[Msg]),
        util_composer_error(L,EN),
        ErrNum is EN+1.


%% MK: I think this case (error without index) is not possible
util_composer_error([error(Msg)|L],ErrNum) :-
        !,
        ( flora_current_compile_filename(FileName) ->
            flora_error_line('[~w] <Composer> ~w',[FileName,Msg])
        ;
            flora_error_line('<Composer> ~w',[Msg])
        ),
        util_composer_error(L,EN),
        ErrNum is EN+1.

%% Skip warnings
util_composer_error([_|L],ErrNum) :- util_composer_error(L,ErrNum).


util_composer_warn([],0) :- !.
util_composer_warn([warning(I1,I2,Msg)|L],WarnNum) :-
        !,
        flora_nth_token(I1,Tk1),
        flora_nth_token(I2,Tk2),
        %%atom_codes(A,[CH_UNDERSCORE]),
        A = '_',
        ( (Tk1 = variable(A,_)) ->
            %% in reporting, prepend ? to anonymous var _
            %% (it is represented as variable(_,...))
            TextStr1=[CH_QUESTION],
            flora_token_text(Tk1,_TextStr1,BLN1,BCN1,_ELN1,_ECN1)
        ;
            flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1)
        ),
        ( (Tk2 = variable(A,_)) ->
            %% prepend ? to anonymous var _
            TextStr2=[CH_QUESTION],
            flora_token_text(Tk2,_TextStr2,BLN2,BCN2,_ELN2,_ECN2)
        ;
            flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2)
        ),
        ( flora_compile_filename_by_token(I1,FileName) ->
            flora_warning_line('[~w] <Composer> near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
                              [FileName,BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
        ;
            flora_warning_line('<Composer> near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
                              [BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
        ),
        flora_warning_indentline,
        flora_warning_line_noheader('~w~n',[Msg]),
        util_composer_warn(L,WN),
        WarnNum is WN+1.

%% Skip errors
util_composer_warn([_|L],WarnNum) :- util_composer_warn(L,WarnNum).


/*************************************************************************
  util_parser_error(+ParserStatus,-ErrNum)
  util_parser_warn(+ParserStatus,-ErrNum)
*************************************************************************/
util_parser_error([],0) :- !.

%% ergotext may need to pass lexer and composer error statuses through
%% the parser's Status field. Hence the next two cases.
util_parser_error([lexer(Errs)|Rest],ErrNum) :-
        !,
        util_lexer_error(Errs,LexNum),
        util_parser_error(Rest,ParsNum),
        ErrNum is LexNum+ParsNum.

util_parser_error([composer(Errs)|Rest],ErrNum) :-
        !,
        util_composer_error(Errs,ComposerNum),
        util_parser_error(Rest,ParsNum),
        ErrNum is ComposerNum+ParsNum.

util_parser_error([error(Indx,Msg)|L],ErrNum) :-
        Indx \== NO_INDEX,
        !,
        flora_nth_token(Indx,Tk),
        A = '_',
        ( (Tk = variable(A,_)) ->
            TextStr=[CH_QUESTION], 
            %% in error reporting, prefix ? to anonymous variable
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(Indx,FileName) ->
            flora_error_line('[~w] <Parser> near line(~w)/char(~w) `~s''',
                            [FileName,BLN,BCN,TextStr])
        ;
            flora_error_line('<Parser> near line(~w)/char(~w) `~s''',
                            [BLN,BCN,TextStr])
        ),
        flora_error_indentline,
        flora_error_line_noheader('~w',[Msg]),
        util_parser_error(L,EN),
        ErrNum is EN+1.

%% the case of error(Message): error(ERROR_GPP) (the only known one)
util_parser_error([Error|L],ErrNum) :-
        (Error = error(Msg) ; Error = error(NO_INDEX,Msg)),
        !,
        ( flora_current_compile_filename(FileName) ->
            flora_error_line('[~w] <Parser> ~w',[FileName,Msg])
        ;
            flora_error_line('<Parser> ~w',[Msg])
        ),
        util_parser_error(L,EN),
        ErrNum is EN+1.
%% Skip warnings in the status list
util_parser_error([warning(_,_)|L],WarnNum) :-
        util_parser_error(L,WarnNum).

%% util_parser_warn/2
util_parser_warn([],0) :- !.
util_parser_warn([warning(I,Msg)|L],WarnNum) :-
        !,
        flora_nth_token(I,Tk),
        A = '_',
        ( (Tk = variable(A,_)) ->
            %% in reporting, prepend ? to anonymous var _
            %% (it is represented as variable(_,...))
            TextStr=[CH_QUESTION],
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(I,FileName) ->
            flora_warning_line('[~w] <Parser> near line(~w)/char(~w) `~s''',
                              [FileName,BLN,BCN,TextStr])
        ;
            flora_warning_line('<Parser> near line(~w)/char(~w) `~s''',
                              [BLN,BCN,TextStr])
        ),
        flora_warning_indentline,
        flora_warning_line_noheader('~w~n',[Msg]),
        util_parser_warn(L,WN),
        WarnNum is WN+1.

%% Skip errors in the status list
util_parser_warn([_|L],WarnNum) :- util_parser_warn(L,WarnNum).


/*************************************************************************
  check_for_dependencies_warn(+ParserStatus,-WarnNum)
  check_for_dependencies_error(+ParserStatus,-ErrNum)
*************************************************************************/

check_for_dependencies_warn([],0) :- !.

check_for_dependencies_warn([warning(HTK,BTK,(MH,MB))|L],WarnNum) :-
        !,
        (
          flora_compile_filename_by_token(HTK,HFileName),
          flora_compile_filename_by_token(BTK,BFileName) ->
          %%flora_warning_line('<Dependency check> ~w in [~w]~w in [~w]', [MH,HFileName,MB,BFileName])
          flora_warning_line('[~w] <Dependency check>', [HFileName]),
          flora_warning_indentline,
          flora_stdwarn_string('~w ~w in [~w]~n', [MH,MB,BFileName])
        ;
          flora_compile_filename_by_token(HTK,HFileName),
          %%flora_warning_line('<Dependency check> ~w in [~w] depends on ~w', [MH,HFileName,MB])
          flora_warning_line('[~w] <Dependency check>', [HFileName]),
          flora_warning_indentline,
          flora_stdwarn_string('~w depends on ~w~n', [MH,MB])
        ;
          flora_compile_filename_by_token(BTK,BFileName),
          %%flora_warning_line('<Dependency check> ~w depends on ~w in [~w]', [MH,MB,BFileName])
          flora_warning_line('<Dependency check>'),
          flora_stdwarn_string('~w depends on ~w in [~w]~n', [MH,MB,BFileName])
        ;
          %%flora_warning_line('<Dependency check> ~w depends on ~w', [MH,MB])
          flora_warning_line('<Dependency check>'),
          flora_warning_indentline,
          flora_warning_line('~w depends on ~w~n', [MH,MB])
        ),
        check_for_dependencies_warn(L,WN),
        WarnNum is WN+1.

%% Skip errors
check_for_dependencies_warn([_|L],WarnNum) :-
        check_for_dependencies_warn(L,WarnNum).


check_for_dependencies_error([],0) :- !.

check_for_dependencies_error([error(Msg)|L],ErrNum) :-
        !,
        ( flora_current_compile_filename(FileName) ->
            flora_error_line('[~w] <Dependency check> ~w', [FileName,Msg])
        ;
            flora_error_line('<Dependency check> ~w', [Msg])
        ),
        check_for_dependencies_error(L,EN),
        ErrNum is EN+1.

%% Skip warnings
check_for_dependencies_error([_|L],ErrNum) :-
        check_for_dependencies_error(L,ErrNum).

/*************************************************************************
  util_compiler_error(+CompileStat,-ErrNum)
  util_compiler_warn(+CompileStat,+MaxWarnNum,+SkippedCompilerWarns)
*************************************************************************/
util_compiler_error([],0) :- !.

util_compiler_error([error(Indx,Msg)|L],ErrNum) :-
        Indx \== NO_INDEX,
        !,
        flora_nth_token(Indx,Tk),
        A = '_',
        ( (Tk = variable(A,_)) ->
            %% prepend ? to anonymous var _
            TextStr=[CH_QUESTION],
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(Indx,FileName) ->
            flora_error_line('[~w] <Compiler> near line(~w)/char(~w) `~s''',
                            [FileName,BLN,BCN,TextStr])
        ;
            flora_error_line('<Compiler> near line(~w)/char(~w) `~s''',
                            [BLN,BCN,TextStr])
        ),
        flora_error_indentline,
        flora_error_line_noheader('~w~n',[Msg]),
        util_compiler_error(L,EN),
        ErrNum is EN+1.

%% the case of error(Message): no longer occurs - leaving just in case
util_compiler_error([Error|L],ErrNum) :-
        (Error = error(Msg) ; Error = error(NO_INDEX,Msg)),
        !,
        ( flora_current_compile_filename(FileName) ->
            flora_error_line('[~w] <Compiler> ~w',[FileName,Msg])
        ;
            flora_error_line('<Compiler> ~w',[Msg])
        ),
        util_compiler_error(L,EN),
        ErrNum is EN+1.

%% Skip warnings
util_compiler_error([_|L],ErrNum) :- util_compiler_error(L,ErrNum).


util_compiler_warn([],_,_) :- !.

util_compiler_warn([warning(Indx,_Msg)|_L],WarnNum,SkippedWarns) :-
        WarnNum =< 0,
        !,
        (SkippedWarns > 0, flora_warnings_level(nocompiler) -> true
        ; (flora_compile_filename_by_token(Indx,FileName) ->
              flora_warning_line('[~w] <Compiler> ~w (or more) warnings were skipped',
                                 [FileName,SkippedWarns])
          ; flora_warning_line('<Compiler> ~w warnings were skipped',
                               [SkippedWarns])
          )
        ).

util_compiler_warn([warning(Indx,Msg)|L],WarnNum,SkippedWarns) :-
        flora_nth_token(Indx,Tk),
        !,
        A = '_',
        ( (Tk = variable(A,_)) ->
            %% prepend ? to anonymous var _
            TextStr=[CH_QUESTION],
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(Indx,FileName) ->
            flora_warning_line('[~w] <Compiler> near line(~w)/char(~w) `~s''',
                              [FileName,BLN,BCN,TextStr])
        ;
            flora_warning_line('<Compiler> near line(~w)/char(~w) `~s''',
                              [BLN,BCN,TextStr])
        ),
        flora_warning_indentline,
        flora_warning_line_noheader('~w~n',[Msg]),
        WN is WarnNum - 1,
        util_compiler_warn(L,WN,SkippedWarns).

%% skip warning if it does not have an associated token
util_compiler_warn([_|L],WarmNum,SkippedWarns) :-
        %% we should really be issuing warnings in this case or else warnings
        %% will be lost because of oversight errors
        util_compiler_warn(L,WarmNum,SkippedWarns).


/*************************************************************************
  util_load_symbol_context_error(+CompileStat,+ErrorLine,+SymbolName,+FileName,-ErrNum)
  util_load_symbol_context_warn(+CompileStat,+WarnLine,+SymbolName,+FileName,-WarnNum)
*************************************************************************/
util_load_symbol_context_error([],_,_,_,0) :- !.

util_load_symbol_context_error([error(_Indx,Mesg)|_L],Line,SymbolName,FileName,1) :-
        !,
        flora_increment_counter(flora_load_errors,1,_,_),
        flora_stderr_nl,
        flora_decode_oid_as_atom(SymbolName,SymbolNamePrintable),
        flora_error_line('[~w] <Loader> near line(~w)/symbol(~w)',
                         [FileName,Line,SymbolNamePrintable]),
        flora_error_indentline,
        flora_error_line_noheader('~w~n',[Mesg]).

%% Skip errors to the last one (if ErrNum > 1)
util_load_symbol_context_error([_|L],Line,SymbolName,FileName,ErrNum) :-
        util_load_symbol_context_error(L,Line,SymbolName,FileName,ErrNum).


util_load_symbol_context_warn([],_,_,_,0) :- !.

util_load_symbol_context_warn([warning(_Indx,Mesg)|_L],Line,SymbolName,FileName,1) :-
        !,
        flora_stdwarn_nl,
        flora_decode_oid_as_atom(SymbolName,SymbolNamePrintable),
        flora_warning_line('[~w] <Loader> near line(~w)/symbol(~w)',
                           [FileName,Line,SymbolNamePrintable]),
        flora_warning_indentline,
        flora_warning_line_noheader('~w~n',[Mesg]).

%% Skip warnings to the last one (if ErrNum > 1)
util_load_symbol_context_warn([_|L],Line,SymbolName,FileName,WarmNum) :-
        util_load_symbol_context_warn(L,Line,SymbolName,FileName,WarmNum).

util_load_metafact_error(FileName,Mesg) :-
        flora_increment_counter(flora_load_errors,1,_,_),
        flora_stderr_nl,
        flora_error_line('[~w] <Loader> ~w', [FileName,Mesg]).


/*************************************************************************
  flora_coder_error(+CoderStatus)
*************************************************************************/
flora_coder_error(NO_ERRORS) :- !.

%% MK: I think this case (error without index) is not possible
flora_coder_error([error(Msg)|L]) :-
        !,
        ( flora_current_compile_filename(FileName) ->
            flora_error_line('[~w] <Coder> ~w',[FileName,Msg])
        ;
            flora_error_line('<Coder> ~w',[Msg])
        ),
        flora_coder_error(L).

flora_coder_error([error(Indx,Msg)|L]) :-
        !,
        flora_nth_token(Indx,Tk),
        A = '_',
        ( (Tk = variable(A,_)) ->
            %% prepend ? to anonymous var _
            TextStr=[CH_QUESTION],
            flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
        ;
            flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
        ),
        ( flora_compile_filename_by_token(Indx,FileName) ->
            flora_error_line('[~w] <Coder> near line(~w)/char(~w) `~s''',
                            [FileName,BLN,BCN,TextStr])
        ;
            flora_error_line('<Coder> near line(~w)/char(~w) `~s''',
                            [BLN,BCN,TextStr])
        ),
        flora_error_indentline,
        flora_error_line_noheader('~w~n',[Msg]),
        flora_coder_error(L).


/*****************************************************************************
  flora_list2conjunct(+List,-Goal)
*****************************************************************************/
flora_list2conjunct([G],G) :- !.

flora_list2conjunct([G|L],(G,LG)) :-
        !,
        flora_list2conjunct(L,LG).


/*************************************************************************
  flMaxerr(+Num)
  Controls how many compile errors to show.
  No longer advertized to the user (not important)
*************************************************************************/
:- flora_set_maxerrors(7).
:- flora_set_maxwarnings(7).

flora_set_maxerrors(X) :-
        (X \== FLORA_ALL, (not integer(X); X < 1)
        -> flora_error_line('invalid argument to flora_set_maxerrors'),
            fail
        ;
            (retract(flora_maxerr(_)), ! ; true),
            assert(flora_maxerr(X))
        ).
flora_get_maxerrors(X) :- flora_maxerr(X).

flora_set_maxwarnings(X) :-
        ((\+integer(X); X < 1)
        -> flora_error_line('invalid argument to flora_set_maxwarnings'),
            fail
        ;
            (retract(flora_maxwarn(_)), ! ; true),
            assert(flora_maxwarn(X))
        ).
flora_get_maxwarnings(X) :- flora_maxwarn(X).


/*************************************************************************
  \dump/1
*************************************************************************/
FL_DUMP(InFile>>Module) :-
        %% Include workspace in the dumped file
        dump_file_internal(InFile,Module,dontsquash).

FL_DUMP(InFile) :-
        %% Ignore workspace in the dumped file
        dump_file_internal(InFile,FLORA_DEFAULT_WORKSPACE,squash).


/*************************************************************************
  dump_file_internal(+File,+Module,+SquashingOption)

  Expects a Flora file as input and dumps the .P file in a more readable
  format. If SquashingOption == squash, ignore Module in the final round 
  of gpp pre-processing.
*************************************************************************/
dump_file_internal(OrigInFile,Module,SquashingOption) :-
        flora_check_filename(OrigInFile,InFile),
        valid_flora_module_name(Module),
        ( flora_locate_file(InFile,FLORA_FILE_EXT_ALT,FlrFile) -> true
        ; flrfilename_error(InFile,FLORA_FILE_EXT_ALT) -> fail
        ),
        %% Find the files that need to be dumped.
        util_mainP_filename(FlrFile,PFile),
        util_FDB_filename(FlrFile,FDBFile),
        util_FLD_filename(FlrFile,FLDFile),
        util_FLM_filename(FlrFile,FLMFile),
        util_FLS_filename(FlrFile,FLSFile),
        util_FLS2_filename(FlrFile,FLS2File),
        util_FLT_filename(FlrFile,FLTFile),
        util_FTX_filename(FlrFile,FTXFile),
        util_dump_filename(PFile,DumpPFile),
        util_dump_filename(FDBFile,DumpFDBFile),
        util_dump_filename(FLDFile,DumpFLDFile),
        util_dump_filename(FLMFile,DumpFLMFile),

        util_compile_file(FlrFile,FL_DUMMYMODULE,PFile,FDBFile,FLDFile,FLMFile,FLSFile,FLS2File,FLTFile,FTXFile,Status),
        ( Status == FLORA_FAILURE -> flora_clear_xpp_options, !, fail
        ; true
        ),
        flora_clear_xpp_options,
        !,
        %% Compilation has succeeded. Need to dump file contents.
        ( SquashingOption == squash -> NewModule=''
        ;
            %% Add '_' to the workspace to simplify reading.
            atom_concat(Module,'_',NewModule)
        ),
        !,
        ( flora_file_op(exists,PFile) ->
            %% Dump the main .P file.
            gpp_dumpfile_internal(PFile,DumpPFile,NewModule)
        ;
            flora_error_line('Failed to create the main dumpfile ~w', [PFile])
        ),
        ( flora_file_op(exists,FDBFile) ->
            %% Dump the .fdb file if it exists.
            gpp_dumpfile_internal(FDBFile,DumpFDBFile,NewModule)
        ;
            true
        ),
        ( flora_file_op(exists,FLDFile) ->
            %% Dump the .fld file if it exists.
            gpp_dumpfile_internal(FLDFile,DumpFLDFile,NewModule)
        ;
            true
        ),
        ( flora_file_op(exists,FLMFile) ->
            %% Dump the .flm (meta-predicates) file if it exists.
            gpp_dumpfile_internal(FLMFile,DumpFLMFile,NewModule)
        ;
            true
        ),
        !.


/*************************************************************************
  gpp_dumpfile_internal(+FileName,+DumpFileName,+Module)

  When this predicate is called, the input file is already checked
  for existence.
*************************************************************************/
gpp_dumpfile_internal(FileName,DumpFileName,Module) :-
        flora_loader_message('Making dump file ~w from ~w',
                             [DumpFileName,FileName]),
        parse_filename(DumpFileName,_,Base,_),
        flora_concat_atoms(['-D FLORA_DUMP -D FLORA_FDB_FILENAME="''',
                           Base,'.',FLORA_FDB_EXT,
                            '''" -D FLORA_FLD_FILENAME="''',
                            Base,'.',FLORA_FLD_EXT,
                            '''" -D FLORA_FLM_FILENAME="''',
                            Base,'.',FLORA_FLM_EXT,
                            '''" -D FLORA_FLS_FILENAME="''',
                            Base,'.',FLORA_FLS_EXT,
                            '''" -D FLORA_FLS2_FILENAME="''',
                            Base,'.',FLORA_FLS2_EXT,
                            '''"'],
                           ExtraOptions),
        flora_set_xpp_options_for_dump(Module,ExtraOptions),
        xpp_process_file(FileName,XPP_process,IOportFromGPP),
        %% Save standard input and output ports
        seeing(StdIn),
        telling(StdOut),
        %% Pipe gpp output to standard input
        see(IOportFromGPP),
        %% Pipe standard output to the dump file
        open(DumpFileName,write,DumpPort),
        tell(DumpPort),
        %% do prettyprinting; gpp output is now piped through
        %% this predicate to the dumpfile
        prettyprint_stdin,
        !,
        check_xpp_process_status(FileName,XPP_process,close_on_error),
        flora_clear_xpp_options,
        %%close(IOportFromGPP),
        %%close(DumpPort),
        seen,
        told,
        %% Restore the old stdin and stdout
        see(StdIn),
        tell(StdOut),
        !.

gpp_dumpfile_internal(FileName,_DumpFileName,_Module) :-
        flora_error_line('Failed to make a dump file for ~w',[FileName]),
        !,
        fail.


/*****************************************************************************
   flora_copy_and_preprocess(?Input, ?Output, +GPP_OptionsList)

   Input and Output are either bound to file names or are unbound variables.
   GPP_OptionsList is a list of options to pass to the preprocessor.
   Each option is an atom. The atoms in the list are concatenated
   and passed to gpp.
*****************************************************************************/
flora_copy_and_preprocess(Input,Output,GPP_OptionsList) :-
        flora_concat_atoms(GPP_OptionsList, XPP_Options),
        flora_replace_xpp_options(XPP_Options),
        xpp_process_file(Input,XPP_process,IOportFromGPP),
        %% Save standard input and output ports
        seeing(StdIn),
        telling(StdOut),
        flora_copy_input(IOportFromGPP,Output),
        !,
        check_xpp_process_status(Input,XPP_process,close_on_error),
        flora_clear_xpp_options,
        seen,
        %% Restore the old stdin and stdout
        see(StdIn),
        tell(StdOut).


/*****************************************************************************
   flora_measure_time(+Call,+Message,+Done)
   Tells now much time the call has been executing.
   Message is printed to identify the call.
*****************************************************************************/
flora_measure_time(Call,Message,Done) :-
        flora_walltime(WT1),
        flora_cputime(T1),
        call(Call),
        flora_cputime(T2),
        flora_walltime(WT2),
        Delta is T2 - T1,
        WDelta is WT2 - WT1,
        fmt_write_string(DeltaAtm,'%1.3f', f(Delta)),
        fmt_write_string(WDeltaAtm,'%1.3f', f(WDelta)),
        (is_list(Message) -> flora_concat_atoms(Message,RealMsg)
        ; RealMsg = Message
        ),
        (Done \== loaddone ->
            flora_loader_message('~w ~w seconds (elapsed time: ~w seconds)',
                                 [RealMsg,DeltaAtm,WDeltaAtm])
        ; flora_answer_switch(chatter) ->
            flora_loader_done_message('~w ~w seconds (elapsed time: ~w seconds)',
                                      [RealMsg,DeltaAtm,WDeltaAtm])
        ; (Message = [DoneMsg,File,_] ->
              flora_concat_atoms([DoneMsg,File],ShortMsg)
          ; ShortMsg = RealMsg
          ),
            flora_loader_done_message('~w', ShortMsg)
        ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generation of the trailer filename
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
    Create a proper trailer filename for the given options: equality,
    inheritance, custom file
*/
make_trailer_filename(TrailerOptions,TrailerFilerFN) :-
        memberchk(FL_EQUALITY(Equality),TrailerOptions),
        memberchk(FL_INHERITANCE(Inheritance),TrailerOptions),
        %% This MUST be member/2, not memberchk/2!
        %% Otherwise, Tabling1 will always be = Tabling2!
        member(FL_TABLING(Tabling2),TrailerOptions),
        member(FL_TABLING(Tabling1),TrailerOptions),
        Tabling1 \== Tabling2,
        memberchk(FL_CUSTOM(Custom),TrailerOptions),
        encode_path_as_filename(Custom,CustomFN),
        (memberchk('FLORA_NONTABLED_MODULE',TrailerOptions)-> NoTable = '+notbl'
        ; NoTable = ''
        ),
        flora_concat_atoms(['trailer$eq=',Equality,'+inh=',Inheritance,'+tbl=',Tabling1,'+',Tabling2,NoTable,'+cus=',CustomFN,'.',PROLOG_PFILE_EXT], TrailerFilerFN),
        !.

/*
   Converts full path to a single filename that is acceptable to both Unix 
   and Windows. The file name has no directory part. This ensures that
   trailer names are uniquely identified by the custom part of the trailer
   and the inheritance/equality parameters.
   Maps: / -> _, \ -> =, : -> %, . -> $
   Each occurrence of _, =, %, $ that is part of the input path is doubled 
   in the output filename.
*/
encode_path_as_filename(InPath, OutFilename) :-
        atom_codes(InPath,InPathList),
        encode_pathList_as_filenameList(InPathList,OutFilenameList),
        atom_codes(OutFilename,OutFilenameList).

encode_pathList_as_filenameList([],[]) :- !.
encode_pathList_as_filenameList([CH_SLASH|Rest],[CH_UNDERSCORE|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_BACKSLASH|Rest],[CH_EQUAL|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_DOT|Rest],[CH_DOLLAR|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_COLON|Rest],[CH_PERCENT|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_UNDERSCORE|Rest],[CH_UNDERSCORE,CH_UNDERSCORE|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_EQUAL|Rest],[CH_EQUAL,CH_EQUAL|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_PERCENT|Rest],[CH_PERCENT,CH_PERCENT|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_DOLLAR|Rest],[CH_DOLLAR,CH_DOLLAR|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([Char|Rest],[Char|Rest1]) :-
        !,
        encode_pathList_as_filenameList(Rest,Rest1).

%% Include #define statements according to TrailerOptions
include_xpp_control_variables(TrailerOptions) :-
        flora_current_out_nl,
        %%flora_current_out_line(':-(compiler_options([xpp_dump])).\n'),
        flora_current_out_line(':-(compiler_options([xpp_on,canonical])).\n'),
        flora_current_out_line('/********** Tabling and Trailer Control Variables ************/'),
        flora_current_out_nl,
        (memberchk('LOADABLETRAILER',TrailerOptions)
        -> flora_current_out_line('#define LOADABLETRAILER')
        ; true
        ),
        (memberchk('FLORA_NONTABLED_MODULE',TrailerOptions)
        -> flora_current_out_line('#define FLORA_NONTABLED_MODULE')
        ; true
        ),
        memberchk(FL_EQUALITY(EqType),TrailerOptions),
        flora_current_out_string('#define EQUALITY~w~n', [EqType]),
        memberchk(FL_INHERITANCE(InhType),TrailerOptions),
        flora_current_out_string('#define INHERITANCE~w~n', [InhType]),
        %% must be member/2 here, NOT memberchk/2!
        %% If we used member/2 then TabType1 will ALWAYS be = TabType2
        member(FL_TABLING(TabType1),TrailerOptions),
        flora_current_out_string('#define TABLING~w~n', [TabType1]),
        member(FL_TABLING(TabType2),TrailerOptions), TabType1 \== TabType2,
        flora_current_out_string('#define TABLING~w~n', [TabType2]),
        memberchk(FL_CUSTOM(CusFile),TrailerOptions),
        (CusFile == NONE
        -> flora_current_out_line('#define CUSTOMnone')
        ; 
            %% file without quotes; quotes are added
            %% in assert(flora_trailer_registry(...)) calls
            flora_current_out_string('#define CUSTOMTRAILER ~w~n', [CusFile])
        ),
        flora_current_out_nl,
        (subsumptive_tabling_requested(TrailerOptions)
        -> flora_current_out_line('#define FLORA_SUBSUMPTIVE_TABLING ')
        ;  true
        ),
        (incremental_tabling_requested(TrailerOptions) ->
            flora_current_out_line('#define FLORA_INCREMENTAL_TABLING ')
        ; flora_current_out_line('#define FLORA_NONINCREMENTAL_TABLING ')
        ),
        flora_current_out_nl,
        !.
include_xpp_control_variables(TrailerOptions) :- 
        flora_error_line('Bug in include_xpp_control_variables/1. Options: ~w', [TrailerOptions]),
        fail.



%% collect all trailer options for module
get_trailer_options(Module,Options) :-
        findall(O,flora_trailer_registry(Module,O),Options).

subsumptive_tabling_requested(TrailerOptions) :-
        memberchk(FL_TABLING(FL_SUBSUMPTIVE),TrailerOptions),
        !.
subsumptive_tabling_in_effect(Module) :-
        flora_trailer_registry(Module,FL_TABLING(FL_SUBSUMPTIVE)).

%% should probably change to nonincremental nomenclature
incremental_tabling_requested(TrailerOptions) :-
        memberchk(FL_TABLING(FL_INCREMENTAL),TrailerOptions),
        !.
incremental_tabling_in_effect(Module) :-
        flora_trailer_registry(Module,_),
        %% Checking for \+ FL_NONINCREMENTAL because FL_INCREMENTAL is now
        %% the default, so may not be explicitly requested
        \+flora_trailer_registry(Module,FL_TABLING(FL_NONINCREMENTAL)).


/*
   extract_trailer_options(+OldOptions,-NewOptions,-TrailerOptions)

   Check for conflicting options in the trailer.
   If no conflicts, split off trailer options, resolve defaults.
   Strip indices from all options.
*/

extract_trailer_options(InputFile,OldOptions,Defaults,NewOptions,NewTrailerOptions) :-
        %% this succeeds, if errors
        \+ found_option_conflicts(InputFile,OldOptions),
        strip_indices_from_options_and_split(OldOptions,NewOptions,TrailerOptions),
        fixup_trailer_options(TrailerOptions,Defaults,NewTrailerOptions),
        \+ loadable_option_conflict(NewTrailerOptions,print).

%% This is not super-efficient, but good enough. Optlist is short (<7) and this
%% pred is called very rarely
%% This is called only for static :- setsemantics (placed in files)
found_option_conflicts(InputFile,OptList) :-
        %% must be member/2
        member((X,IdxX), OptList),
        functor(X,OptName,_),
        functor(Y,OptName,1),
        member((Y,IdxY), OptList),
        conflicting_semantics_options(X,Y),
        !,
        print_option_conflict_error(InputFile,X,Y,IdxX,IdxY).

%% This is not super-efficient, but good enough. Optlist is short (<7) and this
%% pred is called very rarely
%% Similar to found_option_conflicts/2 but Optlist is stripped of the indices
%% Action is: abort/print
loadable_option_conflict(OptList,Action) :-
        %% must be member/2
        member(X, OptList),
        functor(X,OptName,_),
        functor(Y,OptName,1),
        member(Y, OptList),
        (unimplemented_option_combination(X,Y)
        ; conflicting_semantics_options(X,Y)
        ),
        !,
        X =.. [Option,XVal],
        Y =.. [_,YVal],
        (Action==abort -> MsgPrefix = 'executable '
        ; MsgPrefix = ''
        ),
        fmt_write_string(Msg,'%ssetsemantics directive: conflict in option %s=%s+%s\n',
                         args(MsgPrefix,Option,XVal,YVal)),
        (Action==abort -> throw(option_conflict(Msg))
        ; flora_stderr_nl,
            flora_error_line(Msg)
        ).


conflicting_semantics_options(FL_EQUALITY(X),FL_EQUALITY(Y)) :-
        nonvar(X), nonvar(Y), X \= Y.
conflicting_semantics_options(FL_INHERITANCE(X),FL_INHERITANCE(Y)) :-
        nonvar(X), nonvar(Y),  X \= Y.
conflicting_semantics_options(FL_CUSTOM(X),FL_CUSTOM(Y)) :-
        nonvar(X), nonvar(Y),  X \= Y.
conflicting_semantics_options(FL_TABLING(X),FL_TABLING(Y)) :-
        nonvar(X), nonvar(Y),
        ( X == FL_SUBSUMPTIVE, Y == FL_VARIANT, !
        ; Y == FL_SUBSUMPTIVE, X == FL_VARIANT, !
        %% Don't put these here: this is supposed to check for real conflicts,
        %% not unimplemented combinations
        %%; Y == FL_INCREMENTAL, X == FL_SUBSUMPTIVE, !
        %%; Y == FL_SUBSUMPTIVE, X == FL_INCREMENTAL
        ; X == FL_INCREMENTAL, Y == FL_NONINCREMENTAL, !
        ; Y == FL_INCREMENTAL, X == FL_NONINCREMENTAL
        ),
        !.

unimplemented_option_combination(FL_TABLING(X), FL_TABLING(Y)) :-
        %% has been implemented now, but not for attributed variables
        nonvar(X), nonvar(Y),
        (Y == FL_INCREMENTAL, X == FL_SUBSUMPTIVE, !
        ; Y == FL_SUBSUMPTIVE, X == FL_INCREMENTAL
        ).

print_option_conflict_error(InputFile,Opt1,Opt2,Idx1,Idx2) :-
        flora_stderr_nl,
        Opt1 =.. [Option,Val1],
        Opt2 =.. [_,Val2],
        (flora_nth_token(Idx1,Tk1),
            flora_token_text(Tk1,_TextStr1,BLN1,_BCN1,_ELN1,_ECN1),
            flora_nth_token(Idx2,Tk2),
            flora_token_text(Tk2,_TextStr2,BLN2,_BCN2,_ELN2,_ECN2)
        ->
            (BLN1 \= BLN2 ->
                flora_error_line('~w: conflict in option ~w=~w+~w in the directive ~w on lines ~w and ~w',
                                 [InputFile,Option,Val1,Val2,
                                  FL_SETSEMANTICS,BLN1,BLN2])
            ;   flora_error_line('~w: conflict in option ~w=~w+~w in the directive ~w on line ~w',
                                 [InputFile,Option,Val1,Val2,
                                  FL_SETSEMANTICS,BLN1])
            )
        ;
            flora_error_line('~w: conflict in option ~w in the directive ~w',
                             [InputFile,Option,FL_SETSEMANTICS])
        ).


/*
   Takes an option list (for the trailers) of the form [(Option,Index),...]
   and deletes indices from options. Options FLOBJEQLDEF, FL_EQUALITY,
   FL_CUSTOM, FL_INHERITANCE are ignored completely.
*/
strip_indices_from_options_and_split([],[],[]).
strip_indices_from_options_and_split([(Option,_I)|Rest],
                                     StrippedOptions,
                                     [Option|RestTrailer]) :-
        (Option = FLOBJEQLDEF; Option = FL_EQUALITY(_);
            Option = FL_INHERITANCE(_); Option = FL_CUSTOM(_);
            Option = FL_TABLING(_)
        ),
        !,
        strip_indices_from_options_and_split(Rest,StrippedOptions,RestTrailer).
strip_indices_from_options_and_split([(Option,_I)|Rest], [Option|StrippedRest], TrailerOptions) :-
        strip_indices_from_options_and_split(Rest,StrippedRest,TrailerOptions).

/*
   Fix option defaults:
       FLOBJEQLDEF overrides equality(none),
       equality(none), inheritance(flogic), custom(none) are defaults.
   Always succeeds.
*/
fixup_trailer_options(TrailerOptions,Defaults,NewTrailerOptions) :-
        fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions1),
        sort(NewTrailerOptions1,NewTrailerOptions).
fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions) :-
        var(TrailerOptions),
        !,
        fixup_trailer_options1([],Defaults,NewTrailerOptions),
        TrailerOptions = NewTrailerOptions.

fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions) :-
        (memberchk(FLOBJEQLDEF,TrailerOptions)
        ->
            flora_delete_from_list(FLOBJEQLDEF,TrailerOptions,TrailerOptions1),
            /*
            %% This makes :=: in the head override the explicit
            %% equality(none) option. But our stated policy is that
            %% the explicit directive overrides the implicit ones
            */
        ( memberchk(FL_EQUALITY(_),TrailerOptions1)
        -> 
            NewTrailerOptions1 = TrailerOptions1
        ; 
            NewTrailerOptions1 = [FL_EQUALITY(BASIC)|TrailerOptions1]
        )
        ;
            NewTrailerOptions1 = TrailerOptions
        ),
        (memberchk(FL_CUSTOM(File),NewTrailerOptions1)
        ->
            %% custom files must be expanded
            ( (var(File) ; File == NONE)
            -> NewTrailerOptions2 = NewTrailerOptions1
            ;
                flora_file_op(expand,File,ExpandedFile),
                flora_delete_from_list(FL_CUSTOM(File),NewTrailerOptions1,NewTrailerOptions1Tmp),
                NewTrailerOptions2 = [FL_CUSTOM(ExpandedFile)|NewTrailerOptions1Tmp]
            )
        ; NewTrailerOptions2 = NewTrailerOptions1
        ),
        add_default_options(Defaults,NewTrailerOptions2,NewTrailerOptions).


add_default_options([],Options,Options) :- !.
add_default_options([Opt|Defaults],CurrentOptions,NewOptions) :-
        add_one_option(Opt,CurrentOptions,NewOptions1),
        add_default_options(Defaults,NewOptions1,NewOptions).

add_one_option(Option,[],[Option]) :- !.
add_one_option(Option,[HeadOpt|Options],[HeadOpt|NewOptions]) :-
        (
          (conflicting_semantics_options(Option,HeadOpt)
          ; Option = HeadOpt
          )
        ->
          NewOptions = Options
        ;
          add_one_option(Option,Options,NewOptions)
        ).



check_custom_trailer_file(TrailerOptions) :-
        ( memberchk(FL_CUSTOM(File),TrailerOptions)
        ->
            (File == NONE, !
            ;
                flora_file_op(expand,File,ExpandedFile),
                (flora_file_op(exists, ExpandedFile), !
                ; flora_error_line('Custom trailer file not found: ~w', [ExpandedFile]),
                    fail
                )
            )
        ;
            true
        ).



/*
    flora_read_parse_compile_build_term(-Code,?Module,-Status)

    Reads a term from std input, parses, compiles, and builds it.
    Term can also be a reification.
    Molecules or rules are not allowed unless represented as reified terms.
    Always succeeds (unless there is a bug).

    Code: the code of the term read. 
          If the thing read is not a term then Code is left unbound
    Module: If unbound then FLORA_DEFAULT_WORKSPACE is assumed.
            If bound and if the term is a reification then the reified formula
	    is built for this module.
    Status: [OutcomeFlag, EOF_flag|ErrorList]
            OutcomeFlag = null/ok/error
	       null  - a blank line was read, no code generated (Code = null)
	       ok    - good code was generated, no errors
	       error - parsing/compilation errors
	    EOF_flag = eof/not_eof
               not_eof -  end-of-file has not been reached
	       eof     -  if it has been reached. 
            ErrorList - if OutcomeFlag=null/ok, then this list would be empty.
                        if OutcomeFlag=error, then this would be a list of the
			form [error(N1,N2,Message), ...]
			N1, N2 encode the line and character number, which is
			largely irrelevant in this context. Message is an error
			message that explains the problem. Error messages are 
			also printed to stderr.
*/
flora_read_parse_compile_build_term(Code,Module,Status) :-
        flora_read_parse_compile_build_term_errwarn(Code,Module,Status,print).
%% This version has PrintErr. If nonvar - print errors and warnings
flora_read_parse_compile_build_term_errwarn(Code,Module,Status,PrintErr) :-
        (var(Module) -> Module = FLORA_DEFAULT_WORKSPACE; true),
        flora_tokens(InputTokens,LexerStatus), 
        %% get Tokens
        count_errors(LexerStatus,LexErrNum),
        count_warnings(LexerStatus,LexWarnNum),
        ( LexErrNum > 0 ->
            ErrNum=LexErrNum,
            Status1 = LexerStatus
        ; flora_blank_line(InputTokens) ->
            ErrNum = 0,
            Outcome = FLORA_NULL_CODE,
            Code = NULL
        ; %% compose
            flora_compose(InputTokens,ComposerTerm,ComposerStatus),
            count_errors(ComposerStatus,CompoErrNum),
            ( CompoErrNum > 0 ->
                ErrNum=CompoErrNum,
                Status1=ComposerStatus
            ; %% parse
                flora_parse_term_external(ComposerTerm,ParseTerm,ParserStatus),
                count_errors(ParserStatus,ParErrNum),
                ( ParErrNum > 0 ->
                    ErrNum=ParErrNum,
                    Status1 = ParserStatus
                ; %% compile
                    flora_set_compilation_context(CONTEXT_READ_PARSE_COMPILE),
                    flora_compile_pathexp(ParseTerm,CompileCode,CompileStat),
                    flora_clear_compilation_context(CONTEXT_READ_PARSE_COMPILE),
                    count_errors(CompileStat,CompiErrN),
                    ( CompiErrN > 0 ->
                        ErrNum=CompiErrN,
                        Status1=CompileStat 
                    ;
                        flora_build_struct(CompileCode, Module,
                                           '', %% does not matter which context
                                           _Varlist, Code,
                                           _, CoderStatus),
                        count_errors(CoderStatus,ErrNum),
                        Status1 = CoderStatus
                    )
                )
            )
        ),

        (var(ComposerStatus) -> ComposerStatus = NO_ERRORS ; true),
        (var(ParserStatus) -> ParserStatus = NO_ERRORS ; true),
        (var(CompileStat) -> CompileStat = NO_ERRORS ; true),
        (var(CoderStatus) -> CoderStatus = NO_ERRORS ; true),
        (LexErrNum+LexWarnNum > 0 ->
            LexerInfo = lexer([(InputTokens,LexerStatus)])
        ; LexerInfo = lexer(NO_ERRORS)
        ),
        EWS=[error(ErrNum),
             LexerInfo,
             composer(ComposerStatus),
             parser(ParserStatus),
             compiler(CompileStat),
             coder(CoderStatus)],

        (nonvar(PrintErr) ->
            print_warnings(EWS),
            print_errors(EWS)
        ; true
        ),

        (ErrNum == 0 -> Status2 = NO_ERRORS; Status2 = Status1),
        (Outcome == FLORA_NULL_CODE -> true
        ; Status2 = NO_ERRORS -> Outcome = FLORA_GOOD_CODE
        ; Outcome = FLORA_BAD_CODE
        ),
        ( flora_end_of_input(LexerStatus)
        -> Status = [Outcome,FLORA_EOF|Status2]
        ;  Status = [Outcome,FLORA_NOT_EOF|Status2]
        ),
        !.

/*
    flora_read_parse_compile_build_term(-String,-Code,?Module,-Status)
    Like flora_read_parse_compile_build_term/3 but reads from a source
    such as a string (atom(String)) or a file (file(FileName)).
*/
flora_read_parse_compile_build_term(Source,Code,Module,Status) :-
        flora_read_parse_compile_build_term_errwarn(Source,Code,Module,Status,print).
%% If PrintErr is nonvar, print errors and warnings
flora_read_parse_compile_build_term_errwarn(Source,Code,Module,Status,PrintErr) :-
        see_source(Source,IOPort,OldStdin),
        !,
        (flora_read_parse_compile_build_term_errwarn(Code,Module,Status,PrintErr),
            seen_source(IOPort,OldStdin)
        -> true
        ; %% failure is impossible unless a bug
            seen_source(IOPort,OldStdin),
            fail
        ).

/*
   flora_read_parse_compile_build_term_list(+Source,-CodeList,?Module)

   This is like flora_read_parse_compile_build_term/4, but
   it collects all terms from the source (atom(Str) or file(FileName),
   which looks like Term. Term. ... Term.
   and returns them in a list, CodeList, of the form code(TermCode,Status).
   TermCode is the compiled code of a term in String, and Status is the status
   of the compilation for this term, as in flora_read_parse_compile_build_term/3
*/
flora_read_parse_compile_build_term_list(Source,CodeList,Module) :-
        see_source(Source,IOPort,OldStdin),
        !,
        /*
        %% using flora_read_parse_compile_build_loop/3 is more parsimonious
        read_parse_compile_build_terms(CodeList,Module),
        */
        findall(code(Code,Status),
                flora_read_parse_compile_build_loop(Code,Module,Status),
                CodeList),
        seen_source(IOPort,OldStdin).

/*
   flora_read_parse_compile_build_loop(-Code,?Module,-Status) :-

   This one is useful for reading terms one-by-one and returning answers
   interactively. 
   Under 1-at-a-time solution (_one), will wait for input, return parsed code,
   then wait for input again, if the user types ";". If the user types
   RET then succeeds and exits.
   Under the all-solutions semantics (_all), will wait for inputs and process
   them, but will not return answers unless the file is closed (e.g., Ctl-D at
   standard input).
*/
flora_read_parse_compile_build_loop(Code,Module,Status) :-
        flora_read_parse_compile_build_term_errwarn(Code1,Module,Status1,_),
        (Status1 \== [null,eof], Code=Code1, Status=Status1
        ; Status1 == [null,eof] -> fail
        ; flora_read_parse_compile_build_loop(Code,Module,Status)
        ).

flora_read_parse_compile_build_loop(Stream,Code,Module,Status) :-
        seeing(OldStdin),
        see(Stream),
        !,
        (flora_read_parse_compile_build_loop(Code,Module,Status)
        ; see(OldStdin),
            %% as with other stream-oriented I/O, assume user will close
            %% the input stream. Hence, we are not closing it here.
            %%close(Stream),
            fail
        ).


:- export see_source/3, seen_source/2. %% this is a temporary export
see_source(Source,IOPort,OldStdin) :-
        seeing(OldStdin),
        open(Source, read, IOPort),
        see(IOPort).

seen_source(IOPort,OldStdin) :-
        seen,
        see(OldStdin),
        close(IOPort).

check_xpp_process_status(File,Process,Action) :-
        process_control(Process,wait(ExitStatus)),
        (ExitStatus == 0 -> true
        ;
            (var(File) -> Message = 'input stream'
            ; Message = File
            ),
            flora_error_line('error while preprocessing ~w', [Message]),
            (Action==close_on_error ->
                flora_clear_xpp_options,
                seen
            ; true
            ),
            !,
            fail
        ).


%% Preprocess a data file (for "read") and modularize its name
%% If file does not exist, do nothing
xpp_datafile_for_module_and_cache(File,_PreprocessedFile,_Module) :-
        \+flora_file_op(exists,File),
        !.
xpp_datafile_for_module_and_cache(File,PreprocessedFile,Module) :-
        flora_set_xpp_options_for_read(Module),
        %% Don't issue irrelevant warnings
        flora_add_xpp_options('-warninglevel 1 '),
        xpp_process_file(File,XPP_process,IOportFromProc),
        %% copy the preprocessed result to file
        file_open(PreprocessedFile,w,PostGppPort),
        copyIOport(IOportFromProc,PostGppPort),
        close(PostGppPort),
        %% Release the file descriptor used to read from xpp.
        close(IOportFromProc),
        %% Wait so as not to leave zombies.
        !,
        check_xpp_process_status(File,XPP_process,do_nothing),
        flora_clear_xpp_options.

%% give the first line where the token begins
flora_token_index_to_line(TokenIndex,Line) :-
        flora_real_token_number(TokenIndex,RealIdx),
        flora_nth_token(RealIdx,Tk),
        flora_token_text(Tk,_TextStr,Line,_BCN,_ELN,_ECN).
%% give the last line where the token ends
flora_token_index_to_last_line(TokenIndex,Line) :-
        flora_real_token_number(TokenIndex,RealIdx),
        flora_nth_token(RealIdx,Tk),
        flora_token_text(Tk,_TextStr,_BLN,_BCN,Line,_ECN).

user_patch_file(UserPatchPFile) :-
        flora_slash(S),
        %% Get file names in user dir.
        flora_user_floradir(UserFloraDir),
        flora_concat_atoms([UserFloraDir,S,S,'patch.P'],UserPatchPFile).


util_remove_file_carefully(File) :-
        ( flora_file_op(exists,File) -> flora_file_op(unlink,File)
        ; true
        ).

util_remove_filelist_carefully([]) :- !.
util_remove_filelist_carefully([H|T]) :-
        util_remove_file_carefully(H),
        util_remove_filelist_carefully(T).



/*********************************************************************
  util_symbol_context_info(+FLSFile,+FLS2File,FlrFile)
  Save symbols that are used in a flora program into and .fls File
**********************************************************************/
util_symbol_context_info(FLSFile,FLS2File,FlrFile) :-
        flora_file_op(localname,FlrFile,LocalName),     
        telling(PreOut),
        tell(FLSFile),
        write_nowarn_symbols(LocalName),
        write_symbols(LocalName),
        told,
        tell(PreOut),
        write_use_symbols(LocalName,FLS2File).

write_symbols(_LocalName):-
        findall(flora_symbol(Name,N,WS,Index,Line,Context,Transactional,SymFile),
                (symbol(Name,N,WS,Index,Line,SymFile,Context,Transactional),
                    Context \== USE_SENSOR_SYMBOL,
                    Context \== USE_UDF_SYMBOL
                ),
                List),
        !,
        write_symbols_list(List).
write_symbols(_).

write_use_symbols(_LocalName,FLS2File):-
        findall(flora_symbol(Name,N,WS,Index,Line,Context,Transactional,SymFile),
                ((symbol(Name,N,WS,Index,Line,SymFile,USE_SENSOR_SYMBOL,Transactional),
                      Context = USE_SENSOR_SYMBOL)
                ; (symbol(Name,N,WS,Index,Line,SymFile,USE_UDF_SYMBOL,Transactional),
                      Context = USE_UDF_SYMBOL)
                ),
                List),
        !,
        (List == [] ->
            %% if FLS2 file exists, delete it
            (flora_file_op(exists,FLS2File) -> flora_file_op(unlink,FLS2File)
            ; true
            )
        ; %% create new FLS2 file
            telling(PreOut),
            tell(FLS2File),
            write_symbols_list(List),
            told,
            tell(PreOut)
        ).

write_use_symbols(_,_).

write_nowarn_symbols(LocalName) :-
        symbol_warnings_flag(Flag),
        write_canonical(symbol_warnings_flag(Flag,LocalName)),
        flora_write_atom('.'),
        nl.

write_nowarn_symbols(LocalName) :-
        findall(flora_nowarn_symbol(Name,N,WS,Context,Transactional,LocalName),
                nowarn_symbol(Name,N,WS,Context,Transactional),
                List),
        !,
        write_symbols_list(List).
write_nowarn_symbols(_).

write_symbols_list([H|T]):-
        write_canonical(H),
        flora_write_atom('.'),
        nl,
        write_symbols_list(T).

write_symbols_list([]).


/*********************************************************************
  util_save_tabled_udf_predicates(+File,+UDFPreds,-Status)
  Save symbols that are used in a flora program into an .fls File
  Status is NULL, if no FLT file needs to be created.
  Otherwise, it is ok (only NULL is checked)
**********************************************************************/
util_save_tabled_udf_predicates(_File,UDFPreds,NULL) :-
        %% UDFPreds have the form [elt,[elt,[elt,...]]]. Var = end of list.
        %% TODO: Change to difference lists!
        length(UDFPreds,0),
        !.
util_save_tabled_udf_predicates(File,UDFPreds,ok) :-
        telling(PreOut),
        tell(File),
        write_tabled_udf_predicates(UDFPreds),
        told,
        tell(PreOut).

write_tabled_udf_predicates(T) :- var(T), !.

write_tabled_udf_predicates([(PredName,PredArity),UDFPreds]):-
        flora_write_atom('%% FLORA_UDF_DYNAMIC_TABLING is UNused,\n'),
        flora_write_atom('%% as dynamic+tabled is UNimplemented in XSB\n'),
        flora_write_atom('#if defined(FLORA_UDF_DYNAMIC_TABLING)'),
        nl,
        %% in case PredName has single quotes in it
        flora_double_backslash_and_quotes(PredName,PredName2),
        flora_write_atom(':-(dynamic(as(''/''(FLORA_THIS_WORKSPACE('),
        write(PredName2),
        flora_write_atom(')'),
        flora_write_atom(','),
        write(PredArity),
        flora_write_atom('),FLORA_DYNAMICS_TYPE))).'),
        nl,
        flora_write_atom('#endif'),
        nl,
        flora_write_atom('TABLING_CONNECTIVE(table(as(''/''(FLORA_THIS_WORKSPACE('),
        write(PredName2),
        flora_write_atom(')'),
        flora_write_atom(','),
        write(PredArity),
        flora_write_atom('),AUXILIARY_TABLING_TYPE))).'),
        nl,
        write_tabled_udf_predicates(UDFPreds),
        !.

write_tabled_udf_predicates(_).

/******************************************************************************
**   flora_cleanup_registry(+Module)
**   flora_cleanup_udf(+Module)
**
** These are called when a new module is loaded, but not when added.
** This is because we want UDFs and modular prolog predicates to be inherited
** by added files. If the loaded context has a symbol, foo/N,
** which is declared as modular prolog or a UDF and we are adding another file
** in which foo/N is compiled differently, then there would be a loading error.
** So, this inheritance is safe.
** 
******************************************************************************/

flora_cleanup_registry(Module) :-
        (retract(flora_defeasible_module_registry(Module,_)) -> true
        ; true
        ),
        incr_retractall(flora_load_registry(_,Module,_,_,_,_,_)),
        incr_retractall(flora_imported_module_registry(Module,_)).

flora_cleanup_udf(Module) :-
        (Module == FLORA_DEFAULT_WORKSPACE ->
            %% flora_useudf_directive(+Fun,+Arity,+Module,+File,+Line)
            retractall(flora_useudf_directive(_,_,_,_,_)),
            %% flora_used_udf_registry(+Fun,+Arity,-UDFCode,-NewPredCode)
            retractall(flora_used_udf_registry(_,_,_,_))
        ; true
        ),
        flora_fls_storage_name(Module,FLSStorage),
        flora_db_delete_all(FLSStorage),
        abolish_udf_predicates(Module).

abolish_udf_predicates(Module) :-
        repeat,
        ( flora_defined_udf_registry(Module,_Fun,FunArity,_,FunPred,_),
            %% UDF predicate's arity is function arity+2
            FunArity2 is FunArity+2,
            current_predicate(FunPred/FunArity2),
            abolish(FunPred,FunArity2),
            fail
        ; true
        ),
        retractall(flora_defined_udf_registry(Module,_,_,_,_,_)).

abolish_modular_prolog_predicates(Module) :-
        repeat,
        ( flora_modular_prolog_registry(P,Arity,Module),
            %% modular Prolog predicate's arity is arity+1 (caller)
            flora_modularize_atom(P,Module,ModularName),
            Arity1 is Arity+1,
            current_predicate(ModularName/Arity1),
            %% very strange: changing the line below to
            %% abolish(ModularName/Arity1) gives a type error
            abolish(ModularName,Arity1),
            fail
        ; true
        ),
        retractall(flora_modular_prolog_registry(_,_,Module)).

flora_cleanup_rule_metadata(Module) :-
        retractall(FL_RULE_ENABLER(_,_,Module)),
        retractall(FL_TAG_DESCRIPTOR_META_PREDICATE(_,_,Module,_,_)),
        retractall(FL_BOOL_DESCRIPTOR_META_PREDICATE(_,_,Module,_,_)),
        retractall(FL_PROP_DESCRIPTOR_META_PREDICATE(_,_,Module,_,_,_)).

non_udf_user_modular_prlgdefs(ModularPlgPredLst) :-
        findall(P/A,
                (
                  flora_user_modular_prlgdefs(P,A),
                  \+flora_match_substring(NEWUDFPREDICATENAME,P,0)
                ),
                ModularPlgPredLst1),
        sort(ModularPlgPredLst1,ModularPlgPredLst).

udf_user_modular_prlgdefs(ModularPlgPredLst) :-
        findall(P/A,
                flora_user_modular_prlgdefs(P,A),
                ModularPlgPredLst1),
        sort(ModularPlgPredLst1,ModularPlgPredLst).


%% Save the meta info provided in theMetaFactList from the compiler
util_save_meta_info([],_File,[]) :- !.
util_save_meta_info(MetaFactList,File,CoderStatus) :-
        telling(PreOut),
        tell(File),
        %% Include Macro definitions.
        flora_current_out_line('#include "flrheader.flh"'),
        flora_get_counter(FLORA_COMPILATION_COUNTER,CompId),
        flora_current_out_line('#define FLORA_COMPILATION_ID ~w~n',[CompId]),
        flora_current_out_nl,
        flora_extern_code(MetaFactList,CoderStatus),
        told,
        tell(PreOut).


%% This is used because retractall/1 is either slow by itself
%% or is prone to invoke garbage collection too often
%% Using retractall slows down the compiler tremendously for large rule sets
%% The fail-loop is preferable for crearing up small predicates
%%flora_retractall_substitute(X) :- retractall(X).
flora_retractall_substitute(X) :- (retract(X), fail ; true).


%%% For profiling: xsb_profiling:profile_call(...)


flora_experimenting_with(no_attr_vars) :- flora_attributed_vars_disabled.
flora_experimenting_with(attr_vars) :- \+flora_attributed_vars_disabled.
flora_experimenting_with(delay_naf) :-
        flrdelaysupport:enable_experiment(delay_naf).
flora_experimenting_with(not_delaying_naf) :-
        flrdelaysupport:disable_experiment(delay_naf).


/*********************************************************************
  flora_print_include_statement(+FilePath)
**********************************************************************/
/*
flora_print_include_statement(FilePath):-
	parse_filename(FilePath,_Dir,Base,Ext),
	flora_concat_atoms(['#include "',Base,'.',Ext,'"'],IncludeCommand),
	flora_current_out_line(IncludeCommand).
*/
	
/*********************************************************************
  flora_print_define_filename_statement(+FilePath,+DefName),
**********************************************************************/
flora_print_define_filename_statement(FilePath,DefName):-
        parse_filename(FilePath,_Dir,Base,Ext),
        flora_concat_atoms(['#define ',DefName,' "',Base,'.',Ext,'"'],DefCommand),
        flora_current_out_line('#mode save\n#mode nocomment "%"'),
        flora_current_out_line(DefCommand),
        flora_current_out_line('#mode restore').
        

%% Mode: beginning/end. Specifies which bridge rules to write: dyn_a or dyn_z
util_add_modular_prlg_bridge_rules([],_) :- !.
util_add_modular_prlg_bridge_rules([P/A|ModularPrlgPredList],Mode) :-
        flora_coder_write_prolog_bridge_rule(P,A,Mode),
        util_add_modular_prlg_bridge_rules(ModularPrlgPredList,Mode).

util_add_conditional_modular_prlg_bridge_rules([]) :- !.
util_add_conditional_modular_prlg_bridge_rules([P/A|ModularPrlgPredList]) :-
        flora_coder_write_conditional_prolog_bridge_rule(P,A),
        util_add_conditional_modular_prlg_bridge_rules(ModularPrlgPredList).

extractTokenRange(Tokens,TokenRange):-
        first_significant_token(Tokens,FirstToken),
        !,
        last(Tokens,LastToken),
        (flora_token_text(FirstToken,_,L1,C1,_,_) -> true
        ; L1 = -1, C1 = -1
        ),
        (flora_token_text(LastToken,_,_,_,L2,C2) -> true
        ; L2 = L1, C2 = C1
        ),
        (L1 == -1 -> TokenRange = NULL
        ;
            TokenRange = FL_TEXTUAL_INFO_PRED(_StmtNum,_StmtFN,L1,C1,L2,C2)
        ).
extractTokenRange(_Tokens,NULL).

first_significant_token([COMMENT(_)|TokenList],Token) :-
        !,
        first_significant_token(TokenList,Token).
first_significant_token([WHITESPACE(_)|TokenList],Token) :-
        !,
        first_significant_token(TokenList,Token).
first_significant_token([Token|_TokenList],Token).

util_save_textual_info(TextualInfoList,FTXFile) :-
        util_FLR_filename(FTXFile,FlrFile),
        telling(OldFile),
        tell(FTXFile),
        flora_current_out_line('%% Textual information for source file: ~w~n~n',
                               [FlrFile]),
        util_write_textual_info(TextualInfoList),
        told,
        tell(OldFile).
util_write_textual_info([]) :- !.
util_write_textual_info([NULL|TextualInfoList]) :-
        util_write_textual_info(TextualInfoList).
util_write_textual_info([TextInfo|TextualInfoList]) :-
        write_canonical(TextInfo), put(CH_DOT), nl,
        util_write_textual_info(TextualInfoList).

util_save_include_file_info(FlrFile) :- %% does not matter which file is passed
        util_FPJ_filename(FlrFile,FPJFile),
        telling(OldFile),
        tell(FPJFile),
        flora_current_out_line('%% #include info for source file: ~w~n~n',
                               [FlrFile]),
        write_canonical((:- multifile FLORA_INCLUDE_PRJ_INFO/2)),
        put(CH_DOT), nl,
        !,
        %% record if in production mode
        (has_compiler_persistentoption(production_mode) ->
            write_canonical(FLORA_INCLUDE_PRJ_INFO(in_production_mode)),
            put(CH_DOT), nl
        ; true
        ),
        repeat,
        (FLORA_PROJECT_DEPENDENCY(File,Included),
            write_canonical(FLORA_INCLUDE_PRJ_INFO(File,Included)),
            put(CH_DOT), nl,
            fail
        %% the next write adds a dummy record -- just so
        %% that we'll be able to always check if the file is loaded
        ; write_canonical(FLORA_INCLUDE_PRJ_INFO(FlrFile, NULL)),
            put(CH_DOT), nl
        ),
        told,
        tell(OldFile).

load_include_dependencies(FlrFile) :-
        util_FPJ_filename(FlrFile,FPJFile),
        load_dyn(FPJFile).

util_save_query_code(QueryList,Status) :-
        flora_current_out_line('\n\n%%%%%%%%%%%%%%%%%%%%%%% Queries found in the source file %%%%%%%%%%%%%%%%%%%%%%%'),
        flora_current_out_line('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'),
        flora_extern_code(QueryList,Status),
        nl.

util_save_latent_query_signatures(LatentQueryList,Status) :-
        flora_current_out_line('\n\n%%%%%%%%%%%%%%%%%%%%%%%%% Signatures for latent queries %%%%%%%%%%%%%%%%%%%%%%%%'),
        flora_current_out_line('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n'),
        flora_extern_code(LatentQueryList,Status),
        nl.

/******************************************************************************
   flora_get_textual_info(+RuleId,+StmtFileSpec,-Info)
   StmtFileSpec: can be absolute or relative name.
                 Or just even the base name.
                 Can also be FL_SHELL_FICTITIOUS_FILENAME or
	  FL_DYNRULE_FICTITIOUS_FILENAME(PrintableFile)

   Info: FL_TEXTUAL_INFO_PRED(StmtNum,ShortStmtFileSpec,BegLn,BegCh,EndLn,EndCh)
   If the textual info file does not exist, this predicate fails.
******************************************************************************/
flora_get_textual_info(RuleId,StmtFileSpec,Info) :-
        extract_stmt_fileinfo_from_filespec(StmtFileSpec,PrintableFileName,ShortStmtFileName,ShortStmtFileSpec),
        (\+FL_TEXTUAL_INFO_PRED(_,ShortStmtFileName,_,_,_,_) ->
            %% Must really have StmtFileSpec as a full file name or else
            %% FTXFile might not be found if executing from a directory
            %% different from where StmtFileSpec is.
            util_FTX_filename(PrintableFileName,FTXFile),
            (flora_file_op(exists,FTXFile) -> load_textual_info(FTXFile)
            ; PrintableFileName == FL_UNKNOWN_OBJECT -> fail
            ; flora_file_op(cwd,CWD),
                flora_concat_atoms(['FIXME: flora_get_textual_info: FTXFile ',
                                    FTXFile,
                                    ' (for ', PrintableFileName,
                                    ')\n\t  not found in current directory ',
                                    CWD, '\n\n'],
                                   Warning),
                flora_warning_line(Warning)
                /*
                ,flora_abort(['Bug: flora_get_textual_info: FTXFile ', FTXFile,
                             ' (for ', PrintableFileName,
                             ')\n\t  not found in current directory ', CWD])
                */
            )
        ; true
        ),
        get_rule_or_query_number(RuleId,ShortStmtFileSpec,StmtNum),
        Info = FL_TEXTUAL_INFO_PRED(StmtNum,ShortStmtFileName,_,_,_,_),
        call(Info).

get_rule_or_query_number(RuleId,ShortStmtFileSpec,StmtNum) :-
        matching_rule_signature(RuleId,ShortStmtFileSpec,_DescrVarTerm,_Prefix,_Head,_Body,Signature),
        rule_signature_member(rulenumber,Signature,StmtNum),
        !.
get_rule_or_query_number(RuleId,ShortStmtFileSpec,StmtNum) :-
        %% dynamic rule
        matching_rule_signature(RuleId,FL_DYNRULE_FICTITIOUS_FILENAME(ShortStmtFileSpec),_DescrVarTerm,_Prefix,_Head,_Body,Signature),
        rule_signature_member(rulenumber,Signature,StmtNum),
        !.
get_rule_or_query_number(RuleId,ShortStmtFileSpec,StmtNum) :-
        matching_query_signature(RuleId,ShortStmtFileSpec,_Mod,Signature),
        query_signature_member(rulenumber,Signature,StmtNum),
        !.
get_rule_or_query_number(RuleId,ShortStmtFileSpec,StmtNum) :-
        %% dynamic latent query
        matching_query_signature(RuleId,FL_DYNRULE_FICTITIOUS_FILENAME(ShortStmtFileSpec),_Mod,Signature),
        query_signature_member(rulenumber,Signature,StmtNum).


load_textual_info(FTXFile) :-
        flora_loader_message('Dynamically loading ~w', [FTXFile]),
        seeing(OldF),
        see(FTXFile),
        repeat,
        read_canonical(Term),
        ( Term == end_of_file, !
        ;
            storage_insert_fact(flora_textual_info_trie,Term,_),
            fail
        ),
        seen,
        see(OldF),
        Info = FL_TEXTUAL_INFO_PRED(_X,_Y,_Z,_U,_V,_W),
        assert((Info :- storage_find_fact(flora_textual_info_trie,Info))).

clear_file_textual_info(FileName) :-
        flora_file_op(localname,FileName,ShortFileName),
        repeat,
        (storage_delete_fact(flora_textual_info_trie,
                             FL_TEXTUAL_INFO_PRED(_,ShortFileName,_,_,_,_),
                             _),
            fail
        ; true
        ).

skip_loading(FlrFile,PFile,WSXWAMFile,Module,Mode) :-
        flora_load_registry(FlrFile,Module,_,_,Mode,_,(LoadTimeSecs,LoadTimeNanosecs)),
        \+ (flora_module_registry(Module,FL_CHANGED,ChangingFile),
               ChangingFile \= FlrFile),
        file_time_ns(WSXWAMFile,WSXWAMFileTime,WSXWAMFileTimeNanosecs),
        %% resolution is 1 sec on Windows, so WSXWAMFileTime = LoadTimeSecs
        %% are likely
        %% It is a slight problem, which may result in unnecessary reloads
        (WSXWAMFileTime < LoadTimeSecs -> true
        ; WSXWAMFileTime==LoadTimeSecs, WSXWAMFileTimeNanosecs < LoadTimeNanosecs
        ),
        flora_file_op(newerthan,WSXWAMFile,FlrFile),
        flora_file_op(newerthan,WSXWAMFile,PFile),
        skip_recompile(FlrFile,PFile,Module),
        \+ dependent_file_changed(FlrFile),
        \+ included_file_changed(FlrFile,PFile).

skip_recompile(FlrFile,PFile,_Mod) :-
        %% this case occurs when FlrFile is missing and we are trying the .pl
        %% file in the Flora-2 hidden dir that contains compiled files
        FlrFile == PFile,
        !.
skip_recompile(FlrFile,PFile,Module) :-
        %% skip recompilation, if the compiled files are newer than sources
        util_file_newerthan(PFile,FlrFile),
        user_patch_file(UsrPatchFile),
        util_file_newerthan(PFile,UsrPatchFile),
        %% Disregarding the included file info for system modules to avoid 
        %% recompilation of these modules after installation. Otherwise,
        %% there can be race conditions where these modules might be compiled
        %% by some instances of Flora-2 and used by others. This may happen
        %% if the two instances refer to the same installation of Flora-2
        %% via different, but equivalent pathnames.
        (flora_is_system_module_name(Module) -> true
        ; \+ included_file_changed(FlrFile,PFile)
        ).

%% checks if there a load-dependent file that changed since loading?
%% or if a module into which the file was loaded changed
dependent_file_changed(FlrFile) :-
        flora_load_deps_closure(FlrFile,Dependent),
        flora_load_registry(Dependent,Module,_,_,_Mode,_,(DependentLoadTimeSecs,DependentLoadTimeNanosecs)),
        (flora_module_registry(Module,FL_CHANGED) -> true
        ; file_time_ns(Dependent,DependentModTimeSecs,DependentModTimeNanosecs),
            (DependentModTimeSecs > DependentLoadTimeSecs -> true
            ; DependentModTimeSecs == DependentLoadTimeSecs,
                DependentModTimeNanosecs >= DependentLoadTimeNanosecs
            )
        ).

%% is there a load-dependent file that changed since loading?
%% if FPJFile or FTXFile files were deleted after compiling,
%% then this will cause a recompile.
%% If they were deleted after loading then no recompile.
included_file_changed(FlrFile,PFile) :-
        util_FPJ_filename(FlrFile,FPJFile),
        (FLORA_INCLUDE_PRJ_INFO(FlrFile,_) -> true   %% already loaded
        ; \+ flora_file_op(exists,FPJFile) -> true
        ; util_FTX_filename(FlrFile,FTXFile),
            \+ flora_file_op(exists,FTXFile) -> true
        ; load_dyn(FPJFile)
        ),
        file_time_ns(PFile,PFileModTime,PFileModTimeNano),
        !,
        %% in production mode, don't check for included files
        ( FLORA_INCLUDE_PRJ_INFO(in_production_mode) -> fail
        %% next test means no #include statements - don't recompile
        ; \+ (FLORA_INCLUDE_PRJ_INFO(_,SomeDepF), SomeDepF \== NULL) -> fail
        %% PRJ file is stale - recompile
        ; \+ FLORA_INCLUDE_PRJ_INFO(FlrFile,_) -> true
        ; FLORA_INCLUDE_PRJ_INFO(FlrFile,Dependent),
            Dependent \== NULL,
            file_time_ns(Dependent,DependentModTime,DependentModTimeNano),
            (DependentModTime > PFileModTime
            ; DependentModTime == PFileModTime,
                DependentModTimeNano >= PFileModTimeNano
            )
        ).

%% update_load_registry(+FlrFile,+WSXWAMFile,+Module,+HostFile,+Mode)
%% Mode: add/load
update_load_registry(FlrFile,WSXWAMFile,Module,HostFile,Mode) :-
        flora_file_op(localname,FlrFile,ShortFlrFile),
        file_time_ns(WSXWAMFile,WSXWAMFileTimeSecs,WSXWAMFileTimeNanosecs),
        incr_retractall(flora_load_registry(FlrFile,Module,_,_,Mode,HostFile,_)),
        %% clear textual information each time we load/add a file
        clear_file_textual_info(FlrFile),
        epoch_nanoseconds(LoadTimeSecs,LoadTimeNano),
        incr_assert(flora_load_registry(FlrFile,Module,ShortFlrFile,(WSXWAMFileTimeSecs,WSXWAMFileTimeNanosecs),Mode,HostFile,(LoadTimeSecs,LoadTimeNano))),
        retractall(flora_module_registry(Module,_,_)),
        (Mode == add ->
            assert(flora_module_registry(Module,FL_CHANGED,FlrFile))
        ; Mode == load -> assert(flora_module_registry(Module,FL_UNCHANGED,'NULL'()))
        ; true % Mode == fastload
        ).

check_for_import_cyclicity :-
        %% check for cyclic module import
        findall(X,flora_module_import_closure(X,X),ModList),
        fmt_write_string(ModStr,'%S',arg(ModList)),
        (ModList == [] -> true
        ; 
            flora_abort(['cyclicity in :- importmodule directives detected involving these modules: ',
                         ModStr,
                         '. Restructure before proceeding.'],
                        FLORA_ABORT_NOTRACE)
        ).

escape_quotes(Atm,AtmOut) :-
        atom_codes(Atm,AtmL),
        escape_quotes_aux(AtmL,AtmOutL),
        atom_codes(AtmOut,AtmOutL).

escape_quotes_aux([],[]) :- !.
escape_quotes_aux([CH_QUOTE|AtmL],[CH_BACKSLASH,CH_QUOTE|AtmOutL]) :-
        !,
        escape_quotes_aux(AtmL,AtmOutL).
escape_quotes_aux([Ch|AtmL],[Ch|AtmOutL]) :-
        escape_quotes_aux(AtmL,AtmOutL).


%% Control the warnings
flora_warnings_control(X) :- 
        (flora_warnings_level(nocompiler) -> X = (compiler=off)
        ; X = (compiler=on)
        )
        ;
        (flora_warnings_level(nodependency) -> X = (dependency=off)
        ; X = (dependency=on)
        )
        ;
        (flora_warnings_level(noruntime) -> X = (runtime=off)
        ; X = (runtime=on)
        )
        ;
        (\+flora_warnings_level(_) -> X = all
        ; flora_warnings_level(nocompiler),
            flora_warnings_level(nodependency),
            flora_warnings_level(noruntime)
        -> X = off
        ).

flora_set_warnings_control(X) :- 
        \+ground(X),
        !,
        flora_error_line('invalid warnings control option: ~w', [X]),
        throw(FLORA_TOP_LEVEL).
flora_set_warnings_control(off) :- 
        !,
        retractall(flora_warnings_level(_)),
        assert(flora_warnings_level(nocompiler)),
        assert(flora_warnings_level(nodependency)),
        assert(flora_warnings_level(noruntime)).
flora_set_warnings_control(all) :-
        !,
        retractall(flora_warnings_level(_)).
flora_set_warnings_control(compiler=on) :-
        !,
        retractall(flora_warnings_level(nocompiler)).
flora_set_warnings_control(compiler=off) :-
        !,
        (flora_warnings_level(nocompiler) -> true
        ; assert(flora_warnings_level(nocompiler))
        ).
flora_set_warnings_control(dependency=on) :-
        !,
        retractall(flora_warnings_level(nodependency)).
flora_set_warnings_control(dependency=off) :-
        !,
        (flora_warnings_level(nodependency) -> true
        ; assert(flora_warnings_level(nodependency))
        ).
flora_set_warnings_control(runtime=on) :-
        !,
        retractall(flora_warnings_level(noruntime)).
flora_set_warnings_control(runtime=off) :-
        !,
        (flora_warnings_level(noruntime) -> true
        ; assert(flora_warnings_level(noruntime))
        ).
flora_set_warnings_control(X) :- 
        flora_error_line('invalid warnings control option: ~w', [X]),
        throw(FLORA_TOP_LEVEL).

flora_chatter_control(on) :- !, flora_set_switch(chatter).
flora_chatter_control(off) :- !, flora_clear_switch(chatter).

flora_feedback_control(off) :-
        !,
        flora_set_counter(flora_verbose_feedback,0),
        flora_set_banner_control(nofeedback,1),
        flora_stdfdbk_nl.
%% this blocks feedback just for the current goal
flora_feedback_control(tempoff) :-
        !,
        flora_set_counter(flora_verbose_feedback,0),
        flora_increment_counter(flora_feedback_control,1,_,_),
        (flora_configuration(uimode,studio) -> true
        ; flora_stdfdbk_nl
        ).
flora_feedback_control(on) :-
        !,
        %% flora_feedback_control indicates that we are enabling the feedback
        %% used in flranswer.P
        %% Setting flora_feedback_control counter to 1 disables feedback for
        %% current command. Then flranswer sets it to 0 & feedback is enabled.
        flora_set_counter(flora_feedback_control,1),
        flora_set_counter(flora_verbose_feedback,0),
        flora_set_banner_control(nofeedback,0),
        flora_stdfdbk_nl.
flora_feedback_control(verbose) :-
        flora_feedback_control(on),
        flora_set_counter(flora_verbose_feedback,1).

flora_quietload_control(off) :- !, flora_set_banner_control(quietload,0).
flora_quietload_control(on) :- !, flora_set_banner_control(quietload,1).

flora_prompt_control(off) :- !, flora_set_banner_control(noprompt,1).
flora_prompt_control(tempoff) :- !, flora_set_counter(flora_prompt_control,1).
flora_prompt_control(on) :-
        !,
        flora_set_banner_control(noprompt,0).

:- export
        is_studio_probe_in_progress/0,
        check_if_studio_probe/1,
        flora_studio_probe/1,
        flora_studio_probe_fdbk/1.
flora_studio_probe(Call) :-
        flora_feedback_control(tempoff),
        flora_prompt_control(tempoff),
        flora_studio_probe_fdbk(Call).
flora_studio_probe_fdbk(Call) :-
        flrdebugger:flora_notrace,
        call(Call),
        flora_set_counter(flora_studio_probe_in_progress,0).

is_studio_probe_in_progress :-
        flora_get_counter(flora_studio_probe_in_progress,1).

check_if_studio_probe(Call) :-
        arg(1,Call,(_,flrutils:Call1)),
        functor(Call1,Fun,1),
        memberchk(Fun,[flora_studio_probe,flora_studio_probe_fdbk]),
        !,
        flora_set_counter(flora_studio_probe_in_progress,1).
check_if_studio_probe(_) :-
        flora_set_counter(flora_studio_probe_in_progress,0).


%% zaps one attribute
flora_zap_attrvars(Term,Attribute) :-
        flrterm_vars(Term,Vars,0),
        zap_attribute(Vars,Attribute).
zap_attribute([],_) :- !.
zap_attribute([V|Rest],Attr) :-
        del_attr(V,Attr),
        zap_attribute(Rest,Attr).

%% zaps all attributes
flora_zap_attrvars(Term) :-
        flrterm_vars(Term,Vars,0),
        zap_attribute(Vars).
zap_attribute([]) :- !.
zap_attribute([V|Rest]) :-
        delete_attributes(V),
        zap_attribute(Rest).

xsb_consult_handler(Ball,Module,FlrFile,Mode,CurrentDir,OldCWD,Encoding) :-
        %% The next retractall crashes functions/test_func_facts_load_err.flr
        %% Probably a bug in incremental tabling.
        %%retractall(flora_module_registry(Module,_,_)),
        incr_retractall(flora_load_registry(FlrFile,Module,_,_,Mode,_,_)),
        restore_directory_configuration(CurrentDir,OldCWD),
        set_char_encoding(Encoding),
        throw(Ball).

%% +module, +basename (no extension)
%% Normally, loading is blocked during execution pause except when this is true
breakmode_loadable(File,Mod) :-
        flora_file_op(basename,File,Basename),
        breakmode_loadable_data(Mod,Basename).

%% +module, +basename (no extension)
breakmode_loadable_data(fidji,fidjiUtils).


restore_directory_configuration(CurrentDir,OldCWD) :-
        (CurrentDir == '.' ; CurrentDir == '' ; var(CurrentDir) -> true
        ; nonvar(CurrentDir), remove_lib_dir(CurrentDir) ->
            restore_flora_configuration(cwd,OldCWD),
            %% unclear why this was done:
            %% it causes cwd to be reset to baseworkdir after each load.
            %%reset_cwd_to_basedir,
            true
        ; true
        ).

replace_flora_configuration(Key,Value,OldValue) :-
        (has_flora_configuration_dir(Key,OldValue) ->
            add_flora_configuration_dir(Key,Value)
        ; true
        ).
restore_flora_configuration(Key,Value) :-
        (nonvar(Value), flora_configuration(Key,_) ->
            add_flora_configuration_dir(Key,Value)
        ; true
        ).
%% reset_cwd_to_basedir/0 is not used but kept for later
:- export reset_cwd_to_basedir/0.
reset_cwd_to_basedir :-
        (has_flora_configuration_dir(baseworkdir,D) ->
            flora_file_op(chdir,D),
            restore_flora_configuration(cwd,D)
        ; %% the catch-all case: needed only if baseworkdir is uninitialized,
            %% which would be a bug
            true
        ).

has_char_encoding(Enc) :- current_prolog_flag(character_set,Enc).
set_char_encoding(Enc) :-
        (nonvar(Enc) -> set_prolog_flag(character_set,Enc)
        ; true
        ).

/*
   Create a temporary filename in .xsb/flora-.../tmp/subdir by template
   that consists of a url-encoded input file plus a prefix and a suffix.
   This is guaranteed to be writable and unique (modulo the 3 input args)
   If .xsb/flora-.../tmp does not exist, issue an error

   tempfile_by_template(+InputTemplate,+Subdir1,+Subdir2,,+Prefix,+Suffix,-Result)

   Subdir is assumed to not have any special symbols that are not allowed
   in either Unix or Windows. '', if no subdir
*/
flora_tempfile_by_template(InputTemplate,Subdir1,Subdir2,Prefix,Suffix,Result) :-
        flora_user_floradir(UserDir),
        flora_slash(S),
        url_encode(Subdir1,Subdir1_enc),
        url_encode(Subdir2,Subdir2_enc),
        %% $HOME/.xsb/flora-XXX//Subdir1//Subdir2//
        %% Double slashes are for the windows case, since single \ is an escape
        flora_concat_atoms([UserDir,S,S,Subdir1_enc,S,S],UserTmpDir),
        (Subdir2_enc == '' -> UserTmpSubDir = UserTmpDir
        ;
            flora_concat_atoms([UserTmpDir,Subdir2_enc,S,S],UserTmpSubDir)
        ),
        ( flora_file_op(exists,UserTmpDir) -> true
        ;
            ( flora_file_op(mkdir,UserTmpDir) -> true
            ;
                flora_abort(['cannot create folder for temporary user files: ',
                             UserTmpDir],
                            FLORA_ABORT_NOTRACE)
            )
        ),
        ( flora_file_op(exists,UserTmpSubDir) -> true
        ;
            ( flora_file_op(mkdir,UserTmpSubDir) -> true
            ;
                flora_abort(['cannot create subfolder for temporary user files: ',
                             UserTmpSubDir],
                            FLORA_ABORT_NOTRACE)
            )
        ),
        url_encode(InputTemplate,InputTemplate_enc),
        flora_concat_atoms([UserTmpSubDir,Prefix,InputTemplate_enc,Suffix],Result).

flora_system_info(Key=Value) :-
        System = 'ErgoAI',
        flora_configuration(version,Version),
        flora_configuration(patch,Patch),
        flora_configuration(build,Build),
        flora_configuration(releasedate,Release),
        flora_configuration(name,Codename),
        flora_configuration(fullname,Fullname),
        has_flora_configuration_dir(installdir,FloraDir),
        flora_user_floradir(UserFloraDir),
        flora_file_op(cwd,CurrentDir),
        flora_get_user(User),
        xsb_configuration(architecture,Arch),
        xsb_configuration(host_cpu,Cpu),
        xsb_configuration(config_dir,ArchDir),
        xsb_configuration(config_bindir,BinDir),
        xsb_configuration(install_dir,XSB_installdir),
        xsb_configuration(host_os,OS),
        xsb_configuration(word_size,WordSize),
        flora_concat_atoms([System,' ',
                            Version,Patch,
                            ' (',Codename,
                            '; build: ',Build,', ',Release,') on ',Arch],
                           Info),
        !,
        (Key == version -> Value = Version
        ; Key = version, Value = Version
        ; Key == patch -> Value = Patch
        ; Key = patch, Value = Patch
        ; Key == build -> Value = Build
        ; Key = build, Value = Build
        ; Key == releasedate -> Value = Release
        ; Key = releasedate, Value = Release
        ; Key == codename -> Value = Codename
        ; Key = codename, Value = Codename
        ; Key == fullname -> Value = Fullname
        ; Key = fullname, Value = Fullname
        ; Key == system -> Value=System
        ; Key = system, Value=System
        ; Key == host_cpu -> Value = Cpu
        ; Key = host_cpu, Value = Cpu
        ; Key == architecture -> Value = Arch
        ; Key = architecture, Value = Arch
        ; Key == archdir -> Value = ArchDir
        ; Key = archdir, Value = ArchDir
        ; Key == bindir -> Value = BinDir
        ; Key = bindir, Value = BinDir
        ; Key == os -> Value = OS
        ; Key = os, Value = OS
        ; Key == word_size -> Value = WordSize
        ; Key = word_size, Value = WordSize
        ; Key == info -> Value = Info
        ; Key = info, Value = Info
        ; Key == installdir -> Value = FloraDir
        ; Key = installdir, Value = FloraDir
        ; Key == xsbdir -> Value = XSB_installdir
        ; Key = xsbdir, Value = XSB_installdir
        ; Key == auxdir -> Value = UserFloraDir
        ; Key = auxdir, Value = UserFloraDir
        ; Key == cwd -> Value = CurrentDir
        ; Key = cwd, Value = CurrentDir
        ; Key == user -> Value = User
        ; Key = user, Value = User
        ; nonvar(Key) ->
            flora_abort(['system{',Key,'=?Value}: invalid property, ',Key],
                        FLORA_ABORT_NOTRACE)
        ).
            


/*
  util_tailappend(+L1,+L2,-Result): concatenates the options passed in by the
      compiler efficiently, using difference lists.
   Arg3 is bound to the tail of the list represented by first arg.
   flora_tailappend(X,[a,b],T) gives X=[a,b|T].
   Then T is passed to another flora_tailappend(T,[c,d],T1), etc.
*/
/*
util_tailappend(V,[],V) :- !.
util_tailappend([H|V],[H|L],T) :- util_tailappend(V,L,T).
*/


%% textual primitives
:- import
        flora_user_load_registry/4
   from flrregistry.
:- import
        show_rule_signature/13
   from flrcanon.

:- export
        get_goal_line_info_by_id_and_module/4,
        get_included_files/2,
        user_file_in_memory/4.

%% Note: FLORA_INCLUDE_PRJ_INFO is transitively closed
get_included_files(IncludingFile,IncludedFile) :-
        FLORA_INCLUDE_PRJ_INFO(IncludingFile,IncludedFile),
        %% the pair File-FL_SHELL_FICTITIOUS_FILENAME is always
        %% in the .fpj file, for technical reasons
        IncludedFile \== FL_SHELL_FICTITIOUS_FILENAME.

%% Mode = load/add
%% IncludingFile is the file that includes File or null
%% Returns info about loaded files only
%% user_file_in_memory(?File,?Module,-Mode,-IncludingFile)
user_file_in_memory(File,Module,Mode,NULL) :-
        %% top-level file
        (nonvar(File) ->
            flora_file_op(localname,File,ShortFN),
            flora_user_load_registry(_,Module,ShortFN,Mode)
        ; flora_user_load_registry(File,Module,ShortFN,Mode),
            flora_file_op(localname,File,ShortFN)
        ).
user_file_in_memory(File,Module,Mode,IncludingFile) :-
        %% not top-level file, including unbound File
        %% take care of short filenames: get_included_files deals with abs names
        (nonvar(File), flora_file_op(isabsolute,File) ->
            get_included_files(IncludingFile,File)
        ;  get_included_files(IncludingFile,FileVar),
            flora_file_op(localname,FileVar,File),
            flora_file_op(localname,IncludingFile,ShortIncFN),
            flora_user_load_registry(_,Module,ShortIncFN,Mode)
        ).
        

/*
   get_goal_line_info_by_id_and_module(+RuleId,+Module,-File,TextualInfo)
   Returns info about loaded files only.
   File is SHORT file name, as used in rule Ids.
   Although we don't provide info on the file, the file is found among
   the loaded files. Very low probability (if at all possible!) that the
   returned file name will be ambiguous if:
      1. Different files in SAME module have the same rule Id.
      2. The rules with those Ids have SAME statement numbers in those files.
      3. Not included in SAME file (for then statements Id would be different).
      4. Hmm... Maybe ambiguity not possible?
*/
get_goal_line_info_by_id_and_module(RuleId,Module,File,RuleInfo) :-
        show_rule_signature(RuleId,File,
                            _,_,
                            Module,StmtNum,
                            _Head,_Body,
                            _,_,_,_,_),
        user_file_in_memory(File,Module,_,_),
        flora_user_load_registry(FullFile,Module,File,_Mode),
        flora_get_textual_info(RuleId,FullFile,RuleInfo),
        RuleInfo = FL_TEXTUAL_INFO_PRED(StmtNum,_,_,_,_,_).

%% end textual primitives

#include "extensions/flrutil_struct_db.P"
