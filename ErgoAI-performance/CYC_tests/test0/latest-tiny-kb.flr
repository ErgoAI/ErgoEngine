:- iriprefix{silk = "http://vulcan.com/2008/silk#"}.
:- iriprefix{dc = "http://purl.org/dc/elements/1.1/"}.
:- iriprefix{imp = "http://www.cyc.com/silk/implementation/"}.
:- iriprefix{swrlb = "http://www.w3.org/2003/11/swrlb"}.
:- iriprefix{cyc = "http://sw.cyc.com/2009/04/07/concept/"}.
:- iriprefix{silkb = "http://vulcan.com/2008/silk-builtins#"}.
//:- use_argumentation_theory{ogcle} .
//?- [ogclpe>>ogcle] .
//_overrides(?X,?Y) :- silk#overrides(?X,?Y) .
//_overrides(?X,?Y,?Z,?W) :- silk#overrides(?X,?Y,?Z,?W) .
\"urn:uuid:3ab0cc73-96f0-4634-a678-293a086abb26"[silk#strict] .
istAsserted(BaseKB, termOfUnit(CollectionRuleTemplateFn(ArgIsaPredicate), CollectionRuleTemplateFn(ArgIsaPredicate))) .
\"urn:uuid:7f0f8d1a-73f8-454f-892a-78938aa4739c"[silk#strict] .
istAsserted(BaseKB, termOfUnit(CollectionRuleTemplateFn(HypotheticalContext), CollectionRuleTemplateFn(HypotheticalContext))) .
\"urn:uuid:4302dcdc-c656-4e6d-b82a-88ff706a0cf6"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(afterAdding, SubLSymbolFn(("DECACHE-AFTER-ADDINGS"^^_string)))) .
\"urn:uuid:7b37b63f-c1cf-4ae1-b566-e75cc67f3815"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(afterAdding, SubLSymbolFn(("DECACHE-AFTER-ADDINGS"^^_string)))) .
\"urn:uuid:ccab357f-5337-45d6-a15c-5319647b5d48"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(afterRemoving, SubLSymbolFn(("DECACHE-AFTER-REMOVINGS"^^_string)))) .
\"urn:uuid:e9af1d16-f9a4-4697-9290-86e30882f998"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(afterRemoving, SubLSymbolFn(("DECACHE-AFTER-REMOVINGS"^^_string)))) .
\"urn:uuid:b78c9223-371b-4b2b-b894-775b0c374843"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg1Format, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:a35f78a0-d912-45b4-9fbc-f3e37b04c6a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg1Genl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:59d46c23-b005-454c-8059-b598a66fdef9"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg1Isa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:661a22b7-3694-4146-bf5f-de77ed9bca26"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg1Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:e8c4109c-1aba-4270-b66b-fd3277922b42"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg1Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:424a13d5-5692-4e76-abfd-bc12e2b4cb08"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg1QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:e1894968-ef5c-4302-90c6-30b036719f15"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg1SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:d55df8fc-a259-4f0a-a74c-687420f6d6c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg2Format, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:1948bc49-0a8b-45ac-9c90-ddfd5c1f74cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg2Genl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:3fd684dd-6522-4a82-ae67-3a5d14e82799"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg2Isa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:c43947c6-274b-409f-a573-3cb1ed9ef389"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg2Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:fdc683e8-69fe-4930-8b06-f8cda12685a0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg2Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:027ef09d-4ae9-43b7-8148-53ea31cbf5bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg2QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:1a2c4f62-4511-47ac-a633-dc413a4447a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg2SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:c71903a0-5b4a-49b5-ba1d-ce49a990e6f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg3Format, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:598cad35-81d1-49e3-af4e-4b83ec88d19a"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg3Genl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:dacf28c4-d389-4ac5-a306-f8eb8eb6e98e"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg3Isa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:ff9d4685-4138-4dc5-bec7-0f0e10cab979"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg3Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:13f57cd7-6504-4ad1-8d39-c6af73eee550"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg3Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:bed592d0-6968-4367-bc33-9e49bb4d8a03"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg3QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:6a14f55b-26c1-4fdb-9af0-2251b26c8d38"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg3SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:138c7b49-e68b-4306-9e60-57a0ff484a76"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg4Format, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:b0dada5f-f65d-4d5d-85a3-329b19d11c05"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg4Genl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:5205edcb-d84a-4344-a0d0-fe1bb8346952"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg4Isa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:00db5109-1e04-432b-823c-6f6b268db034"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg4Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:a59ee214-67b0-4f60-9980-33e3699cf151"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg4Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:7755cf36-3c6b-4702-b0d7-8d14b49da18b"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg4QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:dbf2f7da-e620-43f3-99d2-c37021c9247e"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg4SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:cdef124f-3efc-41c1-b9de-f67b08f5de10"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg5Format, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:170d1e56-9147-4108-bc42-65452b9960eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg5Genl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:e1a5a60b-ee73-4598-8adc-9d7076a47fce"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg5Isa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:02788536-e91b-41ae-8861-fbbf25c5a10e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg5Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:3265e994-a986-4a7f-b325-e2243c1e3a2a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg5Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:131527b2-f0bc-4db4-a16b-da71fd354209"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg5QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:4da0a514-b393-4e5f-97ff-f02562eab503"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg5SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:8670dda8-4ee5-465e-b324-8054e5ce4d3a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(arg6Isa, SubLSymbolFn(("CYC-ADD-TO-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:cc874c96-a8f3-4439-8a4c-10830ba48699"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(arg6Isa, SubLSymbolFn(("CYC-REMOVE-FROM-ARG-TYPE-CACHE"^^_string)))) .
\"urn:uuid:7b1f4115-a31a-485a-b28b-28d4d4d421e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg6QuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:236f58f8-e64e-4120-b891-78f66c6e4cc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(arg6SometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:dc9d0fce-dc02-4f6e-be0c-a7bb7dca60ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argAndRestGenl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:42daddfd-b4a1-4785-b8be-aa0cb54cdf83"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argAndRestIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:4cdf2ab9-da32-48ad-8593-788d9110a160"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argGenl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:bb3e663b-3d6d-4fc6-ac9e-8fa5b65ad9eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:3e36d98a-6d1d-463c-a990-aece050a1362"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argQuotedIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:e7f05ada-54eb-4711-acfc-3bb9532648ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(argSometimesIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:a009767b-0868-45c5-9336-2dea4a8ae215"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(arity, SubLSymbolFn(("ADD-ARITY"^^_string)))) .
\"urn:uuid:7df9457b-1db4-4af7-a2fe-fc067743bb00"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(arity, SubLSymbolFn(("REMOVE-ARITY"^^_string)))) .
\"urn:uuid:d76e33e9-9c9f-47d4-b950-e753181bc237"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(arityMax, SubLSymbolFn(("ADD-ARITY-MAX"^^_string)))) .
\"urn:uuid:06afdad4-9fbd-40de-87aa-2f1912595052"[silk#strict] .
istAsserted(BaseKB, afterAdding(arityMax, SubLSymbolFn(("ADD-MAX-ARITY"^^_string)))) .
\"urn:uuid:36021896-fc9d-4566-b04d-1a4aa6f08caa"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(arityMax, SubLSymbolFn(("REMOVE-ARITY-MAX"^^_string)))) .
\"urn:uuid:d659d4df-c484-43ea-885d-9ead7bc6e41f"[silk#strict] .
istAsserted(BaseKB, afterRemoving(arityMax, SubLSymbolFn(("REMOVE-MAX-ARITY"^^_string)))) .
\"urn:uuid:08624057-66ce-411e-a7e8-d22100989059"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(arityMin, SubLSymbolFn(("ADD-ARITY-MIN"^^_string)))) .
\"urn:uuid:d4689763-9ed2-4de3-91a7-ecba9f392c71"[silk#strict] .
istAsserted(BaseKB, afterAdding(arityMin, SubLSymbolFn(("ADD-MAX-ARITY"^^_string)))) .
\"urn:uuid:e3932272-8b98-4a7e-812f-f1b177194f1e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(arityMin, SubLSymbolFn(("REMOVE-ARITY-MIN"^^_string)))) .
\"urn:uuid:3417a10b-79ec-4e78-a228-3c621be05cfe"[silk#strict] .
istAsserted(BaseKB, afterRemoving(arityMin, SubLSymbolFn(("REMOVE-MAX-ARITY"^^_string)))) .
\"urn:uuid:9bc8bbdb-c4e0-478e-a307-bac653af827d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(canonicalizerDirectiveForAllArgs, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:9f827995-06d1-493b-9cb8-726ced40b2d6"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(canonicalizerDirectiveForAllArgs, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:eab716fe-1275-48c0-a98c-de62bdd1ffab"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(canonicalizerDirectiveForArg, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:c78dd339-7301-451c-8a2a-577f2d413450"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(canonicalizerDirectiveForArg, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:72250b25-6cb8-4492-befd-d20c1966c9ee"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(canonicalizerDirectiveForArgAndRest, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:78385108-eab3-4a66-b190-2c4e732256ec"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(canonicalizerDirectiveForArgAndRest, SubLSymbolFn(("RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:92a90388-250f-4f6f-a873-7b3067ab77f0"[silk#strict] .
istAsserted(BaseKB, afterAdding(coExtensional, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:0a3d8321-268e-4831-a0d3-a7ddb3663a92"[silk#strict] .
istAsserted(BaseKB, afterAdding(coExtensional, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLS"^^_string)))) .
\"urn:uuid:18b5261d-73ab-4cfd-8b77-85c5d4a795fc"[silk#strict] .
istAsserted(BaseKB, afterAdding(coExtensional, SubLSymbolFn(("PROPAGATE-TO-GENLS"^^_string)))) .
\"urn:uuid:d62148d2-f119-45b4-90b3-ad446c100d56"[silk#strict] .
istAsserted(BaseKB, afterRemoving(coExtensional, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:b5df522b-0399-4220-b99c-25201d6b7d64"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(comment, SubLSymbolFn(("ADD-SUB-WORD-INDEXED-ASSERTION"^^_string)))) .
\"urn:uuid:8643622d-d28f-4d95-80b0-6a97395bccb4"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterRemoving(comment, SubLSymbolFn(("REMOVE-SUB-WORD-INDEXED-ASSERTION"^^_string)))) .
\"urn:uuid:b311c3d6-c4cb-4fb6-a1e1-a8c80d211e77"[silk#strict] .
istAsserted(BaseKB, afterAdding(defaultReformulationDirectionInModeForPred, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:c28169a6-6cf6-4883-b7e1-1b47f183399d"[silk#strict] .
istAsserted(BaseKB, afterRemoving(defaultReformulationDirectionInModeForPred, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:0c83084b-4ed2-417d-a09d-fad80e78c986"[silk#strict] .
istAsserted(BaseKB, afterAdding(defaultReformulatorModePrecedence, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:fe1f081a-5290-496f-88a6-9dfb76af664b"[silk#strict] .
istAsserted(BaseKB, afterRemoving(defaultReformulatorModePrecedence, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:cc0ab962-f9b7-4bcc-8bfb-2b2a7c81818c"[silk#strict] .
istAsserted(BaseKB, afterRemoving(definingMt, SubLSymbolFn(("REMOVE-DEPENDENT-TERM"^^_string)))) .
\"urn:uuid:2190a129-66a5-4129-b881-1d4a7a2131c1"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(defnIff, SubLSymbolFn(("ADD-IFF-DEFN"^^_string)))) .
\"urn:uuid:01cff0e2-5df1-436b-9e66-f3b3742e283a"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(defnIff, SubLSymbolFn(("REMOVE-IFF-DEFN"^^_string)))) .
\"urn:uuid:b73cd280-a573-434c-a716-197673e7aff1"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(defnNecessary, SubLSymbolFn(("ADD-NEC-DEFN"^^_string)))) .
\"urn:uuid:290321d3-7926-4697-8135-7bd1e29ea808"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(defnNecessary, SubLSymbolFn(("REMOVE-NEC-DEFN"^^_string)))) .
\"urn:uuid:de540b99-898f-44f3-873a-ae38d41e91c9"[silk#strict] .
istAsserted(BaseKB, afterAdding(defnSufficient, SubLSymbolFn(("ADD-SUF-DEFN"^^_string)))) .
\"urn:uuid:971acda7-765d-4e9c-ab9f-08ae23a497b4"[silk#strict] .
istAsserted(BaseKB, afterRemoving(defnSufficient, SubLSymbolFn(("REMOVE-SUF-DEFN"^^_string)))) .
\"urn:uuid:46bd83a9-1003-484d-bf4b-7ad3023d9f4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(disjointWith, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:f2e36fab-0288-446a-9ba6-f8335a27c345"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(disjointWith, SubLSymbolFn(("MDW-AFTER-ADDING"^^_string)))) .
\"urn:uuid:29989396-5755-4a92-95c3-96588564d7c6"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(disjointWith, SubLSymbolFn(("MDW-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:86cb1606-49fd-4fc5-bf24-02895faa55ee"[silk#strict] .
istAsserted(BaseKB, afterAdding(elInverse, SubLSymbolFn(("PROPAGATE-TO-GENLINVERSE"^^_string)))) .
\"urn:uuid:4dc93f82-25b9-427f-b98f-1475f30dbaaa"[silk#strict] .
istAsserted(BaseKB, afterAdding(elInverse, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLINVERSE"^^_string)))) .
\"urn:uuid:e817e0e3-cdde-479f-891c-ef183c976080"[silk#strict] .
istAsserted(BaseKB, afterAdding(elementOf, SubLSymbolFn(("CYC-ADD-ELEMENT-OF"^^_string)))) .
\"urn:uuid:58c9d328-b57d-4340-b67a-27d087705229"[silk#strict] .
istAsserted(BaseKB, afterAdding('equalStrings-CaseInsensitive', SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:de378379-9ffa-4079-adff-9bd139506fb5"[silk#strict] .
istAsserted(BaseKB, afterRemoving('equalStrings-CaseInsensitive', SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:50770a7d-5af2-4a17-a546-6dc1e31ef893"[silk#strict] .
istAsserted(BaseKB, afterAdding(equalSymbols, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:88eadc12-db4b-4fd9-8ffd-270d7aeeea5d"[silk#strict] .
istAsserted(BaseKB, afterRemoving(equalSymbols, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:31f86454-102c-42db-8c1f-6ceabae2fb14"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(equals, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:e809bf71-98b0-41fb-99b1-5b6418d40821"[silk#strict] .
istAsserted(BaseKB, afterAdding(equals, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:f055389c-6d70-4561-b0a5-c8e73388a2f3"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(equals, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:69e449f9-0280-4779-8035-8dbfd808e1a2"[silk#strict] .
istAsserted(BaseKB, afterRemoving(equals, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:55d9a512-280b-42cc-ae49-cc925952fd1a"[silk#strict] .
istAsserted(BaseKB, afterAdding(evaluationDefn, SubLSymbolFn(("DECACHE-LISP-DEFUN"^^_string)))) .
\"urn:uuid:0bc86ec9-55a4-432e-83c7-ffc7f2891af9"[silk#strict] .
istAsserted(BaseKB, afterRemoving(evaluationDefn, SubLSymbolFn(("DECACHE-LISP-DEFUN"^^_string)))) .
\"urn:uuid:e2ee8bc7-7287-41c0-8b96-a03ee8727145"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(evaluationResultQuotedIsa, SubLSymbolFn(("ADD-SUF-QUOTED-FUNCTION"^^_string)))) .
\"urn:uuid:f969b91f-9d7e-4762-9aa3-6343bb3d5f15"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(evaluationResultQuotedIsa, SubLSymbolFn(("REMOVE-SUF-QUOTED-FUNCTION"^^_string)))) .
\"urn:uuid:10a12e1a-4d4f-45ad-b8ee-7ebf3e024cd0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(except, SubLSymbolFn(("CYC-EXCEPT-ADDED"^^_string)))) .
\"urn:uuid:043921e9-9200-4f51-b1a5-2ad8c56d7595"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(except, SubLSymbolFn(("CYC-EXCEPT-REMOVED"^^_string)))) .
\"urn:uuid:630361da-1bf1-493a-8247-93415d8ea9f1"[silk#strict] .
istAsserted(BaseKB, afterAdding(expansion, SubLSymbolFn(("ADD-GEN-TEMPLATE-EXPANSION"^^_string)))) .
\"urn:uuid:dc2ce239-d174-4f5e-aeef-1674cee62674"[silk#strict] .
istAsserted(BaseKB, afterAdding(expansion, SubLSymbolFn(("ADD-TO-CONTRACTION-HT"^^_string)))) .
\"urn:uuid:13f9fb62-4870-4202-b4c2-3768ab00d65c"[silk#strict] .
istAsserted(BaseKB, afterAdding(expansion, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:1c6a9bb1-e8e5-4fd3-a0d2-3e6959ad6952"[silk#strict] .
istAsserted(BaseKB, afterRemoving(expansion, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:a25a18be-eee5-4be5-9e32-b79b805247e2"[silk#strict] .
istAsserted(BaseKB, afterRemoving(expansion, SubLSymbolFn(("REMOVE-GEN-TEMPLATE-EXPANSION"^^_string)))) .
\"urn:uuid:795aa180-c7f6-4983-bbd0-5b8e7a2317f7"[silk#strict] .
istAsserted(BaseKB, afterRemoving(expansion, SubLSymbolFn(("REMOVE-FROM-CONTRACTION-HT"^^_string)))) .
\"urn:uuid:fde9029a-b95b-4f44-b1f4-7b07a1d37e48"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(genFormat, SubLSymbolFn(("ADD-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:1511c39f-7c4d-4da6-8924-3cc99669d95b"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterRemoving(genFormat, SubLSymbolFn(("REMOVE-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:3ae92c94-543e-4770-b909-bb1c10ea802f"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(genKeyword, SubLSymbolFn(("ADD-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:5993f511-193f-4337-8dae-af37972315bf"[silk#strict] .
istAsserted(BaseKB, afterAdding(genKeyword, SubLSymbolFn(("ADD-GEN-KEYWORD"^^_string)))) .
\"urn:uuid:267b97ef-a15e-4df4-af8a-d21f2183dff8"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterRemoving(genKeyword, SubLSymbolFn(("REMOVE-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:5123fee1-bf53-4dcf-aa58-64acbc676a7d"[silk#strict] .
istAsserted(BaseKB, afterAdding(genlInverse, SubLSymbolFn(("ADD-GENL-INVERSE"^^_string)))) .
\"urn:uuid:a2a2fcca-21b6-44e7-9977-b7b32676bcdb"[silk#strict] .
istAsserted(BaseKB, afterRemoving(genlInverse, SubLSymbolFn(("REMOVE-GENL-INVERSE"^^_string)))) .
\"urn:uuid:10711a3b-4251-436e-a80b-231779fd2de1"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(genlMt, SubLSymbolFn(("ADD-BASE-MT"^^_string)))) .
\"urn:uuid:b989debf-0d2b-42e1-bba7-26e99e87178a"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(genlMt, SubLSymbolFn(("CLEAR-MT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:c6aeee36-2ebf-452b-b704-0181b0a1ffd8"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(genlMt, SubLSymbolFn(("CLEAR-MT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:d43bbc3d-8c3f-4c02-a259-1f7238b37b5b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(genlMt, SubLSymbolFn(("REMOVE-BASE-MT"^^_string)))) .
\"urn:uuid:e817084d-9ea1-4c49-a2a7-9c610bc7995d"[silk#strict] .
istAsserted(BaseKB, afterAdding(genlPreds, SubLSymbolFn(("ADD-GENL-PREDICATE"^^_string)))) .
\"urn:uuid:bd8f91ae-87d3-425d-af34-5f764bb6f820"[silk#strict] .
istAsserted(BaseKB, afterRemoving(genlPreds, SubLSymbolFn(("REMOVE-GENL-PREDICATE"^^_string)))) .
\"urn:uuid:802896a9-6723-41eb-b28d-ae15b8d1231e"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(genls, SubLSymbolFn(("AFTER-WFF-CONSTRAINT-SATISFIED"^^_string)))) .
\"urn:uuid:5703342d-11ef-459e-a89d-80834d414f6d"[silk#strict] .
istAsserted(BaseKB, afterAdding(genls, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:1ca50d95-fad4-4855-be6c-da77013cc934"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(genls, SubLSymbolFn(("CLEAR-GENLS-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:2fba5107-8741-4d54-bad2-8f6cc07d0a26"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(genls, SubLSymbolFn(("GENLS-AFTER-ADDING"^^_string)))) .
\"urn:uuid:fe0a9509-8447-48e0-811b-6b774be37ae8"[silk#strict] .
istAsserted(BaseKB, afterRemoving(genls, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:8a132e03-5eca-476f-8427-1798c2da7612"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(genls, SubLSymbolFn(("CLEAR-GENLS-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:d5938fe7-a7e7-4e1e-b831-28d04dc5ed44"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(genls, SubLSymbolFn(("GENLS-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:8e509482-3003-4999-98a1-d13ea84364f9"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(genls, SubLSymbolFn(("PGIA-AFTER-REMOVING-GENLS"^^_string)))) .
\"urn:uuid:9fc82c5e-280f-40eb-9e61-33f4c73c214f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(highlyRelevantTerm, SubLSymbolFn(("CYC-ADD-RELEVANT-TERM"^^_string)))) .
\"urn:uuid:22cab3ca-9dd7-4e27-acf6-cf1d0411e062"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(highlyRelevantTerm, SubLSymbolFn(("CYC-REMOVE-RELEVANT-TERM"^^_string)))) .
\"urn:uuid:625bf632-7a09-437d-a237-fc67f31dec2c"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(hlPrototypicalInstance, SubLSymbolFn(("HL-PROTOTYPICAL-INSTANCE-AFTER-ADDING"^^_string)))) .
\"urn:uuid:5b553773-0ee3-4093-89f6-c9a1e5ded4a0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(hlPrototypicalInstance, SubLSymbolFn(("HL-PROTOTYPICAL-INSTANCE-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:608d2525-c15c-4a62-95ce-d0eecc06b4cc"[silk#strict] .
istAsserted(BaseKB, afterAdding(indexicalReferent, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:a709f4f7-92fb-4028-9707-876479a09528"[silk#strict] .
istAsserted(BaseKB, afterRemoving(indexicalReferent, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:1fb5fef4-6c7f-442b-b6b3-6a5d8aae3e88"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgDifferent, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:32016765-eafd-47fb-ad43-5da320c39fee"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgFormat1-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:13121983-5c73-4db4-9ef5-3ca08f665952"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgFormat1-2', SubLSymbolFn(("INTER-ARG-FORMAT-AFTER-ADDING"^^_string)))) .
\"urn:uuid:e68444d4-ebe5-478a-8a33-dec70ed618d1"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgFormat1-2', SubLSymbolFn(("INTER-ARG-FORMAT-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:510c67d8-392c-4b3e-85f1-64d8f4be514e"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgGenl1-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:1268a807-8328-4437-9bd8-90ecb166fd00"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:cbde9cdb-a3cf-45e0-b8df-d46259b59fee"[silk#strict] .
istAsserted(BaseKB, afterAdding(interArgIsa, SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:b437aac7-4acb-4345-aec5-831654203ee8"[silk#strict] .
istAsserted(BaseKB, afterRemoving(interArgIsa, SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:5c6cf188-1018-4200-a98a-4bb649b3664f"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa1-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:412d3240-7f4f-451e-b414-7245e2af5871"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa1-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:b992c2a2-9def-44db-9770-2a5507f0e0f5"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa1-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:459dd114-8bdf-441c-9ac6-cbea6d7ee3d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa1-3', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:6a2768b8-0fc4-435b-a6e3-e820589c82d9"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa1-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:6b306727-a769-4d2c-9a61-3a756539257c"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa1-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:647c1452-251d-44e1-be8d-7b6eca0158e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa1-4', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:05d400f1-81e4-45cd-80e4-b26eb9442662"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa1-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:28371dd7-c710-45c7-8b3b-c940c17906e9"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa1-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:0df78da5-020e-435a-b150-c3ed215b18b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa1-5', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:fd03c96f-a52f-4ee6-98b0-a5110948953b"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa1-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:04993b31-32a5-40dd-b808-f3d91be0bcb0"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa1-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:c2d6cc69-38a8-40df-89f9-0ea4f8eac6f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa2-1', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:000e119a-c8ea-4820-8ae3-acb1959316bb"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa2-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:245db28a-0d76-453f-9b88-b5368918a80c"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa2-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:1775dd2f-5710-49cd-8f53-cc74ddd3bcff"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa2-3', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:8fb33642-cce5-4917-aff0-fb29ac74a45e"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa2-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:33a4db93-26c2-49ae-a423-1119bd2b6d80"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa2-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:152a2ed6-1fab-424d-898d-4ac42e82bf99"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa2-4', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:566947bb-df6f-4a22-aa05-b11e98de7528"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa2-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:7a4ec219-e092-46f4-a15b-4670f71b8d04"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa2-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:56a2887b-aca3-44d9-8071-da70ef512345"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa2-5', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:c78d149a-bd6b-4af7-8812-363603996556"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa2-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:e893bb69-44e8-4064-90e3-ae0ba4f303c0"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa2-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:50078936-da11-4fec-a7c1-1566532974f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa3-1', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:917663bb-8d4f-4f85-8dd9-a4361baf6422"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa3-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:70eb10fd-7277-4362-ad06-80866e7ddb6b"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa3-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:11bacf5a-9a94-4ed4-be48-821f13c26a51"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa3-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:6921b0a8-5e87-450b-9e18-d52ad333562b"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa3-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:34949d63-f854-470f-bc31-003c8358f6e5"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa3-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:0cf8963b-b12c-44aa-8f80-7b48f7f7d192"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa3-4', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:f7b029a9-5ff1-4ba6-8346-ca49a8aaa469"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa3-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:b133bab3-8aca-4d2e-9e7b-cd871611365e"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa3-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:d5c20bb5-e5e4-4b03-b3f2-5b72d2977764"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa3-5', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:99d39538-3f93-4357-826f-5426e88df29a"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa3-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:9b15f248-f38e-4aea-8d8c-211931046712"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa3-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:07d68724-ffdb-47cb-98f8-84f0ba5f0a64"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa4-1', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:d769a8c2-78c4-452a-baf2-1754bbe17caf"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa4-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:180bf136-5b35-4882-b6c9-30aee1276d43"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa4-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:7a27f630-94b4-438b-b4e3-c7f72597b0d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa4-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:0a0ecf42-3374-48f4-bfc3-5515d4130527"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa4-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:05d6b4b3-8b22-4256-948b-fad338312afd"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa4-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:688c01bf-4dbd-48a8-a751-2be71e75d6ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa4-3', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:82dd7a7a-5377-4499-b1c8-5b78c6d97360"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa4-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:e11ff858-d24e-4195-8afa-a34cd7e2359e"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa4-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:f561553f-14fd-4b4f-8fa6-171abebd2cb3"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa4-5', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:6657d931-4c00-487f-805e-9442016e3117"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa4-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:9b7c2ecd-7c7b-4745-8a44-3773b489d505"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa4-5', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:7a7cb855-eb2f-43f7-b6ef-33a82737fbe4"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa5-1', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:7042ecee-dce3-468f-8cf2-4458250725c6"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa5-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:5c78fbc6-075e-4c9d-b5b8-6e9f35e97e84"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa5-1', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:4ab1be5b-fa32-480a-ab36-12f7723d34a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa5-2', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:915f30c6-6dae-4a32-99bd-fbee680a61c9"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa5-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:ea3001b5-f069-48d7-8dea-9453d68b8028"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa5-2', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:7ddb8ba6-8e9c-4ce6-96c9-ca8605660986"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa5-3', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:47bcfbe0-c62d-462c-9a4d-5c456424a44d"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa5-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:3edd348b-dd31-440d-8631-51a51253064b"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa5-3', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:0aa711d7-d9b4-4aa3-a7f9-8df883139df5"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding('interArgIsa5-4', SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:b2ccc896-0a3f-4973-9787-ffb74b086fa6"[silk#strict] .
istAsserted(BaseKB, afterAdding('interArgIsa5-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) .
\"urn:uuid:7272de29-1aee-420e-ada8-efc2a6b8f552"[silk#strict] .
istAsserted(BaseKB, afterRemoving('interArgIsa5-4', SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:867b2b8e-7767-4808-9ef6-c0263a98c99e"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgResultGenl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:cc9a55a6-afad-4d1a-89ca-435666c0ae70"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgResultGenlReln, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:6f6bb5c8-d254-449d-a1de-b457689e233c"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgResultIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:4b25d481-b58c-4ada-b48b-045a73b2c0fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(interArgResultIsaReln, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:9383b618-0efe-40ff-9bba-21919cbce56a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(irrelevantTerm, SubLSymbolFn(("CYC-ADD-IRRELEVANT-TERM"^^_string)))) .
\"urn:uuid:d599c89f-3db5-464f-9b86-3dcb16016daa"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(irrelevantTerm, SubLSymbolFn(("CYC-REMOVE-IRRELEVANT-TERM"^^_string)))) .
\"urn:uuid:9cec5268-b781-48d2-957f-32b5792a43fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(isa, SubLSymbolFn(("AFTER-WFF-CONSTRAINT-SATISFIED"^^_string)))) .
\"urn:uuid:0f8b4f4b-115a-4fb2-bb81-f8ed1117c67e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(isa, SubLSymbolFn(("PGIA-AFTER-ADDING-ISA"^^_string)))) .
\"urn:uuid:16ad0949-b4c0-4707-8cb3-cceb3500cae4"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(isa, SubLSymbolFn(("CLEAR-ISA-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:5730a177-3671-411f-b4d0-b7a3bcfc179f"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(isa, SubLSymbolFn(("INSTANCEOF-AFTER-ADDING"^^_string)))) .
\"urn:uuid:7bfb8146-2aad-46b4-9e18-348d041b6200"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(isa, SubLSymbolFn(("CLEAR-ISA-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:0e2187b5-a59e-4c90-9db4-3850baf2234a"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(isa, SubLSymbolFn(("INSTANCEOF-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:156a777e-f2a1-47c2-a960-fe45e02ba64c"[silk#strict] .
istAsserted(BaseKB, afterAdding(ist, SubLSymbolFn(("ADD-IST"^^_string)))) .
\"urn:uuid:41089a47-4f3f-4177-9560-2607660fd109"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, afterAdding(knownAntecedentRule, SubLSymbolFn(("CYC-ADD-KNOWN-ANTECEDENT-RULE"^^_string)))) .
\"urn:uuid:c81cf4dc-4c52-457c-a972-265986e57048"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, afterRemoving(knownAntecedentRule, SubLSymbolFn(("CYC-REMOVE-KNOWN-ANTECEDENT-RULE"^^_string)))) .
\"urn:uuid:546ebf81-1af3-41ec-9905-571abd0915e3"[silk#strict] .
istAsserted(BaseKB, afterRemoving(natFunction, SubLSymbolFn(("REMOVE-DEPENDENT-TERM"^^_string)))) .
\"urn:uuid:2985b061-5a82-402e-82f0-fd321c125e91"[silk#strict] .
istAsserted(BaseKB, afterAdding(nearestGenlMt, SubLSymbolFn(("PROPAGATE-TO-GENLMT"^^_string)))) .
\"urn:uuid:567b4cbe-f07d-4ba0-8909-9113cfcd71ca"[silk#strict] .
istAsserted(BaseKB, afterAdding(nearestGenlPreds, SubLSymbolFn(("PROPAGATE-TO-GENLPREDS"^^_string)))) .
\"urn:uuid:8c97c1d3-ef48-4e45-8928-ad1ce3641db7"[silk#strict] .
istAsserted(BaseKB, afterAdding(nearestGenls, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:841d0631-97aa-4090-930a-48c91243060f"[silk#strict] .
istAsserted(BaseKB, afterAdding(nearestGenls, SubLSymbolFn(("PROPAGATE-TO-GENLS"^^_string)))) .
\"urn:uuid:38ddb5e9-a2b1-434b-8058-78b2dc99893a"[silk#strict] .
istAsserted(BaseKB, afterRemoving(nearestGenls, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:9c231c5e-f23a-4c2d-ab21-1f3bba5049cf"[silk#strict] .
istAsserted(BaseKB, afterAdding(nearestIsa, SubLSymbolFn(("PROPAGATE-TO-ISA"^^_string)))) .
\"urn:uuid:a55af64d-ea3b-4e67-958c-8526a4bebcd5"[silk#strict] .
istAsserted(BaseKB, afterAdding(negationInverse, SubLSymbolFn(("ADD-NEGATION-INVERSE"^^_string)))) .
\"urn:uuid:b5a728b6-ece1-4e9b-9169-18bc50be7e52"[silk#strict] .
istAsserted(BaseKB, afterRemoving(negationInverse, SubLSymbolFn(("REMOVE-NEGATION-INVERSE"^^_string)))) .
\"urn:uuid:cebca184-c06b-4028-9768-63c6869becc9"[silk#strict] .
istAsserted(BaseKB, afterAdding(negationPreds, SubLSymbolFn(("NEGATION-PREDICATE-AFTER-ADDING"^^_string)))) .
\"urn:uuid:5d4779d3-4e6b-4300-97bf-2af4b1b20888"[silk#strict] .
istAsserted(BaseKB, afterRemoving(negationPreds, SubLSymbolFn(("NEGATION-PREDICATE-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:138e7b3c-1337-4dc2-b7c2-73698c7cdeaf"[silk#strict] .
istAsserted(BaseKB, afterAdding(oldConstantName, SubLSymbolFn(("ADD-OLD-CONSTANT-NAME"^^_string)))) .
\"urn:uuid:c0b7207d-4a15-4466-8713-f7d141c761aa"[silk#strict] .
istAsserted(BaseKB, afterRemoving(oldConstantName, SubLSymbolFn(("REMOVE-OLD-CONSTANT-NAME"^^_string)))) .
\"urn:uuid:0eae3172-500e-4243-a131-946b93e199ba"[silk#strict] .
istAsserted(BaseKB, afterAdding(preservesGenlsInArg, SubLSymbolFn(("PGIA-AFTER-ADDING-PGIA"^^_string)))) .
\"urn:uuid:cfcd5d45-4c49-4c5d-9267-f854a0f7a8a2"[silk#strict] .
istAsserted(BaseKB, afterAdding(prettyString, SubLSymbolFn(("ADD-SEMANTIC-ASSERTION"^^_string)))) .
\"urn:uuid:f522da19-24f4-43c8-8484-399af503a3ed"[silk#strict] .
istAsserted(BaseKB, afterRemoving(prettyString, SubLSymbolFn(("REMOVE-SEMANTIC-ASSERTION"^^_string)))) .
\"urn:uuid:2cd30a9d-8356-488f-912c-979dc141f71c"[silk#strict] .
istAsserted(BaseKB, afterAdding('prettyString-Canonical', SubLSymbolFn(("ADD-SEMANTIC-ASSERTION"^^_string)))) .
\"urn:uuid:0d5170ce-3a10-460b-906c-acc7f50331ab"[silk#strict] .
istAsserted(BaseKB, afterRemoving('prettyString-Canonical', SubLSymbolFn(("REMOVE-SEMANTIC-ASSERTION"^^_string)))) .
\"urn:uuid:2b81a568-9c42-4cb7-8575-db306f33d527"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(quotedDefnIff, SubLSymbolFn(("ADD-IFF-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:096643f8-8b84-4380-b4dd-62182b0d3df1"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(quotedDefnIff, SubLSymbolFn(("REMOVE-IFF-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:586342c4-5957-4c81-9af2-18feb4791906"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(quotedDefnNecessary, SubLSymbolFn(("ADD-NEC-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:6653dd24-39fc-4619-a070-060ca07497ad"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(quotedDefnNecessary, SubLSymbolFn(("REMOVE-NEC-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:a5f73246-4c74-4a53-b285-31aca42231fd"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(quotedDefnSufficient, SubLSymbolFn(("ADD-SUF-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:675dfd3c-87fb-4f1f-a748-4efd06a85788"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(quotedDefnSufficient, SubLSymbolFn(("REMOVE-SUF-QUOTED-DEFN"^^_string)))) .
\"urn:uuid:b8f762e2-bf11-43a2-818c-e45f1c7a3c1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(quotedIsa, SubLSymbolFn(("AFTER-WFF-CONSTRAINT-SATISFIED"^^_string)))) .
\"urn:uuid:f84c972f-a707-4e2e-a312-58e340277379"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(quotedIsa, SubLSymbolFn(("SKSI-QUOTED-ISA-AFTER-ADDINGS"^^_string)))) .
\"urn:uuid:92a1c808-5ebb-45c0-821f-1fa79851c9b7"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(quotedIsa, SubLSymbolFn(("QUOTED-INSTANCEOF-AFTER-ADDING"^^_string)))) .
\"urn:uuid:d023bc01-aa25-4328-9c26-47d75ed45c11"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(quotedIsa, SubLSymbolFn(("SKSI-QUOTED-ISA-AFTER-REMOVINGS"^^_string)))) .
\"urn:uuid:b398053f-5964-44f2-9684-c9c6955fe109"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(quotedIsa, SubLSymbolFn(("QUOTED-INSTANCEOF-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:4362db1a-413f-4df9-94e3-cbc02ac791f6"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulationDirectionInMode, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:171ecf50-41da-4d9c-9fba-6666b7fc2049"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulationDirectionInMode, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:3ea7965d-1ee1-4d94-bd78-095335c9a60e"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulationPrecondition, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:1951b775-74c9-43cc-81a5-058f59e7d13d"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulationPrecondition, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:1d9328af-028b-48e8-8d02-6857dc90bfce"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulatorEquals, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:ed6e1ca2-6ee7-416b-8f6a-ad93ec56d106"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulatorEquals, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:42f0f95f-b95b-41da-906a-200d30412814"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulatorEquiv, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:5082b57c-9879-4530-8bfd-41ad3448a707"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulatorEquiv, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:b09052a5-3cc1-4f8f-8a0a-7fa79ecf5889"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulatorRule, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:995642be-41d0-4ba7-8c51-4c87f2663fd8"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulatorRule, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:298dbf29-ce72-4a1e-8fe3-da39cce48034"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulatorRuleProperties, SubLSymbolFn(("PROPAGATE-INVERSE-TO-ISA"^^_string)))) .
\"urn:uuid:0d6ae129-6bc0-40ea-b897-4cc2f4c33a81"[silk#strict] .
istAsserted(BaseKB, afterAdding(reformulatorRuleProperties, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:86d9a59c-d8b5-4918-9898-cd52d55d4455"[silk#strict] .
istAsserted(BaseKB, afterRemoving(reformulatorRuleProperties, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:36b569b3-e96f-4380-a462-057a6e94e833"[silk#strict] .
istAsserted(BaseKB, afterAdding(relationAllInstance, SubLSymbolFn(("ADD-RELATION-ALL-INSTANCE"^^_string)))) .
\"urn:uuid:31caa4a1-dc44-4bc8-a96d-511da08219eb"[silk#strict] .
istAsserted(BaseKB, afterRemoving(relationAllInstance, SubLSymbolFn(("REMOVE-RELATION-ALL-INSTANCE"^^_string)))) .
\"urn:uuid:68d54584-3be4-4fab-a766-34326532fe52"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(relationExpansion, SubLSymbolFn(("ADD-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:1f3e6d96-800d-45d5-948c-9960466aea5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterRemoving(relationExpansion, SubLSymbolFn(("REMOVE-GENERATION-ASSERTION"^^_string)))) .
\"urn:uuid:3308bc4f-f320-426f-b434-7dc25bb8f34e"[silk#strict] .
istAsserted(BaseKB, afterAdding(relationInstanceAll, SubLSymbolFn(("ADD-RELATION-INSTANCE-ALL"^^_string)))) .
\"urn:uuid:4da3686a-56e2-40b8-8b14-5c120baadde7"[silk#strict] .
istAsserted(BaseKB, afterRemoving(relationInstanceAll, SubLSymbolFn(("REMOVE-RELATION-INSTANCE-ALL"^^_string)))) .
\"urn:uuid:0e73f068-c637-4921-9f44-d42623935da2"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(resultGenl, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:448780fb-038a-4d01-bafc-93c4618564a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterAdding(resultIsa, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) .
\"urn:uuid:b805422d-e846-4cdd-be4e-5ae2a600774b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(resultIsa, SubLSymbolFn(("ADD-SUF-FUNCTION"^^_string)))) .
\"urn:uuid:0debebe9-161f-44bf-b49f-4fb393cc64ed"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(resultIsa, SubLSymbolFn(("REMOVE-SUF-FUNCTION"^^_string)))) .
\"urn:uuid:859b9d4a-e659-4e3f-b768-7822cb8b05f5"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(resultQuotedIsa, SubLSymbolFn(("ADD-SUF-QUOTED-FUNCTION"^^_string)))) .
\"urn:uuid:ad31a1a3-490e-41e3-93f2-46bf2efc1258"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(resultQuotedIsa, SubLSymbolFn(("REMOVE-SUF-QUOTED-FUNCTION"^^_string)))) .
\"urn:uuid:729eb619-6ec6-4923-a5bd-921b0ccc7b4e"[silk#strict] .
istAsserted(BaseKB, afterAdding(rewriteOf, SubLSymbolFn(("DECACHE-SOME-SOURCE-REWRITE-OF-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:a012da6e-dce2-4cfc-9996-247924829360"[silk#strict] .
istAsserted(BaseKB, afterAdding(rewriteOf, SubLSymbolFn(("CYC-ADD-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:405cad7a-fd7b-4b9d-b3ab-912c27f65186"[silk#strict] .
istAsserted(BaseKB, afterAdding(rewriteOf, SubLSymbolFn(("REWRITE-OF-AFTER-ADDING"^^_string)))) .
\"urn:uuid:f3eeafec-80bf-4ff7-91d6-e06aab033892"[silk#strict] .
istAsserted(BaseKB, afterAdding(rewriteOf, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:4fd620f1-0ef1-42b8-b3b7-9f6b4a851a9b"[silk#strict] .
istAsserted(BaseKB, afterRemoving(rewriteOf, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:1be0c88b-6042-4a00-845a-8fb102768e7a"[silk#strict] .
istAsserted(BaseKB, afterRemoving(rewriteOf, SubLSymbolFn(("CYC-REMOVE-REFORMULATION-ASSERTION"^^_string)))) .
\"urn:uuid:8e0f5e75-9812-4621-bea3-b43b6cb84d2d"[silk#strict] .
istAsserted(BaseKB, afterRemoving(rewriteOf, SubLSymbolFn(("DECACHE-SOME-SOURCE-REWRITE-OF-ASSERTIONS-SOMEWHERE"^^_string)))) .
\"urn:uuid:7c5da38a-6eac-4280-93ca-ce8f15397c24"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(ruleAfterAdding, SubLSymbolFn(("DECACHE-RULE-AFTER-ADDINGS"^^_string)))) .
\"urn:uuid:cdd02647-3659-4db5-9bde-fdf9cee0a936"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(ruleAfterAdding, SubLSymbolFn(("DECACHE-RULE-AFTER-ADDINGS"^^_string)))) .
\"urn:uuid:bad52c7c-7005-4049-a2a5-7ca586dec0e5"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterAdding(ruleAfterRemoving, SubLSymbolFn(("DECACHE-RULE-AFTER-REMOVINGS"^^_string)))) .
\"urn:uuid:b6b8bad8-f5c7-4c36-ade2-0ae6aab5759d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, afterRemoving(ruleAfterRemoving, SubLSymbolFn(("DECACHE-RULE-AFTER-REMOVINGS"^^_string)))) .
\"urn:uuid:73bd96fd-3802-4b5e-adee-d54c3ee2fb32"[silk#strict] .
istAsserted(UniversalVocabularyMt, afterRemoving(skolem, SubLSymbolFn(("SKOLEM-AFTER-REMOVING"^^_string)))) .
\"urn:uuid:9c7c9fd9-75d0-42e4-bce7-a0176c799bfc"[silk#strict] .
istAsserted(BaseKB, afterAdding(substring, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:5e62aaa5-106c-43f3-8fdd-4d0f25d4aab0"[silk#strict] .
istAsserted(BaseKB, afterAdding(substring, SubLSymbolFn(("ADD-TVA-CACHE-KEY"^^_string)))) .
\"urn:uuid:f205f956-81bb-4867-b17c-085c193383a1"[silk#strict] .
istAsserted(BaseKB, afterRemoving(substring, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:70cc851b-dbda-49f5-abd6-465854694847"[silk#strict] .
istAsserted(BaseKB, afterRemoving(substring, SubLSymbolFn(("REMOVE-TVA-CACHE-KEY"^^_string)))) .
\"urn:uuid:6d596c83-74e8-4013-b27d-ed591fead752"[silk#strict] .
istAsserted(BaseKB, afterRemoving(termDependsOn, SubLSymbolFn(("REMOVE-DEPENDENT-TERM"^^_string)))) .
\"urn:uuid:2ee784a4-7200-48a9-828e-5cb2fa86aa42"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterAdding(termOfUnit, SubLSymbolFn(("ADD-TERM-OF-UNIT"^^_string)))) .
\"urn:uuid:2bec96ac-cff3-4d7f-878c-1abe712c16fb"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, afterRemoving(termOfUnit, SubLSymbolFn(("REMOVE-TERM-OF-UNIT"^^_string)))) .
\"urn:uuid:cb916e53-0cec-4e4e-a055-4566f05b9987"[silk#strict] .
istAsserted(BaseKB, afterAdding(transitiveViaArg, SubLSymbolFn(("ADD-TRANSITIVE-VIA-ARG"^^_string)))) .
\"urn:uuid:20ddc6fb-4cf0-48a6-9b16-b81224b79efb"[silk#strict] .
istAsserted(BaseKB, afterAdding(transitiveViaArg, SubLSymbolFn(("CLEAR-CACHED-TVA-CHECKS"^^_string)))) .
\"urn:uuid:06667b50-43c2-408f-b043-e4941b588000"[silk#strict] .
istAsserted(BaseKB, afterRemoving(transitiveViaArg, SubLSymbolFn(("REMOVE-TRANSITIVE-VIA-ARG"^^_string)))) .
\"urn:uuid:25376303-c468-4482-930c-a6d2c6b420ec"[silk#strict] .
istAsserted(BaseKB, afterRemoving(transitiveViaArg, SubLSymbolFn(("CLEAR-CACHED-TVA-CHECKS"^^_string)))) .
\"urn:uuid:fd003a93-1743-468a-9ae2-0f473e3abc84"[silk#strict] .
istAsserted(BaseKB, afterAdding(transitiveViaArgInverse, SubLSymbolFn(("ADD-TRANSITIVE-VIA-ARG-INVERSE"^^_string)))) .
\"urn:uuid:eaff1c2b-13e4-4379-8484-ba510549a463"[silk#strict] .
istAsserted(BaseKB, afterAdding(transitiveViaArgInverse, SubLSymbolFn(("CLEAR-CACHED-SOME-TVA-CHECKS"^^_string)))) .
\"urn:uuid:594c4a7f-630e-441f-bb1b-97dba5344831"[silk#strict] .
istAsserted(BaseKB, afterRemoving(transitiveViaArgInverse, SubLSymbolFn(("REMOVE-TRANSITIVE-VIA-ARG-INVERSE"^^_string)))) .
\"urn:uuid:c6c73c13-8c36-452f-9624-147a1158d475"[silk#strict] .
istAsserted(BaseKB, afterRemoving(transitiveViaArgInverse, SubLSymbolFn(("CLEAR-CACHED-SOME-TVA-CHECKS"^^_string)))) .
\"urn:uuid:c45ee982-3ec7-4241-ad49-ff3f36f0f036"[silk#strict] .
istAsserted(BaseKB, afterAdding(trueRule, SubLSymbolFn(("ADD-TRUE-RULE"^^_string)))) .
\"urn:uuid:f3ba483b-71a1-49bc-8e11-b63bcae211f9"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, afterAdding(unitMultiplicationFactor, SubLSymbolFn(("CLEAR-UNIT-MULTIPLICATION-FACTOR-CACHES"^^_string)))) .
\"urn:uuid:07645eb0-41d3-409d-9179-2e87d951ae70"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, afterRemoving(unitMultiplicationFactor, SubLSymbolFn(("CLEAR-UNIT-MULTIPLICATION-FACTOR-CACHES"^^_string)))) .
\"urn:uuid:c5e12652-9463-4bf0-8586-26693c2d59c5"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(AllowGenericArgVariables, CanonicalizerDirective)) .
\"urn:uuid:3f0da60a-38a9-409d-8afd-d346dbe2883d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(AllowKeywordVariables, CanonicalizerDirective)) .
\"urn:uuid:853348e1-fb52-40b4-8979-a6e856e86777"[silk#strict] .
istAsserted(CoreCycLMt, isa(AntiSymmetricBinaryPredicate, Collection)) .
\"urn:uuid:62b58e16-cec8-46d6-9faa-27b36f2c8b0c"[silk#strict] .
istAsserted(CoreCycLMt, genls(AntiSymmetricBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:e557a14c-74bc-43b6-93ff-5b1f70760874"[silk#strict] .
istAsserted(CoreCycLMt, isa(AntiTransitiveBinaryPredicate, Collection)) .
\"urn:uuid:fdbb6481-c723-41cf-aca5-91482aa4734d"[silk#strict] .
istAsserted(CoreCycLMt, genls(AntiTransitiveBinaryPredicate, IrreflexiveBinaryPredicate)) .
\"urn:uuid:ff09d962-1674-478c-bf69-2718673543f4"[silk#strict] .
istAsserted(CoreCycLMt, isa(April, Collection)) .
\"urn:uuid:95e46e04-c4e2-4cdd-8b7a-22b15d5eeb39"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgConstraintPredicate, Collection)) .
\"urn:uuid:6977d0b3-ba15-4371-8443-5173b40669a1"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgGenlBinaryPredicate, Collection)) .
\"urn:uuid:7546b18e-d950-4fba-af28-ecd349689fb1"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgGenlBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:3b19c002-5637-41e7-97f7-4f11a5b35567"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgGenlQuantityBinaryPredicate, Collection)) .
\"urn:uuid:176774cd-4429-4f31-961b-05162caa4da3"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgGenlQuantityBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:a3e5e091-50c1-4471-9d3c-0935467727fb"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgGenlQuantityTernaryPredicate, Collection)) .
\"urn:uuid:5edba304-7ece-4b2d-b52c-8a656ab2e6fb"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgGenlQuantityTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:81e97e14-0f50-4931-810d-3b9be12cdbff"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgGenlTernaryPredicate, Collection)) .
\"urn:uuid:314e508b-b7a9-4398-93bd-a7ae8acd016d"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgGenlTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:79d91c70-16ad-438c-a6d8-acefd96535af"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgIsaBinaryPredicate, Collection)) .
\"urn:uuid:4b202f30-f4ef-48f9-ba0a-059a7520ed7d"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgIsaBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:71ae03e7-8ead-4b85-82c5-34bad256f967"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgIsaTernaryPredicate, Collection)) .
\"urn:uuid:113dfdf1-6e41-4299-9280-98bea8986802"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgIsaTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:64a83d43-8a83-43ab-8177-79f597398c55"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgQuotedIsaBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:d3211b64-0740-43f6-9be1-38bbd1330b7c"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgQuotedIsaTernaryPredicate, Collection)) .
\"urn:uuid:aeac2932-1a4a-4137-a508-3904d379e87f"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgQuotedIsaTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:bfdbfda7-e7a6-4554-97d9-c03fc1aca923"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgTypeBinaryPredicate, Collection)) .
\"urn:uuid:37cac827-7b8a-411d-bed9-7448856ecb6a"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgTypeBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:0d83586e-b413-42f5-bf11-9d46f094689f"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgTypeBinaryPredicate, ArgTypePredicate)) .
\"urn:uuid:152c895c-5917-477d-b253-629ba130aafd"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgTypePredicate, Collection)) .
\"urn:uuid:b16732c6-922b-4c4b-8907-b338f5a9d7ab"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgTypePredicate, ArgConstraintPredicate)) .
\"urn:uuid:9a847244-43e5-4023-9952-8c2d5e5fac61"[silk#strict] .
istAsserted(CoreCycLMt, isa(ArgTypeTernaryPredicate, Collection)) .
\"urn:uuid:59e7d71a-ed2f-4bc1-ba0c-83abfd6e133e"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgTypeTernaryPredicate, TernaryPredicate)) .
\"urn:uuid:efdc80e2-0dbe-4248-b453-c233f06748e6"[silk#strict] .
istAsserted(CoreCycLMt, genls(ArgTypeTernaryPredicate, ArgTypePredicate)) .
\"urn:uuid:639fc82c-072f-49ea-a864-79f63b36357e"[silk#strict] .
istAsserted(CoreCycLMt, isa(AssociativeRelation, Collection)) .
\"urn:uuid:86655496-2b18-4594-bda3-68eb04771f2b"[silk#strict] .
istAsserted(CoreCycLMt, genls(AssociativeRelation, Relation)) .
\"urn:uuid:f6fdf2ba-3d0c-4c19-b639-a129a10760a9"[silk#strict] .
istAsserted(CoreCycLMt, isa(AsymmetricBinaryPredicate, Collection)) .
\"urn:uuid:0576f20e-16bb-472e-87ee-1de29596c27c"[silk#strict] .
istAsserted(CoreCycLMt, genls(AsymmetricBinaryPredicate, IrreflexiveBinaryPredicate)) .
\"urn:uuid:65e0576a-9913-4cf0-b456-a925c2e0876e"[silk#strict] .
istAsserted(CoreCycLMt, genls(AsymmetricBinaryPredicate, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:e842d8d5-d9c9-4219-863b-b504ed98755f"[silk#strict] .
istAsserted(CoreCycLMt, isa(August, Collection)) .
\"urn:uuid:1827b160-493a-4e0c-bbd1-224d88fb7379"[silk#strict] .
istAsserted(CoreCycLMt, isa(BinaryFunction, Collection)) .
\"urn:uuid:7e41c929-c372-4061-a696-28a338837356"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryFunction, BinaryRelation)) .
\"urn:uuid:20ebab20-a45d-4268-af22-b6fe4e485b05"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryFunction, 'Function-Denotational')) .
\"urn:uuid:198e3f50-505b-431c-8e17-9f9fddf6dc7c"[silk#strict] .
istAsserted(CoreCycLMt, isa(BinaryPredicate, Collection)) .
\"urn:uuid:48aa38e8-f685-4b70-8e1c-0c3fb1688174"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryPredicate, BinaryRelation)) .
\"urn:uuid:ccac940b-b27e-4686-97bf-65104645a720"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryPredicate, Predicate)) .
\"urn:uuid:4fc04b35-f29e-4a9f-8614-288ff2071b46"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryPredicate, FixedArityRelation)) .
\"urn:uuid:eeeba6cd-b806-44c4-9a96-1333bfd9d56b"[silk#strict] .
istAsserted(CoreCycLMt, isa(BinaryRelation, Collection)) .
\"urn:uuid:95251431-7d72-4d6b-ba0f-4c2ba5875a31"[silk#strict] .
istAsserted(CoreCycLMt, genls(BinaryRelation, FixedArityRelation)) .
\"urn:uuid:130baa31-fdcd-4654-834c-9fe9a851e91a"[silk#strict] .
istAsserted(CoreCycLMt, isa(BookkeepingPredicate, Collection)) .
\"urn:uuid:927b6e8a-3f0f-47a1-b1b6-d94e23323c39"[silk#strict] .
istAsserted(CoreCycLMt, genls(BookkeepingPredicate, Predicate)) .
\"urn:uuid:b5b76504-d730-4df0-b3b4-9f529ebd70e4"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(BroadMicrotheory, Collection)) .
\"urn:uuid:3715a583-4244-4ea9-985b-f378bad22050"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Collection, Collection)) .
\"urn:uuid:5a6f1fa7-fe41-46eb-960d-ad293207c048"[silk#strict] .
istAsserted(CoreCycLMt, genls(Collection, SetOrCollection)) .
\"urn:uuid:c986009b-f229-475b-83d3-359e3e6de198"[silk#strict] .
istAsserted(LogicalTruthMt, genls(Collection, Thing)) .
\"urn:uuid:f4d7450d-77ff-4f68-8ff4-b7afc614ea88"[silk#strict] .
istAsserted(CoreCycLMt, isa(CollectionDenotingFunction, Collection)) .
\"urn:uuid:0b13fc3d-9b21-41ea-bebb-f5189d710e1d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CollectionDenotingFunction, 'Function-Denotational')) .
\"urn:uuid:63829ec6-84f7-4c63-a852-ebe4beedd51c"[silk#strict] .
istAsserted(CoreCycLMt, isa(CommutativeRelation, Collection)) .
\"urn:uuid:804c58e3-073e-4f2f-acc2-7dafa79434d6"[silk#strict] .
istAsserted(CoreCycLMt, genls(CommutativeRelation, Relation)) .
\"urn:uuid:44ea3c3e-cf1a-4c20-be19-fb16c8ae3bac"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(CycHLTruthValue, Collection)) .
\"urn:uuid:3aa9688e-6eb1-4000-ad6c-634c3ef5dff0"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLAssertedAssertion, Collection)) .
\"urn:uuid:fb014d0a-84de-452e-afc7-154b24a4fe97"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAssertedAssertion, CycLAssertion)) .
\"urn:uuid:6973c443-c13f-4d55-a7eb-2c03868f6fcc"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLAssertion, Collection)) .
\"urn:uuid:b5c1be58-ea50-4d67-809b-9826936d8e33"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAssertion, 'CycLSentence-Assertible')) .
\"urn:uuid:aaf90536-4eb0-41d4-a261-30684082db12"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(CycLAssertionDirection, Collection)) .
\"urn:uuid:024da5ff-c0c0-4cf1-8f60-001b2e444e13"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLAtomicAssertion, Collection)) .
\"urn:uuid:cd6a8304-2ab7-4da3-b9f5-5303ca74485f"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicAssertion, CycLAssertion)) .
\"urn:uuid:b10b0760-346e-4b18-bcdd-fa2de73cf096"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicAssertion, CycLAtomicSentence)) .
\"urn:uuid:81fb0228-17d6-4e4d-b0ea-98cd8383410e"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLAtomicSentence, Collection)) .
\"urn:uuid:ed255745-f690-409b-bc61-3c1d99d3d13c"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicSentence, CycLFormulaicSentence)) .
\"urn:uuid:238fe582-45de-4746-9dbf-211f316b6d5d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicSentence, CycLSentence)) .
\"urn:uuid:74daebcb-5a53-4725-b772-14212715f456"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLAtomicTerm, Collection)) .
\"urn:uuid:33e8951f-c061-4f3a-a1e1-cdb745553ee2"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicTerm, CycLDenotationalTerm)) .
\"urn:uuid:41f5191a-78cd-4e78-84ea-60866a41d5c6"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLAtomicTerm, CycLExpression)) .
\"urn:uuid:5dd9df42-cbfb-4ccc-a0f0-a48f2d856c01"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedAtomicSentence, Collection)) .
\"urn:uuid:af0d7e99-cc78-495a-a391-222c8cae3cab"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedAtomicSentence, CycLAtomicSentence)) .
\"urn:uuid:5df1507f-ad9c-4382-9ac9-264811e6ef4b"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedAtomicTerm, Collection)) .
\"urn:uuid:af8585b5-5400-445e-b204-7cd16c8b1f43"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedAtomicTerm, CycLAtomicTerm)) .
\"urn:uuid:e4a2e95e-0f37-48cc-9873-2bc944f21c95"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedAtomicTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:ed279fe8-9eb4-4ede-b867-9410039cd6e0"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedDenotationalTerm, Collection)) .
\"urn:uuid:34c1d421-5618-40e8-9ac8-e2c861413b77"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedDenotationalTerm, CycLDenotationalTerm)) .
\"urn:uuid:dc35229b-3e62-4fbb-bcfd-b9f2888fd40c"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedDenotationalTerm, CycLClosedExpression)) .
\"urn:uuid:5caeee1e-4ffb-4694-b7e0-8648b7181461"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedExpression, Collection)) .
\"urn:uuid:7d00060f-8718-4f6e-8efc-abe4947de117"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedExpression, CycLTerm)) .
\"urn:uuid:6bf7ba31-313c-4bac-b58a-cf3df6750911"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedExpression, CycLExpression)) .
\"urn:uuid:0126f9de-dfbc-427f-ba3f-2658d7ff6696"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedFormula, Collection)) .
\"urn:uuid:e706f145-de40-4c38-844e-4a125a987910"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedFormula, CycLClosedExpression)) .
\"urn:uuid:8d24892c-1207-49b7-a8f4-e22ac4deb059"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedFormula, CycLFormula)) .
\"urn:uuid:4f9813dd-1993-40d0-a8b3-578764331f31"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedNonAtomicTerm, Collection)) .
\"urn:uuid:6e69877b-6911-48b9-a404-8226a758af22"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedNonAtomicTerm, CycLNonAtomicTerm)) .
\"urn:uuid:1d0f4560-42e2-4460-8116-57dc22802307"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedNonAtomicTerm, 'CycLNonAtomicTerm-ClosedFunctor')) .
\"urn:uuid:0c437c4e-d8dc-4e34-be3a-16c31c8b730e"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedNonAtomicTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:aa29c428-5610-463d-8262-880e52b23cce"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLClosedSentence, Collection)) .
\"urn:uuid:39994ac6-eae3-453c-b063-a059f983c13d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLClosedSentence, 'CycLSentence-ClosedPredicate')) .
\"urn:uuid:b7e73151-6e4a-4283-b774-36f1de8dcefe"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLConstant, Collection)) .
\"urn:uuid:bde23524-8ca3-4915-90b1-f063bb7ec8b1"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLConstant, CycLReifiedDenotationalTerm)) .
\"urn:uuid:7a7b5b3f-08b5-4d19-a229-b5014bfcb435"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLConstant, CycLClosedAtomicTerm)) .
\"urn:uuid:93f7b0cf-ef5b-49a6-a0ed-2ca8c4604bc9"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLConstant, CycLRepresentedAtomicTerm)) .
\"urn:uuid:66f9df30-2de8-41ff-b228-0dd0bd5c723b"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLConstant, CycLReifiableDenotationalTerm)) .
\"urn:uuid:2e69d8b3-66b7-43df-aeb7-4e8192fbdf4f"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLDeducedAssertion, Collection)) .
\"urn:uuid:ec829367-e907-46c3-a53d-1090ba9eff46"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLDeducedAssertion, CycLAssertion)) .
\"urn:uuid:23a75e6c-8ec3-4663-9173-0e70d98560cb"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLDenotationalTerm, Collection)) .
\"urn:uuid:fb212ec0-df52-4c31-8fa3-4fc754bc91e1"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLDenotationalTerm, CycLTerm)) .
\"urn:uuid:ff140afd-ca38-47b5-beb5-848132314b1f"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLDenotationalTerm, CycLExpression)) .
\"urn:uuid:5237b457-e7bf-4139-b6a5-8c56d51fe6b6"[silk#strict] .
istAsserted(LogicalTruthMt, isa(CycLExpression, Collection)) .
\"urn:uuid:b53cada1-389c-4eaf-81d1-a875b6ccc237"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLExpression, SubLSExpression)) .
\"urn:uuid:cef63f74-1aa5-423c-ac22-dcc4d0033bd8"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLExpression, CycLTerm)) .
\"urn:uuid:245cba37-c5df-43b1-a5d3-339efb5c970a"[silk#strict] .
istAsserted(LogicalTruthMt, genls(CycLExpression, Thing)) .
\"urn:uuid:b6346df2-d1ac-4920-b4f7-88530b3be925"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, quotedDefnIff(CycLExpression, SubLSymbolFn(("CYCL-EXPRESSION?"^^_string)))) .
\"urn:uuid:0c445d57-4989-414f-a9a1-0f48de455bcb"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLExpression-Askable', Collection)) .
\"urn:uuid:a8ce0c92-4e59-47c2-b168-5e66e963f257"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLExpression-Askable', CycLExpression)) .
\"urn:uuid:4097552d-8593-4859-8d58-d98fb1b2485e"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLExpression-Assertible', Collection)) .
\"urn:uuid:8efad58d-4dae-4ee8-9a7b-f4ffc389182d"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLExpression-Assertible', 'CycLExpression-Askable')) .
\"urn:uuid:8cb88e2e-07ea-4f90-8f00-5d894d516747"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLFormula, Collection)) .
\"urn:uuid:9ff662ea-5c3f-417e-9d87-e13329472587"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLFormula, CycLTerm)) .
\"urn:uuid:baee6151-bb6d-434d-a63a-1a8e7ecb8b1a"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLFormula, CycLExpression)) .
\"urn:uuid:48b86512-6d80-4fdf-baf8-8ae8aea607b8"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLFormulaicSentence, Collection)) .
\"urn:uuid:4bfc7e11-b0b3-400a-b872-b5127b2d0375"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLFormulaicSentence, CycLFormula)) .
\"urn:uuid:c7db5061-4d8a-4964-8107-0c3234fc9310"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLFormulaicSentence, CycLSentence)) .
\"urn:uuid:c346e970-4d67-4312-b730-ed58452c77aa"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLGAFAssertion, Collection)) .
\"urn:uuid:51455c63-2d45-432c-830b-edf66b84612f"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLGAFAssertion, CycLAtomicAssertion)) .
\"urn:uuid:0aa3986d-b360-4762-bd3d-2c6ac83b5721"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLGAFAssertion, CycLClosedAtomicSentence)) .
\"urn:uuid:22b28f44-c481-4176-984c-2c8d7c62e3e4"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLGenericRelationFormula, Collection)) .
\"urn:uuid:9360b2af-bb99-4efe-abed-472bb4eff10d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLGenericRelationFormula, CycLFormula)) .
\"urn:uuid:c74f301f-2f49-4757-939a-9cc52d654975"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(CycLIndexedTerm, Collection)) .
\"urn:uuid:9cddc536-73dc-4447-b1d3-545606db9ae5"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLNonAtomicReifiedTerm, Collection)) .
\"urn:uuid:5f5949c4-2c16-4360-82a5-ff62ee30d3df"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLNonAtomicReifiedTerm, CycLReifiedDenotationalTerm)) .
\"urn:uuid:1effc9f4-8d04-4c66-97cd-8d8c38b99748"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLNonAtomicReifiedTerm, CycLClosedNonAtomicTerm)) .
\"urn:uuid:b10197bf-a1b6-49d1-8857-eb2f75693081"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLNonAtomicTerm, Collection)) .
\"urn:uuid:53666f06-6b43-480c-aa12-cee20e37ec83"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLNonAtomicTerm, CycLDenotationalTerm)) .
\"urn:uuid:62cc3da8-87f3-4454-9255-d4c206233c50"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLNonAtomicTerm, CycLFormula)) .
\"urn:uuid:ca68a64c-4bf2-4683-adc2-1c0c97e01bba"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLNonAtomicTerm, CycLRepresentedTerm)) .
\"urn:uuid:a4ab02e9-170c-4b6e-956d-170ad772ad73"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLNonAtomicTerm-Askable', Collection)) .
\"urn:uuid:f46d7937-4ae3-4287-9ab2-61e7d5305d7d"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLNonAtomicTerm-Askable', CycLNonAtomicTerm)) .
\"urn:uuid:4cf8a4da-f8f5-41bc-82b0-791588094780"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLNonAtomicTerm-Askable', 'CycLExpression-Askable')) .
\"urn:uuid:3b65ead4-1c6e-4673-935b-34c70c76fdde"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLNonAtomicTerm-Assertible', Collection)) .
\"urn:uuid:b12b8e79-84a9-4317-9832-50d120ca5e68"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLNonAtomicTerm-Assertible', 'CycLExpression-Assertible')) .
\"urn:uuid:0ce4d480-a026-40dd-9111-116b025765b2"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLNonAtomicTerm-Assertible', 'CycLNonAtomicTerm-Askable')) .
\"urn:uuid:8c4bd294-0da4-4152-a9b5-ebca0490e757"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLNonAtomicTerm-ClosedFunctor', Collection)) .
\"urn:uuid:6f4cbf45-88c8-4428-9572-194d50b7094f"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLNonAtomicTerm-ClosedFunctor', CycLNonAtomicTerm)) .
\"urn:uuid:6800be5a-213d-47cc-b7ff-64cab992529f"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLOpenDenotationalTerm, Collection)) .
\"urn:uuid:f1ea9461-1ea0-4af3-9778-d6f161e1ca03"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenDenotationalTerm, CycLDenotationalTerm)) .
\"urn:uuid:b00db862-08c7-4301-a30d-5e38fb59964a"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenDenotationalTerm, CycLOpenExpression)) .
\"urn:uuid:20e07fed-d2c7-4953-a5a3-31a8e63898e8"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLOpenExpression, Collection)) .
\"urn:uuid:2aab4aa3-9243-400f-8eae-99b1c691525a"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenExpression, CycLTerm)) .
\"urn:uuid:4636130b-563a-4f9b-910e-7b5bf66b1b63"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenExpression, CycLExpression)) .
\"urn:uuid:d0aa3f92-cf0a-4afc-afb4-f9638f7cc76f"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLOpenFormula, Collection)) .
\"urn:uuid:5bb69ab6-0848-49f9-b183-b0656c136e74"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenFormula, CycLOpenExpression)) .
\"urn:uuid:5cf93c16-d6e4-45c0-86cb-0dfd6725a585"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenFormula, CycLFormula)) .
\"urn:uuid:94d7d366-52ff-4c4e-a880-e5f0ee40e12d"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLOpenNonAtomicTerm, Collection)) .
\"urn:uuid:a8af52f8-726a-4fe9-aa40-ffe6ef810966"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenNonAtomicTerm, CycLNonAtomicTerm)) .
\"urn:uuid:0c61f54b-32f7-4ea1-b2a3-6007bd1133d3"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenNonAtomicTerm, CycLOpenFormula)) .
\"urn:uuid:67200556-01c1-4604-818e-e316ad0d34f6"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenNonAtomicTerm, CycLOpenDenotationalTerm)) .
\"urn:uuid:f1ffb237-8fb0-40e9-bf8f-eada33d3a8ba"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLOpenSentence, Collection)) .
\"urn:uuid:116bc0e6-5565-48aa-8625-6c0515ad3046"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenSentence, CycLFormulaicSentence)) .
\"urn:uuid:d5716e2a-de2b-4797-a72e-5ad38ada09e4"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenSentence, CycLOpenFormula)) .
\"urn:uuid:76464f40-5972-4fee-b2f3-35a0c14fb107"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLOpenSentence, CycLSentence)) .
\"urn:uuid:cb48055e-12f1-4fe8-827e-7ffee4c337c5"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLPropositionalSentence, Collection)) .
\"urn:uuid:8dcb6437-2be2-44d8-a61e-d688628d069d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLPropositionalSentence, 'CycLSentence-Askable')) .
\"urn:uuid:0e81b02f-9df2-4aa0-b55b-4836af260b54"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLPropositionalSentence, CycLClosedSentence)) .
\"urn:uuid:ac5b94d5-8d77-4494-8e5c-7d21f559cacc"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(CycLReformulationRulePredicate, Collection)) .
\"urn:uuid:a5f56831-7f96-4a28-830c-9135c535c217"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLReifiableDenotationalTerm, Collection)) .
\"urn:uuid:518465b6-b746-481a-9f77-0f5ce49b3539"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLReifiableDenotationalTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:39e6ec08-65f9-4d86-819c-1883aabb6fe7"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(CycLReifiableNonAtomicTerm, Collection)) .
\"urn:uuid:64e2857b-fb59-44c5-9891-39aa790f74c3"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(CycLReifiableNonAtomicTerm, CycLIndexedTerm)) .
\"urn:uuid:fcbaa34a-775b-4257-93bd-a23b9640cd3e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(CycLReifiableNonAtomicTerm, CycLExpression)) .
\"urn:uuid:de931e25-7005-4718-9025-45a8e5a825f6"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, quotedDefnIff(CycLReifiableNonAtomicTerm, SubLSymbolFn(("CYCL-REIFIABLE-NON-ATOMIC-TERM?"^^_string)))) .
\"urn:uuid:152ff620-b4bf-4397-a3c4-8537f23c49b8"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLReifiedDenotationalTerm, Collection)) .
\"urn:uuid:1258f061-a5fa-45a5-9cde-d11edcdadc59"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLReifiedDenotationalTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:c6d586b5-dff4-4961-b528-c9d91e8f64f1"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLRepresentedAtomicTerm, Collection)) .
\"urn:uuid:55a22372-78bf-4ac2-beff-bbb6c7e9f7d1"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLRepresentedAtomicTerm, CycLAtomicTerm)) .
\"urn:uuid:eab544ce-9352-4c32-a32b-520c118afc78"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLRepresentedAtomicTerm, CycLRepresentedTerm)) .
\"urn:uuid:16c56bcf-182a-4ecb-b51e-a54cda3e1a34"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLRepresentedTerm, Collection)) .
\"urn:uuid:e2e5cb91-e693-4b71-a8b5-871e6e908236"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLRepresentedTerm, CycLDenotationalTerm)) .
\"urn:uuid:59c531ed-7544-47f9-b879-c003ebaff833"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLRuleAssertion, Collection)) .
\"urn:uuid:35e05c29-c7f7-4375-9b1f-adb0bf54d006"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLRuleAssertion, CycLAssertion)) .
\"urn:uuid:d9ae5d46-1356-4d52-8813-dba3dacf06b8"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLSentence, Collection)) .
\"urn:uuid:746e8ca9-dfba-4e67-8ff1-0f732d7fccbc"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLSentence, CycLExpression)) .
\"urn:uuid:b2cf0885-2ac2-42b0-b8b4-964c6c0c1476"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLSentence, CycLTerm)) .
\"urn:uuid:ee8ec7a9-058c-4669-ad86-dca2d131350b"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLSentence-Askable', Collection)) .
\"urn:uuid:4b4e3afd-e236-4767-b85f-3c6a6e1f0e0c"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLSentence-Askable', CycLSentence)) .
\"urn:uuid:0c7fadd4-b038-4d84-9ae2-2d580329186c"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLSentence-Askable', 'CycLExpression-Askable')) .
\"urn:uuid:b5f0015b-03f4-4d7d-976f-7908bcf74221"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLSentence-Assertible', Collection)) .
\"urn:uuid:12d7202f-7041-41e5-85df-995bcf337621"[silk#strict] .
istAsserted(LogicalTruthMt, isa('CycLSentence-Assertible', Collection)) .
\"urn:uuid:6fc433cd-e81f-4c0d-88b0-8e561e1ba55e"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLSentence-Assertible', 'CycLSentence-Askable')) .
\"urn:uuid:3e4770ef-3ddc-4eb2-abd0-2cb3e6d3bd6a"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLSentence-Assertible', 'CycLExpression-Assertible')) .
\"urn:uuid:70949472-ee65-4ffe-ae9d-19d7ab3da169"[silk#strict] .
istAsserted(CoreCycLMt, isa('CycLSentence-ClosedPredicate', Collection)) .
\"urn:uuid:dbf903b3-1f8f-40cf-a1ec-5db470e13224"[silk#strict] .
istAsserted(CoreCycLMt, genls('CycLSentence-ClosedPredicate', CycLSentence)) .
\"urn:uuid:c42b4c48-6ae4-4518-a13e-630c82ed33d2"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLTerm, Collection)) .
\"urn:uuid:fca768f1-a2de-4eda-9210-800d5eddc223"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLTerm, CycLExpression)) .
\"urn:uuid:79ce0a28-5f12-4c9e-b9a1-2ad25f80f51b"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLTruthValueSentence, Collection)) .
\"urn:uuid:d29f6c98-9e80-4171-bd2c-84f29c365557"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLTruthValueSentence, CycLClosedSentence)) .
\"urn:uuid:bfc691f8-a8c3-43ab-a554-96b4baf24392"[silk#strict] .
istAsserted(CoreCycLMt, isa(CycLVariable, Collection)) .
\"urn:uuid:162a1ac0-2547-46e6-955a-1aaafb982fc0"[silk#strict] .
istAsserted(LogicalTruthMt, isa(CycLVariable, Collection)) .
\"urn:uuid:d6145a5e-5545-454e-9447-395ee4a4b09d"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLVariable, CycLRepresentedAtomicTerm)) .
\"urn:uuid:825d144b-2286-40c2-8e1e-873868cb0324"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLVariable, CycLAtomicTerm)) .
\"urn:uuid:8b9c9867-bd16-4140-9def-1333d94ecb80"[silk#strict] .
istAsserted(CoreCycLMt, genls(CycLVariable, CycLOpenDenotationalTerm)) .
\"urn:uuid:c009fe2a-c553-469b-a75c-4858e9c6b17f"[silk#strict] .
istAsserted(CoreCycLMt, isa(Cyclist, Collection)) .
\"urn:uuid:d4800090-f77b-43fa-a458-664b9d225c1c"[silk#strict] .
istAsserted(CoreCycLMt, isa(December, Collection)) .
\"urn:uuid:c1e9adb9-adcc-472a-b86f-b0e8852d20cf"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(DefaultMonotonicPredicate, Collection)) .
\"urn:uuid:c0fead9f-ec6c-4740-a2b0-dcd51baafb84"[silk#strict] .
istAsserted(CoreCycLMt, isa(DirectedMultigraph, Collection)) .
\"urn:uuid:71f7913c-4492-40db-bac1-5871c873578f"[silk#strict] .
istAsserted(CoreCycLMt, genls(DirectedMultigraph, Multigraph)) .
\"urn:uuid:9f7e9f83-52af-4f99-bb0e-d73673608d8e"[silk#strict] .
istAsserted(CoreCycLMt, isa(DistributingMetaKnowledgePredicate, Collection)) .
\"urn:uuid:35ad9b52-ea4a-4f5b-9eb9-187a835e6e8a"[silk#strict] .
istAsserted(CoreCycLMt, isa(DocumentationConstant, Collection)) .
\"urn:uuid:a7e0b33a-ff9f-4269-8c8b-2d37285ffbd5"[silk#strict] .
istAsserted(CoreCycLMt, genls(DocumentationConstant, CycLConstant)) .
\"urn:uuid:929feb92-f80a-4d7d-9383-2c0a079d3a09"[silk#strict] .
istAsserted(CoreCycLMt, isa(DocumentationPredicate, Collection)) .
\"urn:uuid:d821f8ad-403d-4e5f-a679-3dd06a209f7a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(DontReOrderCommutativeTerms, CanonicalizerDirective)) .
\"urn:uuid:f43776b4-f29e-4510-8904-32d749926526"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa('ELRelation-OneWay', Collection)) .
\"urn:uuid:bb744ff0-b688-4e34-bddb-d2d6e38ebd20"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(EscapeQuote, UnreifiableFunction)) .
\"urn:uuid:5cbf3cff-28de-4930-a81e-ddf173f3ccaa"[silk#strict] .
istAsserted(LogicalTruthMt, quotedIsa(EscapeQuote, CycLExpression)) .
\"urn:uuid:f7f6117c-5ae8-4fe5-bf47-29822241af01"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, resultIsa(EscapeQuote, CycLTerm)) .
\"urn:uuid:f37b5902-36b2-489f-b038-caae6ee3ee4e"[silk#strict] .
istAsserted(CoreCycLMt, isa(EvaluatableFunction, Collection)) .
\"urn:uuid:d46ce6f3-49a7-49f0-b459-c69394328a94"[silk#strict] .
istAsserted(CoreCycLMt, genls(EvaluatableFunction, EvaluatableRelation)) .
\"urn:uuid:9d01fbcf-9643-40e6-a892-9b5188820781"[silk#strict] .
istAsserted(CoreCycLMt, genls(EvaluatableFunction, 'Function-Denotational')) .
\"urn:uuid:6d8ebc7a-43f6-43a6-99bb-16be10c18df2"[silk#strict] .
istAsserted(CoreCycLMt, isa(EvaluatableRelation, Collection)) .
\"urn:uuid:f3f0ed2f-8cc3-49c3-9614-7938f5d8f7b3"[silk#strict] .
istAsserted(CoreCycLMt, genls(EvaluatableRelation, Relation)) .
\"urn:uuid:42f3dfeb-b8f4-4ce3-abee-4c8a300bba7e"[silk#strict] .
istAsserted(CoreCycLMt, isa(ExceptionPredicate, Collection)) .
\"urn:uuid:82bef53f-df68-4a70-8a67-c1114fe760ea"[silk#strict] .
istAsserted(CoreCycLMt, isa(ExistentialQuantifier, Collection)) .
\"urn:uuid:279d5635-350e-422d-9c76-402d3261bb6d"[silk#strict] .
istAsserted(CoreCycLMt, genls(ExistentialQuantifier, Quantifier)) .
\"urn:uuid:4c4bdef7-8654-4ad2-97c8-161b9ae9db63"[silk#strict] .
istAsserted(LogicalTruthMt, isa(ExpandSubLFn, 'Function-Denotational')) .
\"urn:uuid:ef865351-1beb-419b-9b47-5691fbc05565"[silk#strict] .
istAsserted(LogicalTruthMt, isa(ExpandSubLFn, FixedArityRelation)) .
\"urn:uuid:4d8f4e68-4fc2-4454-9711-fae1cfd60b8e"[silk#strict] .
istAsserted(LogicalTruthMt, isa(False, TruthValue)) .
\"urn:uuid:8fa17e62-f898-481f-9d1d-7ab02031f71f"[silk#strict] .
istAsserted(CoreCycLMt, quotedIsa(False, CycLTruthValueSentence)) .
\"urn:uuid:3adb97db-2a30-4fa4-967e-9158046e4959"[silk#strict] .
istAsserted(CoreCycLMt, isa(February, Collection)) .
\"urn:uuid:e52b9777-463d-41a7-b344-6c105ba62265"[silk#strict] .
istAsserted(LogicalTruthMt, isa(FixedArityRelation, Collection)) .
\"urn:uuid:d8836429-8526-4317-8dff-bd90d9d2be39"[silk#strict] .
istAsserted(LogicalTruthMt, genls(FixedArityRelation, Relation)) .
\"urn:uuid:b8c097cd-7223-40a8-9d27-16ce84a8c9a3"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(FixedAritySkolemFuncN, Collection)) .
\"urn:uuid:d63dbd4f-f476-4497-b141-e58279a8def7"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(FixedAritySkolemFuncN, FixedAritySkolemFunction)) .
\"urn:uuid:43780f3b-cf40-4c4c-a1d8-87e1603b2156"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(FixedAritySkolemFuncN, SkolemFuncN)) .
\"urn:uuid:f0aac3a5-2893-4276-b2ab-0f590cfdac57"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(FixedAritySkolemFunction, Collection)) .
\"urn:uuid:c1a5e862-be01-4483-8bf2-1047d8a44727"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(FixedAritySkolemFunction, SkolemFunction)) .
\"urn:uuid:d4a92de7-dc13-45e3-89b4-f0ac813fa26b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(FixedAritySkolemFunction, FixedArityRelation)) .
\"urn:uuid:dfa305d3-ffd9-4f70-896a-e9dbc52b5ce3"[silk#strict] .
istAsserted(CoreCycLMt, isa(Format, Collection)) .
\"urn:uuid:579915a6-e7a2-407a-9025-c2e32614172e"[silk#strict] .
istAsserted(LogicalTruthMt, isa('Function-Denotational', Collection)) .
\"urn:uuid:be2daed9-12c9-4f15-a636-23c0a0d670d1"[silk#strict] .
istAsserted(LogicalTruthMt, genls('Function-Denotational', Relation)) .
\"urn:uuid:baa0dce7-9254-458f-9e2c-df222a4a4774"[silk#strict] .
istAsserted(CoreCycLMt, isa(HumanCyclist, Collection)) .
\"urn:uuid:fbfb51f6-c4fb-4529-b54e-bf3881febe7e"[silk#strict] .
istAsserted(CoreCycLMt, genls(HumanCyclist, Cyclist)) .
\"urn:uuid:c083b4b0-61f6-4e0c-bf26-5b4bdaf3b0be"[silk#strict] .
istAsserted(CoreCycLMt, isa(HypotheticalContext, Collection)) .
\"urn:uuid:57d6c1da-f3cb-4650-816d-1660442a2fea"[silk#strict] .
istAsserted(CoreCycLMt, genls(HypotheticalContext, Microtheory)) .
\"urn:uuid:22d1fff7-b053-45fc-8aed-b3b191a34ba6"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Individual, Collection)) .
\"urn:uuid:b0ddf8bb-7491-4f3c-8489-6fd77c02f030"[silk#strict] .
istAsserted(LogicalTruthMt, genls(Individual, Thing)) .
\"urn:uuid:a7c6fe1e-0910-4060-a1e1-b90db2c3e821"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(InferenceRelatedBookkeepingPredicate, Collection)) .
\"urn:uuid:7f65d5ba-ff7e-4846-b5b2-070ba2badf2e"[silk#strict] .
istAsserted(CoreCycLMt, isa(Integer, Collection)) .
\"urn:uuid:d56341cb-2821-492d-b48a-f4bb2dd1ee1c"[silk#strict] .
istAsserted(CoreCycLMt, isa(InterArgFormatPredicate, Collection)) .
\"urn:uuid:71e0de96-88de-42f6-86e0-faa2cde48731"[silk#strict] .
istAsserted(CoreCycLMt, genls(InterArgFormatPredicate, TernaryPredicate)) .
\"urn:uuid:ea13c124-ad52-484d-93ac-8c11f70fbab8"[silk#strict] .
istAsserted(CoreCycLMt, isa(InterArgIsaPredicate, Collection)) .
\"urn:uuid:3219c379-efbe-4277-8c59-a3b602d26eb9"[silk#strict] .
istAsserted(CoreCycLMt, isa(IrreflexiveBinaryPredicate, Collection)) .
\"urn:uuid:1a7d8999-ca59-44d3-ac21-1358d6847659"[silk#strict] .
istAsserted(CoreCycLMt, genls(IrreflexiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:07aec05a-2402-4e67-9f31-e2c3142955b2"[silk#strict] .
istAsserted(CoreCycLMt, isa(January, Collection)) .
\"urn:uuid:7c502972-7f71-4150-b35a-343f2e74a573"[silk#strict] .
istAsserted(CoreCycLMt, isa(July, Collection)) .
\"urn:uuid:239dfb8c-bb38-4e98-a18c-c4cc33219f0f"[silk#strict] .
istAsserted(CoreCycLMt, isa(June, Collection)) .
\"urn:uuid:0b9b25bb-dfe4-4f1c-b25e-7936e86177da"[silk#strict] .
istAsserted(CoreCycLMt, isa(KnowledgeBase, Collection)) .
\"urn:uuid:c4d78390-3884-45b3-9f9b-a46db3026276"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(LeaveSomeTermsAtEL, CanonicalizerDirective)) .
\"urn:uuid:252c340b-efc4-4b52-bbed-c2330e5466cb"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(LeaveSomeTermsAtELAndAllowKeywordVariables, CanonicalizerDirective)) .
\"urn:uuid:05c65925-6f98-479c-a024-361221a04396"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(LeaveVariablesAtEL, CanonicalizerDirective)) .
\"urn:uuid:9ca359c0-2701-4df6-b038-c261344e6c09"[silk#strict] .
istAsserted(CoreCycLMt, isa(List, Collection)) .
\"urn:uuid:e812012d-6a8e-4e15-b45f-bf4e133bab35"[silk#strict] .
istAsserted(LogicalTruthMt, isa(LogicalConnective, Collection)) .
\"urn:uuid:9ecae52f-690e-4702-b289-39f36c8d357b"[silk#strict] .
istAsserted(LogicalTruthMt, genls(LogicalConnective, SententialRelation)) .
\"urn:uuid:84d999df-34f6-49a2-b172-787a024bfb8b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(LogicalTruthImplementationMt, Microtheory)) .
\"urn:uuid:90e5bf02-8975-485e-a402-6425ed2b18a0"[silk#strict] .
istAsserted(LogicalTruthMt, isa(LogicalTruthMt, Microtheory)) .
\"urn:uuid:ffb9a93f-fd5d-48ad-98ed-6d286bef3fb3"[silk#strict] .
istAsserted(CoreCycLMt, isa(March, Collection)) .
\"urn:uuid:a097cffc-45c8-4bb9-9367-91f84e773f1a"[silk#strict] .
istAsserted(CoreCycLMt, isa(May, Collection)) .
\"urn:uuid:c42f51b2-d0a8-4b46-bd8e-2e6d9efa744b"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Microtheory, Collection)) .
\"urn:uuid:97141ce9-8ec6-4f02-bbbb-7b801ece61f0"[silk#strict] .
istAsserted(CoreCycLMt, isa(MicrotheoryDesignatingRelation, Collection)) .
\"urn:uuid:51f743a4-bf77-49f9-ac1b-14493909bf10"[silk#strict] .
istAsserted(CoreCycLMt, genls(MicrotheoryDesignatingRelation, Relation)) .
\"urn:uuid:1f114b90-3611-4eab-ac70-93fa8734df14"[silk#strict] .
istAsserted(CoreCycLMt, isa(MonthOfYearType, Collection)) .
\"urn:uuid:d137ac2a-38f5-488c-ac5b-7f4b0698e984"[silk#strict] .
istAsserted(CoreCycLMt, isa(Multigraph, Collection)) .
\"urn:uuid:522db2b6-6337-4ae2-8374-2bc365095118"[silk#strict] .
istAsserted(LogicalTruthMt, isa(NonNegativeInteger, Collection)) .
\"urn:uuid:04e1c1cf-6b55-49ee-a535-a3d9c6b58adf"[silk#strict] .
istAsserted(CoreCycLMt, genls(NonNegativeInteger, Integer)) .
\"urn:uuid:7e4b0f6f-d76e-4758-9886-0e25b011364e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, defnIff(NonNegativeInteger, SubLSymbolFn(("CYC-NON-NEGATIVE-INTEGER"^^_string)))) .
\"urn:uuid:94f85c55-e15d-4bf0-b10f-f2b1e0d070ad"[silk#strict] .
istAsserted(CoreCycLMt, isa(NonNegativeScalarInterval, Collection)) .
\"urn:uuid:57d8890d-8245-4908-9ea2-001f5cb1d677"[silk#strict] .
istAsserted(CoreCycLMt, genls(NonNegativeScalarInterval, ScalarInterval)) .
\"urn:uuid:a78222ab-1fca-4cab-add6-b067ddd4e4da"[silk#strict] .
istAsserted(CoreCycLMt, isa(November, Collection)) .
\"urn:uuid:c77d2dc3-516b-4d84-9a9f-fb24aaaa6420"[silk#strict] .
istAsserted(CoreCycLMt, isa(October, Collection)) .
\"urn:uuid:b8e051f3-3d25-4ee2-befb-d1734e45575c"[silk#strict] .
istAsserted(CoreCycLMt, isa(PartiallyCommutativeRelation, Collection)) .
\"urn:uuid:7af0e38e-1b2c-4ebd-8543-a7bd2622d203"[silk#strict] .
istAsserted(CoreCycLMt, genls(PartiallyCommutativeRelation, Relation)) .
\"urn:uuid:ed5b1f4f-e71a-43d1-85c2-dc9f11236f38"[silk#strict] .
istAsserted(LogicalTruthMt, isa(PositiveInteger, Collection)) .
\"urn:uuid:1d712493-b5bc-4e75-b60d-96af42978b2e"[silk#strict] .
istAsserted(CoreCycLMt, genls(PositiveInteger, Integer)) .
\"urn:uuid:1c8da5c1-8582-4ef9-9e01-9fe1154288bf"[silk#strict] .
istAsserted(LogicalTruthMt, genls(PositiveInteger, NonNegativeInteger)) .
\"urn:uuid:778c771c-6586-4a5c-b420-ea11efe5b019"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, defnIff(PositiveInteger, SubLSymbolFn(("CYC-POSITIVE-INTEGER"^^_string)))) .
\"urn:uuid:f7acd0fe-9e81-4ad6-9555-00a2155e2ee1"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Predicate, Collection)) .
\"urn:uuid:5c35a391-4a2b-4bf9-99f4-1ead3d6d884e"[silk#strict] .
istAsserted(LogicalTruthMt, genls(Predicate, TruthFunction)) .
\"urn:uuid:2d2e96e6-d901-4584-b240-0733667a2695"[silk#strict] .
istAsserted(CoreCycLMt, isa(ProblemSolvingCntxt, Collection)) .
\"urn:uuid:89049ba4-ba83-4423-9fca-a28b5c6e88d1"[silk#strict] .
istAsserted(CoreCycLMt, genls(ProblemSolvingCntxt, Microtheory)) .
\"urn:uuid:49ebf5e6-adee-4ad0-98c2-a6982a7cef49"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Quantifier, Collection)) .
\"urn:uuid:42ea97b3-b416-4221-ad81-db537beae523"[silk#strict] .
istAsserted(LogicalTruthMt, genls(Quantifier, SententialRelation)) .
\"urn:uuid:a541e152-e5cf-469a-a8b5-400ea4898c82"[silk#strict] .
istAsserted(CoreCycLMt, genls(Quantifier, ScopingRelation)) .
\"urn:uuid:453fb420-fef6-415e-999f-239167d77b8e"[silk#strict] .
istAsserted(LogicalTruthMt, isa(QuasiQuote, 'Function-Denotational')) .
\"urn:uuid:efe7f7dc-5c6a-46bf-a600-f79b5ab86fe7"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, resultIsa(QuasiQuote, CycLTerm)) .
\"urn:uuid:f2dcce11-7812-4979-be46-7b90b3378d53"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuaternaryFunction, Collection)) .
\"urn:uuid:c63cebe7-b003-4b5f-8f60-52df2726cee9"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuaternaryFunction, QuaternaryRelation)) .
\"urn:uuid:2ba17df9-445a-4dd6-84a3-dc5d24320bfa"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuaternaryFunction, 'Function-Denotational')) .
\"urn:uuid:a7216a82-1193-4e2f-ab7c-0313160f26ec"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuaternaryPredicate, Collection)) .
\"urn:uuid:4bd9b887-f7a7-4719-8c5b-adc116e777e7"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuaternaryPredicate, Predicate)) .
\"urn:uuid:3aed8cca-00fa-4bae-a4ef-34a781bbb9d9"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuaternaryPredicate, QuaternaryRelation)) .
\"urn:uuid:bc88aa73-4a8e-48a5-8c1f-be484107e051"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuaternaryRelation, Collection)) .
\"urn:uuid:60d77f2e-d284-4e06-bae6-8f476941880e"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuaternaryRelation, FixedArityRelation)) .
\"urn:uuid:7fc8b072-527b-485f-aad6-126de930220d"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuintaryFunction, Collection)) .
\"urn:uuid:436c13af-7897-4633-9ea4-273e91e3f23c"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuintaryFunction, QuintaryRelation)) .
\"urn:uuid:4f22de5c-f56d-4250-9f10-2438bbad04d4"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuintaryFunction, 'Function-Denotational')) .
\"urn:uuid:e3ba212c-3a0c-47b7-a9fd-33e413246b9b"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuintaryPredicate, Collection)) .
\"urn:uuid:5b514b98-0aaa-4207-8535-1dee4e28f9be"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuintaryPredicate, QuintaryRelation)) .
\"urn:uuid:ac5320e1-eeac-4779-ae59-3b3220cd1856"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuintaryPredicate, Predicate)) .
\"urn:uuid:a2be894e-7c31-4b3a-abde-fc5ef2f00c05"[silk#strict] .
istAsserted(CoreCycLMt, isa(QuintaryRelation, Collection)) .
\"urn:uuid:4d3fbc85-6edc-4c62-b35a-2dafd794b29c"[silk#strict] .
istAsserted(CoreCycLMt, genls(QuintaryRelation, FixedArityRelation)) .
\"urn:uuid:a5082d13-b9d1-4e1f-81a2-09562670e87e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(Quote, UnreifiableFunction)) .
\"urn:uuid:88cda1bd-ca51-4b30-bd3e-e6885eb8bfc9"[silk#strict] .
istAsserted(LogicalTruthMt, quotedIsa(Quote, CycLExpression)) .
\"urn:uuid:9cf4f134-6e10-402d-b134-b4dc9b7a7e76"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, resultIsa(Quote, CycLTerm)) .
\"urn:uuid:db9dfda4-dde6-4bb2-bbb2-d505a4a614ae"[silk#strict] .
istAsserted(CoreCycLMt, genls(RealNumber, ScalarPointValue)) .
\"urn:uuid:959241b5-8434-4892-a6c3-a6c15c96274c"[silk#strict] .
istAsserted(CoreCycLMt, isa(ReflexiveBinaryPredicate, Collection)) .
\"urn:uuid:ea2183ad-f982-4a35-9285-7caa9b42c089"[silk#strict] .
istAsserted(CoreCycLMt, genls(ReflexiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:a0233b86-13bf-4457-a6f7-bacba9de42eb"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(ReformulatorDirectivePredicate, Collection)) .
\"urn:uuid:cb92f9e6-d3eb-4f57-b665-055f5d5645c0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(ReformulatorHighlyRelevantFORT, Collection)) .
\"urn:uuid:e1ba6fd3-d041-4640-8656-531dbec9c2ec"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(ReformulatorIrrelevantFORT, Collection)) .
\"urn:uuid:8680a25e-64f4-43ba-a18f-40c2be742e5f"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(ReifiableFunction, Collection)) .
\"urn:uuid:8c805cfb-f1b3-4f1c-b85d-f64a0e1ac2de"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(ReifiableFunction, 'Function-Denotational')) .
\"urn:uuid:d9ba493b-5049-4923-b40d-e75f79d570f1"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Relation, Collection)) .
\"urn:uuid:8e5a13d8-b7cc-40be-a996-ed56e16b6022"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(RelaxArgTypeConstraintsForVariables, CanonicalizerDirective)) .
\"urn:uuid:7dc7c75c-184f-4e6b-9fd4-d8abd3ee289e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(RuleTemplate, Collection)) .
\"urn:uuid:e6a06aeb-edc2-4bbf-9dcf-f38e0c2690dd"[silk#strict] .
istAsserted(CoreCycLMt, isa(ScalarInterval, Collection)) .
\"urn:uuid:b10de301-3f63-4101-a81f-addcb0b49925"[silk#strict] .
istAsserted(CoreCycLMt, isa(ScalarPointValue, Collection)) .
\"urn:uuid:4e93109d-1bff-4ece-9d50-425e4279af5a"[silk#strict] .
istAsserted(CoreCycLMt, genls(ScalarPointValue, ScalarInterval)) .
\"urn:uuid:4d46b00d-90b2-4528-a320-79d13b1d3920"[silk#strict] .
istAsserted(CoreCycLMt, isa(ScopingRelation, Collection)) .
\"urn:uuid:7cd46258-d006-44dd-a7f4-f9c89ec88e40"[silk#strict] .
istAsserted(CoreCycLMt, genls(ScopingRelation, Relation)) .
\"urn:uuid:82a0be8a-4951-46b1-8e09-ddc4b75dd49e"[silk#strict] .
istAsserted(LogicalTruthMt, isa(SententialRelation, Collection)) .
\"urn:uuid:a7645539-cdd5-447e-a563-3b5c59137494"[silk#strict] .
istAsserted(LogicalTruthMt, genls(SententialRelation, TruthFunction)) .
\"urn:uuid:e957acf0-b8ed-47a4-bb58-ab300ddf7fb5"[silk#strict] .
istAsserted(CoreCycLMt, isa(September, Collection)) .
\"urn:uuid:2f075b02-593d-4aa7-9e1d-6a876dac8e94"[silk#strict] .
istAsserted(CoreCycLMt, isa('Set-Mathematical', Collection)) .
\"urn:uuid:90a776ca-df8d-4a8a-8c8b-0eaaeda29d23"[silk#strict] .
istAsserted(CoreCycLMt, genls('Set-Mathematical', SetOrCollection)) .
\"urn:uuid:d0fb27ac-7f95-4d16-bdff-468f16781416"[silk#strict] .
istAsserted(CoreCycLMt, isa(SetOrCollection, Collection)) .
\"urn:uuid:907e5b4e-e159-472e-b141-f2483f89d46f"[silk#strict] .
istAsserted(CoreCycLMt, genls(SetOrCollection, Thing)) .
\"urn:uuid:202d5c85-1aad-4b3c-af12-2a52c4363f81"[silk#strict] .
istAsserted(CoreCycLMt, isa(SiblingDisjointAttributeType, Collection)) .
\"urn:uuid:6a7693f4-fa95-4c1e-9bfc-906c01269b93"[silk#strict] .
istAsserted(CoreCycLMt, isa(SiblingDisjointCollectionType, Collection)) .
\"urn:uuid:00d965c4-129d-43aa-a017-7d559ff8156b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SkolemFuncN, Collection)) .
\"urn:uuid:b009d43c-3ef4-4f05-acd5-9845be4648b6"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SkolemFuncN, SkolemFunction)) .
\"urn:uuid:39a39220-2605-496f-b07d-4f0aefe2cec6"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(SkolemFunction, Collection)) .
\"urn:uuid:2833b3ae-9c9d-4c27-a3fa-eba9c210ec40"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(SkolemFunction, ReifiableFunction)) .
\"urn:uuid:5ca2b69c-50a1-45f7-b5cc-fc688776649b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLAtom, Collection)) .
\"urn:uuid:2e6cfa56-c445-4529-a5d2-d0de24080418"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLAtomicTerm, Collection)) .
\"urn:uuid:2ed2bad3-5484-48af-9084-0ff4321180a5"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLAtomicTerm, CycLClosedAtomicTerm)) .
\"urn:uuid:99017ac8-d075-4072-857b-0fc698ff1dba"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLCharacter, Collection)) .
\"urn:uuid:0e079b81-b5d2-44ae-8ea5-a36ac94084f1"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLCharacter, SubLAtomicTerm)) .
\"urn:uuid:dba4d5dc-41b5-485f-9287-40dc82e03cf8"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLInteger, Collection)) .
\"urn:uuid:3744b04e-3ad4-4459-9168-d1003100d9fc"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLInteger, SubLRealNumber)) .
\"urn:uuid:7faa07cb-1356-4706-8fa9-394d5127a00f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLKeyword, SubLExpressionType)) .
\"urn:uuid:7b74e4bf-c2a8-4414-8c74-f139fbf4da3a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLKeyword, Collection)) .
\"urn:uuid:2048a839-3b36-4328-8605-75a0f16bccfd"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLList, Collection)) .
\"urn:uuid:42515d73-a23f-474a-ac74-21e9e9a6e69e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(SubLNonNegativeInteger, Collection)) .
\"urn:uuid:ef7f17c8-4ea6-4187-8e8b-dbd7a621dcf7"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLNonNegativeInteger, SubLInteger)) .
\"urn:uuid:f7bd2154-c7b0-4ec1-a6fd-42735b0a88da"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(SubLNonNegativeInteger, CycLExpression)) .
\"urn:uuid:caeeca56-2d40-4509-8f83-2953ac525256"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, quotedDefnIff(SubLNonNegativeInteger, SubLSymbolFn(("CYC-NON-NEGATIVE-INTEGER"^^_string)))) .
\"urn:uuid:acb97555-ad38-472d-8d16-06e0bcb4718b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLNonVariableSymbol, Collection)) .
\"urn:uuid:458e7744-779a-4936-a95c-09fa0538c0af"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLNonVariableSymbol, SubLAtomicTerm)) .
\"urn:uuid:e7426e00-f7a8-4648-9fe1-32b362d32a49"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLNonVariableSymbol, SubLSymbol)) .
\"urn:uuid:9a822d36-43d0-4b21-ba1a-f08648562c2d"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(SubLPositiveInteger, SubLExpressionType)) .
\"urn:uuid:077d10f4-3247-4302-bea0-24a3b9fbeb76"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(SubLPositiveInteger, Collection)) .
\"urn:uuid:84e429e5-9bd8-4b18-a6b6-bae17cdab46f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLPositiveInteger, SubLInteger)) .
\"urn:uuid:d9accb8e-30ee-40b2-b5c0-02e9f9ef77e8"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(SubLPositiveInteger, SubLNonNegativeInteger)) .
\"urn:uuid:cc172327-4b52-4347-bd41-3bcffff985a2"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, quotedDefnIff(SubLPositiveInteger, SubLSymbolFn(("CYC-POSITIVE-INTEGER"^^_string)))) .
\"urn:uuid:10f658a8-1800-4d58-8674-053eb91320fa"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLRealNumber, Collection)) .
\"urn:uuid:54bb10ef-b9dc-426e-a9fa-66df62da147f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLRealNumber, SubLAtomicTerm)) .
\"urn:uuid:7a6ac771-1856-46c5-8301-e6160a9477f3"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(SubLString, Collection)) .
\"urn:uuid:ecbef434-ddaa-4e03-833f-79cd88cf19ad"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLString, SubLAtomicTerm)) .
\"urn:uuid:d4c4ee80-1711-462f-b99e-3d2d332db26d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLString, SubLAtom)) .
\"urn:uuid:a1387c57-d284-4bd4-8195-ac34a3e4d835"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(SubLSymbol, Collection)) .
\"urn:uuid:589f69a7-4f61-46b3-913a-2d91d2c9872c"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(SubLSymbol, SubLAtom)) .
\"urn:uuid:4ccace07-ba73-4f78-b9d5-ec5fb7f382af"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(SubLSymbol, CycLExpression)) .
\"urn:uuid:bfe4584e-8634-44ac-be00-0f3f0d1ddf91"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, quotedDefnIff(SubLSymbol, SubLSymbolFn(("SYMBOLP"^^_string)))) .
\"urn:uuid:bdcad1b6-e6b5-4b9f-88eb-6d86487331fd"[silk#strict] .
istAsserted(CoreCycLMt, isa(SymmetricBinaryPredicate, Collection)) .
\"urn:uuid:844b8fc3-1761-451c-b738-59b5d8e73d03"[silk#strict] .
istAsserted(CoreCycLMt, genls(SymmetricBinaryPredicate, CommutativeRelation)) .
\"urn:uuid:6d0f4902-67ae-4237-a041-5bbb59d76dce"[silk#strict] .
istAsserted(CoreCycLMt, genls(SymmetricBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:61406898-2f9f-482b-9ed4-bc9132f70593"[silk#strict] .
istAsserted(CoreCycLMt, isa(TernaryFunction, Collection)) .
\"urn:uuid:071929a1-a989-46e8-a670-30ed6911d50b"[silk#strict] .
istAsserted(CoreCycLMt, genls(TernaryFunction, 'Function-Denotational')) .
\"urn:uuid:1fba0da7-160c-4456-9e35-cee8953e4d24"[silk#strict] .
istAsserted(CoreCycLMt, genls(TernaryFunction, TernaryRelation)) .
\"urn:uuid:e4f4a4fe-e460-47c4-8f09-433e816483ff"[silk#strict] .
istAsserted(CoreCycLMt, isa(TernaryPredicate, Collection)) .
\"urn:uuid:fbdd171b-379f-4d20-98da-9781ea702e08"[silk#strict] .
istAsserted(CoreCycLMt, genls(TernaryPredicate, Predicate)) .
\"urn:uuid:4466021f-28a2-4ad3-93a5-b881ca55b526"[silk#strict] .
istAsserted(CoreCycLMt, genls(TernaryPredicate, TernaryRelation)) .
\"urn:uuid:fb0ad187-58cf-4b0c-a8e9-f450c032c04f"[silk#strict] .
istAsserted(CoreCycLMt, isa(TernaryRelation, Collection)) .
\"urn:uuid:fc9c113b-7bed-4889-b7bd-fdd2fe162d2a"[silk#strict] .
istAsserted(CoreCycLMt, genls(TernaryRelation, FixedArityRelation)) .
\"urn:uuid:68233cc0-d5eb-4adb-8688-f48a0cbb4fcd"[silk#strict] .
istAsserted(CoreCycLMt, isa(TheCollectionOf, ReifiableFunction)) .
\"urn:uuid:8c48961a-2642-404e-a208-5f88a37d5d88"[silk#strict] .
istAsserted(CoreCycLMt, isa(TheCollectionOf, CollectionDenotingFunction)) .
\"urn:uuid:0754f242-bf7a-4390-ab4f-6f766da39a36"[silk#strict] .
istAsserted(CoreCycLMt, isa(TheCollectionOf, BinaryFunction)) .
\"urn:uuid:0cfaed1e-6ce6-4e42-860f-20b75058f718"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(TheTerm, Collection)) .
\"urn:uuid:5c73fb04-4c60-488f-8d95-7444e8153dc4"[silk#strict] .
istAsserted(LogicalTruthMt, isa(Thing, Collection)) .
\"urn:uuid:759a6fa9-5a34-44d4-8638-5410f63f7df5"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, defnIff(Thing, SubLSymbolFn(("TRUE"^^_string)))) .
\"urn:uuid:3cb5aeeb-83e7-49ad-b525-bec4cdfab119"[silk#strict] .
istAsserted(CoreCycLMt, isa(TransitiveBinaryPredicate, Collection)) .
\"urn:uuid:f030a71c-ffb6-4514-bef4-353000c73eae"[silk#strict] .
istAsserted(CoreCycLMt, genls(TransitiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:b5705a59-593b-4a07-bcd0-0fca5269ec0b"[silk#strict] .
istAsserted(LogicalTruthMt, isa(True, TruthValue)) .
\"urn:uuid:ad867edb-812f-4076-b5c4-237026d01993"[silk#strict] .
istAsserted(CoreCycLMt, quotedIsa(True, CycLTruthValueSentence)) .
\"urn:uuid:a3173a84-6c60-4a4c-9e71-0de72dd9a6de"[silk#strict] .
istAsserted(LogicalTruthMt, isa(TruthFunction, Collection)) .
\"urn:uuid:ee686a3d-fc28-4fce-bf9e-a245d13755c6"[silk#strict] .
istAsserted(LogicalTruthMt, genls(TruthFunction, Relation)) .
\"urn:uuid:82ef4a6b-31a0-4f42-a211-9949dd45758e"[silk#strict] .
istAsserted(LogicalTruthMt, isa(TruthValue, Collection)) .
\"urn:uuid:321b8c82-94a5-43d3-a815-e57aa65ea447"[silk#strict] .
istAsserted(CoreCycLMt, isa(UnaryFunction, Collection)) .
\"urn:uuid:f4d7d971-953f-4488-b86f-8ed693f3e103"[silk#strict] .
istAsserted(CoreCycLMt, genls(UnaryFunction, UnaryRelation)) .
\"urn:uuid:66a53c2b-8b11-4539-9f18-e029cc3cd3d0"[silk#strict] .
istAsserted(CoreCycLMt, genls(UnaryFunction, 'Function-Denotational')) .
\"urn:uuid:4bfb815a-0163-4e7f-a131-247ac1ffef4c"[silk#strict] .
istAsserted(CoreCycLMt, isa(UnaryPredicate, Collection)) .
\"urn:uuid:30b8502e-42c1-4c8c-9c5e-7d8ebae9e32e"[silk#strict] .
istAsserted(CoreCycLMt, genls(UnaryPredicate, Predicate)) .
\"urn:uuid:b1159818-2335-4948-906a-e989e85f2992"[silk#strict] .
istAsserted(CoreCycLMt, genls(UnaryPredicate, UnaryRelation)) .
\"urn:uuid:3d135888-6308-4308-b45d-76a77243a830"[silk#strict] .
istAsserted(CoreCycLMt, isa(UnaryRelation, Collection)) .
\"urn:uuid:6f98f1c9-aa0d-4f15-bd6d-f48232114a39"[silk#strict] .
istAsserted(CoreCycLMt, genls(UnaryRelation, FixedArityRelation)) .
\"urn:uuid:552367d1-7e54-43f6-bc5f-2903876d4b03"[silk#strict] .
istAsserted(CoreCycLMt, isa(UnitOfMeasure, Collection)) .
\"urn:uuid:a65375b4-1113-4bde-8915-55b8337919bb"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(UnreifiableFunction, Collection)) .
\"urn:uuid:8e1c922f-4860-48ea-8968-0143f7a59010"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(UnreifiableFunction, 'Function-Denotational')) .
\"urn:uuid:13485c59-6774-4e58-b7af-79f87d869210"[silk#strict] .
istAsserted(LogicalTruthMt, isa(VariableArityRelation, Collection)) .
\"urn:uuid:65b52ab0-9d1d-4811-bdf2-ea8ba4c70924"[silk#strict] .
istAsserted(LogicalTruthMt, genls(VariableArityRelation, Relation)) .
\"urn:uuid:7927ff43-ba90-43e2-b115-56cc5cb73bb0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(VariableAritySkolemFuncN, Collection)) .
\"urn:uuid:799d070f-1bfc-4e1e-bcb3-adc2a112249d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(VariableAritySkolemFuncN, VariableAritySkolemFunction)) .
\"urn:uuid:45e67325-b912-4630-bffa-ae4b0073aece"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genls(VariableAritySkolemFuncN, SkolemFuncN)) .
\"urn:uuid:9a92a6a8-26ea-484d-acae-b76d81ecf13e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(VariableAritySkolemFunction, Collection)) .
\"urn:uuid:b293b41d-5709-419e-bcb2-9cd74c60a7bc"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(VariableAritySkolemFunction, SkolemFunction)) .
\"urn:uuid:f764e968-b974-409f-b751-bfca9bdf24b1"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, genls(VariableAritySkolemFunction, VariableArityRelation)) .
\"urn:uuid:2db8c918-3357-47f1-8c23-a8c430ca4a34"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(afterAdding, Predicate)) .
\"urn:uuid:a227189a-2ab2-4ea7-b2f8-895e7ab9b11a"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, arity(afterAdding, (2))) .
\"urn:uuid:c62b3ea1-6e02-4e38-924e-b4801d95fc1b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(afterRemoving, Predicate)) .
\"urn:uuid:9b6ff89f-b7c0-4fc6-bd1a-64f3e7666cb5"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, arity(afterRemoving, (2))) .
\"urn:uuid:5ec2ed53-d533-46dc-a8db-c349621c5713"[silk#strict] .
istAsserted(LogicalTruthMt, isa(cyc#and, VariableArityRelation)) .
\"urn:uuid:7488ab1f-65f6-4dae-9345-0b5f170ba72f"[silk#strict] .
istAsserted(LogicalTruthMt, isa(cyc#and, LogicalConnective)) .
\"urn:uuid:1fad0880-5e0d-4407-8afb-0c38665988d6"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg1Format, WFFConstraintPredicate)) .
\"urn:uuid:abb0870e-ca62-4751-9e20-7f6b2eff16cc"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg1Genl, WFFConstraintPredicate)) .
\"urn:uuid:793fb630-2127-4ccd-83ae-1f9165ad3d84"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg1Isa, WFFConstraintPredicate)) .
\"urn:uuid:3cf521b5-b25e-4b94-8649-0d37e39cf74c"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg1QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:cb51efc7-f8a7-4dce-90b0-073225effaa2"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg1SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:455cf4f2-5581-4075-92fd-4da38bc58da0"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg2Format, WFFConstraintPredicate)) .
\"urn:uuid:12a11600-ea56-4538-90c4-a17272eeebce"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg2Genl, WFFConstraintPredicate)) .
\"urn:uuid:85d963f3-b82e-4739-9b83-1fb8853f09bb"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg2Isa, WFFConstraintPredicate)) .
\"urn:uuid:5d74b012-05b2-435b-8fb0-916097420be7"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg2QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:da24998e-bbb0-4fec-b535-489454542c25"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg2SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:b8f05e8b-408b-4b08-8727-f419d1c9f30f"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg3Format, WFFConstraintPredicate)) .
\"urn:uuid:f59795c1-b435-413f-ac9c-182f38161eb7"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg3Genl, WFFConstraintPredicate)) .
\"urn:uuid:c7343c5f-8b3e-4800-abc6-b3762781b331"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg3Isa, WFFConstraintPredicate)) .
\"urn:uuid:95aeb969-5a8c-4945-8608-695eb805bc65"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg3QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:38e2ba8b-8619-4ce1-bc1e-62623938072d"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg3SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:2b41f393-46a2-41c0-b0c9-eb1c58337caf"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg4Format, WFFConstraintPredicate)) .
\"urn:uuid:ca36c5b9-75eb-4ed9-8719-d74d5413b38a"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg4Genl, WFFConstraintPredicate)) .
\"urn:uuid:638b00a7-2b55-4ddd-a8a9-d4268a484cca"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg4Isa, WFFConstraintPredicate)) .
\"urn:uuid:265fc43c-dcbf-44d1-a344-79aa84d16433"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg4QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:3127b73e-154e-450e-bde6-ae9df9eab832"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg4SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:644aac13-3daa-456c-b7ec-652e97c018b1"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg5Format, WFFConstraintPredicate)) .
\"urn:uuid:b234456e-43f9-4a17-be9f-9ec7449ecbae"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg5Genl, WFFConstraintPredicate)) .
\"urn:uuid:a05f3216-3d6d-4a4f-9052-38564c33019c"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg5Isa, WFFConstraintPredicate)) .
\"urn:uuid:0cf11087-efa3-40b9-8790-277cc61548e8"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg5QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:6966e5a8-55c2-4604-87b8-07d06973f79d"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg5SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:3e8d7eeb-265d-435e-bb30-88965ad74fe5"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg6QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:d9acd074-c899-43ec-b158-46f3482e9313"[silk#strict] .
istAsserted(CoreCycLMt, isa(arg6SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:3eb7a1fc-7698-4f0c-ad0b-85ee50683f09"[silk#strict] .
istAsserted(CoreCycLMt, isa(argAndRestGenl, WFFConstraintPredicate)) .
\"urn:uuid:142bd261-7969-4257-b190-3c7655381564"[silk#strict] .
istAsserted(CoreCycLMt, isa(argAndRestIsa, WFFConstraintPredicate)) .
\"urn:uuid:6c5fc46d-7f5e-4680-95ac-fdacca0118b2"[silk#strict] .
istAsserted(LogicalTruthMt, isa(argAndRestIsa, Predicate)) .
\"urn:uuid:8bc11909-c8af-40ad-8f00-acde4abcfb84"[silk#strict] .
istAsserted(LogicalTruthMt, arity(argAndRestIsa, (3))) .
\"urn:uuid:4e68cd03-4ff0-4a21-87b4-074bfb4b1a72"[silk#strict] .
istAsserted(CoreCycLMt, isa(argGenl, WFFConstraintPredicate)) .
\"urn:uuid:a131c329-6244-4a87-b54e-c145bc6f16a4"[silk#strict] .
istAsserted(CoreCycLMt, isa(argIsa, WFFConstraintPredicate)) .
\"urn:uuid:babb5a76-36f0-4abc-9387-468bfc662835"[silk#strict] .
istAsserted(LogicalTruthMt, isa(argIsa, Predicate)) .
\"urn:uuid:7ddf8da6-760c-4f67-86ec-fbfe65c07da6"[silk#strict] .
istAsserted(LogicalTruthMt, arity(argIsa, (3))) .
\"urn:uuid:7c1f165f-408c-4a2c-a941-b22653614c6b"[silk#strict] .
istAsserted(CoreCycLMt, isa(argQuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:da348d86-80e2-4ce1-ba82-5b615b47deb2"[silk#strict] .
istAsserted(CoreCycLMt, isa(argSometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:c81605b4-54cb-4c9d-a64d-e6757db3218d"[silk#strict] .
istAsserted(LogicalTruthMt, isa(arity, Predicate)) .
\"urn:uuid:fb57d912-67f2-45a5-9ac4-13f70f2fd679"[silk#strict] .
istAsserted(LogicalTruthMt, arity(arity, (2))) .
\"urn:uuid:af9076d3-eb85-4ff5-adab-5421939aeed6"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(canonicalizerDirectiveForAllArgs, Relation)) .
\"urn:uuid:3c6bd79a-e86e-4451-b16a-496ff7ef4033"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg2Isa(canonicalizerDirectiveForAllArgs, CanonicalizerDirective)) .
\"urn:uuid:5a5b9cb8-51ba-4cbc-a723-9152b25dab1b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(canonicalizerDirectiveForArg, Relation)) .
\"urn:uuid:53ddd364-c32b-44c3-9b96-45ce5e6415b8"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg2Isa(canonicalizerDirectiveForArg, PositiveInteger)) .
\"urn:uuid:615c6b2a-150b-4eb3-93ae-2d114254a05e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg3Isa(canonicalizerDirectiveForArg, CanonicalizerDirective)) .
\"urn:uuid:5b0fb21a-156c-4739-90f0-1752419f106e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(canonicalizerDirectiveForArgAndRest, Relation)) .
\"urn:uuid:c9fd0a8b-1409-40fc-92c6-d7463daa3570"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg2Isa(canonicalizerDirectiveForArgAndRest, PositiveInteger)) .
\"urn:uuid:e86793e2-4e04-47cb-9809-e0326bd2738f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg3Isa(canonicalizerDirectiveForArgAndRest, CanonicalizerDirective)) .
\"urn:uuid:555bba1c-e2bd-447f-8bb0-95955012a80b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, genlPreds(canonicalizerDirectiveForArgAndRest, canonicalizerDirectiveForArg)) .
\"urn:uuid:6145afea-ff26-4ded-834d-f9b44c13eddd"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completeExtentAsserted, Predicate)) .
\"urn:uuid:9506bea3-c07d-4807-a50d-1c8026cc1083"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentAsserted, completeExtentEnumerable)) .
\"urn:uuid:f5983469-cbdc-4b12-8ed2-ad1b9154725b"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completeExtentAssertedForValueInArg, Predicate)) .
\"urn:uuid:6764700d-349d-4e36-9b9d-a9b1eb8fd315"[silk#strict] .
istAsserted(CoreCycLMt, arg2Isa(completeExtentAssertedForValueInArg, Thing)) .
\"urn:uuid:653e9c39-b101-42fd-9a58-fc466790e67d"[silk#strict] .
istAsserted(CoreCycLMt, arg3Isa(completeExtentAssertedForValueInArg, NonNegativeInteger)) .
\"urn:uuid:89916fba-ba1e-4054-b51f-d8777a2140e3"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentAssertedForValueInArg, completeExtentEnumerableForValueInArg)) .
\"urn:uuid:99526307-6e87-42db-a69a-4f4e109c28d9"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completeExtentDecidable, Predicate)) .
\"urn:uuid:f3990d8a-f46f-4ab0-abf2-99dd22ed7b39"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completeExtentDecidableForValueInArg, Predicate)) .
\"urn:uuid:1ff5d8fa-31df-4632-a414-330620950131"[silk#strict] .
istAsserted(CoreCycLMt, arg2Isa(completeExtentDecidableForValueInArg, Thing)) .
\"urn:uuid:01fd4536-95e6-40fc-9acf-db383904e5a4"[silk#strict] .
istAsserted(CoreCycLMt, arg3Isa(completeExtentDecidableForValueInArg, NonNegativeInteger)) .
\"urn:uuid:b6fdf7a7-ebe4-4120-835c-f945fc9f35b5"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentEnumerable, completeExtentDecidable)) .
\"urn:uuid:1bc66e96-d6fa-4e88-8446-7e03ed3b1ede"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentEnumerable, minimizeExtent)) .
\"urn:uuid:f41670a3-1ebc-4276-9e55-a454005ef1b9"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completeExtentEnumerableForArg, Predicate)) .
\"urn:uuid:0fa4d254-78d6-49ba-a206-22e9690228ce"[silk#strict] .
istAsserted(CoreCycLMt, arg2Isa(completeExtentEnumerableForArg, NonNegativeInteger)) .
\"urn:uuid:7d006f23-8da3-4b80-adb1-e90db8070677"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentEnumerableForValueInArg, nonAbducibleWithValueInArg)) .
\"urn:uuid:89c21dd6-791e-4c06-9e05-b7d300882d99"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentEnumerableForValueInArg, completeExtentDecidableForValueInArg)) .
\"urn:uuid:615db4ad-debb-4ad1-be8e-ccdbff042c0a"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completeExtentEnumerableViaBackchain, minimizeExtent)) .
\"urn:uuid:dea76cce-3ad0-4d8b-88b7-fb51381b9292"[silk#strict] .
istAsserted(CoreCycLMt, arg1Isa(completelyDecidableCollection, Collection)) .
\"urn:uuid:80a1f132-c559-4080-a008-854b6de08a71"[silk#strict] .
istAsserted(CoreCycLMt, genlPreds(completelyEnumerableCollection, completelyDecidableCollection)) .
\"urn:uuid:164a3862-8fea-4c4c-a00a-a0850273412b"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(defnIff, Predicate)) .
\"urn:uuid:d1fc0fe7-2b2f-4ce1-897b-da571852fd2e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, arity(defnIff, (2))) .
\"urn:uuid:d2fb77b0-0cda-49c1-bbec-6b0a34c8d265"[silk#strict] .
istAsserted(LogicalTruthMt, isa(denotes, Predicate)) .
\"urn:uuid:22c446e5-74b2-445e-9a78-4eb191010158"[silk#strict] .
istAsserted(LogicalTruthMt, arity(denotes, (2))) .
\"urn:uuid:b2699d89-7843-417c-8314-1ed378a7521f"[silk#strict] .
istAsserted(CoreCycLMt, isa(disjointWith, WFFConstraintPredicate)) .
\"urn:uuid:26a3cc39-fbad-4c53-9202-b6412efaad90"[silk#strict] .
istAsserted(LogicalTruthMt, isa(disjointWith, Predicate)) .
\"urn:uuid:25d1f631-11c9-4a31-9fa6-cecfe948c474"[silk#strict] .
istAsserted(LogicalTruthMt, arity(disjointWith, (2))) .
\"urn:uuid:217fdca0-51e0-4af7-8c62-fb90c0352c85"[silk#strict] .
istAsserted(LogicalTruthMt, isa(equals, Predicate)) .
\"urn:uuid:eb747e9d-abfa-484f-9db6-6a0a10e33ac2"[silk#strict] .
istAsserted(LogicalTruthMt, arity(equals, (2))) .
\"urn:uuid:aee0ee49-0c69-464d-bc2b-55c4736905ab"[silk#strict] .
istAsserted(CoreCycLMt, isa(expresses, Predicate)) .
\"urn:uuid:ecc6f7aa-e7da-4983-95b0-45d62e40dfe4"[silk#strict] .
istAsserted(LogicalTruthMt, isa(forAll, Quantifier)) .
\"urn:uuid:c2ce64de-6821-457e-8933-09f4fe3c9c67"[silk#strict] .
istAsserted(LogicalTruthMt, arity(forAll, (2))) .
\"urn:uuid:97507d0f-c059-40e1-adb9-ad68519cdf5b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(genlCanonicalizerDirectives, CanonicalizerDirective)) .
\"urn:uuid:02a350bd-4250-420b-8df0-e48437892e7e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg2Isa(genlCanonicalizerDirectives, CanonicalizerDirective)) .
\"urn:uuid:868a22cb-9233-44e1-8542-730b1bc64753"[silk#strict] .
istAsserted(LogicalTruthMt, isa(genlMt, Predicate)) .
\"urn:uuid:0d0edfeb-098b-4779-8ef0-51a513faeecf"[silk#strict] .
istAsserted(LogicalTruthMt, arity(genlMt, (2))) .
\"urn:uuid:47955ae3-0990-40cf-a662-a3a4890b9fde"[silk#strict] .
istAsserted(LogicalTruthMt, isa(genls, Predicate)) .
\"urn:uuid:e91e262b-deb5-4a63-bea1-efe6e86c0d46"[silk#strict] .
istAsserted(LogicalTruthMt, arity(genls, (2))) .
\"urn:uuid:2cd98915-270b-41c5-912f-9c213fa0d488"[silk#strict] .
istAsserted(LogicalTruthMt, isa(implies, FixedArityRelation)) .
\"urn:uuid:81af97e1-54af-4253-be62-f1bc96122922"[silk#strict] .
istAsserted(LogicalTruthMt, isa(implies, LogicalConnective)) .
\"urn:uuid:d5c3058b-b961-4b18-9b1e-4fea532a4209"[silk#strict] .
istAsserted(LogicalTruthMt, arity(implies, (2))) .
\"urn:uuid:3f773fe8-1981-4864-871e-a97aa643fcc3"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgDifferent, WFFConstraintPredicate)) .
\"urn:uuid:8ba63055-1267-4647-97e1-cbc83ef1d302"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgFormat1-2', WFFConstraintPredicate)) .
\"urn:uuid:0a420177-cb39-44f0-b957-fe37e8d17b41"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgGenl1-2', WFFConstraintPredicate)) .
\"urn:uuid:f4b72e4b-1139-4133-9352-c1a6e6659882"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgIsa, WFFConstraintPredicate)) .
\"urn:uuid:4e85b24b-0583-4d85-b0b1-c5404e9a709c"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa1-2', WFFConstraintPredicate)) .
\"urn:uuid:0b7b489e-11b4-46e5-be94-6d3032e341ce"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa1-3', WFFConstraintPredicate)) .
\"urn:uuid:531d5b24-5986-459c-a06d-b942d4fb1528"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa1-4', WFFConstraintPredicate)) .
\"urn:uuid:b50ac342-8c6a-482d-9180-526f8a61a708"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa1-5', WFFConstraintPredicate)) .
\"urn:uuid:1f522411-4e4e-40b1-8768-84821bdce8a5"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa2-1', WFFConstraintPredicate)) .
\"urn:uuid:6c1bb7f8-bca9-4052-ae27-b8c55c1de040"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa2-3', WFFConstraintPredicate)) .
\"urn:uuid:aa574207-f7dc-4a51-b020-502b05a5485a"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa2-4', WFFConstraintPredicate)) .
\"urn:uuid:63d803c6-9401-4760-81d6-b8d7f25f8ffd"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa2-5', WFFConstraintPredicate)) .
\"urn:uuid:c258668a-6e27-4195-8a52-984390e83dc1"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa3-1', WFFConstraintPredicate)) .
\"urn:uuid:ba39f18c-ca45-4102-b775-4436e4694563"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa3-2', WFFConstraintPredicate)) .
\"urn:uuid:3ea4e854-5992-4f1c-8de3-61906007a99a"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa3-4', WFFConstraintPredicate)) .
\"urn:uuid:b4419621-8da6-4852-9347-65dc94f3498d"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa3-5', WFFConstraintPredicate)) .
\"urn:uuid:e180d280-5713-4475-a90d-99a37ef8be91"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa4-1', WFFConstraintPredicate)) .
\"urn:uuid:0f2fd9c2-b0de-4eb4-a9ac-1b1ca804acbc"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa4-2', WFFConstraintPredicate)) .
\"urn:uuid:99d788d8-8d0a-4b7d-8bef-56ea39208382"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa4-3', WFFConstraintPredicate)) .
\"urn:uuid:14b10482-184e-40dd-96f7-7f271c9315cf"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa4-5', WFFConstraintPredicate)) .
\"urn:uuid:d8f3b05e-8aca-4aea-b0be-d87bf2b38c9c"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa5-1', WFFConstraintPredicate)) .
\"urn:uuid:bfa592e1-f504-4085-a642-a87dece2f17e"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa5-2', WFFConstraintPredicate)) .
\"urn:uuid:d55d914a-aac6-4cd9-a7e1-059241754cde"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa5-3', WFFConstraintPredicate)) .
\"urn:uuid:03c036ad-ac70-4954-8a26-0fcca1f47118"[silk#strict] .
istAsserted(CoreCycLMt, isa('interArgIsa5-4', WFFConstraintPredicate)) .
\"urn:uuid:ff5ca475-4c22-4713-ba86-dab71a9fac21"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgResultGenl, WFFConstraintPredicate)) .
\"urn:uuid:c1daf343-297f-4d09-b350-e0c434c4caf9"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgResultGenlReln, WFFConstraintPredicate)) .
\"urn:uuid:937f44d3-344a-4a31-914e-97ac375fc656"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgResultIsa, WFFConstraintPredicate)) .
\"urn:uuid:b667e52e-abed-445d-b0d6-c8f986124cd3"[silk#strict] .
istAsserted(CoreCycLMt, isa(interArgResultIsaReln, WFFConstraintPredicate)) .
\"urn:uuid:95b8e898-b3a6-4ecc-9481-897924577f5d"[silk#strict] .
istAsserted(LogicalTruthMt, isa(isa, Predicate)) .
\"urn:uuid:aae2fedc-860e-428b-9b3c-3d0e19b4e8fa"[silk#strict] .
istAsserted(LogicalTruthMt, arity(isa, (2))) .
\"urn:uuid:fea74f2a-7f0d-4745-a58f-f0c1940a82af"[silk#strict] .
istAsserted(LogicalTruthMt, isa(ist, Predicate)) .
\"urn:uuid:0c61c3bb-dde3-4975-af2b-deca637d433b"[silk#strict] .
istAsserted(LogicalTruthMt, arity(ist, (2))) .
\"urn:uuid:a37118cb-e069-420c-8d11-85eac7742abb"[silk#strict] .
istAsserted(CoreCycLMt, isa(means, Predicate)) .
\"urn:uuid:11514ea1-7626-4e34-8ef8-32a04584b81d"[silk#strict] .
istAsserted(LogicalTruthMt, isa(not, FixedArityRelation)) .
\"urn:uuid:42bb26f1-8575-4b80-8eac-04c1fa25c768"[silk#strict] .
istAsserted(LogicalTruthMt, isa(not, LogicalConnective)) .
\"urn:uuid:bd0d7da3-b901-499b-bf7a-1410f937d1e6"[silk#strict] .
istAsserted(LogicalTruthMt, arity(not, (1))) .
\"urn:uuid:e48e439e-0552-43ca-a4b0-3e220f4dbffd"[silk#strict] .
istAsserted(LogicalTruthMt, isa(cyc#or, VariableArityRelation)) .
\"urn:uuid:420a236b-e068-4876-aa29-21ab1c1532b6"[silk#strict] .
istAsserted(LogicalTruthMt, isa(cyc#or, LogicalConnective)) .
\"urn:uuid:589dea8b-f93c-4ade-97cd-2f424fc3bcad"[silk#strict] .
istAsserted(CoreCycLMt, isa(resultGenl, WFFConstraintPredicate)) .
\"urn:uuid:0e4bb7e3-f475-4069-bf04-ed425d97de00"[silk#strict] .
istAsserted(CoreCycLMt, isa(resultIsa, WFFConstraintPredicate)) .
\"urn:uuid:5ad03a0f-76ca-4021-a7a4-33cd0f22e77b"[silk#strict] .
istAsserted(LogicalTruthMt, isa(resultIsa, Predicate)) .
\"urn:uuid:6d5d00ab-4b7e-4c6a-a0d4-bb95f30a0be9"[silk#strict] .
istAsserted(LogicalTruthMt, arity(resultIsa, (2))) .
\"urn:uuid:f66ba218-3437-4f5a-9563-367c9ef343e3"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(ruleAfterAdding, Predicate)) .
\"urn:uuid:14c86ec9-9670-4126-9731-e66d822c2bd6"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(ruleAfterAdding, Predicate)) .
\"urn:uuid:d3bc4af2-ebc0-4490-ab95-5b0a9537b8ad"[silk#strict] .
istAsserted(CoreCycLImplementationMt, isa(ruleAfterRemoving, Predicate)) .
\"urn:uuid:f99000a2-d695-4957-a036-a047336ffe38"[silk#strict] .
istAsserted(CoreCycLImplementationMt, arg1Isa(ruleAfterRemoving, Predicate)) .
\"urn:uuid:d249df53-9d1b-4d3c-85e8-6b2c6dbf0433"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, isa(termOfUnit, Predicate)) .
\"urn:uuid:267497bd-59eb-4d0e-a0b9-1c7f1f72f63f"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, arg2QuotedIsa(termOfUnit, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:92dc1c07-1818-4a3e-b0e3-99fd21aad70d"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, arity(termOfUnit, (2))) .
\"urn:uuid:039a2986-4ca3-49a6-b70e-91872be8831a"[silk#strict] .
istAsserted(LogicalTruthMt, isa(thereExists, Quantifier)) .
\"urn:uuid:b6d9734b-a9fa-46d5-a2fa-e71a74cbd5d8"[silk#strict] .
istAsserted(LogicalTruthMt, arity(thereExists, (2))) .
\"urn:uuid:40dce9e6-fbb7-44f8-93ed-2c4713336da8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(AntiSymmetricBinaryPredicate)) .
\"urn:uuid:934b9646-d527-42eb-8edf-2cb3b5fe4dd9"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(AntiSymmetricBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:33c04eaf-ceff-49dd-85be-140f4b1bd9e4"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(AntiTransitiveBinaryPredicate)) .
\"urn:uuid:8eb28c63-a5c7-4d32-96ea-654129432234"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(AntiTransitiveBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:438a9ab8-5f7b-43f0-be15-49a59f300d40"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgConstraintPredicate)) .
\"urn:uuid:268be874-a2be-46a8-a352-add49d92aa67"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgConstraintPredicate, UniversalVocabularyMt)) .
\"urn:uuid:8516a27e-fd87-4f2c-a2d6-be88a3da5853"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgGenlBinaryPredicate)) .
\"urn:uuid:6cf96a17-1133-4d44-aa46-d11c4a50d960"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgGenlBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:2849c4a7-ba8a-4586-bc0a-6ac337852a76"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgGenlQuantityBinaryPredicate)) .
\"urn:uuid:efbfd08c-8cca-4df2-98ce-6ddcfefe2c71"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgGenlQuantityBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:bfdefadb-333f-4b89-9820-04422c23785d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgGenlQuantityTernaryPredicate)) .
\"urn:uuid:32008186-212f-472a-a3ef-b38edd42c247"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgGenlQuantityTernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:ddd5b7f3-8338-404f-84f8-9afd11728cef"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgGenlTernaryPredicate)) .
\"urn:uuid:38f32168-1478-405a-b26a-0c27896ad50e"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgGenlTernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:7d333ef3-2e22-450a-8105-5e51209adf00"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgIsaBinaryPredicate)) .
\"urn:uuid:8bad0712-a8a2-4ba2-a6ff-959f399c344c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgIsaBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:7fa1b2a5-98b9-44f3-9cac-790f814db356"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgIsaTernaryPredicate)) .
\"urn:uuid:f96dd421-4833-457b-998d-7175abae0762"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgIsaTernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:9248cd51-1f83-4a62-af73-9f469271ab1c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgQuotedIsaTernaryPredicate)) .
\"urn:uuid:b3886fc7-d02f-4c75-b483-0506698c629c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgQuotedIsaTernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:d1a8f1a5-6400-48ca-8a10-e7e593c07cfb"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgTypeBinaryPredicate)) .
\"urn:uuid:f3ae7399-6210-405a-bf17-8a6849bdddda"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgTypeBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:6a6bd830-4833-4df9-8268-230551c070a0"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgTypePredicate)) .
\"urn:uuid:46a033c3-5275-47fc-b90b-3efa60671b38"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgTypePredicate, UniversalVocabularyMt)) .
\"urn:uuid:273493a9-8b02-4f36-884c-5aaea87813f6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ArgTypeTernaryPredicate)) .
\"urn:uuid:3dd9bf1a-385e-4bed-9b9d-cf51524a58b8"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ArgTypeTernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:3625708d-78b4-4a00-95f1-5b63eb3de104"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(AssociativeRelation)) .
\"urn:uuid:b48ea380-5a8f-476f-bf82-62490009c541"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(AssociativeRelation, UniversalVocabularyMt)) .
\"urn:uuid:1fa691c1-e509-4602-badc-a6af28c67364"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(AsymmetricBinaryPredicate)) .
\"urn:uuid:d69cfb0d-9880-47c2-bf84-6bf6b64f1249"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(AsymmetricBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:1a623063-ac82-48f5-ad11-d73f8ca78ecc"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:e44dced5-975c-416f-9210-b17e3c76d818"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(AtemporalNecessarilyEssentialCollectionType, UniversalVocabularyMt)) .
\"urn:uuid:d176eaee-32a3-4d08-b92a-11eaed25d47e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(BinaryFunction)) .
\"urn:uuid:64b26f21-077b-4ed0-91b2-f0fa5c293e5e"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(BinaryFunction, UniversalVocabularyMt)) .
\"urn:uuid:2d54ce8c-a1af-4819-be06-3b865e4b7d11"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(BinaryPredicate)) .
\"urn:uuid:98c613a7-2e20-42c7-b890-f19d16bfb569"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(BinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:9d0df1ce-91e9-4763-a56f-63695b21ded4"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(BinaryRelation)) .
\"urn:uuid:264bdb8a-a6a9-4785-a3cc-e92bed341a27"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(BinaryRelation, UniversalVocabularyMt)) .
\"urn:uuid:007a58eb-90ce-49dd-8b38-007053c6ec30"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(BookkeepingPredicate)) .
\"urn:uuid:b1f7995a-fb10-459f-bb15-7a8b559062ce"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(BookkeepingPredicate, UniversalVocabularyMt)) .
\"urn:uuid:236defb1-2bc7-41d3-a3cb-9260fa2bce23"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(BroadMicrotheory)) .
\"urn:uuid:3365beca-ba68-44e7-a6b0-0d3e4bf77d6b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(BroadMicrotheory, BaseKB)) .
\"urn:uuid:5267ab85-bd72-49c8-be6b-c0310f3ed04a"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CanonicalizerDirective)) .
\"urn:uuid:6ba7bb65-32ca-463c-b818-051b72b9a37b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CanonicalizerDirective, CoreCycLImplementationMt)) .
\"urn:uuid:aa7dec60-24f6-405b-b934-0b476f245e6b"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Collection)) .
\"urn:uuid:fbf96ea6-1377-4378-b520-9f1b44551748"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Collection, UniversalVocabularyMt)) .
\"urn:uuid:59df6d63-87a0-4007-b3e9-61a1ef28be35"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CollectionDenotingFunction)) .
\"urn:uuid:b556439b-f6b3-4610-80ec-904c622dc5e9"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CollectionDenotingFunction, UniversalVocabularyMt)) .
\"urn:uuid:1d5d9635-99dc-4d13-94b0-f8d0b83a689a"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CommutativeRelation)) .
\"urn:uuid:1108500c-115a-42f0-adb5-2bbd7516465b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CommutativeRelation, UniversalVocabularyMt)) .
\"urn:uuid:124d99a5-d0a9-46e5-84ea-747efd11a798"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAssertedAssertion)) .
\"urn:uuid:40de4bcc-8802-4d50-91c8-af83ea77aa63"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAssertedAssertion, UniversalVocabularyMt)) .
\"urn:uuid:65046629-0fb8-4a56-ae6b-320eb5ee8652"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAssertion)) .
\"urn:uuid:b591f1b1-27a0-4ebf-8a1d-b4dd8ba0dc86"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAssertion, UniversalVocabularyMt)) .
\"urn:uuid:3eaf7d2e-db5c-4180-a4a7-3ffa1df1dd23"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAssertionDirection)) .
\"urn:uuid:e8d23e95-b96d-4daf-8fe7-647777baa08e"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAssertionDirection, UniversalVocabularyMt)) .
\"urn:uuid:6434dab1-2c31-4423-b16a-2a377fb43438"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAtomicAssertion)) .
\"urn:uuid:55140be5-2fca-4e46-b83b-9a04c09a6443"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAtomicAssertion, UniversalVocabularyMt)) .
\"urn:uuid:165c6464-8517-4a43-9c9c-b8e0fa91d9eb"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAtomicSentence)) .
\"urn:uuid:bbdcfbf9-4686-4bb0-b00f-af67f490ac69"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAtomicSentence, UniversalVocabularyMt)) .
\"urn:uuid:b1fe122d-8624-43b6-8380-c75a6aa13c0d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLAtomicTerm)) .
\"urn:uuid:c0108812-3f02-4200-8df5-7aafecc80e21"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:3f5569cd-dc99-4b34-abb6-dbe49dc005d8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedAtomicSentence)) .
\"urn:uuid:4e897043-06e6-4232-b0ce-5170a3e92b4c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedAtomicSentence, UniversalVocabularyMt)) .
\"urn:uuid:d5ff3dcd-2923-47ed-8f1f-1ec2c1360cbb"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedAtomicTerm)) .
\"urn:uuid:ee42b6d2-a29b-4bf9-a77f-bc3425de4129"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:8fc86a77-481c-45b1-bdd3-59997506fdb8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedDenotationalTerm)) .
\"urn:uuid:d38fa4ff-2661-42f2-960a-983b54cd8cee"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedDenotationalTerm, UniversalVocabularyMt)) .
\"urn:uuid:767cbc3b-8137-4f39-9a2f-ea7e93a228a0"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedExpression)) .
\"urn:uuid:fe567218-cd4e-4912-99e7-356fe9c0ed3a"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedExpression, UniversalVocabularyMt)) .
\"urn:uuid:40ea72f3-71b6-47fe-8c1e-61804a256269"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedFormula)) .
\"urn:uuid:703e9c3e-b716-47a9-9134-d35c72ccab27"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedFormula, UniversalVocabularyMt)) .
\"urn:uuid:08303228-a297-47b2-9c61-f782f0779dd5"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedNonAtomicTerm)) .
\"urn:uuid:8f80f6fc-5aac-430e-b72a-1414d56720dd"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedNonAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:394208d4-746e-4855-b386-68008b2bb615"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLClosedSentence)) .
\"urn:uuid:9d874852-ab1a-4448-8e87-9e51a84ec4a6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLClosedSentence, UniversalVocabularyMt)) .
\"urn:uuid:1ffa351f-e064-47dd-b603-6f22b48a468e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLConstant)) .
\"urn:uuid:3445f9f0-d93e-4eaf-8190-d7d8e53177c3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLConstant, UniversalVocabularyMt)) .
\"urn:uuid:850b6fe9-32a7-4951-a212-4ef0af2aff52"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLDeducedAssertion)) .
\"urn:uuid:7f4adea0-ed29-4c35-a3ad-11fdc2894ec3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLDeducedAssertion, UniversalVocabularyMt)) .
\"urn:uuid:2113b5ff-99af-4b0d-8d61-6c36abd2bb92"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLDenotationalTerm)) .
\"urn:uuid:ed67e69b-500a-4a34-b7c8-396ae83258bc"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLDenotationalTerm, UniversalVocabularyMt)) .
\"urn:uuid:47f2af6c-0f0e-4166-8617-d1ac4ca90dd2"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLDenotationalTerm-Assertible')) .
\"urn:uuid:d914e950-81c8-475a-9b55-8d5437ef8cdc"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLDenotationalTerm-Assertible', UniversalVocabularyMt)) .
\"urn:uuid:ea4a8fd4-1352-4908-ad36-4c022a686970"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLExpression)) .
\"urn:uuid:53e48176-c015-4859-89af-2350448cb426"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLExpression, UniversalVocabularyMt)) .
\"urn:uuid:8ab442f9-dc2d-4694-834b-6007070d7f69"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLExpression-Askable')) .
\"urn:uuid:03afd99e-ac0a-4ef8-9b24-eff8bf5f4b92"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLExpression-Askable', UniversalVocabularyMt)) .
\"urn:uuid:67e2ac96-c4d7-49ab-bb97-72ffd78451eb"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLExpression-Assertible')) .
\"urn:uuid:8e22ed7c-5c00-46c8-984a-2379ae72eab3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLExpression-Assertible', UniversalVocabularyMt)) .
\"urn:uuid:05ffbbeb-7fa6-46a3-a715-d23ee36117ef"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLExpressionType)) .
\"urn:uuid:8e94b10c-96e3-49af-9458-54d7def5c4a3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLExpressionType, UniversalVocabularyMt)) .
\"urn:uuid:15e80ab7-4e3c-4bd0-ba83-52ef523ebf98"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLFormula)) .
\"urn:uuid:87547346-1661-4bac-bff6-b0c8b1ffacf9"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLFormula, UniversalVocabularyMt)) .
\"urn:uuid:91dd7de6-3c01-466e-92e1-a7dae099120f"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLFormulaicSentence)) .
\"urn:uuid:f1c0278e-ee9a-4615-9904-d031efa8fb81"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLFormulaicSentence, UniversalVocabularyMt)) .
\"urn:uuid:257ff534-53d7-4fac-8269-ae3945968910"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLGAFAssertion)) .
\"urn:uuid:216b1e45-158d-4044-b821-ecbf1d8a3f72"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLGAFAssertion, UniversalVocabularyMt)) .
\"urn:uuid:7a29a52e-f2f1-4e12-b343-22582b20e210"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLGenericRelationFormula)) .
\"urn:uuid:cdaeb907-e0b3-41a1-af3d-37d56d97128d"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLGenericRelationFormula, UniversalVocabularyMt)) .
\"urn:uuid:9f5ffd08-5fb7-4a1c-9f7a-a52d1730a62f"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLIndexedTerm)) .
\"urn:uuid:ecf82628-dfb2-42e7-8120-77d32d08e78e"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLIndexedTerm, UniversalVocabularyMt)) .
\"urn:uuid:7c7de778-ba28-4573-9325-a51da543b512"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLNonAtomicReifiedTerm)) .
\"urn:uuid:270e656c-cde4-426b-98c6-61f03a251774"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLNonAtomicReifiedTerm, UniversalVocabularyMt)) .
\"urn:uuid:f287b745-b79e-4ff8-a080-0882c75cc2ef"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLNonAtomicTerm)) .
\"urn:uuid:75e121ea-6491-4950-b496-ad9aec480630"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLNonAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:099a809f-d6d3-4713-9e7a-f00212b3b908"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLNonAtomicTerm-Askable')) .
\"urn:uuid:3d4cab2a-dab9-4d05-8fe5-c51b49603be1"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLNonAtomicTerm-Askable', UniversalVocabularyMt)) .
\"urn:uuid:abe858f1-ef8d-4966-8d89-ce35c6576bd1"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLNonAtomicTerm-Assertible')) .
\"urn:uuid:5dd9d767-b538-4086-babb-ec5ad5783028"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLNonAtomicTerm-Assertible', UniversalVocabularyMt)) .
\"urn:uuid:62e18d81-8600-4e66-8965-f87c907c2737"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLOpenDenotationalTerm)) .
\"urn:uuid:dcb39caa-7544-4beb-9cf0-ba0e04a0b9be"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLOpenDenotationalTerm, UniversalVocabularyMt)) .
\"urn:uuid:b778e5cd-894d-4324-913d-2b00e074dfc3"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLOpenExpression)) .
\"urn:uuid:bd675172-b765-4ce3-b314-cea4f3a01c55"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLOpenExpression, UniversalVocabularyMt)) .
\"urn:uuid:2b3cca8b-c26c-47e6-8c5c-ca82b53e0d0e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLOpenFormula)) .
\"urn:uuid:3673509d-c784-4261-8997-66c5ba372efa"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLOpenFormula, UniversalVocabularyMt)) .
\"urn:uuid:5f4f1a46-c940-494c-aabf-4aafb35f33a8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLOpenNonAtomicTerm)) .
\"urn:uuid:2864fda5-fc29-49d8-ba57-e15095509332"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLOpenNonAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:87fdf810-faa8-4b6f-8ad3-c612338294f6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLOpenSentence)) .
\"urn:uuid:7d40d63d-e004-4cf4-bc8d-db06ed672df6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLOpenSentence, UniversalVocabularyMt)) .
\"urn:uuid:2b7db063-f895-486a-b19c-60c6f7a94eb4"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLPropositionalSentence)) .
\"urn:uuid:8d152a98-cefe-4a6b-a9bf-4fb54b06732c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLPropositionalSentence, UniversalVocabularyMt)) .
\"urn:uuid:c667cfdf-c5c5-4f83-a1e4-ebeedd8f74a3"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLReifiableDenotationalTerm)) .
\"urn:uuid:528d758d-e9e1-4fbe-971d-93b850d665b4"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLReifiableDenotationalTerm, UniversalVocabularyMt)) .
\"urn:uuid:c6fade4d-4e9a-48f2-88a9-a2f85a99cbb7"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLReifiableNonAtomicTerm)) .
\"urn:uuid:390bd7a6-2cfe-453c-8617-182505fcb446"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLReifiableNonAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:1f8ae8b6-5cc9-4bd1-9d39-9d525cf82df6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLReifiedDenotationalTerm)) .
\"urn:uuid:894cb97c-19b2-4858-a546-884f74e59100"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLReifiedDenotationalTerm, UniversalVocabularyMt)) .
\"urn:uuid:a23b73f4-8b8d-4d02-b6af-57263157b0d6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLRepresentedAtomicTerm)) .
\"urn:uuid:3cbc11a3-4c5d-4635-a86a-06475b4fd069"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLRepresentedAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:813649c8-2204-4e6f-bd69-f49038b33eca"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLRepresentedTerm)) .
\"urn:uuid:2311fc33-e7ca-4062-bab8-3172165e78e1"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLRepresentedTerm, UniversalVocabularyMt)) .
\"urn:uuid:e575ceaf-5163-48ae-b19b-177d12f9aaf9"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLRuleAssertion)) .
\"urn:uuid:4ff861f1-3796-4085-94b4-a7bc621cc0d2"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLRuleAssertion, UniversalVocabularyMt)) .
\"urn:uuid:6acef219-2984-4381-a436-3de8a0aa8ed7"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLSentence)) .
\"urn:uuid:4735d784-5739-4307-9605-c7c2c1d71f7f"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLSentence, UniversalVocabularyMt)) .
\"urn:uuid:0404a757-4d00-4aa9-9033-a554d0cc9dac"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLSentence-Askable')) .
\"urn:uuid:cd5bf2bd-7f70-4e06-8ef1-403a3efc8978"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLSentence-Askable', UniversalVocabularyMt)) .
\"urn:uuid:cdbec63c-9785-4a88-a49a-d0c2b3724255"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('CycLSentence-Assertible')) .
\"urn:uuid:c897e57c-bd08-4889-a771-2d4f9e8c7e28"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('CycLSentence-Assertible', UniversalVocabularyMt)) .
\"urn:uuid:97e838b2-92d5-4700-8a00-ffffd091b728"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLTerm)) .
\"urn:uuid:e836598d-304c-4885-81f4-16e4037c1ff2"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLTerm, UniversalVocabularyMt)) .
\"urn:uuid:47f34eb4-d7f9-439f-9858-f2a044aec95d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLTruthValueSentence)) .
\"urn:uuid:dd5c0c56-b1a9-4f43-ae2e-f5cfef94a781"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLTruthValueSentence, UniversalVocabularyMt)) .
\"urn:uuid:c7acf42f-e606-4158-adc4-57d8ec62051c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(CycLVariable)) .
\"urn:uuid:feda5bda-2fc7-4947-b12d-ab090aebd392"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(CycLVariable, UniversalVocabularyMt)) .
\"urn:uuid:ac231209-0711-4726-bc15-3751a232762e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(DefaultMonotonicPredicate)) .
\"urn:uuid:60aa9e5f-66de-48e3-aae9-ee13936edb44"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(DefaultMonotonicPredicate, UniversalVocabularyMt)) .
\"urn:uuid:35e4d8a7-979b-4adc-af04-0651a1668ca9"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(DirectedMultigraph)) .
\"urn:uuid:ea14157c-e2ab-4445-a830-d42b60b35ed6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(DirectedMultigraph, UniversalVocabularyMt)) .
\"urn:uuid:f7b7e645-65c2-45fa-9440-f4a47385512a"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(DisjointCollectionType)) .
\"urn:uuid:62162db1-a6bb-45f2-b19f-2b87dcc1d1c6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(DisjointCollectionType, UniversalVocabularyMt)) .
\"urn:uuid:20ebe949-4156-44a3-8055-5b2f561271b5"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(DistributingMetaKnowledgePredicate)) .
\"urn:uuid:8a329894-9399-4f50-b809-c8f3207ad637"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(DistributingMetaKnowledgePredicate, UniversalVocabularyMt)) .
\"urn:uuid:0b90e7b1-e2e9-43c6-804e-eddb0e21a1ca"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ELRelation)) .
\"urn:uuid:8b21f4cf-ca54-4bc2-a138-d22590eb2812"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ELRelation, UniversalVocabularyMt)) .
\"urn:uuid:a08d551a-3376-44e2-aac7-95c490f89478"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('ELRelation-OneWay')) .
\"urn:uuid:639b209d-c27a-4a2c-84ba-2a33e3c712b6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('ELRelation-OneWay', UniversalVocabularyMt)) .
\"urn:uuid:2a9292f3-25a3-4634-83b6-7f44ec5fb8ba"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('ELRelation-Reversible')) .
\"urn:uuid:a48850d7-53c4-4d4e-bad2-98bf39d3d2a9"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('ELRelation-Reversible', UniversalVocabularyMt)) .
\"urn:uuid:7c79467d-af37-4c35-82b6-f7b61a9bd4ab"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(EvaluatableFunction)) .
\"urn:uuid:53787275-3333-45df-8724-53c41c061116"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(EvaluatableFunction, UniversalVocabularyMt)) .
\"urn:uuid:b17ccb63-5f3b-4f6a-8062-8833c51b3fa0"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(EvaluatableRelation)) .
\"urn:uuid:803273ae-cea5-4b66-8b68-3e7a9bd1582c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(EvaluatableRelation, UniversalVocabularyMt)) .
\"urn:uuid:ac6e6c99-37af-4133-bd1b-c94c427b5578"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ExceptionPredicate)) .
\"urn:uuid:72c55693-466c-4995-8cfb-9fe07b0f5739"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ExceptionPredicate, UniversalVocabularyMt)) .
\"urn:uuid:02fe32f3-0db5-427c-8dfe-e8659cda2461"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ExistentialQuantifier)) .
\"urn:uuid:b29f947d-9a32-4ccb-a5e2-c96ba5d1cce1"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ExistentialQuantifier, UniversalVocabularyMt)) .
\"urn:uuid:fddd4723-a906-48a0-a4ea-262d96bad7f6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('ExistentialQuantifier-Bounded')) .
\"urn:uuid:97c0c4fb-89a1-4287-8b62-ada29606bb2e"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('ExistentialQuantifier-Bounded', UniversalVocabularyMt)) .
\"urn:uuid:86b6ece5-df71-4fb6-9956-9878146296aa"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(FixedArityRelation)) .
\"urn:uuid:262133fa-d6b7-45e9-9e23-81a7bea84067"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(FixedArityRelation, UniversalVocabularyMt)) .
\"urn:uuid:9e478beb-06ec-41fd-a0f9-efbbf64e3085"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(FixedAritySkolemFuncN)) .
\"urn:uuid:40180c9b-7a00-4c84-9174-075b436e9b41"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(FixedAritySkolemFuncN, UniversalVocabularyMt)) .
\"urn:uuid:7bc39871-56a1-4a5d-8c16-bfe446b0673c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(FixedAritySkolemFunction)) .
\"urn:uuid:f0b52771-d1d6-40e4-91d5-8b5966a04689"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(FixedAritySkolemFunction, UniversalVocabularyMt)) .
\"urn:uuid:8b9f2b56-9ade-4977-bbbf-b50bb3f02a30"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Format)) .
\"urn:uuid:93ee9fd1-83d3-42a4-b836-1da5b1d19fa4"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Format, UniversalVocabularyMt)) .
\"urn:uuid:de7d416e-dd3a-4265-bb50-0b76cf423f6f"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('Function-Denotational')) .
\"urn:uuid:59e8c8e7-bd56-45d5-a633-0b10c22f37cf"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('Function-Denotational', UniversalVocabularyMt)) .
\"urn:uuid:ba28e76a-2496-48d1-bf8f-7d89c3db5cc5"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(HLExternalIDString)) .
\"urn:uuid:e39c3de4-71b2-4e51-8f39-590db57b9fdb"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(HLExternalIDString, UniversalVocabularyMt)) .
\"urn:uuid:3d9f7228-4eea-4162-902d-7c61b2da5394"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(HypotheticalContext)) .
\"urn:uuid:bf05298f-6342-419e-b10d-3fc1bde85172"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(HypotheticalContext, UniversalVocabularyMt)) .
\"urn:uuid:b9c3ed4b-aa18-412f-87c7-1c5923179f04"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Individual)) .
\"urn:uuid:37c11989-9fb7-4f86-9dae-e42fa75e037c"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Individual, UniversalVocabularyMt)) .
\"urn:uuid:16c515b4-5c58-4a7c-928f-589d15989bfc"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:905cc8a4-dd02-47a4-b517-9af34a36baf3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(InferenceRelatedBookkeepingPredicate, BaseKB)) .
\"urn:uuid:02cead61-c243-4c6f-990d-98127f280e73"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Integer)) .
\"urn:uuid:35829698-8489-4ea2-bd66-642c32a0eb94"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Integer, UniversalVocabularyMt)) .
\"urn:uuid:2d667169-c935-47f3-8284-fc7a7bec0973"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(InterArgFormatPredicate)) .
\"urn:uuid:586e9fa3-6e0c-43b9-b3a1-0da7a9f90331"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(InterArgFormatPredicate, UniversalVocabularyMt)) .
\"urn:uuid:80385307-0a88-4e60-9dc3-92b05cd8d087"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(InterArgIsaPredicate)) .
\"urn:uuid:3537987f-a752-491f-9f16-509a4266637d"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(InterArgIsaPredicate, UniversalVocabularyMt)) .
\"urn:uuid:431aaa9b-c4d6-4e53-9586-a01de7051b4c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(IrreflexiveBinaryPredicate)) .
\"urn:uuid:42bb0498-6a90-4c23-a377-b72450f41efd"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(IrreflexiveBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:1512a59e-5577-49c2-83d1-4c16fcb22832"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(List)) .
\"urn:uuid:a4dfcc2e-4a87-417a-9647-c030cf28223b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(List, UniversalVocabularyMt)) .
\"urn:uuid:d6695f8e-2a8e-4b87-886d-3b57f4dfae68"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(LogicalConnective)) .
\"urn:uuid:ce63a676-7edd-419d-8d11-144e845c8ace"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(LogicalConnective, UniversalVocabularyMt)) .
\"urn:uuid:72511b1b-a59b-47d2-8eee-105042d9abc6"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Microtheory)) .
\"urn:uuid:64294411-80d3-4acf-ad38-e0685fc667d2"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Microtheory, UniversalVocabularyMt)) .
\"urn:uuid:baf28bce-bfa1-483b-aca3-5c4a9e5fe75e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(MicrotheoryDesignatingRelation)) .
\"urn:uuid:46a5a81f-b2e5-4867-99ad-13bdab2a6cde"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(MicrotheoryDesignatingRelation, UniversalVocabularyMt)) .
\"urn:uuid:f6810436-a69f-441e-8361-ac92531a8aeb"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(MonthOfYearType)) .
\"urn:uuid:cee56ec1-b08f-4e39-800c-f28dac2eaa79"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(MonthOfYearType, UniversalVocabularyMt)) .
\"urn:uuid:3df688f7-d9d4-4ae2-b0f7-c39e8459bb7a"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Multigraph)) .
\"urn:uuid:bccb5b05-2123-4436-8bfb-c477978ff244"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Multigraph, UniversalVocabularyMt)) .
\"urn:uuid:002fd33c-6fa2-4b3c-92af-eb26ff8c34f8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(NonNegativeInteger)) .
\"urn:uuid:6efcd10a-5fd8-4fe1-952b-8ed94d024b4d"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(NonNegativeInteger, UniversalVocabularyMt)) .
\"urn:uuid:9b6da133-b5e6-4c07-a01a-16c094395722"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(NonNegativeScalarInterval)) .
\"urn:uuid:b967ce13-80d5-4c9e-9baf-3693ada604a3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(NonNegativeScalarInterval, UniversalVocabularyMt)) .
\"urn:uuid:636173ed-dd07-4a36-b56d-f180a2d9663b"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(PartiallyCommutativeRelation)) .
\"urn:uuid:0cd762e4-649b-4e6a-b437-a872d670eb88"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(PartiallyCommutativeRelation, UniversalVocabularyMt)) .
\"urn:uuid:2c4e69a9-cfd1-4508-aa8a-4483df7dbc99"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(PositiveInteger)) .
\"urn:uuid:d96d3250-f7de-405f-b8e6-a753f4e687dc"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(PositiveInteger, UniversalVocabularyMt)) .
\"urn:uuid:675c1fde-f710-4b47-b020-63dc1dd61cfa"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Predicate)) .
\"urn:uuid:7f690bdc-dc70-4d52-b247-11223ba48647"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Predicate, UniversalVocabularyMt)) .
\"urn:uuid:567bf776-4367-4250-926c-751b33622a8c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ProblemSolvingCntxt)) .
\"urn:uuid:9527b673-990e-42c9-941d-3b36d73c4ea2"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ProblemSolvingCntxt, UniversalVocabularyMt)) .
\"urn:uuid:e7312bb2-6203-44b8-9af0-474f4d55823a"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Quantifier)) .
\"urn:uuid:5aaf0f8c-5ba0-4f52-8985-8557ad909766"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Quantifier, UniversalVocabularyMt)) .
\"urn:uuid:ebf38235-adb8-4d4a-a4f3-d6c88699d0fd"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuaternaryFunction)) .
\"urn:uuid:662381b2-7a2d-4709-a1e4-20125ba5ccff"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuaternaryFunction, UniversalVocabularyMt)) .
\"urn:uuid:94315e15-d359-4bfc-9ce7-4edd7d722b7d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuaternaryPredicate)) .
\"urn:uuid:0d2d43d1-533e-4198-8594-8b5d4d2f4411"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuaternaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:995073b8-217d-431a-bdca-8a83b263a9cf"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuaternaryRelation)) .
\"urn:uuid:74de8c68-bc02-47fe-aa1f-ad5cc51babf4"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuaternaryRelation, UniversalVocabularyMt)) .
\"urn:uuid:59be6343-5267-4cae-a293-61ec8d933e23"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuintaryFunction)) .
\"urn:uuid:1c3727c3-be71-41e2-b5f8-924567c79106"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuintaryFunction, UniversalVocabularyMt)) .
\"urn:uuid:311ef682-c32d-4b4b-9d7d-23aa6e679086"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuintaryPredicate)) .
\"urn:uuid:f6f453fa-62bc-4479-ac87-b8b67053e314"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuintaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:bb899622-6d55-4141-8d7d-45509bca659c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(QuintaryRelation)) .
\"urn:uuid:bdce4969-74cc-4f1b-ba66-b16cfc082104"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(QuintaryRelation, UniversalVocabularyMt)) .
\"urn:uuid:a395f9f3-a4bb-4492-a99c-4ebe7af2af72"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(RealNumber)) .
\"urn:uuid:ecd4c68b-1642-4783-8254-2dedcae13fef"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(RealNumber, UniversalVocabularyMt)) .
\"urn:uuid:27cf1874-ffb8-460b-b462-a95d02ccaa07"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ReflexiveBinaryPredicate)) .
\"urn:uuid:17f9e436-fc43-4b40-95d3-34fc0d3a027a"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ReflexiveBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:b0c06fd7-5568-47bf-a75d-ed0b7a23774b"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ReformulatorDirectivePredicate)) .
\"urn:uuid:a5af53f7-8c39-4d3f-b2ef-25d5ec091ee1"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ReformulatorDirectivePredicate, UniversalVocabularyMt)) .
\"urn:uuid:ded55b9d-e701-4a66-8bf5-d770966d9658"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ReifiableFunction)) .
\"urn:uuid:7606c6d8-df3a-4f8f-8a8e-d94527155fde"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ReifiableFunction, UniversalVocabularyMt)) .
\"urn:uuid:cf3df377-fcbb-4215-b387-9d843b1e0aef"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Relation)) .
\"urn:uuid:7cdfe884-4346-438a-9d6e-d2e7f29a6899"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Relation, UniversalVocabularyMt)) .
\"urn:uuid:f8750ec4-24ed-4c04-bd64-0c431d056300"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ScalarIntegralValue)) .
\"urn:uuid:61f3ab5f-2c09-44de-9b43-3f83b08eda37"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ScalarIntegralValue, UniversalVocabularyMt)) .
\"urn:uuid:172c508a-2b1f-4d38-a93f-fccf0e6688e7"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ScalarInterval)) .
\"urn:uuid:ead130ed-a731-4661-ac36-79b18440c0e9"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ScalarInterval, UniversalVocabularyMt)) .
\"urn:uuid:d3766c7d-2e53-4e1f-b2a7-c8e0b7656d89"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ScalarPointValue)) .
\"urn:uuid:3fd1ee69-3ca6-4d30-bd3d-5d583f1b6387"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ScalarPointValue, UniversalVocabularyMt)) .
\"urn:uuid:a20c4a7c-afa4-42ee-b727-e8617f59efa7"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(ScopingRelation)) .
\"urn:uuid:7bb66fa7-c505-434a-94f5-652dd2e6a813"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(ScopingRelation, UniversalVocabularyMt)) .
\"urn:uuid:f2f98917-7065-431e-9473-b1fd05d27856"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SententialRelation)) .
\"urn:uuid:569eb2e5-5016-4901-b2c4-967d96eb09f6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SententialRelation, UniversalVocabularyMt)) .
\"urn:uuid:35429e98-6aff-49fe-957f-54e9bc2e05fd"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection('Set-Mathematical')) .
\"urn:uuid:ab6dc0c2-4151-4ea6-a8b5-239c87105801"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt('Set-Mathematical', UniversalVocabularyMt)) .
\"urn:uuid:cbfab86e-6054-41d5-89eb-cc6d57c09a9e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SetOrCollection)) .
\"urn:uuid:3c59ac41-a33e-49f0-a655-7e94ca9825c6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SetOrCollection, UniversalVocabularyMt)) .
\"urn:uuid:51e8a5f7-6ecd-4493-a7b1-72df467803d8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SiblingDisjointAttributeType)) .
\"urn:uuid:bfcbe564-f5a8-444f-ad6e-a7ad72e9b459"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SiblingDisjointAttributeType, UniversalVocabularyMt)) .
\"urn:uuid:7d8be931-9fc4-41b4-9706-e12ba8a910c2"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SiblingDisjointCollectionType)) .
\"urn:uuid:c73c93aa-4600-4b78-98b0-8770a5ad603b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SiblingDisjointCollectionType, UniversalVocabularyMt)) .
\"urn:uuid:a0482cf4-bfcc-487a-b96b-e3906d334164"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SkolemFunction)) .
\"urn:uuid:b74b8a57-d466-4be6-8061-b9ea2fa7c06a"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SkolemFunction, UniversalVocabularyMt)) .
\"urn:uuid:2cd7f421-5602-4492-b651-d7c477f857fc"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLAtom)) .
\"urn:uuid:16b5b5d1-a92f-4502-8e97-99f38402fde0"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLAtom, UniversalVocabularyMt)) .
\"urn:uuid:959ab26e-c119-475c-9bcb-9bb411a5b91c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLAtomicTerm)) .
\"urn:uuid:c4a9da9c-cf4c-4d73-bb09-7b230a4cd0c4"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLAtomicTerm, UniversalVocabularyMt)) .
\"urn:uuid:3b655a4c-6e9e-47d8-9da7-2dfec277f45e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLCharacter)) .
\"urn:uuid:d9cb2475-d755-4cbc-9422-005be4e55d2a"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLCharacter, UniversalVocabularyMt)) .
\"urn:uuid:4fe81837-6261-4062-9291-a6cbc6217da7"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLExpressionType)) .
\"urn:uuid:bb9848e7-aff4-4aa0-8c61-e8e4c5605639"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLExpressionType, UniversalVocabularyMt)) .
\"urn:uuid:084f7f2e-029b-4c6e-a4b8-127403ba4276"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLInteger)) .
\"urn:uuid:b648fcf5-2dbb-42e9-88a8-408c677fbb23"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLInteger, UniversalVocabularyMt)) .
\"urn:uuid:2e8c3892-4f71-4d8f-aab6-4883dcc5d8a0"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLKeyword)) .
\"urn:uuid:00679c02-7f3c-4fcf-86e5-b246b789bd19"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLKeyword, UniversalVocabularyMt)) .
\"urn:uuid:e7d0ed2d-b495-40aa-922a-57d0e3a35341"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLList)) .
\"urn:uuid:a2b8c68a-6324-48e0-bd9b-149e781150e0"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLList, UniversalVocabularyMt)) .
\"urn:uuid:536ad908-6dcc-4ea1-9795-eee8da69d411"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLNonNegativeInteger)) .
\"urn:uuid:ba9c2e50-a1ab-4142-b883-58ae3a180a59"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLNonNegativeInteger, UniversalVocabularyMt)) .
\"urn:uuid:16faba5d-a49b-42a9-9c2c-1b3b66d5d827"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLNonVariableNonKeywordSymbol)) .
\"urn:uuid:0024db1a-8cc4-47cc-8d06-02574a0d6256"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLNonVariableNonKeywordSymbol, UniversalVocabularyMt)) .
\"urn:uuid:5067acdd-82b0-40d0-ba7e-9b2a33a4eb0d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLNonVariableSymbol)) .
\"urn:uuid:26a0eb2e-d146-4756-b7db-d6dc935c01d3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLNonVariableSymbol, UniversalVocabularyMt)) .
\"urn:uuid:034d217a-0f83-456c-bad8-852c8fecd3f8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLPositiveInteger)) .
\"urn:uuid:33e2959a-f92a-4250-bac4-100619d80da6"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLPositiveInteger, UniversalVocabularyMt)) .
\"urn:uuid:51a56d26-d77d-4503-9332-f7ad56fdacf1"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLRealNumber)) .
\"urn:uuid:915ea4ff-e51f-43eb-858a-600b7e0aa4fe"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLRealNumber, UniversalVocabularyMt)) .
\"urn:uuid:e8205177-77b2-4db7-b128-41c490d0758c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLSExpression)) .
\"urn:uuid:c4fd5381-1d1f-4f34-b0a8-894cc61feffa"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLSExpression, UniversalVocabularyMt)) .
\"urn:uuid:fe5fd822-5ecb-49da-a8b6-b3dc06d81118"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLString)) .
\"urn:uuid:909f911d-a575-4113-aa2a-23e8167173c3"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLString, UniversalVocabularyMt)) .
\"urn:uuid:baceb934-9baa-47e8-b553-58d1d263c25e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SubLSymbol)) .
\"urn:uuid:9626c38d-4a5d-4723-91f0-c95909244825"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SubLSymbol, UniversalVocabularyMt)) .
\"urn:uuid:149d66ef-a8b2-4097-b3a2-37e0357e72e8"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(SymmetricBinaryPredicate)) .
\"urn:uuid:5f05abd6-8a82-499e-bb78-1e6297b64e6f"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(SymmetricBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:7707953e-6952-44c8-918c-74f8fa7875be"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TernaryFunction)) .
\"urn:uuid:c5c08abc-080f-43ee-9278-80bfec10a9e5"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TernaryFunction, UniversalVocabularyMt)) .
\"urn:uuid:e396c72a-e686-4361-b282-df785f5b4a40"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TernaryPredicate)) .
\"urn:uuid:f227ee77-49d1-43d3-b5c7-78cde62c91a2"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TernaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:a10c7f14-e859-4c1f-b10c-50a64fec338d"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TernaryRelation)) .
\"urn:uuid:df3dee1d-aae8-4640-a8a3-754ef2fb0edd"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TernaryRelation, UniversalVocabularyMt)) .
\"urn:uuid:9ad7093b-e5e6-4b19-8e94-254e4e351e70"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TheTerm)) .
\"urn:uuid:4d4b8eaf-32c0-4578-8c43-12240a305ebd"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TheTerm, UniversalVocabularyMt)) .
\"urn:uuid:1824a9b5-4c41-4054-9252-a2afba50d6ce"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(Thing)) .
\"urn:uuid:8366ca44-e653-4419-a67a-1a512881853a"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(Thing, UniversalVocabularyMt)) .
\"urn:uuid:bc644846-c783-4be2-aa66-354a6c8ab4f2"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TransitiveBinaryPredicate)) .
\"urn:uuid:f2137bb3-49e3-479f-9493-3628dea4e482"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TransitiveBinaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:b772e659-2591-4030-8dbe-efbf010f9f67"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(TruthFunction)) .
\"urn:uuid:64155182-1e67-4874-b4f4-db492d6058cf"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(TruthFunction, UniversalVocabularyMt)) .
\"urn:uuid:2681343f-27bd-4fcf-8215-34e4fef786d0"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnaryFunction)) .
\"urn:uuid:02b09cb2-7cfd-488b-8ec9-e0ab83b78b13"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnaryFunction, UniversalVocabularyMt)) .
\"urn:uuid:ac6fd2e7-c63a-4c1b-91cb-69de9c29804c"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnaryPredicate)) .
\"urn:uuid:ff66d659-0898-47f6-8802-1ba2abfd40aa"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnaryPredicate, UniversalVocabularyMt)) .
\"urn:uuid:aaee62da-a07b-468d-b214-6b089d3b8f08"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnaryRelation)) .
\"urn:uuid:c423310a-f766-435d-9120-b7897d00ff53"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnaryRelation, UniversalVocabularyMt)) .
\"urn:uuid:88dcac35-447e-4006-9bc6-68a8ed85b42e"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnitOfMeasure)) .
\"urn:uuid:e20fc25d-dd8a-4e40-a5c9-62d490f6abf5"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnitOfMeasure, UniversalVocabularyMt)) .
\"urn:uuid:1f0dc319-9c21-4f58-89e9-5340c2243443"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnknownScalarInterval)) .
\"urn:uuid:bfb30644-b1f8-49ce-b1ac-a8c650844497"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnknownScalarInterval, UniversalVocabularyMt)) .
\"urn:uuid:2ad998c1-b9e4-40a9-a089-92e8099d0044"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(UnreifiableFunction)) .
\"urn:uuid:6a4c2550-6e69-4653-8584-62775c42acbe"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(UnreifiableFunction, UniversalVocabularyMt)) .
\"urn:uuid:cc68490f-3a03-4388-af4f-748f63743fbf"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(VariableArityRelation)) .
\"urn:uuid:047e27fa-a489-482d-9476-fea772258d5b"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(VariableArityRelation, UniversalVocabularyMt)) .
\"urn:uuid:b5228dc3-7399-4e8c-8bed-5beb5a37152b"[silk#strict] .
istAsserted(BaseKB, decontextualizedCollection(VariableAritySkolemFunction)) .
\"urn:uuid:f37bb30e-4024-4f2d-af78-0734da15337f"[silk#strict] .
istAsserted(BaseKB, collectionConventionMt(VariableAritySkolemFunction, UniversalVocabularyMt)) .
\"urn:uuid:f1b6e08e-283b-4ecc-9867-f13c789de0fb"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(arity)) .
\"urn:uuid:298f5746-9db1-46c6-a6cd-6288b8771cd0"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(arity, UniversalVocabularyMt)) .
\"urn:uuid:be6ad6e8-81d2-4af3-8e53-fa203582ae98"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(arityMax)) .
\"urn:uuid:857ab7b4-af0c-44f9-b369-ac5eef97b12c"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(arityMax, UniversalVocabularyMt)) .
\"urn:uuid:d058bfd7-a4cf-40a2-8e95-1c40cb7f98bb"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(arityMin)) .
\"urn:uuid:5ed695e8-4dbe-42a8-8cdd-5965be4f0121"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(arityMin, UniversalVocabularyMt)) .
\"urn:uuid:d1209c18-7a16-43f5-8322-4d251b22cada"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(assertionDirection)) .
\"urn:uuid:2ac3e484-ab40-4fcd-896f-160b221e1cba"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(assertionDirection, BaseKB)) .
\"urn:uuid:6d727b67-1105-4bc1-bf72-ca995891fe7c"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(assertiveWFFRule)) .
\"urn:uuid:52c40d1c-4eb8-4b1c-8c92-a5471e03576e"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(canonicalizerDirectiveForAllArgs)) .
\"urn:uuid:f12a4a87-7939-4567-878e-35c3fa558010"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(canonicalizerDirectiveForAllArgs, UniversalVocabularyImplementationMt)) .
\"urn:uuid:9e0f7f46-a324-4fd4-8874-ab9c5c9ea4f3"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(canonicalizerDirectiveForArg)) .
\"urn:uuid:6696ee20-e44c-495b-9590-6f60a9dfbaf5"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(canonicalizerDirectiveForArg, UniversalVocabularyImplementationMt)) .
\"urn:uuid:2e945211-5a7d-4a68-8a39-8cd61489fedb"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(canonicalizerDirectiveForArgAndRest)) .
\"urn:uuid:edb6fbfe-6ba0-43db-94af-1dc17824164c"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(canonicalizerDirectiveForArgAndRest, UniversalVocabularyImplementationMt)) .
\"urn:uuid:dfef69c2-17da-477a-bd19-541675e3f7ce"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(collectionConventionMt)) .
\"urn:uuid:1e04ca08-89f6-4642-a761-df0f34397cd2"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(collectionConventionMt, BaseKB)) .
\"urn:uuid:55d7a1af-2010-47eb-a9ef-4afbd2641584"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(decontextualizedCollection)) .
\"urn:uuid:fc431f9d-880b-4a55-b768-6cc3614b6d05"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(decontextualizedCollection, BaseKB)) .
\"urn:uuid:82173c27-9ad8-4520-8c57-c2cd802d85d6"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(decontextualizedPredicate)) .
\"urn:uuid:baba0256-13e7-4b0c-91f3-d331cf84a841"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(decontextualizedPredicate, BaseKB)) .
\"urn:uuid:4f19c705-a720-469c-a1f1-f244423358f3"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(definingMt)) .
\"urn:uuid:c6f73205-9d63-4a7a-8988-a4ec344676d4"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(definingMt, BaseKB)) .
\"urn:uuid:501760ad-c956-49f2-af82-40798b06aebb"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(ephemeralTerm)) .
\"urn:uuid:a966775a-fa2c-4a43-b24a-f907acf3907e"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(evaluateImmediately)) .
\"urn:uuid:14a85592-eb57-4da5-92c1-069b51c929f8"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(genlMt)) .
\"urn:uuid:a462a253-cd2f-4c8f-a3ec-3bcccf3b2cfc"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(genlMt, UniversalVocabularyMt)) .
\"urn:uuid:958f824f-6f77-4b94-a360-c06820c65791"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(ist)) .
\"urn:uuid:c033c214-5353-49d7-abc5-4b30cc002d2c"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(ist, BaseKB)) .
\"urn:uuid:fca552e5-d06d-4edb-ae5d-cf244340ece9"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(istAsserted)) .
\"urn:uuid:89494e40-f634-4853-87a0-e4e625c69de9"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(istAsserted, BaseKB)) .
\"urn:uuid:26a7462e-5955-484d-aa52-51bb6d037e01"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(nearestGenlMt)) .
\"urn:uuid:7351d819-dc2f-4735-b697-5ff673640c58"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(nearestGenlMt, UniversalVocabularyMt)) .
\"urn:uuid:4dcedf5b-3c57-40e5-9766-1259b83dfaa2"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(notAssertibleMt)) .
\"urn:uuid:5799b672-c820-4e93-b630-c5ea700d4dc8"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(notAssertibleMt, UniversalVocabularyMt)) .
\"urn:uuid:570744fa-182a-46f0-9346-96dc808ad2c5"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(predicateConventionMt)) .
\"urn:uuid:5316dc99-1eaf-4abd-89f1-21673a43e19b"[silk#strict] .
istAsserted(UniversalVocabularyMt, predicateConventionMt(predicateConventionMt, BaseKB)) .
\"urn:uuid:e9bc840c-7d11-426f-a61f-a439d5854a89"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(quotedArgument)) .
\"urn:uuid:a70226a9-4edd-4e0b-bf9d-4ca077ffef29"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(quotedArgument, UniversalVocabularyMt)) .
\"urn:uuid:f3d25f1c-a173-4fbf-b2fe-dbc983e9c246"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(skolem)) .
\"urn:uuid:445a049d-26f5-4059-8002-35b75569ff01"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(skolem, BaseKB)) .
\"urn:uuid:4887d9c1-aeb6-40fb-878b-09a790feb667"[silk#strict] .
istAsserted(BaseKB, decontextualizedPredicate(termOfUnit)) .
\"urn:uuid:4573e27a-0ceb-413d-a012-c840dc4bc9a4"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(termOfUnit, BaseKB)) .
\"urn:uuid:bfa418bc-63ae-4341-98c2-2dbcddd270e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AbsoluteValueFn, UnaryFunction)) .
\"urn:uuid:c69f457b-a3a7-4672-ae71-5177d1975aec"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AbsoluteValueFn, EvaluatableFunction)) .
\"urn:uuid:e8e9bad6-d826-4471-9fe5-7e7f024b5414"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(AbsoluteValueFn, ScalarInterval)) .
\"urn:uuid:096a8267-033f-460d-aad1-7d3be13e7288"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(AbsoluteValueFn, NonNegativeScalarInterval)) .
\"urn:uuid:5a29b430-b1e1-48d4-acb4-1cf8f22e3d92"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(AbsoluteValueFn, (1))) .
\"urn:uuid:2a0b9ef1-cfa9-42c9-b4ce-a7af7c600fb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AntiSymmetricBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7cf150f7-860a-4e10-ad0f-d98d75cfdf74"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AntiSymmetricBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:72e4545b-a0bc-4f1e-a204-b50b84bd3d63"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AntiTransitiveBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d06da849-6af2-42a0-8513-eddd8fd8cb7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AntiTransitiveBinaryPredicate, IrreflexiveBinaryPredicate)) .
\"urn:uuid:0c83e8ff-f496-448c-bd89-c8f56f9d558a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(April, MonthOfYearType)) .
\"urn:uuid:86e9b443-5e77-41b2-81af-377076fc389b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(April, Individual)) .
\"urn:uuid:11c75d9e-97f5-4416-8bd2-6589c8e7bd95"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgConstraintPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b95f76ca-99c0-4732-9e5c-49867ce2c125"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgConstraintPredicate, Predicate)) .
\"urn:uuid:d4ec2fa9-de82-4eb1-a619-fe36dd15a019"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgGenlBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:532ea443-91b0-4fef-b4ba-19ca55010a6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgGenlBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:f2e0db07-e851-48c3-a7c4-68aa4416cfcb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgGenlQuantityBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:154d6e71-adbc-4805-a2f6-40a054e38826"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgGenlQuantityBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:ac839616-cc5e-43fe-9f69-fcb5c7200bc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgGenlQuantityTernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d8227733-9f8a-4784-a1c4-f9d02b6587ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgGenlQuantityTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:77de7239-f4a0-43b5-886e-e2739435f47a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgGenlTernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b87d843f-0777-44d6-a92a-cc6c774cd3d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgGenlTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:5e59575f-a4b0-44a1-8e77-eca91837877d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgIsaBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3928b3fa-6332-4831-b647-a3828aaa6dd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgIsaBinaryPredicate, ArgIsaPredicate)) .
\"urn:uuid:7a65d32f-034f-4828-a991-731a75334267"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgIsaBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:b1730227-7768-40d2-b2e4-dedf97920537"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgIsaPredicate, Collection)) .
\"urn:uuid:c1b6e4b8-dbc1-46e4-a119-881c98a65536"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgIsaPredicate, ArgTypePredicate)) .
\"urn:uuid:942ea936-c8ca-431c-bcb2-315187afd0be"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgIsaTernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:1b812048-8f02-4efa-90b7-c585d8c6c2ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgIsaTernaryPredicate, ArgIsaPredicate)) .
\"urn:uuid:f64d0a1e-4162-4cf2-bb3a-399af5e9d5ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgIsaTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:29800919-85f8-4b57-b5b6-9de97d9f2f6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgQuotedIsaBinaryPredicate, Collection)) .
\"urn:uuid:51c7c7ec-e9d7-4af0-811f-eb7e1b8fe084"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgQuotedIsaBinaryPredicate, ArgQuotedIsaPredicate)) .
\"urn:uuid:cfd46882-1393-4f91-b4ee-2f371883f839"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgQuotedIsaBinaryPredicate, ArgTypeBinaryPredicate)) .
\"urn:uuid:d753e6de-4d1b-44b9-a3df-938e568227cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgQuotedIsaPredicate, Collection)) .
\"urn:uuid:9f6632ec-d539-4c64-8bdc-353ac134cd72"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgQuotedIsaPredicate, ArgTypePredicate)) .
\"urn:uuid:3ca6a3ea-0770-42f3-8aea-fa06b3a03ead"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgQuotedIsaTernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:56b09a5c-e5ae-4d18-800a-abac068ee648"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgQuotedIsaTernaryPredicate, ArgQuotedIsaPredicate)) .
\"urn:uuid:17784451-e821-48f6-8bc0-c89905b015f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgQuotedIsaTernaryPredicate, ArgTypeTernaryPredicate)) .
\"urn:uuid:57ee075d-d159-4d5b-8331-04da319d45be"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgSometimesIsaPredicate, Collection)) .
\"urn:uuid:fdc70e5c-738d-43b0-be3d-a01bd083c07a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgSometimesIsaPredicate, Predicate)) .
\"urn:uuid:28b09f46-7305-4a7c-a758-903930c5afb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgTypeBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4082ab21-a36a-48f4-ac22-c318342eede7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypeBinaryPredicate, ArgTypePredicate)) .
\"urn:uuid:23daf4bf-652f-4ff0-9f83-9057bfa5e023"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypeBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:dfec7797-86fd-434f-960f-b0be66d4438f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgTypePredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8a55a6db-0c3a-461a-bd03-28ae98684cfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypePredicate, CycLTerm)) .
\"urn:uuid:40034549-5491-42f0-9322-03c2c98c8e62"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypePredicate, ArgConstraintPredicate)) .
\"urn:uuid:8abaa49a-8a83-4e27-9a7a-b52dc9b021b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ArgTypeTernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b7882a05-580a-4113-be97-2b6e3b0a6736"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypeTernaryPredicate, ArgTypePredicate)) .
\"urn:uuid:63d84e1d-8b03-4bde-945b-6b87d0f6ee7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ArgTypeTernaryPredicate, TernaryPredicate)) .
\"urn:uuid:adab999b-14f9-43f4-adbe-a18168d22ff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedFalseDefault, HLAssertedArgumentKeywordDatastructure)) .
\"urn:uuid:c80c50d6-9a2b-489e-a409-0a56c16bf70e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedFalseDefault, Individual)) .
\"urn:uuid:377a382f-4895-412c-adfb-4ccee7910c7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedFalseMonotonic, HLAssertedArgumentKeywordDatastructure)) .
\"urn:uuid:a0b7dc5e-4a67-479d-b8a8-ed3a83380b0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedFalseMonotonic, Individual)) .
\"urn:uuid:c42de090-38ae-4970-96d6-30fc082869d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedTrueDefault, HLAssertedArgumentKeywordDatastructure)) .
\"urn:uuid:67c5bf77-29b8-4911-98d4-9106a9ea3531"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedTrueDefault, Individual)) .
\"urn:uuid:ca2e064e-9cc8-4b2e-a100-3a708dea37ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedTrueMonotonic, HLAssertedArgumentKeywordDatastructure)) .
\"urn:uuid:181d694d-a15a-402e-9f65-9d8776881355"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssertedTrueMonotonic, Individual)) .
\"urn:uuid:aba9c130-0c9c-4d1f-baf1-991ee9d201fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AssociativeRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:99e0c562-414a-44f5-94d8-98d8a423d11f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AssociativeRelation, Relation)) .
\"urn:uuid:503c2421-3df2-4573-b5d5-35ff463aa2c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AsymmetricBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:67888ddb-a1be-433d-9582-48b627bcd3bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(AsymmetricBinaryPredicate, 'RemovalModuleSupportedCollection-Generic')) .
\"urn:uuid:d481e410-fea4-428b-98d6-8efbec7fc0f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(AsymmetricBinaryPredicate, TransformationModuleSupportedCollection)) .
\"urn:uuid:935e4a3c-410b-44f7-ba30-13107b98fbe7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AsymmetricBinaryPredicate, IrreflexiveBinaryPredicate)) .
\"urn:uuid:43ad9a8d-0a9d-44fc-8c84-9569a37af69e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AsymmetricBinaryPredicate, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:bf78209d-62df-4c22-860e-c7f420050157"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(AtemporalNecessarilyEssentialCollectionType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8e9cb2f5-a280-440f-9551-8e15ec6de862"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(AtemporalNecessarilyEssentialCollectionType, Collection)) .
\"urn:uuid:6671a527-6ef1-4c0e-a707-5787342185f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(August, MonthOfYearType)) .
\"urn:uuid:a008d0e1-86e0-474d-a542-715526f910a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(August, Individual)) .
\"urn:uuid:691a4ae6-5c57-434a-af52-320472753300"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Average, EvaluatableFunction)) .
\"urn:uuid:e6ca39e0-0f5d-4a60-9fc6-e594e931e804"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Average, BinaryFunction)) .
\"urn:uuid:cd0422b9-9978-4e0e-abfd-b0c397d5c426"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(Average, SetOrCollection)) .
\"urn:uuid:983651d5-1ac0-422a-814f-28cc6e1b1466"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(Average, UnaryFunction)) .
\"urn:uuid:32cc2b19-853b-4a5e-9684-2091e850eec5"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Average, ScalarInterval)) .
\"urn:uuid:8dbf011a-d66d-4168-aea7-33e792c12b28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Average, (2))) .
\"urn:uuid:40efe830-5ce6-4404-881f-07601ac089e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Backward-AssertionDirection', CycLAssertionDirection)) .
\"urn:uuid:0af6691d-8c0f-4719-9424-21217c83631b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Backward-AssertionDirection', CycLAssertion)) .
\"urn:uuid:9d8caae7-ea29-4986-bacb-e034f9768b37"[silk#strict] .
istAsserted(BaseKB, isa(BaseKB, BroadMicrotheory)) .
\"urn:uuid:296d0f91-e67d-429f-9d80-7f80a6462450"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BaseKB, UniversalVocabularyMt)) .
\"urn:uuid:1e869509-34cc-4745-88aa-98a2dd142f8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BaseKB, UniversalVocabularyImplementationMt)) .
\"urn:uuid:0e740798-f553-4c40-bdaf-cc0ceb820949"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BaseKB, CoreCycLImplementationMt)) .
\"urn:uuid:9fb06959-9134-4131-84d4-7e9fb93a6317"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BinaryFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0e759ee6-bec2-427c-bab3-0b96c0f1d65c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryFunction, 'Function-Denotational')) .
\"urn:uuid:f9f9f284-89d6-4fa5-8131-889c24091cc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryFunction, BinaryRelation)) .
\"urn:uuid:45fde2e0-9feb-4dc1-98c8-3e0d37da2ae9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:50d500bf-549b-41b5-a30c-41ff0270d4af"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BinaryPredicate, PredicateTypeByArity)) .
\"urn:uuid:61849e69-81d1-4a4b-b925-14ed77080483"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryPredicate, FixedArityRelation)) .
\"urn:uuid:5c9990d0-b8e9-44a7-8da3-e14e46721704"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryPredicate, Predicate)) .
\"urn:uuid:58394191-1b56-44b0-9326-2aaba862b8b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryPredicate, BinaryRelation)) .
\"urn:uuid:f7fb9196-97a6-4bfa-8490-8035f8947bc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BinaryRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:94f52048-83c5-4565-a44d-eaf1dd2d0559"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BinaryRelation, FixedArityRelation)) .
\"urn:uuid:fa9d3435-3994-4760-b599-470b83c1c329"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BookkeepingMt, BroadMicrotheory)) .
\"urn:uuid:300a6194-919a-41a8-885b-0723429e28b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BookkeepingMt, Microtheory)) .
\"urn:uuid:6c76cb22-568e-40bf-8c4b-4bda71017aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BookkeepingMt, EnglishParaphraseMt)) .
\"urn:uuid:dd2d01ba-a760-46cf-b117-8eb12d7aad7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BookkeepingPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f69e020d-3a34-4430-ac2f-f6ebdef29fd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BookkeepingPredicate, Predicate)) .
\"urn:uuid:c9ea7f50-b4b1-4a09-acd8-ecbd32a04cba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(BroadMicrotheory, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:377ebf41-ae75-4abf-8438-e3da9e685535"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(BroadMicrotheory, Microtheory)) .
\"urn:uuid:9b38bf79-1363-4c52-9f44-c9401cd5490a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CanonicalizerDirective, Collection)) .
\"urn:uuid:004e8d12-0f33-44ba-be54-4ffdbb8b1555"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CanonicalizerDirective, Individual)) .
\"urn:uuid:bc5e1cf9-b229-4db9-855d-bfcfd3a03a68"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CharacterString, Collection)) .
\"urn:uuid:5345a63b-29fe-44e9-9bcc-3a540a4dd7af"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CharacterString, List)) .
\"urn:uuid:550f2cf1-a9c2-4602-a1b1-6cc257b540b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnNecessary(CharacterString, SubLSymbolFn(("CYC-LIST-OF-TYPE-NECESSARY"^^_string)))) .
\"urn:uuid:17235635-35b1-49ca-ab42-86ebbde3f8b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(CharacterString, SubLSymbolFn(("CYC-LIST-OF-TYPE-SUFFICIENT"^^_string)))) .
\"urn:uuid:f6ee5c7c-029c-41d3-a5df-add1b42812a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(CharacterString, SubLSymbolFn(("CYCL-STRING-P"^^_string)))) .
\"urn:uuid:97852d1d-30a0-48ac-97eb-a8c8a7d7b3f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Closed-InferenceProblemLinkStatus', Collection)) .
\"urn:uuid:9c09ecd9-8fca-4dea-ba8c-dc98cbfabd5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Closed-InferenceProblemLinkStatus', CycInferenceProblemLinkStatus)) .
\"urn:uuid:050a57c9-490c-41a9-aeec-f08e7fe207e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Code-AssertionDirection', CycLAssertionDirection)) .
\"urn:uuid:415ee279-478f-4941-b31c-eb78a9218c4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Code-AssertionDirection', CycLAssertion)) .
\"urn:uuid:ade507de-61e1-4389-87f1-e1239a2c3537"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Collection, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:24e58646-52b0-4847-a9a0-efb8519d5864"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Collection, SetOrCollection)) .
\"urn:uuid:b57dcd0e-147b-4b50-8ffb-ff4d06d25b6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionDenotingFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:996f5531-b79a-457d-8fa3-42575c4bd0e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CollectionDenotingFunction, 'Function-Denotational')) .
\"urn:uuid:6ddd0692-7701-4491-bddc-911edcc94c51"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(genls(CollectionDenotingFunction, ReifiableFunction))) .
\"urn:uuid:1c2387b6-d8aa-43fd-b143-90ceb60088a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn, ReifiableFunction)) .
\"urn:uuid:952e6216-3422-43dd-9a2d-f5ba2852106d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn, UnaryFunction)) .
\"urn:uuid:3a6ab1af-58ba-4cd0-a6cd-e346d75140d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CollectionRuleTemplateFn, Collection)) .
\"urn:uuid:0e3b4871-c357-48c2-a6a4-f22e7d4925f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(CollectionRuleTemplateFn, Thing)) .
\"urn:uuid:45b65138-1f23-4b83-8307-b35547fbde21"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CollectionRuleTemplateFn, RuleTemplate)) .
\"urn:uuid:bc3388ee-0a40-46f1-a3fa-43ffb00edf27"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CollectionRuleTemplateFn, (1))) .
\"urn:uuid:e5a8c2e9-28fa-4903-a64f-fdb9b32e4206"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CommutativeRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:16bbacd3-b303-48f7-87e8-7befc5da69b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CommutativeRelation, Relation)) .
\"urn:uuid:82639fdd-2cbf-4acb-ad7c-72b985bb9d82"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(genls(CommutativeRelation, PartiallyCommutativeRelation))) .
\"urn:uuid:4808ca78-7134-4d3d-9599-c95ac01ecf7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CoreCycLImplementationMt, Microtheory)) .
\"urn:uuid:15cec699-3cfa-459e-8254-531cfaead263"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLImplementationMt, LogicalTruthImplementationMt)) .
\"urn:uuid:5560a232-1dbe-4d3f-82a6-95155b27ee2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLImplementationMt, CoreCycLMt)) .
\"urn:uuid:cf5c96d7-471f-4123-b62a-1b3e0a56c443"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CoreCycLMt, Microtheory)) .
\"urn:uuid:062eafd3-89fb-40d7-8aac-9f6b9e1e75d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLMt, LogicalTruthMt)) .
\"urn:uuid:52acd403-fa69-4997-a3d7-5f2a5657dfb3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLMt, CoreCycLImplementationMt)) .
\"urn:uuid:0cbb619e-b18c-496f-bfaf-d582538e28b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CurrentWorldDataCollectorMt-NonHomocentric', Microtheory)) .
\"urn:uuid:0c0dd840-ec14-4c2f-acfd-5ae618ba850f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt('CurrentWorldDataCollectorMt-NonHomocentric', CyclistDefinitionalMt)) .
\"urn:uuid:47205342-881f-487f-9f22-9cd7b2fab2d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycAdministrator, HumanCyclist)) .
\"urn:uuid:e2d611fa-b313-4663-9778-c204d840493d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(CycAdministrator, IndeterminateTerm)) .
\"urn:uuid:aa4d8fd5-9146-465d-bfba-bdde7757fd6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycArgumentDatastructure, Collection)) .
\"urn:uuid:f071fc92-2918-4358-9346-275cd6b392d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycArgumentDatastructure, CycKBDatastructure)) .
\"urn:uuid:a2e4f61e-2a78-45f2-a1ad-31f27ecab826"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycDeductionDatastructure, Collection)) .
\"urn:uuid:d4fc2853-d1f8-4dbf-9c0c-6a4922ef3e36"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycDeductionDatastructure, CycArgumentDatastructure)) .
\"urn:uuid:ba41754f-1fc9-430a-ab9a-09aca694abc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycHLSupportDatastructure, Collection)) .
\"urn:uuid:19644045-f55d-480e-a871-912b54a95727"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycHLSupportDatastructure, CycKBDatastructure)) .
\"urn:uuid:0d94164a-7584-4a2b-b39d-127e54ddafa2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycHLSupportDatastructure, CycSupportDatastructure)) .
\"urn:uuid:2ef71204-9e1b-4319-8f62-6ed9c032f5fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycHLTruthValue, Collection)) .
\"urn:uuid:6e840ca4-e2e2-4f24-b1f2-b5a29768a7c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycHLTruthValue, Individual)) .
\"urn:uuid:13ca5294-7270-4472-8d9d-5d29535c1eff"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInference, Collection)) .
\"urn:uuid:d62e956f-cc64-4e4f-a5ca-22fce3984f45"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInference, CycInferenceDataStructure)) .
\"urn:uuid:16ee74f6-e626-4a6b-bd9c-1c3039b29dbb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceAnswer, Collection)) .
\"urn:uuid:2235eeee-5aba-45b1-b21f-c82d54d71239"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInferenceAnswer, CycInferenceDataStructure)) .
\"urn:uuid:14cf8ff9-52cf-41bc-a7c6-23662d10b77a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceAnswerJustification, Collection)) .
\"urn:uuid:b98e5ecf-99d8-4dcc-8e59-a8e1207f1e2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInferenceAnswerJustification, CycInferenceDataStructure)) .
\"urn:uuid:169545e1-bd9e-4a4f-a26f-42dc88bbefa8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceBindingsDataStructure, Collection)) .
\"urn:uuid:ebba5332-84b2-4797-bc7e-ff4b817eb891"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInferenceBindingsDataStructure, CycInferenceDataStructure)) .
\"urn:uuid:1642ff34-057c-4a3e-8bda-713cc72887d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceDataStructure, Collection)) .
\"urn:uuid:0aa5ae6b-5ce9-4dd9-8992-eb3f6f81cd13"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInferenceDataStructure, Individual)) .
\"urn:uuid:b4aca574-4f42-4bc3-b23f-7c47b08d5c4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceFn, BinaryFunction)) .
\"urn:uuid:d1edbd34-42e6-4eb7-b249-56832e5591fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceFn, ReifiableFunction)) .
\"urn:uuid:7bfb2418-d387-4a5d-b3b3-a05a17cbdb6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycInferenceFn, NonNegativeInteger)) .
\"urn:uuid:f30c991e-2e59-45ac-924f-ecbe1d4f63e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(CycInferenceFn, CycProblemStore)) .
\"urn:uuid:1690c167-5ed9-410c-9238-9a78c0a7ef69"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycInferenceFn, CycInference)) .
\"urn:uuid:4b638956-2de8-48a8-83df-8e168f51884a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycInferenceFn, (2))) .
\"urn:uuid:064d149e-e931-4e64-9a55-dc06343d36f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycInferenceProblemLinkStatus, Collection)) .
\"urn:uuid:eef77a94-8747-4370-b016-b309becf770c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycInferenceProblemLinkStatus, CycInferenceDataStructure)) .
\"urn:uuid:9c5da548-ab25-4673-9eac-32802d3bba1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycKBDatastructure, Collection)) .
\"urn:uuid:194822f9-f229-401d-a772-0df91ed8ca53"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycKBDatastructure, Individual)) .
\"urn:uuid:b83d5612-1583-47b3-827b-5339c15b6ae5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertedAssertion, CycLExpressionType)) .
\"urn:uuid:d3d2987c-2b8d-4171-a641-55b03e1d4fa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertedAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:fccb238e-0c3e-4773-aad6-de99bbbe22bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAssertedAssertion, CycLAssertion)) .
\"urn:uuid:f631ffff-989c-499c-91d9-553533491cbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLAssertedAssertion, SubLSymbolFn(("CYCL-ASSERTED-ASSERTION?"^^_string)))) .
\"urn:uuid:9599420b-ce97-4b21-bc33-3875aef92c3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertion, CycLExpressionType)) .
\"urn:uuid:0cf13a03-41cd-4cfc-b6fd-9d1026604920"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:cda7d00d-bd95-4b32-963c-ce8a3142b103"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAssertion, CycLIndexedTerm)) .
\"urn:uuid:d2dbaa5b-7fdf-4b77-9f35-878cf621f994"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAssertion, CycSupportDatastructure)) .
\"urn:uuid:9a016edb-7178-46dc-b62c-8acdb7422592"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAssertion, 'CycLSentence-Assertible')) .
\"urn:uuid:da241038-8047-48f7-9df2-33cf31a9b211"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLAssertion, SubLSymbolFn(("CYCL-ASSERTION?"^^_string)))) .
\"urn:uuid:81f86389-78f1-4006-8164-89cbcefc48e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertionDirection, SiblingDisjointCollectionType)) .
\"urn:uuid:1af32443-c16e-4ffd-9169-384350d8e8f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAssertionDirection, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:952997f1-9213-4dd3-9393-2a5b9c7b4c98"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAssertionDirection, Collection)) .
\"urn:uuid:1d31dec4-3d04-4050-b082-c6670ff6ad93"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicAssertion, CycLExpressionType)) .
\"urn:uuid:ac988c27-3d9e-43cf-b579-74a494813385"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:42e9b07e-5048-43dc-954b-02fd05d3b43f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicAssertion, CycLAssertion)) .
\"urn:uuid:f95e6f2d-0ac0-460d-b3a1-c24742dc06a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicAssertion, CycLAtomicSentence)) .
\"urn:uuid:823bac07-f618-47db-a269-402aafa766e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLAtomicAssertion, SubLSymbolFn(("CYCL-ATOMIC-ASSERTION?"^^_string)))) .
\"urn:uuid:b5b79df4-a9da-4dcb-8f77-b63cd4f97bd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicSentence, CycLExpressionType)) .
\"urn:uuid:648184e8-2b41-4916-87ee-f582531af231"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:67c35b39-f4e9-4253-b0f4-0a68d5443a89"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicSentence, CycLSentence)) .
\"urn:uuid:03257cd0-2245-4e57-a926-240e1548f80c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicSentence, CycLFormulaicSentence)) .
\"urn:uuid:6dcebfc8-0281-4fdf-b016-cfb973e7a7ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLAtomicSentence, SubLSymbolFn(("CYCL-ATOMIC-SENTENCE?"^^_string)))) .
\"urn:uuid:7db124d2-f4ce-4f29-9a8b-ddd64dbc3e0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicTerm, CycLExpressionType)) .
\"urn:uuid:b27afc86-14e0-42c7-a128-ed43d2e5625e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4bba4a58-a289-4305-8e2d-2c997b73aaf3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicTerm, CycLExpression)) .
\"urn:uuid:ab598e18-4ca1-4e5b-bc3d-6055c816ce95"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicTerm, CycLDenotationalTerm)) .
\"urn:uuid:b9407410-eb09-44ef-af04-e6e2bfa1e96e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLAtomicTerm, 'CycLDenotationalTerm-Assertible')) .
\"urn:uuid:fef9d2dc-8efb-44e5-a5a8-b9066d0b08d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLAtomicTerm, SubLSymbolFn(("CYCL-ATOMIC-TERM-P"^^_string)))) .
\"urn:uuid:eacfcd0d-8838-4674-b10b-e9ebf132d6c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedAtomicSentence, CycLExpressionType)) .
\"urn:uuid:faa383ba-e7ef-46ee-9dc7-1f08f36204df"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedAtomicSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3ff7d0f9-a3c9-4e64-95eb-fb561e61189a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedAtomicSentence, CycLAtomicSentence)) .
\"urn:uuid:be8f0603-cd67-4c9d-b03d-c7ce3f34ac4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedAtomicSentence, CycLClosedFormula)) .
\"urn:uuid:2a8c7a96-21d4-4404-bad1-7e204527b308"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedAtomicSentence, CycLClosedSentence)) .
\"urn:uuid:7a0d1405-09cc-4853-a9e1-c23b51cfa2d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedAtomicSentence, SubLSymbolFn(("CYCL-CLOSED-ATOMIC-SENTENCE?"^^_string)))) .
\"urn:uuid:4ec51591-3e9e-4747-b5b9-af4434bf1bf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedAtomicTerm, CycLExpressionType)) .
\"urn:uuid:06213948-63b3-416c-aafb-8ff5b3833bbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3a75be5d-586f-4f69-b349-e0ed668cf137"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedAtomicTerm, CycLAtomicTerm)) .
\"urn:uuid:631f46d7-1b29-4122-b0a6-3a0f082badc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedAtomicTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:01184261-fe3e-451f-8890-e5d733bf04b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedAtomicTerm, SubLSymbolFn(("CYCL-CLOSED-ATOMIC-TERM-P"^^_string)))) .
\"urn:uuid:51ec8d46-4531-4e59-8ef3-431816644854"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedDenotationalTerm, CycLExpressionType)) .
\"urn:uuid:791da1ac-2420-4538-8f43-3960356316d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedDenotationalTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:dc21ccef-d5f4-4924-bd72-15fb72c8eeb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedDenotationalTerm, CycLDenotationalTerm)) .
\"urn:uuid:e88d6745-7cbb-4b75-a996-13d6aadbad18"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedDenotationalTerm, CycLClosedExpression)) .
\"urn:uuid:4e51b894-5ecc-47fe-8bc5-36f19e808902"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedDenotationalTerm, SubLSymbolFn(("CYCL-CLOSED-DENOTATIONAL-TERM?"^^_string)))) .
\"urn:uuid:b4a7e498-c0a5-4d17-b9d4-c083217abc11"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedExpression, CycLExpressionType)) .
\"urn:uuid:6d42417a-a89d-4e9d-a91c-459c857b379f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedExpression, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b05ce7b3-7e8a-4395-b21c-4892ade4a795"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedExpression, CycLExpression)) .
\"urn:uuid:2cf900c9-7bbe-4fe3-8639-a8df257186c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedExpression, CycLTerm)) .
\"urn:uuid:8aefb720-f83e-42e5-8d60-7f2deba7f793"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedExpression, SubLSymbolFn(("CYCL-CLOSED-EXPRESSION?"^^_string)))) .
\"urn:uuid:db278d1f-b6a2-447f-90f7-e6628648afed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedFormula, CycLExpressionType)) .
\"urn:uuid:4dbae9f1-ec81-4bf6-956c-4a214c6450a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedFormula, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0bdff74c-d750-49df-adcf-99078d38db2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedFormula, CycLClosedExpression)) .
\"urn:uuid:9cd56710-580b-4d2e-8be9-69e77ce587f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedFormula, CycLFormula)) .
\"urn:uuid:4b942d9a-8f97-4e4c-83a9-ff6d818440c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedFormula, SubLSymbolFn(("CYCL-CLOSED-FORMULA?"^^_string)))) .
\"urn:uuid:59f3203a-2abc-4bc3-9ee0-cdcceb78f702"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedNonAtomicTerm, CycLExpressionType)) .
\"urn:uuid:af4c252a-77e0-4628-b63a-c7f88e3d804d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedNonAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:739f5723-1556-4d4a-8838-0a1aeff2ae11"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedNonAtomicTerm, 'CycLNonAtomicTerm-ClosedFunctor')) .
\"urn:uuid:526c00a3-8663-4923-b66a-22ab07d94c92"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedNonAtomicTerm, CycLNonAtomicTerm)) .
\"urn:uuid:e941c410-baf9-44dc-a77c-d076c10d1e81"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedNonAtomicTerm, Thing)) .
\"urn:uuid:4de7142f-356f-48f9-9b49-9e12ea1ba156"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedNonAtomicTerm, CycLClosedFormula)) .
\"urn:uuid:3e1cd3a2-8de3-4ecd-8c7e-ab5534eabf43"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedNonAtomicTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:a1849096-773a-4f05-98b0-6ba05f3c4877"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedNonAtomicTerm, SubLSymbolFn(("CYCL-CLOSED-NON-ATOMIC-TERM?"^^_string)))) .
\"urn:uuid:7c1f6c93-46af-4f85-abab-197c1846767f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedSentence, CycLExpressionType)) .
\"urn:uuid:10a9332d-8918-407b-bc02-648a63b4cc3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLClosedSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7d219b9a-8cd9-4322-a5b0-3d38f25934af"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedSentence, 'CycLSentence-ClosedPredicate')) .
\"urn:uuid:f82f03fc-a751-493b-a84f-4aa5e1659e58"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLClosedSentence, CycLClosedExpression)) .
\"urn:uuid:f5e983e8-e039-4862-8abf-0b4ee83edc82"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLClosedSentence, SubLSymbolFn(("CYCL-CLOSED-SENTENCE?"^^_string)))) .
\"urn:uuid:1b26a214-4899-4d40-a0d4-1ef1cff1c9c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLConstant, CycLExpressionType)) .
\"urn:uuid:fbeed1b4-3e69-4f8d-8146-ef770bf6a9a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLConstant, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:2242e80a-0673-4905-b737-85df46d94302"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLConstant, CycLRepresentedAtomicTerm)) .
\"urn:uuid:f6f96a9b-784d-4cdb-b556-9b9e93f5fc52"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLConstant, CycLClosedAtomicTerm)) .
\"urn:uuid:d4e9ec2e-48a5-4751-8084-71767aed6c85"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLConstant, CycLReifiedDenotationalTerm)) .
\"urn:uuid:c0f96e44-20b1-4a44-8dc6-16aa8a0b0c21"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLConstant, SubLSymbolFn(("CYCL-CONSTANT-P"^^_string)))) .
\"urn:uuid:e831deba-0f97-4c60-ab32-ca3c05b090e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLDeducedAssertion, CycLExpressionType)) .
\"urn:uuid:ab049925-cc7f-4451-8734-20721cd65798"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLDeducedAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:10f9ed83-810a-4dcc-a99d-2a75cc3c066e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLDeducedAssertion, CycLAssertion)) .
\"urn:uuid:0be266b7-3039-4ce9-b1f9-31790ae974cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLDeducedAssertion, SubLSymbolFn(("CYCL-DEDUCED-ASSERTION?"^^_string)))) .
\"urn:uuid:83b9658c-90bb-4273-927e-cac7258dfa57"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLDenotationalTerm, CycLExpressionType)) .
\"urn:uuid:bf10be76-27ef-4b27-9f0c-f9f3385310f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLDenotationalTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f7f69c12-6596-475c-9ea4-f1c237724542"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLDenotationalTerm, CycLExpression)) .
\"urn:uuid:7a1e5855-a534-4929-86c7-b237c7817594"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLDenotationalTerm, CycLTerm)) .
\"urn:uuid:baffbfbb-a7e6-4123-ac9f-b1695f5774dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLDenotationalTerm, SubLSymbolFn(("CYCL-DENOTATIONAL-TERM-P"^^_string)))) .
\"urn:uuid:aaf76b78-392e-4cc4-9008-a9f35a422757"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLDenotationalTerm-Assertible', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:cabacef5-5b9a-4a04-a11c-9eb33cfc3b0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLDenotationalTerm-Assertible', CycLExpressionType)) .
\"urn:uuid:0bbc08d9-bced-4f62-95f0-d3ddf8ead8a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLDenotationalTerm-Assertible', 'CycLExpression-Assertible')) .
\"urn:uuid:92269302-df58-4594-a974-5aec4779f793"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLDenotationalTerm-Assertible', CycLDenotationalTerm)) .
\"urn:uuid:cf0cde18-cdf9-4cc8-94b5-52c2e1cc6091"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLExpression, CycLExpressionType)) .
\"urn:uuid:9fa4f91a-c09d-4e13-bf23-7045cc8d9a9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLExpression, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:dd314712-7df6-4c0e-92b5-29043cda087c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLExpression, Thing)) .
\"urn:uuid:4d81eb9b-6c5a-4fff-8b49-5bc74bdeec37"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLExpression, SubLSExpression)) .
\"urn:uuid:5552c02f-683c-4b57-827d-25caceed14b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLExpression, CycLTerm)) .
\"urn:uuid:5e1124be-463d-4145-9a6b-ef52dad36112"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLExpression, SubLSymbolFn(("CYCL-EXPRESSION?"^^_string)))) .
\"urn:uuid:b9bdc918-5254-437e-bcbc-50c5c7bdad83"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLExpression-Askable', CycLExpressionType)) .
\"urn:uuid:3ca7bd4c-e7e1-463f-a92c-97c96ca18f5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLExpression-Askable', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:1306b25e-8087-47af-a5f4-4241de857ddc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLExpression-Askable', CycLExpression)) .
\"urn:uuid:38aa5ad1-be55-46f5-bf93-307e9357a351"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLExpression-Askable', Thing)) .
\"urn:uuid:e598e843-73e2-4fd7-9aef-d246d922ecab"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLExpression-Askable', SubLSymbolFn(("CYCL-EXPRESSION-ASKABLE?"^^_string)))) .
\"urn:uuid:256d092c-5549-438d-9708-2362bc2cad04"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLExpression-Assertible', CycLExpressionType)) .
\"urn:uuid:81ad08ba-1168-4f56-841c-d75cebf71494"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLExpression-Assertible', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6faa321d-87e2-4559-bbe6-d477643dd440"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLExpression-Assertible', 'CycLExpression-Askable')) .
\"urn:uuid:71bc5db7-88cd-45a2-b1b3-a0c452a3171c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLExpression-Assertible', Thing)) .
\"urn:uuid:ebcae98f-5bc5-4364-9319-76a6c2ebe04e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLExpression-Assertible', SubLSymbolFn(("CYCL-EXPRESSION-ASSERTIBLE?"^^_string)))) .
\"urn:uuid:efc5c8fe-38ac-4818-90ed-defb723e49e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLExpressionType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4365e71b-4f47-4492-af26-6fffba89df1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLExpressionType, SubLExpressionType)) .
\"urn:uuid:63a9e508-211c-4aff-9d9d-026356440c06"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLFormula, CycLExpressionType)) .
\"urn:uuid:5c75a0e8-2411-4fe0-88ff-3e6255cc8ad1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLFormula, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:07cae7e8-3e1d-469c-82dd-af3c50929591"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLFormula, CycLExpression)) .
\"urn:uuid:1599e18d-f029-49ce-93f4-2b2138cdfdda"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLFormula, CycLTerm)) .
\"urn:uuid:5081258b-b8dc-4972-9213-81cbed33eaa6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLFormula, SubLSymbolFn(("CYCL-FORMULA?"^^_string)))) .
\"urn:uuid:01084ca2-a717-443f-a765-dd0f49c5738a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLFormulaicSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:096e8ab1-83ce-4255-a21b-c34010702cd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLFormulaicSentence, CycLExpressionType)) .
\"urn:uuid:be13cbd8-69dc-4e5f-a18f-527286e8271b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLFormulaicSentence, CycLSentence)) .
\"urn:uuid:722642a4-b265-407c-9620-7433d51f178b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLFormulaicSentence, CycLFormula)) .
\"urn:uuid:e73006e3-00cb-4faa-b299-8c54e8249ad8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLGAFAssertion, CycLExpressionType)) .
\"urn:uuid:a12f2d77-d49c-4724-aa94-e5e471493e2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLGAFAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:baefbf05-c7cb-442e-a3a5-5cf6d6d17a37"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLGAFAssertion, CycLClosedAtomicSentence)) .
\"urn:uuid:f0f5b29a-378a-47e8-8bb7-05c4a44e1968"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLGAFAssertion, CycLAtomicAssertion)) .
\"urn:uuid:a85ce8ba-f2b2-477f-a420-a4479729f433"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLGAFAssertion, CycLAssertion)) .
\"urn:uuid:a9194526-513d-4f9c-8cc2-46131482c673"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLGAFAssertion, SubLSymbolFn(("CYCL-GAF-ASSERTION?"^^_string)))) .
\"urn:uuid:f7b26833-461d-4ba6-9ab9-55b5077e2eb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLGenericRelationFormula, CycLExpressionType)) .
\"urn:uuid:b0518288-d274-4d54-ab51-4efeb2687d05"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLGenericRelationFormula, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:cafac0a3-0694-4fee-b28e-d04245a8f7f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLGenericRelationFormula, CycLFormula)) .
\"urn:uuid:bc136eda-5331-4900-ac82-966c58d67cd2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLGenericRelationFormula, Thing)) .
\"urn:uuid:d8cacb70-1bf7-474a-a3a5-bddabb2b7825"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLGenericRelationFormula, SubLSymbolFn(("CYCL-UNBOUND-RELATION-FORMULA-P"^^_string)))) .
\"urn:uuid:9c5c485e-9840-42e0-887d-1f7788921c42"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLIndexedTerm, CycLExpressionType)) .
\"urn:uuid:427826ab-2587-4141-9f13-7f5a7fa2340c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLIndexedTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4229c032-b67e-4273-94e1-c380533e8f4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLIndexedTerm, CycLClosedExpression)) .
\"urn:uuid:76efb074-63de-49cd-80cf-bbd231aa398e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLIndexedTerm, SubLSymbolFn(("CYCL-INDEXED-TERM?"^^_string)))) .
\"urn:uuid:c80705f1-9328-41be-8c47-385116e2bf2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLNonAtomicReifiedTerm, CycLExpressionType)) .
\"urn:uuid:2a9b2d18-63fb-46d0-9baf-dbe871c61929"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLNonAtomicReifiedTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:a39d3f01-7856-45f1-9fe1-12f77f485541"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicReifiedTerm, CycLClosedNonAtomicTerm)) .
\"urn:uuid:2c3afd1d-a76b-40d8-ab11-81c9aba00ab6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicReifiedTerm, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:c700a898-0966-4262-9999-966099d10aad"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicReifiedTerm, CycKBDatastructure)) .
\"urn:uuid:ea4c8953-cd58-4e50-b1b1-50092a35741b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicReifiedTerm, CycLReifiedDenotationalTerm)) .
\"urn:uuid:3f6de188-6caa-4a80-8aba-66c78b381371"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLNonAtomicReifiedTerm, SubLSymbolFn(("CYCL-NON-ATOMIC-REIFIED-TERM?"^^_string)))) .
\"urn:uuid:383771dc-f774-44fe-a4a7-a711627ca469"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLNonAtomicTerm, CycLExpressionType)) .
\"urn:uuid:e4b10384-9b3c-4d9a-92a6-83a215160514"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLNonAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6440f68a-ad8a-400a-a8df-82455632906f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicTerm, CycLRepresentedTerm)) .
\"urn:uuid:848d69ef-b0f1-4393-ac7c-c9aac52bc7ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicTerm, CycLFormula)) .
\"urn:uuid:cb0db9ad-d6e3-45e5-b76f-5cec19302cd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLNonAtomicTerm, CycLDenotationalTerm)) .
\"urn:uuid:c674334c-9eb2-490f-83fc-af10c4d0d0a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLNonAtomicTerm, SubLSymbolFn(("CYCL-NON-ATOMIC-TERM?"^^_string)))) .
\"urn:uuid:e1cb2002-a5e4-4ce3-a529-91fda9212ed5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-Askable', CycLExpressionType)) .
\"urn:uuid:85dccd95-9c59-4ce5-b8bd-544d067d78e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-Askable', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:17214b80-cf14-431b-8bf4-fe0165d32b37"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Askable', 'CycLExpression-Askable')) .
\"urn:uuid:be0fcf70-e49e-4a10-b467-85bfb92dd105"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Askable', CycLNonAtomicTerm)) .
\"urn:uuid:d47fba25-2306-42de-98b9-ce0ca9ca7c40"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Askable', Thing)) .
\"urn:uuid:632cdd70-f775-4790-b44f-8b1889725c48"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLNonAtomicTerm-Askable', SubLSymbolFn(("CYCL-NON-ATOMIC-TERM-ASKABLE?"^^_string)))) .
\"urn:uuid:fdbd22d8-2778-47d4-bd30-b90b5d8d17f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-Assertible', CycLExpressionType)) .
\"urn:uuid:016cea1c-04b5-45cb-82b3-1e2cb493b9d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-Assertible', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5c9b9348-42dc-48cb-a588-b8ed24578c77"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Assertible', 'CycLNonAtomicTerm-Askable')) .
\"urn:uuid:faed5d6a-e8df-4144-a267-b4d223e10a69"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Assertible', 'CycLExpression-Assertible')) .
\"urn:uuid:ee762967-223d-45ef-a28e-256c138e5da3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Assertible', Thing)) .
\"urn:uuid:e305a743-a995-4569-a1de-3caab5877d1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-Assertible', 'CycLDenotationalTerm-Assertible')) .
\"urn:uuid:3a194b28-14c8-43ca-b782-610eab00ac4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLNonAtomicTerm-Assertible', SubLSymbolFn(("CYCL-NON-ATOMIC-TERM-ASSERTIBLE?"^^_string)))) .
\"urn:uuid:4dbf292b-1875-4b59-88bc-d0eb16537282"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-ClosedFunctor', Collection)) .
\"urn:uuid:817b7d90-5455-4ee8-8e13-04f91febff86"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLNonAtomicTerm-ClosedFunctor', CycLExpressionType)) .
\"urn:uuid:e0ce00a5-b132-45e9-8d4d-bf06db1d66d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-ClosedFunctor', CycLNonAtomicTerm)) .
\"urn:uuid:c19be72e-f8d6-4da1-b936-830b8604aff8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLNonAtomicTerm-ClosedFunctor', Thing)) .
\"urn:uuid:c7d7cae4-408f-45aa-8875-34859c37f2d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenDenotationalTerm, CycLExpressionType)) .
\"urn:uuid:c1747d34-7582-495b-84fb-9c00bdd3ca65"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenDenotationalTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:418078ae-ca41-417c-a69a-20c31c465d39"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenDenotationalTerm, CycLDenotationalTerm)) .
\"urn:uuid:7cbcd756-cd23-4c9e-aab4-2c4b4b6cd2b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenDenotationalTerm, CycLOpenExpression)) .
\"urn:uuid:ff9d1c45-3b1e-4e4d-b4f4-9e633b47ad78"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLOpenDenotationalTerm, SubLSymbolFn(("CYCL-OPEN-DENOTATIONAL-TERM?"^^_string)))) .
\"urn:uuid:0f02b066-6d1c-434a-8308-21b2d3e7cbc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenExpression, CycLExpressionType)) .
\"urn:uuid:e301a5d4-4367-4c0a-86fa-68bad6e87e99"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenExpression, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:2f0c4692-ac2f-4546-8983-43864cd6fd8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenExpression, CycLExpression)) .
\"urn:uuid:636f87b9-94cf-47a7-8b63-7a4875db6340"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenExpression, CycLTerm)) .
\"urn:uuid:c22f09c8-a7a0-467b-ba12-99d75966c21a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLOpenExpression, SubLSymbolFn(("CYCL-OPEN-EXPRESSION?"^^_string)))) .
\"urn:uuid:95b39a30-e43d-41f3-8bac-1f9af8c17df3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenFormula, CycLExpressionType)) .
\"urn:uuid:5a40c5e8-c0ac-4612-919c-2b9ee82afb4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenFormula, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:85dfe42f-f64c-4943-afd0-41cd37dfc8ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenFormula, CycLOpenExpression)) .
\"urn:uuid:becd35ae-8d55-4145-9d02-2c84664f8b8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenFormula, Thing)) .
\"urn:uuid:014ddd27-1ae0-454b-ad85-6235c39d5ba8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenFormula, CycLFormula)) .
\"urn:uuid:23713c99-9bb9-4e37-8701-4238a4137a8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLOpenFormula, SubLSymbolFn(("CYCL-OPEN-FORMULA?"^^_string)))) .
\"urn:uuid:9e923e8e-5ef2-4e84-9257-e0edb8e9380c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenNonAtomicTerm, CycLExpressionType)) .
\"urn:uuid:07070bd6-fdad-41a1-b483-91f9f329c6fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenNonAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:595d3c2e-5dc5-42fb-a3e2-7f766e979d81"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenNonAtomicTerm, CycLOpenFormula)) .
\"urn:uuid:dbf27a44-907d-4c9b-9bd8-802ae75a6eb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenNonAtomicTerm, CycLNonAtomicTerm)) .
\"urn:uuid:e71f3300-4f3c-4093-a5dc-0404ad51ac77"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenNonAtomicTerm, Thing)) .
\"urn:uuid:9498edc8-8b1e-469b-b0a4-4da8fc634aaf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenNonAtomicTerm, CycLOpenDenotationalTerm)) .
\"urn:uuid:67e414b5-49e6-40fc-91df-f19e430287a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLOpenNonAtomicTerm, SubLSymbolFn(("CYCL-OPEN-NON-ATOMIC-TERM?"^^_string)))) .
\"urn:uuid:42952bd8-b740-4092-9bb2-ccd18ad1ff61"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenSentence, CycLExpressionType)) .
\"urn:uuid:822371c1-1ec0-48bb-894f-5113f2a7d1f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLOpenSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f26f95eb-2a3e-4ae1-a1eb-3b2ef92ef461"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenSentence, CycLSentence)) .
\"urn:uuid:74ae8662-8ed0-4097-a50e-867d56a9af55"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenSentence, CycLOpenFormula)) .
\"urn:uuid:081d3d82-6d1b-4adf-9e98-8fa144980c83"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenSentence, CycLFormulaicSentence)) .
\"urn:uuid:8d6398aa-c56c-49b0-8c0a-9c183a02f5da"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLOpenSentence, CycLOpenExpression)) .
\"urn:uuid:03112a87-ae0a-40b5-9118-8fdc3c4495ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLOpenSentence, SubLSymbolFn(("CYCL-OPEN-SENTENCE?"^^_string)))) .
\"urn:uuid:75b5d84c-6620-4c2e-9728-82b62433e0d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLPropositionalSentence, CycLExpressionType)) .
\"urn:uuid:00b9def5-18a0-49c9-b608-5e555973eb8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLPropositionalSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:09f6b011-08ce-4fc4-84c0-49780bfdabc0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLPropositionalSentence, CycLClosedSentence)) .
\"urn:uuid:c90a5744-2837-4673-aec8-8f252d39ed13"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLPropositionalSentence, 'CycLSentence-Askable')) .
\"urn:uuid:831edd71-0221-4046-9594-dc0d11810ac8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLPropositionalSentence, SubLSymbolFn(("CYCL-PROPOSITIONAL-SENTENCE?"^^_string)))) .
\"urn:uuid:202aed03-bcd3-4d3a-bdf9-84ed39800cae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReformulationRulePredicate, Collection)) .
\"urn:uuid:7e007fee-2e4f-4e6c-8595-64dbe0b9b82f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReformulationRulePredicate, Predicate)) .
\"urn:uuid:740fcb4b-ed46-4e8a-a393-32d2f2c16b99"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiableDenotationalTerm, CycLExpressionType)) .
\"urn:uuid:02bef75d-b47d-41f0-b4c2-f19e5104d622"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiableDenotationalTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4d4e7412-110b-404a-af6e-95ce4fb9c8f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableDenotationalTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:b16c650e-532a-4faf-b1f0-e319432c0121"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableDenotationalTerm, CycLIndexedTerm)) .
\"urn:uuid:fda7d36b-8334-4b09-9a8d-6ac06c0b9ada"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLReifiableDenotationalTerm, SubLSymbolFn(("CYCL-REIFIABLE-DENOTATIONAL-TERM?"^^_string)))) .
\"urn:uuid:08e210e3-8b16-4e94-915b-3a5ade3f0c4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiableNonAtomicTerm, CycLExpressionType)) .
\"urn:uuid:b4f5f2a2-fe8e-418d-9654-810f7f920361"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiableNonAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8f8d3c32-b764-4e31-bc69-b81a77d7c49c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableNonAtomicTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:45bd8a87-709b-41eb-93b8-19631062ca64"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableNonAtomicTerm, CycLExpression)) .
\"urn:uuid:531387ae-c0f0-4cc3-b3a1-db97f508a2a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableNonAtomicTerm, CycLIndexedTerm)) .
\"urn:uuid:9c1255b7-eff9-4145-87fc-31653bd8aef6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableNonAtomicTerm, CycLNonAtomicTerm)) .
\"urn:uuid:c353ea1b-c675-4fd7-9399-14318504f64b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiableNonAtomicTerm, CycLClosedNonAtomicTerm)) .
\"urn:uuid:f1963eae-f424-4641-8e3d-253211e881de"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLReifiableNonAtomicTerm, SubLSymbolFn(("CYCL-REIFIABLE-NON-ATOMIC-TERM?"^^_string)))) .
\"urn:uuid:fe34e62a-3e6b-4817-8288-e6f409260e9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiedDenotationalTerm, CycLExpressionType)) .
\"urn:uuid:b0f23c90-138c-427b-b0e0-19862625f423"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLReifiedDenotationalTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7fbc084b-a0da-4493-a7b4-a56898ffba69"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiedDenotationalTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:812f9843-795a-4a53-a880-f375e9483244"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLReifiedDenotationalTerm, Thing)) .
\"urn:uuid:4f50f642-3a42-4422-8c2a-74d4c46982a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLReifiedDenotationalTerm, SubLSymbolFn(("CYCL-REIFIED-DENOTATIONAL-TERM?"^^_string)))) .
\"urn:uuid:7cfecb8f-4db5-40ac-9c33-8a81b6bb8869"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRepresentedAtomicTerm, CycLExpressionType)) .
\"urn:uuid:7a2dd181-de56-4e43-b39f-e25fb00f8615"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRepresentedAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f8e0c6b3-d14a-425a-9938-858e3a9e8392"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLRepresentedAtomicTerm, CycLAtomicTerm)) .
\"urn:uuid:618c3a1b-0658-4f1b-8ded-01baf5fc1ca0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLRepresentedAtomicTerm, CycLRepresentedTerm)) .
\"urn:uuid:3050c574-2ff8-45a5-aba4-f45adc693405"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLRepresentedAtomicTerm, SubLSymbolFn(("CYCL-REPRESENTED-ATOMIC-TERM-P"^^_string)))) .
\"urn:uuid:8fa7e71e-05ef-417b-976a-a2e6459f3b8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRepresentedTerm, CycLExpressionType)) .
\"urn:uuid:df083e1e-32e8-4d39-82da-1623bd522113"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRepresentedTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f050cb11-3f19-4728-8087-bd34637bdcbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLRepresentedTerm, CycLDenotationalTerm)) .
\"urn:uuid:0e3381db-2390-4d2b-8087-70c530af5b99"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLRepresentedTerm, SubLSymbolFn(("CYCL-REPRESENTED-TERM?"^^_string)))) .
\"urn:uuid:baf1ebb3-f6dc-49ae-ac6b-f02043a66298"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRuleAssertion, CycLExpressionType)) .
\"urn:uuid:19da68da-da51-47b8-9ab7-da4166d3e3ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLRuleAssertion, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7d99db9c-1fe0-4ce4-87f5-ef65ec7b1652"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLRuleAssertion, CycLAssertion)) .
\"urn:uuid:51b636d4-a2a7-4953-a452-7f50b37f8ae1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLRuleAssertion, SubLSymbolFn(("CYCL-RULE-ASSERTION?"^^_string)))) .
\"urn:uuid:53d68185-724b-4b82-b939-8ae36431f5b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLSentence, CycLExpressionType)) .
\"urn:uuid:41c6caf7-3727-4b8f-8179-ba1ffc49d549"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4aa3b007-8535-41ac-b147-d47f15962969"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLSentence, CycLTerm)) .
\"urn:uuid:54ba689d-c91a-4e11-bf69-053945abc8f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLSentence, SubLSymbolFn(("CYCL-SENTENCE?"^^_string)))) .
\"urn:uuid:ccf0e354-4044-4ee8-9169-5368f6b7bb43"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-Askable', CycLExpressionType)) .
\"urn:uuid:39091547-a352-4e3d-b2ae-a9b87f4c7cda"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-Askable', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b94bcceb-fee9-41ff-ba92-a38b090df7db"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLSentence-Askable', 'CycLExpression-Askable')) .
\"urn:uuid:fa5eb686-73be-418d-90c3-cc9719651ab4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLSentence-Askable', CycLSentence)) .
\"urn:uuid:8acbf5f0-e749-4944-8204-47423acefa50"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLSentence-Askable', SubLSymbolFn(("CYCL-SENTENCE-ASKABLE?"^^_string)))) .
\"urn:uuid:f103a7b6-ef1f-4884-b0eb-ef55686d5cc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-Assertible', CycLExpressionType)) .
\"urn:uuid:995154be-2d6e-4dbf-8e4b-762cb4ea55a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-Assertible', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d708f926-5166-4937-9342-45119c739c9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLSentence-Assertible', 'CycLExpression-Assertible')) .
\"urn:uuid:b3bdf3e7-fb9d-4b71-9c2f-aeda61c902d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLSentence-Assertible', 'CycLSentence-Askable')) .
\"urn:uuid:e174a075-1e2b-447d-9d98-43a939978a27"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff('CycLSentence-Assertible', SubLSymbolFn(("CYCL-SENTENCE-ASSERTIBLE?"^^_string)))) .
\"urn:uuid:b11d11bd-046c-4a7a-bd42-67994b52f5f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-ClosedPredicate', Collection)) .
\"urn:uuid:a21c9266-3696-4416-b36f-3a20ddb9f2aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycLSentence-ClosedPredicate', CycLExpressionType)) .
\"urn:uuid:834de484-3456-4635-bd1b-6fc4e72ce055"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycLSentence-ClosedPredicate', CycLSentence)) .
\"urn:uuid:cc804a7f-c01e-46ad-aac7-bda2b22c6964"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:e407c841-f2ef-47df-b633-bb874d416e5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLTerm, CycLExpressionType)) .
\"urn:uuid:3c0c42d7-5cd1-453a-869e-5745856da8db"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLTerm, CycLExpression)) .
\"urn:uuid:6c7ce249-cd5f-4b1b-92f8-73db92e606e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLTerm, SubLSymbolFn(("CYCL-EXPRESSION?"^^_string)))) .
\"urn:uuid:56796f32-5771-4d0e-8597-16266df536f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLTruthValueSentence, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:be7f71a0-2378-428a-978a-b09acab27dad"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLTruthValueSentence, CycLExpressionType)) .
\"urn:uuid:fb3f8f38-6da6-4541-b742-a85163252230"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLTruthValueSentence, CycLConstant)) .
\"urn:uuid:7ea8f307-475a-40a7-89eb-1994ed9681bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLTruthValueSentence, CycLClosedSentence)) .
\"urn:uuid:7943a861-1ef8-411b-8647-614b59c62982"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLVariable, CycLExpressionType)) .
\"urn:uuid:abac4d14-c035-475c-ad20-f3379b7a6613"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycLVariable, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:fe27b1a3-f537-44fe-9d6f-cd850f9f2ba6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLVariable, CycLOpenDenotationalTerm)) .
\"urn:uuid:19d0bedc-8ef4-4dcf-b00c-f29ce3e793d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLVariable, CycLAtomicTerm)) .
\"urn:uuid:8c1ac051-a3cb-4211-919a-dd448383d58b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycLVariable, CycLRepresentedAtomicTerm)) .
\"urn:uuid:bf762a3f-119f-4a6b-99dc-f8b250958b59"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(CycLVariable, SubLSymbolFn(("CYCL-VARIABLE-P"^^_string)))) .
\"urn:uuid:240df538-3f80-4a55-98d5-c7cc32c5e249"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblem, Collection)) .
\"urn:uuid:190d1649-e2b7-4f65-b7b6-bf8aeaca6575"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycProblem, CycInferenceDataStructure)) .
\"urn:uuid:f1dd0dad-51c8-4e43-bf18-a5d5d414b39b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemFn, BinaryFunction)) .
\"urn:uuid:27a776a7-e0bb-4cf9-8623-6007368a8691"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemFn, UnreifiableFunction)) .
\"urn:uuid:db780a35-858a-435c-81f0-9b8a97fe66fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycProblemFn, NonNegativeInteger)) .
\"urn:uuid:bea98a00-4215-49cb-9132-88a75fc6adcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(CycProblemFn, CycProblemStore)) .
\"urn:uuid:ce052f70-cc44-4ea7-a655-4c41f46d863b"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycProblemFn, CycProblem)) .
\"urn:uuid:c56b33ff-7b5b-418f-a5d8-f101b20a19bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycProblemFn, (2))) .
\"urn:uuid:726a2737-cbcc-406d-a8e8-4512eda5cfa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemLink, Collection)) .
\"urn:uuid:f684d359-403a-4d2c-a25b-71f739c355c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycProblemLink, CycInferenceDataStructure)) .
\"urn:uuid:74729a83-d2ed-462f-bd42-5ec26567246e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-AnswerLink', Collection)) .
\"urn:uuid:2f535136-2e66-4113-ade2-3806b0021df9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-AnswerLink', 'CycProblemLink-Structural')) .
\"urn:uuid:65be0cd3-3d2e-4d0b-ab05-c8cd393bd408"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Conjunctive', Collection)) .
\"urn:uuid:9a6d7db8-bf83-48ba-9bb8-e167b51dd76c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Conjunctive', 'CycProblemLink-Logical')) .
\"urn:uuid:d9374a2d-0fe5-4251-84c5-e51141556040"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Content', Collection)) .
\"urn:uuid:6b59844d-65d5-4581-9697-ecf295cfb511"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Content', CycProblemLink)) .
\"urn:uuid:25d62358-4b00-4047-a892-87ae2d1bd788"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Disjunctive', Collection)) .
\"urn:uuid:3c554502-7055-424b-984e-d4129beb603d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Disjunctive', 'CycProblemLink-Logical')) .
\"urn:uuid:8ee3ad17-f800-4be2-aae2-a753e61ac73e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Join', Collection)) .
\"urn:uuid:98d40864-e1f3-444a-8b2b-782355889889"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Join', 'CycProblemLink-Conjunctive')) .
\"urn:uuid:f2aeedd0-7a1c-4478-9840-6a5c52d23d82"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-JoinOrdered', Collection)) .
\"urn:uuid:bd871396-c5d4-49c1-88fb-8b99581af016"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-JoinOrdered', 'CycProblemLink-Conjunctive')) .
\"urn:uuid:fb52c19c-ba4c-4b8c-a28a-2420bc123a50"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Logical', Collection)) .
\"urn:uuid:acd4a905-7f51-4f06-ad8c-769b09768ddf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Logical', 'CycProblemLink-Structural')) .
\"urn:uuid:0cb702b1-85b7-4dea-b227-8c23233ab834"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Removal', Collection)) .
\"urn:uuid:b5959b1f-b66a-41b6-96f8-314598f79d2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Removal', 'CycProblemLink-Content')) .
\"urn:uuid:faa2647b-94c2-42e3-8532-81324677b3f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Restriction', Collection)) .
\"urn:uuid:7e7d523d-9863-4e0b-9dd1-ceef09dc2fd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Restriction', 'CycProblemLink-Structural')) .
\"urn:uuid:f960767c-d48b-4d08-bdff-6eb99082f3b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Split', Collection)) .
\"urn:uuid:8d9c75d1-9622-4b31-9d0f-ca502a74fe58"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Split', 'CycProblemLink-Conjunctive')) .
\"urn:uuid:6c9b1fd4-0677-421c-8e04-c2a5f52dcfb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Structural', Collection)) .
\"urn:uuid:5418cec2-783c-4655-9456-47a61728270f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Structural', CycProblemLink)) .
\"urn:uuid:7a4f29da-b603-4d67-b5c6-da1906b8968e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Transformation', Collection)) .
\"urn:uuid:edc6bd8e-31ea-4068-9104-b48ecf81a5f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Transformation', Individual)) .
\"urn:uuid:b2515c96-3141-4fa5-a4f0-2e69e8a1a9b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('CycProblemLink-Union', Collection)) .
\"urn:uuid:35ef2946-39b2-420a-b12d-fd26ede9da59"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('CycProblemLink-Union', 'CycProblemLink-Disjunctive')) .
\"urn:uuid:eeb78c9a-d6cb-41dd-ae55-04bf2ffcb012"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemLinkFn, BinaryFunction)) .
\"urn:uuid:d6551e7b-0202-4c2b-b7b1-91f8f04628aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemLinkFn, UnreifiableFunction)) .
\"urn:uuid:41ecba03-ae80-4db2-b2f3-7bbe84e2555f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycProblemLinkFn, NonNegativeInteger)) .
\"urn:uuid:89a9b82b-895b-4825-b3a9-15d35257b24e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(CycProblemLinkFn, CycProblemStore)) .
\"urn:uuid:1b000ae2-7217-4f1f-b7d0-eeae1df0ccfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycProblemLinkFn, CycProblemLink)) .
\"urn:uuid:767d2ae2-ae0f-45bf-acf6-394a56974c07"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycProblemLinkFn, (2))) .
\"urn:uuid:181251e0-0120-468b-92f9-a3cd182afc59"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemStore, Collection)) .
\"urn:uuid:afe9d144-8cf9-4d85-8023-f6cca637575d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycProblemStore, CycInferenceDataStructure)) .
\"urn:uuid:57a8f6c2-87c7-490b-9343-d35258e3ffa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemStoreFn, UnaryFunction)) .
\"urn:uuid:3da9d52d-7626-460e-93a1-beb10335c49c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProblemStoreFn, UnreifiableFunction)) .
\"urn:uuid:49c14d38-5650-4385-b331-ca5a1e708a52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycProblemStoreFn, NonNegativeInteger)) .
\"urn:uuid:ac6101ab-84b9-42fe-8a72-d96ace54e29e"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycProblemStoreFn, CycProblemStore)) .
\"urn:uuid:baf236b2-69d2-4dd3-ab72-4293b82f7fdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycProblemStoreFn, (1))) .
\"urn:uuid:0300d4f7-313d-4846-a687-515154791df7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProof, Collection)) .
\"urn:uuid:6cee0848-2673-4964-aba1-7f5ebb0f282c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycProof, CycInferenceDataStructure)) .
\"urn:uuid:9c1d8a28-aee1-4533-96a9-ceeebf63722e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProofFn, BinaryFunction)) .
\"urn:uuid:c616fd4d-1165-418b-ba05-85cfa0231888"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProofFn, UnreifiableFunction)) .
\"urn:uuid:cf016b8c-d4e2-4c13-9507-5351463bd205"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycProofFn, NonNegativeInteger)) .
\"urn:uuid:d38ccecf-2ca7-4834-acb8-69153f6dc763"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(CycProofFn, CycProblemStore)) .
\"urn:uuid:d4fc732b-6536-4029-b3fc-265f5919e11d"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycProofFn, CycProof)) .
\"urn:uuid:e2174962-f391-4d22-a1b9-be59f2c64bdc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycProofFn, (2))) .
\"urn:uuid:6048aa59-a3e7-48a1-b0a7-1d3701430393"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycProvabilityStatus, Collection)) .
\"urn:uuid:c06ff38b-c363-4de1-966b-ecc2e34b1b83"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycProvabilityStatus, CycInferenceDataStructure)) .
\"urn:uuid:3349c828-4542-4590-890e-a1e4fc0bf031"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycSupportDatastructure, Collection)) .
\"urn:uuid:64bb5b4d-8c11-4e84-847a-9870d0116ac4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycSupportDatastructure, CycInferenceDataStructure)) .
\"urn:uuid:31792840-3787-4bff-bfaf-f163848fac5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycTactic, Collection)) .
\"urn:uuid:36c973ed-f020-4882-b9c6-4bcbb86b15d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycTactic, CycInferenceDataStructure)) .
\"urn:uuid:f4657d7e-8bb9-43c8-8612-ded1d55ee51d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycTacticFn, UnreifiableFunction)) .
\"urn:uuid:af67fb21-96a2-413d-98d7-3112f01de7b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycTacticFn, BinaryFunction)) .
\"urn:uuid:714196a6-9d20-4355-9707-940cf50ff7c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(CycTacticFn, NonNegativeInteger)) .
\"urn:uuid:a2d5b40c-0d9f-47d3-b387-f8cb7470949e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(CycTacticFn, CycTactic)) .
\"urn:uuid:6b793d8a-d4af-4cb8-a3a3-e8a28a2e9381"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(CycTacticFn, CycTactic)) .
\"urn:uuid:aa518d5c-7f73-44af-b40a-ad54dcb30178"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(CycTacticFn, (2))) .
\"urn:uuid:44f36abe-ae19-4c28-8f55-5fe48109fc10"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CycTransformationProof, Collection)) .
\"urn:uuid:3afe325b-c2f0-4f9e-8e55-09f9a31eee14"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(CycTransformationProof, CycProof)) .
\"urn:uuid:dfb26300-b336-4ceb-83af-8a54377b63b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Cyclist, Collection)) .
\"urn:uuid:45b59cd0-df7e-4a06-9aac-5c8ebeef04fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Cyclist, Individual)) .
\"urn:uuid:a056f239-5a9f-4bf1-b1ae-d9ab45dd561a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CyclistDefinitionalMt, Microtheory)) .
\"urn:uuid:a27124fc-d14c-45a5-b4a0-d4c1bf75cf6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CyclistDefinitionalMt, BaseKB)) .
\"urn:uuid:ae04340c-877d-454e-91de-5d3622e64935"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DateDecodeStringFn, EvaluatableFunction)) .
\"urn:uuid:a3496f70-b36f-4fb5-9261-54c0e1e52e38"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DateDecodeStringFn, BinaryFunction)) .
\"urn:uuid:15d7f8df-9624-448b-92fa-8ecbef3f34c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(DateDecodeStringFn, CharacterString)) .
\"urn:uuid:0c43410a-a421-4a56-b638-ea63bd3e5417"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(DateDecodeStringFn, CharacterString)) .
\"urn:uuid:439b4677-1e08-417b-b097-e680e33fc749"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(DateDecodeStringFn, Individual)) .
\"urn:uuid:e20d2dff-513d-4df3-bcc0-95a5dc8d2564"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(DateDecodeStringFn, (2))) .
\"urn:uuid:2afd8dff-00fc-425d-9ebd-1accfd96de94"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DateEncodeStringFn, EvaluatableFunction)) .
\"urn:uuid:c318b478-1f24-4e2e-b27d-999404d5a543"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DateEncodeStringFn, BinaryFunction)) .
\"urn:uuid:6c62962b-0aa1-4090-8b30-59dd2d32a061"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(DateEncodeStringFn, CharacterString)) .
\"urn:uuid:df69c4d9-2755-487f-a253-ea1ce45ca966"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(DateEncodeStringFn, Individual)) .
\"urn:uuid:016ac337-1c8e-40a5-9baa-b10439dd6845"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(DateEncodeStringFn, CharacterString)) .
\"urn:uuid:cc58ac1d-b454-4cab-bfb4-bbe909a78878"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(DateEncodeStringFn, (2))) .
\"urn:uuid:80b882ed-6a94-432b-a09c-9e7711866bfb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DayOfWeekType, SiblingDisjointCollectionType)) .
\"urn:uuid:039af0c4-7d9b-4cb0-9a91-9ebe5d4bdf53"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DayOfWeekType, Collection)) .
\"urn:uuid:6adff7df-03e1-4f8a-8a96-a9362ad8de4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(December, MonthOfYearType)) .
\"urn:uuid:7a5a3fbc-c413-49f4-9899-6ca82422bd42"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(December, Individual)) .
\"urn:uuid:c7fa7137-c6ff-48ba-9e45-68d91f0c5691"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DefaultFalse, Individual)) .
\"urn:uuid:90a029da-f6b9-400d-b643-0a17a3e7ae04"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DefaultFalse, CycHLTruthValue)) .
\"urn:uuid:6f9cb7ea-57ef-45b8-b14b-a49c3b62be23"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DefaultMonotonicPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:61623a84-f53b-453e-9b29-411301b90996"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DefaultMonotonicPredicate, Predicate)) .
\"urn:uuid:8578a3ad-7ab9-4c63-bec9-2adaf8b99062"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DefaultTrue, CycHLTruthValue)) .
\"urn:uuid:adf35115-3c5b-4344-9464-73c6efef3fc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DefaultTrue, Individual)) .
\"urn:uuid:35a8f248-79b2-4587-8ddf-cb074e751267"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DifferenceFn, BinaryFunction)) .
\"urn:uuid:5c2d7a31-2825-4e97-80e3-d18c1e0b8079"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DifferenceFn, EvaluatableFunction)) .
\"urn:uuid:d224bd69-4002-405e-b73b-7ad5516cfe52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(DifferenceFn, ScalarInterval)) .
\"urn:uuid:6acdc078-b4a8-4146-81ac-dcde7f1155a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(DifferenceFn, ScalarInterval)) .
\"urn:uuid:61ff9d08-7f5c-4a88-ae1c-a34b92cf679c"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(DifferenceFn, ScalarInterval)) .
\"urn:uuid:e1902bd8-4d6d-4a92-9fdb-b84e65d67e5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(DifferenceFn, (2))) .
\"urn:uuid:47cdb7f6-c53f-4b69-8c84-faa9968344ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DirectedMultigraph, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b0f967e9-67e0-47de-8385-5a6b2a86d9f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DirectedMultigraph, Multigraph)) .
\"urn:uuid:6c8ff4eb-fa46-4b61-9d9f-4f7f9477b14b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DisjointCollectionType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7779a4e4-efca-4bda-9470-b7fc00c3430d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DisjointCollectionType, SiblingDisjointCollectionType)) .
\"urn:uuid:da2f0371-5b63-4657-b7cc-e7ccabdd2f28"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DistributingMetaKnowledgePredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0d6dae19-09f7-4308-8075-4fd5e862ef33"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DistributingMetaKnowledgePredicate, Predicate)) .
\"urn:uuid:9eaff40f-2352-41b9-8eb5-a60b8e5a3242"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DocumentationConstant, CycLExpressionType)) .
\"urn:uuid:9667e678-dabe-4418-94f9-13d7b3ad8751"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DocumentationConstant, CycLConstant)) .
\"urn:uuid:0c65c7fa-e64f-4fbe-878e-fe17d375d3ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(DocumentationPredicate, Collection)) .
\"urn:uuid:071477c2-e8ba-467b-9aa6-fd7e6527fb01"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(DocumentationPredicate, DocumentationConstant)) .
\"urn:uuid:07b23922-3267-4b6c-bb2e-62f368240486"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(DocumentationPredicate, Predicate)) .
\"urn:uuid:a92e9636-b787-46dd-95d2-43bb6280f691"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ELRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7f3bd7eb-8fec-46a6-afcd-09f88c6c9bd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ELRelation, Relation)) .
\"urn:uuid:9f8907fe-d266-447f-9018-bb98c8031da9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('ELRelation-OneWay', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5da00d93-116c-4050-b41e-80169e32233c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('ELRelation-OneWay', ELRelation)) .
\"urn:uuid:e90ad4c9-188f-48be-8e43-0a16aa4d50eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('ELRelation-Reversible', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:63aeca40-c9ed-4c47-8601-9cc5d82891fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('ELRelation-Reversible', ELRelation)) .
\"urn:uuid:332ee3f5-af85-4c4d-8d16-df5707329b01"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EnglishParaphraseMt, Microtheory)) .
\"urn:uuid:d9b774c8-4b3e-46f6-acfa-6993c6754b3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(EnglishParaphraseMt, 'CurrentWorldDataCollectorMt-NonHomocentric')) .
\"urn:uuid:2714de01-f766-4e84-b645-bf08d3c28245"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EscapeQuote, UnaryFunction)) .
\"urn:uuid:f90fb15e-5f8a-4914-9a56-c9def0e26c9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EscapeQuote, UnreifiableFunction)) .
\"urn:uuid:10303a58-41b1-4629-8088-e05b73786bdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EscapeQuote, WFFSupportedTerm)) .
\"urn:uuid:bc635dca-2743-4c20-84cd-1e52ea80ec05"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(EscapeQuote, InferenceSupportedTerm)) .
\"urn:uuid:7ce3f2ac-3665-4f54-8ea0-66cb870ca37e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(EscapeQuote, Thing)) .
\"urn:uuid:8ece1838-474d-4c6c-9792-620ee1f2014d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(EscapeQuote, CycLTerm)) .
\"urn:uuid:53eb203c-73c7-448d-81c9-466db17752b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(EscapeQuote, Thing)) .
\"urn:uuid:9261461a-d39f-4079-b277-fcbd632e0b4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(EscapeQuote, CycLTerm)) .
\"urn:uuid:7bd6993b-fe7f-4ab5-955d-33ae3af9369a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(EscapeQuote, (1))) .
\"urn:uuid:7b26e3cd-9808-48a7-9908-1593372d8356"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EvaluatableFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:7ad7023f-532f-4518-a399-c5cad859560c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatableFunction, 'Function-Denotational')) .
\"urn:uuid:0d1b01b8-4243-4685-a538-7ef709a44714"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatableFunction, UnreifiableFunction)) .
\"urn:uuid:a85098a2-87f5-44ef-bfd9-791176cb5d99"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatableFunction, EvaluatableRelation)) .
\"urn:uuid:13993985-f15c-4e27-bee8-c7a62d0af640"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EvaluatablePredicate, Collection)) .
\"urn:uuid:3680c5ad-a06c-4cb7-a7f4-d026024ec8e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatablePredicate, Predicate)) .
\"urn:uuid:0b7c1f2f-b0b9-42d1-8341-8a16f78b4a27"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatablePredicate, EvaluatableRelation)) .
\"urn:uuid:aa5af4d8-6806-47cc-bebc-f1b5d84d22f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EvaluatableRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:02c417a7-5afd-46f0-841d-663220901bc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(EvaluatableRelation, Relation)) .
\"urn:uuid:87174f6e-46b7-40d1-af01-aed37807cf00"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EvaluateSubLFn, EvaluatableFunction)) .
\"urn:uuid:94091755-de14-4d73-99bd-2c1ea4bd6321"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EvaluateSubLFn, UnaryFunction)) .
\"urn:uuid:08e4dd8f-ba30-4c09-8a5d-e76ce3bc3fbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(EvaluateSubLFn, CycLNonAtomicTerm)) .
\"urn:uuid:f8ee395c-80b2-4a49-bba6-0f83e4085449"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(EvaluateSubLFn, Thing)) .
\"urn:uuid:6040abb2-560a-4d86-baac-88f90789e810"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(EvaluateSubLFn, (1))) .
\"urn:uuid:54a6f3a4-a5e7-4f15-9bdc-e2dc73efc67e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(EverythingPSC, ProblemSolvingCntxt)) .
\"urn:uuid:5fc8e14a-5591-4934-9e2f-477044d9ccf0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(EverythingPSC, BaseKB)) .
\"urn:uuid:9387aca9-3f28-4eab-9af4-d5b807830c6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExceptionPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:01e87861-3e0d-4cf1-9c31-923cfb53b39f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ExceptionPredicate, Predicate)) .
\"urn:uuid:86e24046-4897-4465-a0bd-7354f126b5de"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExistentialQuantifier, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:67bb6443-4a55-438e-b9c9-5f57a73759b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ExistentialQuantifier, Quantifier)) .
\"urn:uuid:f9e19cce-ae97-477c-9fd9-3ddf2dfb43b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('ExistentialQuantifier-Bounded', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d209718e-a21f-4ddc-9e15-2bc3a37c08e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('ExistentialQuantifier-Bounded', ExistentialQuantifier)) .
\"urn:uuid:e8c2ee7a-4f8e-47f7-8fd0-e975827a9b12"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('ExistentialQuantifier-Bounded', TernaryRelation)) .
\"urn:uuid:87ff9a8d-0fd0-4842-ad39-beda541a4124"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExpFn, UnaryFunction)) .
\"urn:uuid:6eb4ac14-d99c-4d15-8999-772e3daa7ed8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExpFn, EvaluatableFunction)) .
\"urn:uuid:a9cdd679-7be7-48a8-bd07-d83bc41b0cc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ExpFn, ScalarPointValue)) .
\"urn:uuid:8f5be112-6aa3-4b59-935f-9060f0cfe4b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(ExpFn, ScalarPointValue)) .
\"urn:uuid:3fc65d4f-aa69-40ae-9c17-c6ce5d7e73a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ExpFn, (1))) .
\"urn:uuid:b90d4bd3-9cb5-48e8-a5e2-d98ebcdb928b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExpandSubLFn, UnreifiableFunction)) .
\"urn:uuid:7493fdc2-5cc9-4f0d-86d1-65117208ac24"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ExpandSubLFn, BinaryFunction)) .
\"urn:uuid:9b284bf6-84c9-469c-b30f-a58a8c8050e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(ExpandSubLFn, SubLList)) .
\"urn:uuid:43792187-d786-4e82-80cd-131f7d107490"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(ExpandSubLFn, SubLSExpression)) .
\"urn:uuid:8be8bee9-008d-4686-a59a-38ccded3dfb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ExpandSubLFn, (2))) .
\"urn:uuid:a22174b3-4cf5-4c5d-ae15-e25c522b574a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-FunctionFn', UnreifiableFunction)) .
\"urn:uuid:2d299bc4-2e25-44dd-8ab8-ada6251d3dba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-FunctionFn', BinaryFunction)) .
\"urn:uuid:82e1e398-49e5-48ce-aa54-939486d8b5a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('FOL-FunctionFn', 'Function-Denotational')) .
\"urn:uuid:4d20d1d1-dbb6-4ae4-b13e-d8e72e0f9078"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('FOL-FunctionFn', NonNegativeInteger)) .
\"urn:uuid:451d9d3c-6258-434c-a893-79145129b70e"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa('FOL-FunctionFn', 'Function-Denotational')) .
\"urn:uuid:28dcb2ec-f73e-4852-b353-be6230ab09d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('FOL-FunctionFn', (2))) .
\"urn:uuid:0ad92ee3-c1f1-4ef1-b23a-89ea520a1189"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-PredicateFn', UnreifiableFunction)) .
\"urn:uuid:8c5021ae-ca2d-409b-a791-dea0a88d1e49"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-PredicateFn', BinaryFunction)) .
\"urn:uuid:f0c1985b-14b2-4b60-b487-e44d6db77cfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('FOL-PredicateFn', Thing)) .
\"urn:uuid:44d57437-a8fa-4086-aa5a-067f4936140a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('FOL-PredicateFn', NonNegativeInteger)) .
\"urn:uuid:1acd5c32-aec5-48f4-bb42-70cc0d30b1b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa('FOL-PredicateFn', Predicate)) .
\"urn:uuid:dfff63a7-106f-434f-b039-acc6c25ae15d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('FOL-PredicateFn', (2))) .
\"urn:uuid:601edd63-d8cc-42d5-a3ab-3842a2b6fc21"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-TermFn', UnreifiableFunction)) .
\"urn:uuid:38d67f49-e3ce-49e9-b1c3-34a4be375264"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('FOL-TermFn', UnaryFunction)) .
\"urn:uuid:2023bddb-d9c3-41d1-af8a-6c587d3481e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('FOL-TermFn', Thing)) .
\"urn:uuid:fee79eb0-45d4-4481-b4a0-490686cbb7d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa('FOL-TermFn', Thing)) .
\"urn:uuid:df0754f2-44f6-4d4e-aec1-8bcccb6d7265"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('FOL-TermFn', (1))) .
\"urn:uuid:94568b70-086f-43f3-869b-bcac442c10bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(False, TruthValue)) .
\"urn:uuid:a9133fa2-6331-443a-b0e9-98360e7546ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(False, CycLTruthValueSentence)) .
\"urn:uuid:396412c0-71dd-4dad-a373-71d83bfc2dac"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(quotedIsa(False, 'CycLSentence-Assertible'))) .
\"urn:uuid:8a48968e-d37a-49b4-97a4-ad4e003c3fd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(February, MonthOfYearType)) .
\"urn:uuid:c4010ca1-a9a7-4cc3-a584-b67c5b22f08e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(February, Individual)) .
\"urn:uuid:d657acd0-53c1-4e90-8736-6ca02e76967a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FixedArityRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6bb87b45-5fb0-4513-acf6-57fa80715d79"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(FixedArityRelation, Relation)) .
\"urn:uuid:8430d1e5-3c10-47f6-a3c2-67f37db1f888"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FixedAritySkolemFuncN, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ce23ecda-3955-406f-8460-5342793fa247"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(FixedAritySkolemFuncN, SkolemFuncN)) .
\"urn:uuid:19b52482-e19a-4640-9f78-183c24b65c1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(FixedAritySkolemFuncN, FixedAritySkolemFunction)) .
\"urn:uuid:55e344f7-6df1-4cd7-8152-93aa146dd05c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FixedAritySkolemFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8e53420f-b84c-4bf2-b1e0-49231ee72c46"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(FixedAritySkolemFunction, FixedArityRelation)) .
\"urn:uuid:29a3028d-7aa1-41ef-9132-0069bf34dbdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(FixedAritySkolemFunction, SkolemFunction)) .
\"urn:uuid:b2bbd9d0-6808-4bac-b7d6-f62fe1f7b469"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Format, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:9e22c60a-0e77-42ee-93f5-60f678cd6e74"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Format, Individual)) .
\"urn:uuid:059b8807-e212-4927-ae01-079a45202c6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgFn, EvaluatableFunction)) .
\"urn:uuid:f5317b13-3358-4564-b962-726687af399d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgFn, BinaryFunction)) .
\"urn:uuid:2befffa8-dc82-4134-81c9-6986f36b03ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(FormulaArgFn, NonNegativeInteger)) .
\"urn:uuid:f5ec7889-a95f-4516-8b45-baa94fb266df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(FormulaArgFn, Thing)) .
\"urn:uuid:81fc7745-40bf-44dc-8e19-22803c6aa2d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(FormulaArgFn, CycLFormula)) .
\"urn:uuid:e591db22-83fd-448d-83cb-8fc2502cee6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(FormulaArgFn, Thing)) .
\"urn:uuid:bad7cecc-89be-448c-a019-7c9251848350"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(FormulaArgFn, (2))) .
\"urn:uuid:1edcc53b-b212-4a04-949c-0f828da5094a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgListFn, EvaluatableFunction)) .
\"urn:uuid:0cddd1e7-b26f-4835-aa3e-548833efc749"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgListFn, UnaryFunction)) .
\"urn:uuid:75374f32-f7b0-4b2d-9c7a-9ed022fe14b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(FormulaArgListFn, Thing)) .
\"urn:uuid:ba01ea27-5b69-450d-9932-37b7b5f8a044"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(FormulaArgListFn, CycLFormula)) .
\"urn:uuid:04bcc193-c507-495d-82fe-06e9a36e45fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(FormulaArgListFn, List)) .
\"urn:uuid:e2043731-1e56-43cf-ba15-109cf06e77eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(FormulaArgListFn, (1))) .
\"urn:uuid:b71411c6-c42d-493c-9dad-42ea70d70ea1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgSetFn, EvaluatableFunction)) .
\"urn:uuid:abddf9ef-4046-4854-a9f5-2ca5d6f4b41f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArgSetFn, UnaryFunction)) .
\"urn:uuid:f0db7d5a-4261-4b26-9e0e-68e3c0b16d05"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(FormulaArgSetFn, Thing)) .
\"urn:uuid:99cbb041-9650-485c-81d6-7f7fd2f67631"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(FormulaArgSetFn, CycLFormula)) .
\"urn:uuid:d7e41d06-497a-4e4d-95ae-e88508dacc17"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(FormulaArgSetFn, 'Set-Mathematical')) .
\"urn:uuid:50b76f50-cc86-4593-8b46-fe99d23c35fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(FormulaArgSetFn, (1))) .
\"urn:uuid:a20f206d-1291-40d4-8eb5-f37eafc742be"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArityFn, EvaluatableFunction)) .
\"urn:uuid:4c18b494-3547-46ad-8565-54ef6c7b88a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FormulaArityFn, UnaryFunction)) .
\"urn:uuid:da25ffe6-e16c-481d-ad5b-6ad9d09bded1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(FormulaArityFn, Thing)) .
\"urn:uuid:c4269a9e-5122-4930-ab7f-b0002ed5a2cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(FormulaArityFn, CycLFormula)) .
\"urn:uuid:925dc844-8044-4b93-b5bd-a05a4b76abe5"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(FormulaArityFn, PositiveInteger)) .
\"urn:uuid:46c1729f-1fac-4e0a-a66c-4447eb0147da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(FormulaArityFn, (1))) .
\"urn:uuid:8a7e8fb4-52e4-49db-9108-8e1c0f6eeff8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Forward-AssertionDirection', CycLAssertionDirection)) .
\"urn:uuid:2a32be5a-b515-485a-bdaa-910785a446ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Forward-AssertionDirection', CycLAssertion)) .
\"urn:uuid:51e3f0f6-8d70-4a7f-b6a5-575ec9fdc9c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Friday, DayOfWeekType)) .
\"urn:uuid:a8713379-e888-47ed-b43c-9b8126e1fef2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Friday, Individual)) .
\"urn:uuid:f8b57165-ba2e-4089-bbc1-be65b8a51fac"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Friday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:b7728867-90cb-4df6-9e3c-8da6abc01ab1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Function-Denotational', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:fff88161-3a18-402f-826e-a44eb2bcbd0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Function-Denotational', Relation)) .
\"urn:uuid:f566f7ce-c06d-47ce-84f3-37f41db4d9df"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FunctionToArg, BinaryFunction)) .
\"urn:uuid:b90bf1a1-baf8-41d4-a37d-0e4cd06b4a59"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(FunctionToArg, UnreifiableFunction)) .
\"urn:uuid:66654868-2ce5-4f58-abac-94b27383163c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(FunctionToArg, PositiveInteger)) .
\"urn:uuid:40dcffba-99d8-4821-8b71-daa60ba89576"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(FunctionToArg, Predicate)) .
\"urn:uuid:ef0eb394-835d-41d9-9726-ceeec185017c"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(FunctionToArg, EvaluatableFunction)) .
\"urn:uuid:38b1bbf4-9a15-47c9-ace6-e18c12c5615d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(FunctionToArg, (2))) .
\"urn:uuid:72fd79f8-c704-4e31-ada9-d9651df028b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Good-ProblemProvabilityStatus', Collection)) .
\"urn:uuid:3d467fee-c6d0-4f0e-b0d1-6b65ee289921"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Good-ProblemProvabilityStatus', CycProvabilityStatus)) .
\"urn:uuid:6bd7f4fa-ab34-48ca-85c4-50b8d64b9503"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Guest, HumanCyclist)) .
\"urn:uuid:58b6c0de-fed6-44cd-bf64-fc471d006cdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(Guest, IndeterminateTerm)) .
\"urn:uuid:1c6313a3-6d92-4943-9894-4daee6ae6d7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(HLAssertedArgumentKeywordDatastructure, Collection)) .
\"urn:uuid:e14aa811-b85f-4a59-8c60-4d9a33ce9bbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(HLAssertedArgumentKeywordDatastructure, CycArgumentDatastructure)) .
\"urn:uuid:fe0575a5-b67f-4438-9134-1dbb82ecc2bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(HLExternalIDString, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4a805b52-2d1f-4538-ab29-3ed0bb115b2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(HLExternalIDString, SubLAtom)) .
\"urn:uuid:e648ffdb-898d-46bc-9552-59e572428e41"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(HLExternalIDString, SubLSymbolFn(("HL-EXTERNAL-ID-STRING-P"^^_string)))) .
\"urn:uuid:d325d9ee-1276-4dc5-beb2-c904af143377"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(HLPrototypicalTerm, CycLExpressionType)) .
\"urn:uuid:9cddccb8-2802-48d4-9384-65aa48f0ea0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(HLPrototypicalTerm, IndeterminateTerm)) .
\"urn:uuid:f6ce9404-5e61-4db0-a7a9-7f457f83890e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(HumanCyclist, Collection)) .
\"urn:uuid:2c337299-5de7-4760-bead-c6a9c2117fb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(HumanCyclist, Cyclist)) .
\"urn:uuid:346be819-9dba-45f0-9044-33ff2b567506"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(HypotheticalContext, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:c93dbc69-fefd-4ec6-87e4-2fe1ed758fba"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(HypotheticalContext, Microtheory)) .
\"urn:uuid:b6e992f2-ee79-4c3f-b017-735076816aa8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IndeterminateTerm, CycLExpressionType)) .
\"urn:uuid:7f7fb96b-4e10-4903-8e55-13d43b85e697"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(IndeterminateTerm, CycLClosedDenotationalTerm)) .
\"urn:uuid:214a77df-b24a-484d-90cb-57ad5bd6dc2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IndeterminateTermDenotingFunction, Collection)) .
\"urn:uuid:4ea265ef-8260-4588-9d62-395f83866eb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(IndeterminateTermDenotingFunction, 'Function-Denotational')) .
\"urn:uuid:fc65f3d3-4599-4ee7-854e-345978413dd9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Individual, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4ff54b80-0e16-4506-8c94-3e97fea7d6e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Individual, Thing)) .
\"urn:uuid:41cfc29b-8f3f-4d10-9826-f387af53948c"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnNecessary(Individual, SubLSymbolFn(("CYC-INDIVIDUAL-NECESSARY"^^_string)))) .
\"urn:uuid:5beaf6dc-073d-455f-9a3d-bee5c5559375"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferencePSC, ProblemSolvingCntxt)) .
\"urn:uuid:b322e71c-57c5-48bc-b3fa-ae8fc460f0ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(InferencePSC, BaseKB)) .
\"urn:uuid:1715043e-7eed-4805-bfe6-48abb9c8970a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceRelatedBookkeepingPredicate, Collection)) .
\"urn:uuid:cd7a9faa-f0c2-4ff2-af36-14459738f237"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InferenceRelatedBookkeepingPredicate, BookkeepingPredicate)) .
\"urn:uuid:0665627c-083f-473e-8ead-92455de10489"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedCollection, CycLExpressionType)) .
\"urn:uuid:72594884-2b8c-4b07-9284-7bf30e2c3dab"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InferenceSupportedCollection, InferenceSupportedTerm)) .
\"urn:uuid:06f44f25-a7ad-4f7e-998e-d9b026fc478f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedFunction, Collection)) .
\"urn:uuid:355dee2a-9794-483f-ad59-cfeaabce3c18"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedFunction, CycLExpressionType)) .
\"urn:uuid:190a460f-8710-435e-9680-a27d721412c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InferenceSupportedFunction, CycLTerm)) .
\"urn:uuid:899e2042-02ba-4d95-9c8f-e6872b7fc7a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedPredicate, Collection)) .
\"urn:uuid:54d7fc65-9632-4bf5-94ab-d06da56add93"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedPredicate, CycLExpressionType)) .
\"urn:uuid:a76bcb46-0d20-46a6-bb91-5d99f26235d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InferenceSupportedPredicate, InferenceSupportedTerm)) .
\"urn:uuid:96d7bd72-b9ef-4c23-aba9-b8081872088a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedTerm, Collection)) .
\"urn:uuid:8064876e-2bd5-4132-888e-907b97d09f43"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InferenceSupportedTerm, CycLExpressionType)) .
\"urn:uuid:a08ffd59-93d4-4dd8-8df2-918ece7e373d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InferenceSupportedTerm, CycLTerm)) .
\"urn:uuid:8a0884c8-1bf8-46e4-aa8e-a316675237e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Integer, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:091fdf43-f4ab-4541-9f5e-132686b584c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Integer, RealNumber)) .
\"urn:uuid:c12acad7-6c94-45ab-846c-a949bff35a2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Integer, ScalarIntegralValue)) .
\"urn:uuid:bf3bbcc6-fe41-48b6-96b2-2d080cc5f4b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(Integer, SubLSymbolFn(("CYC-INTEGER"^^_string)))) .
\"urn:uuid:1491e98f-7232-44c0-b8f3-b1d2edcc1923"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Integer, SubLSymbolFn(("INTEGERP"^^_string)))) .
\"urn:uuid:73c76a1c-e615-4d38-99e4-87dd658a6ca5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InterArgFormatPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6aeeb3a8-c344-40b4-b24a-275634eb475d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InterArgFormatPredicate, TernaryPredicate)) .
\"urn:uuid:10820c33-4ecb-45e9-9507-4f4d3f13628e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InterArgFormatPredicate, ArgConstraintPredicate)) .
\"urn:uuid:743e780e-9ecb-4626-aaf4-9829cd5d20a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(InterArgIsaPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:782a0b8b-2c84-41b0-941b-806aa6e0fe05"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(InterArgIsaPredicate, ArgIsaPredicate)) .
\"urn:uuid:14d8431d-4389-4c0c-8082-5e7f91a88932"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IntervalEntry, Format)) .
\"urn:uuid:17d9fe26-2da9-4be5-b736-d3224132d878"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(IntervalEntry, WFFSupportedTerm))) .
\"urn:uuid:b1eea810-dc11-4d90-9778-985617b418ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IntervalMaxFn, UnaryFunction)) .
\"urn:uuid:2097ae53-b215-4d41-b91f-5834179b244d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IntervalMaxFn, UnreifiableFunction)) .
\"urn:uuid:56417a96-e610-49e5-b25d-f13a7e1efe5f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(IntervalMaxFn, ScalarInterval)) .
\"urn:uuid:95026462-225f-4b6d-93f6-c31e1dce3068"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(IntervalMaxFn, ScalarInterval)) .
\"urn:uuid:db7c624d-923f-490d-9fd8-9aa6881e160d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(IntervalMaxFn, (1))) .
\"urn:uuid:0792b3a5-8b47-4c9f-bd18-2aa77359fda0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IntervalMinFn, UnaryFunction)) .
\"urn:uuid:e0683419-0c29-4174-ac30-c21803244791"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IntervalMinFn, UnreifiableFunction)) .
\"urn:uuid:f66bdaf6-0892-48c9-a82a-d65dcf1ac3a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(IntervalMinFn, ScalarInterval)) .
\"urn:uuid:aef18e84-fe85-4683-b62b-b5ea982615eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(IntervalMinFn, ScalarInterval)) .
\"urn:uuid:ba6a8a84-bac5-42b8-a1a2-33c9835e3856"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(IntervalMinFn, (1))) .
\"urn:uuid:6d33ef36-c6d5-49b7-8dfc-923175bbfef8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(IrreflexiveBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0851d9d0-dc10-4b0e-96db-f69183d16108"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(IrreflexiveBinaryPredicate, 'RemovalModuleSupportedCollection-Generic')) .
\"urn:uuid:71bb354f-c36e-4fe6-812b-682f5bdb1b96"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(IrreflexiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:a142cbcb-8d53-4675-be82-6ab658dc47a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(January, MonthOfYearType)) .
\"urn:uuid:bc7393be-f893-47c4-8349-ab233423e864"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(January, Individual)) .
\"urn:uuid:fb8a9673-3b69-4d98-b9b2-2a5a83d2511d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(July, MonthOfYearType)) .
\"urn:uuid:66d52df4-8fb3-43c0-8bc0-27fcda4f6efc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(July, Individual)) .
\"urn:uuid:1fd31fd2-25f3-409f-9c45-e552b54260c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(June, MonthOfYearType)) .
\"urn:uuid:f3b2b613-d8f4-49f7-b5cf-0d25a7c8d1f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(June, Individual)) .
\"urn:uuid:c4992059-a3d6-4331-a056-77bd3b56a366"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Kappa, ScopingRelation)) .
\"urn:uuid:44eb11d6-30d7-4fdd-afe7-2ebd07f50068"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Kappa, BinaryFunction)) .
\"urn:uuid:d4ae2b7f-8963-4f3f-bc1a-4c2250478f2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Kappa, UnreifiableFunction)) .
\"urn:uuid:424fb193-af38-4128-a8d4-1dfa04f441c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(Kappa, InferenceSupportedFunction)) .
\"urn:uuid:0b7725f9-e86e-4f51-bf64-ccf5c7b1af32"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(Kappa, SubLList)) .
\"urn:uuid:9a0907ac-b49e-48b4-acc7-7cd09753d0ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(Kappa, 'CycLSentence-Assertible')) .
\"urn:uuid:32c2dc96-4410-47ec-8f18-40fdb473c996"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Kappa, Predicate)) .
\"urn:uuid:21a9f251-c222-4bf9-a18f-37b4f35c6e83"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Kappa, (2))) .
\"urn:uuid:0e0b9fb8-54d0-4896-856d-f4b54ab29b93"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(KnowledgeBase, Collection)) .
\"urn:uuid:a119e88a-9a4d-4a66-9e7d-6d4b68be9818"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(KnowledgeBase, Individual)) .
\"urn:uuid:40da4f06-536b-4b96-a2f1-0dee51bfa47b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Lambda, BinaryFunction)) .
\"urn:uuid:9ad1a04e-4add-4221-8a64-0d1bb669b384"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Lambda, ScopingRelation)) .
\"urn:uuid:740c2f70-3bee-4c41-a270-e60ae0ea06f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(Lambda, InferenceSupportedFunction))) .
\"urn:uuid:3b1e0587-c07b-45aa-931b-85e350cc2e43"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(Lambda, Thing)) .
\"urn:uuid:74bfaef6-80fd-41fe-b6fe-a734a4d4bd48"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(Lambda, SubLList)) .
\"urn:uuid:4ba7f4d6-fa4e-4557-b213-a67c7e40618e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(Lambda, 'CycLDenotationalTerm-Assertible')) .
\"urn:uuid:cad5eee1-5768-409d-9b77-61a17cbb6504"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Lambda, 'Function-Denotational')) .
\"urn:uuid:869c7762-ac8c-4e28-98ea-1c546417949a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Lambda, FixedArityRelation)) .
\"urn:uuid:f98840ac-26d5-4b9e-a5ed-231e727c672a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Lambda, (2))) .
\"urn:uuid:8c90a968-1f3a-4e1e-842a-dfdb3656cd49"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(List, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f6aee5d4-eec8-4d10-8a63-bd39e724988e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(List, Individual)) .
\"urn:uuid:de7c71e4-d1d8-4520-bbcc-ead74631cd9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnNecessary(List, SubLSymbolFn(("CYC-LIST-OF-TYPE-NECESSARY"^^_string)))) .
\"urn:uuid:8603d649-6155-473a-b236-d607767f2972"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(List, SubLSymbolFn(("CYC-LIST-OF-TYPE-SUFFICIENT"^^_string)))) .
\"urn:uuid:837dbd4e-e5f9-4af5-82d2-5fda327670b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(LogFn, UnaryFunction)) .
\"urn:uuid:cb9ca5de-a6ec-4e43-a3c9-02bd2b0b2ca3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(LogFn, EvaluatableFunction)) .
\"urn:uuid:eaaefb83-17db-4210-a7c2-5db5b72167a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(LogFn, NonNegativeScalarInterval)) .
\"urn:uuid:c77ec539-a82b-448c-8e74-7f30db4a4868"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(LogFn, RealNumber)) .
\"urn:uuid:85ffc8d3-24fd-497b-90f6-98255b674540"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(LogFn, RealNumber)) .
\"urn:uuid:1c29c6f3-7f82-479b-b4c4-0a978790f92a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(LogFn, (1))) .
\"urn:uuid:9131c190-d168-451a-8d7a-f91a05d2b24e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(LogicalConnective, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:aa09253d-2da1-4ff8-8f72-0d664592a022"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(LogicalConnective, SententialRelation)) .
\"urn:uuid:47eee7ac-2b86-4fc4-8071-46a4f6499e15"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(LogicalTruthImplementationMt, Microtheory)) .
\"urn:uuid:f360724c-3691-489c-9b7c-a2d149a97a30"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(LogicalTruthImplementationMt, LogicalTruthMt)) .
\"urn:uuid:22f14e27-808e-48e2-8a39-7c66dd80b34b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(LogicalTruthMt, Microtheory)) .
\"urn:uuid:469e5f61-ede3-4639-8ae8-6e3ed4be7fee"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(LogicalTruthMt, LogicalTruthImplementationMt)) .
\"urn:uuid:e619cf51-8997-475f-9269-7c9a604304e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(March, MonthOfYearType)) .
\"urn:uuid:b4792fa6-3b33-4965-a18f-e70284bdcba7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(March, Individual)) .
\"urn:uuid:d893114b-4ad8-4ecb-b15b-9ad6d10a1329"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MaxRangeFn, EvaluatableFunction)) .
\"urn:uuid:91d79e89-1c1b-4b66-9e5b-3209de41ff3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MaxRangeFn, CommutativeRelation)) .
\"urn:uuid:4115706e-aa82-49dc-b654-598cb311c4f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MaxRangeFn, VariableArityRelation)) .
\"urn:uuid:24736f9e-4c7d-4c88-8865-97825e464a05"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(MaxRangeFn, ScalarInterval)) .
\"urn:uuid:4884ef4a-04af-4e43-babd-923285f068a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MaxRangeFn, ScalarInterval)) .
\"urn:uuid:9c03ba58-ec3f-4ce0-9714-b48bd339a0ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(MaxRangeFn, (1))) .
\"urn:uuid:5ec3e46d-0249-4078-834f-3ce0feb4b441"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Maximum, EvaluatableFunction)) .
\"urn:uuid:410f6977-e36d-4ccd-9c2c-d4bf0d76f163"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Maximum, BinaryFunction)) .
\"urn:uuid:17c2b28a-937c-4125-8362-50fb4dd5f5a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(Maximum, SetOrCollection)) .
\"urn:uuid:8e1626c9-3615-423e-9137-bd1111fb0631"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(Maximum, UnaryFunction)) .
\"urn:uuid:db864d04-b2f6-420d-8c84-98f74073e5ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Maximum, ScalarInterval)) .
\"urn:uuid:a1f82d50-8a8b-45f1-9a19-e5068a3e2a1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Maximum, (2))) .
\"urn:uuid:8afe17c1-9216-4865-b835-963902ee20e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(May, MonthOfYearType)) .
\"urn:uuid:54a80203-b7d5-48dc-8d96-8072556bcf62"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(May, Individual)) .
\"urn:uuid:35c9393a-7ce9-415f-a7fd-2f981b6b5225"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MeaningInSystemFn, ReifiableFunction)) .
\"urn:uuid:6d67931c-00a8-4eb7-894c-6600e81e20a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MeaningInSystemFn, BinaryFunction)) .
\"urn:uuid:b8b75572-5f9b-4343-8910-fdef5dc0f40f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(MeaningInSystemFn, Individual)) .
\"urn:uuid:33c85df3-986e-49df-9b7c-f9fbf2b609af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(MeaningInSystemFn, CharacterString)) .
\"urn:uuid:480e41a0-5d4e-4676-8691-97be46a7533a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MeaningInSystemFn, Thing)) .
\"urn:uuid:861d76f0-9fa9-434a-83c1-dc838735384a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(MeaningInSystemFn, (2))) .
\"urn:uuid:31c2023c-2670-4a2a-bd22-a0e6158380ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Microtheory, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d2e001b5-256e-4f4d-82c3-c42418234e5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Microtheory, Individual)) .
\"urn:uuid:cec33770-b6d5-499e-8a47-cc3aada90f6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MicrotheoryDesignatingRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d43ebff8-dbfd-4088-8706-00eb91806231"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(MicrotheoryDesignatingRelation, Relation)) .
\"urn:uuid:8a47b68b-3146-45a6-a61f-4d7d8085f027"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MinRangeFn, EvaluatableFunction)) .
\"urn:uuid:fc2fadd6-3ac8-4572-9faa-fe66824f2a4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MinRangeFn, CommutativeRelation)) .
\"urn:uuid:f370f07e-3db9-4759-8d70-5fa70fdab535"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MinRangeFn, AssociativeRelation)) .
\"urn:uuid:aec223d9-1921-4c8f-8a8a-d5145495544f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MinRangeFn, VariableArityRelation)) .
\"urn:uuid:18b6cba8-7700-4a9c-b53f-df7a8f87f237"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(MinRangeFn, ScalarInterval)) .
\"urn:uuid:0e484463-0f03-4f4c-922a-891bd645354d"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MinRangeFn, ScalarInterval)) .
\"urn:uuid:ff7538de-4ab8-41e4-8d25-ff8fb5d02ec1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(MinRangeFn, (1))) .
\"urn:uuid:1bb9571c-fafa-4bdc-93f0-e1d2d4a0a929"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Minimum, EvaluatableFunction)) .
\"urn:uuid:785339b8-8e88-456c-87ca-2aef15de0515"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Minimum, BinaryFunction)) .
\"urn:uuid:1721cba5-c281-465b-a73e-ae5e692604a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(Minimum, SetOrCollection)) .
\"urn:uuid:4dd98aaa-4e8a-48ea-a98a-19d1b65dee6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(Minimum, UnaryFunction)) .
\"urn:uuid:0fb1a06b-9207-43f2-a726-b253a4017f4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Minimum, ScalarInterval)) .
\"urn:uuid:9c794aad-e593-4172-9738-db3b301eefea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Minimum, (2))) .
\"urn:uuid:50c12483-a600-4834-99a4-97f661643cae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ModuloFn, BinaryFunction)) .
\"urn:uuid:cfed4c6f-a20a-4346-a9f5-5edb92e5e74d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ModuloFn, EvaluatableFunction)) .
\"urn:uuid:28db4b7c-17ba-4c7c-9107-83f12bbf410a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ModuloFn, ScalarInterval)) .
\"urn:uuid:d1052a7a-a90b-4c7c-842d-33b19a296b73"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(ModuloFn, ScalarPointValue)) .
\"urn:uuid:00a65669-95be-4d59-8b7f-ec3cfff25a0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(ModuloFn, ScalarInterval)) .
\"urn:uuid:0c50e803-ff2f-44b2-b5e9-53437874a5c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ModuloFn, (2))) .
\"urn:uuid:5228e113-5c08-4f98-84df-1e70cfb4dba8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Monday, DayOfWeekType)) .
\"urn:uuid:5cc82957-5442-4921-b30c-40fd0ba7a5f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Monday, Individual)) .
\"urn:uuid:cbdaf9dc-85fc-43c2-9389-6af7c55df425"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Monday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:564dd495-f9b9-4e76-9201-14535ac388af"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonotonicallyFalse, Individual)) .
\"urn:uuid:9ce8345d-3413-442b-953e-9da18ef0ae21"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonotonicallyFalse, CycHLTruthValue)) .
\"urn:uuid:d4a26947-5ae7-4f4b-bf12-de99b08d8b09"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonotonicallyTrue, Individual)) .
\"urn:uuid:a27c8505-b24e-47c2-a3f2-054fe3a12f72"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonotonicallyTrue, CycHLTruthValue)) .
\"urn:uuid:ec4514e3-f58a-4870-be48-25d4ee8258ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonthOfYearType, SiblingDisjointCollectionType)) .
\"urn:uuid:890e65ff-a9e8-4f17-ac16-1ff3e140253d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MonthOfYearType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ceb6edc0-80f4-4d40-97c5-1954767eac64"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(MonthOfYearType, Collection)) .
\"urn:uuid:3dbdc373-e90f-479b-a15d-fc78194b0911"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtSpace, UnreifiableFunction)) .
\"urn:uuid:14a74da4-1ca3-4248-8a23-3f70deef0540"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtSpace, VariableArityRelation)) .
\"urn:uuid:55ad0ebc-fd13-4647-b334-fe563b0b60a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtSpace, CommutativeRelation)) .
\"urn:uuid:4b96f589-bb13-4751-a0c2-742e72221e91"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(MtSpace, Microtheory)) .
\"urn:uuid:904b3b47-2523-489b-a852-6f25626a1056"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MtSpace, Microtheory)) .
\"urn:uuid:cca84a20-2c52-4d7f-84e3-c017a1f8d953"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtTimeDimFn, UnreifiableFunction)) .
\"urn:uuid:0955941a-43f3-4b28-af59-9ec721fbbc57"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtTimeDimFn, UnaryFunction)) .
\"urn:uuid:0ae8a896-12d5-4f2b-82e8-9239e6869cd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(MtTimeDimFn, Individual)) .
\"urn:uuid:e30fae2f-698c-462f-ac2c-053aaa00e79a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MtTimeDimFn, Microtheory)) .
\"urn:uuid:55ab1778-1fc3-47ad-befe-179cc36a773b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(MtTimeDimFn, (1))) .
\"urn:uuid:df36a720-f162-4e88-b148-8b620b5aaad3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtTimeWithGranularityDimFn, BinaryFunction)) .
\"urn:uuid:3ec5734a-92a6-4b09-b957-5af8ad9b60ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtTimeWithGranularityDimFn, UnreifiableFunction)) .
\"urn:uuid:386e6ad1-fc43-471e-94bf-e72015b7b579"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(MtTimeWithGranularityDimFn, Individual)) .
\"urn:uuid:9abd0d04-45c1-4049-a6ac-a7dc21304bb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(MtTimeWithGranularityDimFn, Collection)) .
\"urn:uuid:29ae358e-747c-4179-ad8d-1c34f5d6ed43"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MtTimeWithGranularityDimFn, Microtheory)) .
\"urn:uuid:414d7548-3707-4656-97f7-a363f5e30948"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(MtTimeWithGranularityDimFn, (2))) .
\"urn:uuid:b2baa78e-b9e6-457e-8b62-12a545dcc823"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtUnionFn, UnreifiableFunction)) .
\"urn:uuid:7fb3bebc-f0b6-4ac6-b611-d82d00532103"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtUnionFn, VariableArityRelation)) .
\"urn:uuid:cd048161-a7de-4a3a-869a-3b2c9023ae59"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtUnionFn, CommutativeRelation)) .
\"urn:uuid:231d86ba-dc33-414e-92c4-60058895c9e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(MtUnionFn, AssociativeRelation)) .
\"urn:uuid:2f5d865d-ad18-438a-8445-c1340e39f757"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(MtUnionFn, Microtheory)) .
\"urn:uuid:f46be5cf-9309-48e0-97cd-01ed6d46accc"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(MtUnionFn, ProblemSolvingCntxt)) .
\"urn:uuid:43907e65-24af-4dcc-a464-783455d024c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Multigraph, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0c69e793-849e-4548-aa7f-c08b7cebe84a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Multigraph, Individual)) .
\"urn:uuid:4ca9c270-9d99-459f-914d-717137923a71"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Neutral-ProblemProvabilityStatus', Collection)) .
\"urn:uuid:f845a22a-1e0b-474b-9e29-641fddd9a775"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Neutral-ProblemProvabilityStatus', CycProvabilityStatus)) .
\"urn:uuid:42fc4e04-028c-471d-b525-e2ce09aac787"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('NoGood-ProblemProvabilityStatus', Collection)) .
\"urn:uuid:e11cb08f-2c72-4222-8321-3da51cc4c697"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('NoGood-ProblemProvabilityStatus', CycProvabilityStatus)) .
\"urn:uuid:522d3a49-fa83-40ac-a69c-40ecdffabed7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(NonNegativeInteger, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:fb1a28a6-286b-4274-8742-a8d3464100ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(NonNegativeInteger, Integer)) .
\"urn:uuid:a2571363-7e80-4853-86f0-f2312867abea"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(NonNegativeInteger, NonNegativeScalarInterval)) .
\"urn:uuid:c2bf6fd5-7ac2-47d9-a5cd-e17abce7f7d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(NonNegativeInteger, SubLSymbolFn(("CYC-NON-NEGATIVE-INTEGER"^^_string)))) .
\"urn:uuid:8b434bd0-c4c4-420f-b1a9-1516c104a548"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(NonNegativeScalarInterval, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6475a6a9-3baf-4c98-9673-14fd48c33c3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(NonNegativeScalarInterval, ScalarInterval)) .
\"urn:uuid:026f0559-00f3-4222-9a81-f405b1bd9d0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(NonNegativeScalarInterval, SubLSymbolFn(("NON-NEGATIVE-SCALAR-INTERVAL?"^^_string)))) .
\"urn:uuid:b3ae48f3-65d2-42e1-bd52-12e1b9c07fcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(November, MonthOfYearType)) .
\"urn:uuid:b8a51957-bb41-451f-ac99-11713ab4463b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(November, Individual)) .
\"urn:uuid:64d2d1a7-eafd-45b4-8735-391ec4ecc9ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(October, MonthOfYearType)) .
\"urn:uuid:13f10781-c0ed-4ada-9cb3-b6c8085d130c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(October, Individual)) .
\"urn:uuid:8e186199-6d01-4f91-899e-fc975a272651"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Open-InferenceProblemLinkStatus', Collection)) .
\"urn:uuid:5cffb527-9928-4cd8-93c5-187fc26e3242"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Open-InferenceProblemLinkStatus', CycInferenceProblemLinkStatus)) .
\"urn:uuid:0ab60997-0aa8-4900-bf8e-6bf90bbd0f8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PartiallyCommutativeRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d901ff6b-ab8d-478c-95ea-36f7a2a47355"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(PartiallyCommutativeRelation, Relation)) .
\"urn:uuid:68930a57-5622-4098-bae3-c0c30ec450f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PerFn, ReifiableFunction)) .
\"urn:uuid:aeddcecb-3157-4951-9f99-c5b92565c9c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PerFn, BinaryFunction)) .
\"urn:uuid:c0707f22-09d9-4958-acca-eff69f8cb1b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(PerFn, UnitOfMeasure)) .
\"urn:uuid:bcf73dcf-8cd6-4d65-b57d-6c9bcb6a4dcf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(PerFn, UnitOfMeasure)) .
\"urn:uuid:35715e91-b778-4752-9a4c-596dae0bf2a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(PerFn, UnitOfMeasure)) .
\"urn:uuid:f5523c5c-0b60-4841-a943-74e1b77902ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(PerFn, (2))) .
\"urn:uuid:13b16af2-d241-4e26-bed2-795eb87cfeb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Percent, EvaluatableFunction)) .
\"urn:uuid:4fb235ee-5882-4d43-a6ca-9b6e3afd3245"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Percent, UnitOfMeasure)) .
\"urn:uuid:db636047-ee33-4f70-8633-00e738430cdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(Percent, ScalarInterval)) .
\"urn:uuid:e897bb6d-ea11-41ee-bade-b240bafb93f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Percent, ScalarInterval)) .
\"urn:uuid:66db9f81-5154-420d-81ec-eca6c756ed61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(Percent, (1))) .
\"urn:uuid:4d6dff08-7854-42ee-a8cd-48ab69aa237a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMax(Percent, (2))) .
\"urn:uuid:4c6d72d4-4b25-480e-aefe-e12a9657a535"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusAll, EvaluatableFunction)) .
\"urn:uuid:00293208-2c76-4f36-9cf3-d87d49cabde8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusAll, BinaryFunction)) .
\"urn:uuid:9710bb95-fcf8-44d8-b1f3-cb1340c36519"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(PlusAll, SetOrCollection)) .
\"urn:uuid:e421f273-a856-4d7e-a28c-6325530e81a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(PlusAll, UnaryFunction)) .
\"urn:uuid:165bcb0f-722e-479b-9bb2-ed5cd5af8acc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(PlusAll, EvaluatableFunction)) .
\"urn:uuid:dff3e4ee-ed06-4f55-b58f-54ff14f2a4cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(PlusAll, ScalarInterval)) .
\"urn:uuid:defd6042-6365-460e-b3db-3777e83d347e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(PlusAll, (2))) .
\"urn:uuid:f1e8070d-414e-4636-b15e-6f18135ab4d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusFn, CommutativeRelation)) .
\"urn:uuid:02e68700-1857-4744-b40b-e401784f03a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusFn, AssociativeRelation)) .
\"urn:uuid:3d5fb9a1-ac83-4e90-a3ca-0fa891afec1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusFn, EvaluatableFunction)) .
\"urn:uuid:bf839b7b-a732-4802-a3ad-48fc55d949ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PlusFn, VariableArityRelation)) .
\"urn:uuid:6a4e3e3b-eb96-4085-b065-4bf6514c256a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(PlusFn, ScalarInterval)) .
\"urn:uuid:53bfe9d5-b161-45d9-8f6f-b2e7b94b0ea7"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(PlusFn, ScalarInterval)) .
\"urn:uuid:1e6a909b-b207-47b9-bec4-187644a3d004"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(PlusFn, (1))) .
\"urn:uuid:5915d263-de21-4eae-9bda-00bec77e8069"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PositiveInteger, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:74c1841a-4200-4f7e-8dc9-1970e7383d51"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(PositiveInteger, NonNegativeInteger)) .
\"urn:uuid:64459c15-26f8-428c-a9c7-3aff8eb52394"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(PositiveInteger, SubLSymbolFn(("CYC-POSITIVE-INTEGER"^^_string)))) .
\"urn:uuid:a4359d95-33dc-43d2-98dc-c7f5611e614e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Predicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5d384198-f865-4f0c-87fd-330caca77451"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Predicate, TruthFunction)) .
\"urn:uuid:0a3caa86-878e-4603-bf7b-ab41fcfad5f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(PredicateTypeByArity, DisjointCollectionType)) .
\"urn:uuid:d840c177-ec4f-49c7-94b4-ac90ed6d3491"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(PredicateTypeByArity, Collection)) .
\"urn:uuid:4cc126c6-f877-4b08-a2c7-d55d23e235eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ProblemSolvingCntxt, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:08c5b422-f267-432f-8c61-96e9f00a08ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ProblemSolvingCntxt, Microtheory)) .
\"urn:uuid:0c80111c-cea0-450b-b15c-ec70a86bb1b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Quantifier, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4fbf23ea-51ba-482f-a0dc-3fcf553631df"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Quantifier, ScopingRelation)) .
\"urn:uuid:180d595e-38c4-4ae0-bde6-a6f784391726"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Quantifier, SententialRelation)) .
\"urn:uuid:5fa269e8-3c69-4194-9ebb-1988b3ab5e9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuantityConversionFn, EvaluatableFunction)) .
\"urn:uuid:0695fff0-7711-468b-92b9-f8f5121420a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuantityConversionFn, BinaryFunction)) .
\"urn:uuid:f065f845-d23b-468e-b3af-78ff8b8d731b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuantityConversionFn, IndeterminateTermDenotingFunction)) .
\"urn:uuid:63897ee8-8a5e-42fe-90c0-5391e0feb995"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(QuantityConversionFn, UnitOfMeasure)) .
\"urn:uuid:2059cd7e-0e32-4819-9004-6dd53a87fab3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(QuantityConversionFn, ScalarInterval)) .
\"urn:uuid:56eb79fa-23ac-4ed3-bd81-1de38e6d67b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(QuantityConversionFn, ScalarInterval)) .
\"urn:uuid:d92c41cb-5a5f-4f79-9c89-acfa365752d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(QuantityConversionFn, (2))) .
\"urn:uuid:f72e0040-a949-4122-a109-f4fdc77e23b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuasiQuote, UnreifiableFunction)) .
\"urn:uuid:ddd571e1-b1cb-42ea-83b8-b4e2c178380c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuasiQuote, UnaryFunction)) .
\"urn:uuid:bca9f3f6-12f6-4180-a7e1-b780b16f5b0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuasiQuote, WFFSupportedTerm)) .
\"urn:uuid:7c982074-37d8-46c0-8368-6bab4f6e0831"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(QuasiQuote, InferenceSupportedTerm)) .
\"urn:uuid:e939d6f5-ddf9-40f9-b3ba-c3d790af022f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(QuasiQuote, Thing)) .
\"urn:uuid:56eed6eb-8ce2-4fc7-b2f3-849790b176a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(QuasiQuote, CycLTerm)) .
\"urn:uuid:95f2057b-9c40-4b1d-8bab-78db73dcf1b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(QuasiQuote, CycLTerm)) .
\"urn:uuid:783bbdaa-6156-4717-b94c-3a225a1d6431"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(QuasiQuote, Thing)) .
\"urn:uuid:54c57e5a-7450-4d71-a067-0458e0928038"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(QuasiQuote, (1))) .
\"urn:uuid:1abd9f6a-8ddb-47db-9b50-73aecfddb13f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuaternaryFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:00c2de31-6af0-4703-b559-adea078f412c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuaternaryFunction, 'Function-Denotational')) .
\"urn:uuid:35786585-5b30-4065-844c-5616ede7d863"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuaternaryFunction, QuaternaryRelation)) .
\"urn:uuid:5d1f075b-c29d-4c3f-a47b-8c3ded59d8c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuaternaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0f28c95a-51d4-49db-bdf6-323c0e642ded"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuaternaryPredicate, PredicateTypeByArity)) .
\"urn:uuid:c80252eb-49bb-49aa-952d-118967f423ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuaternaryPredicate, Predicate)) .
\"urn:uuid:9aa2d066-707d-4e90-bf6d-beeafbc84c50"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuaternaryPredicate, QuaternaryRelation)) .
\"urn:uuid:00001e25-25e3-4efa-baac-f114f871b60a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuaternaryRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:02b58356-8df0-4882-be14-78b88705df1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuaternaryRelation, FixedArityRelation)) .
\"urn:uuid:c74fc901-c7c3-47ee-b97f-50225c1d6ca4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QueryMt, Microtheory)) .
\"urn:uuid:f4f54adc-39ea-4b31-9789-961b3457114d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(QueryMt, IndeterminateTerm)) .
\"urn:uuid:917a6372-6f4b-4f04-b5ef-aef2c9d512b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(QueryMt, BaseKB)) .
\"urn:uuid:fc9593dd-4133-4d5f-b8a3-81fd7144d148"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuintaryFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:65fe5dbd-f04c-4310-94a2-8b32aedd6c1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuintaryFunction, 'Function-Denotational')) .
\"urn:uuid:f32b61e5-22f3-4cb7-be73-e47977435789"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuintaryFunction, QuintaryRelation)) .
\"urn:uuid:f5ea9d49-a7bf-4fdb-8a43-17157b509433"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuintaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:fd5c3261-8028-45f2-b29d-960e42a29731"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuintaryPredicate, PredicateTypeByArity)) .
\"urn:uuid:a27157fd-5adf-4649-91bc-ef2c72368def"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuintaryPredicate, Predicate)) .
\"urn:uuid:209cc668-a250-4b0a-b576-910bbe9dedf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuintaryPredicate, QuintaryRelation)) .
\"urn:uuid:553ba83b-da1c-45f5-94de-a47c702c506f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuintaryRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:48870781-1fe9-4357-8ecd-738d6a83f84c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(QuintaryRelation, FixedArityRelation)) .
\"urn:uuid:e0d55564-848e-475c-8ebc-398dcb93fd92"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Quote, UnaryFunction)) .
\"urn:uuid:7744a825-a776-4901-b964-0394be4b32b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Quote, UnreifiableFunction)) .
\"urn:uuid:8a9df233-7697-4fdc-91c1-959babeef246"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Quote, WFFSupportedTerm)) .
\"urn:uuid:b58b9a4f-88ae-44cf-8d4b-2a890b897ddc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(Quote, InferenceSupportedTerm)) .
\"urn:uuid:f913764c-b4c0-4f55-b586-30dca02bf6ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(Quote, Thing)) .
\"urn:uuid:47ea4d76-ad15-4377-8fff-b6e5992d250e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(Quote, CycLTerm)) .
\"urn:uuid:b43a403d-60a3-421d-95b8-4500ed43d3c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Quote, Thing)) .
\"urn:uuid:b182d002-bee2-49ff-9b41-321b19f0a367"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Quote, CycLTerm)) .
\"urn:uuid:7cf786dd-9508-4f63-8fca-0f91e09f54cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(Quote, (1))) .
\"urn:uuid:77c12609-810f-452e-961b-011d565cf4d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuotientFn, BinaryFunction)) .
\"urn:uuid:1f5feae5-4e71-45f9-8e90-8e6fa4847b00"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(QuotientFn, EvaluatableFunction)) .
\"urn:uuid:755752d7-54c2-4102-bf51-09139729a6b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(QuotientFn, ScalarInterval)) .
\"urn:uuid:380fdaa7-0ac9-4a72-8c31-909d51929aba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(QuotientFn, ScalarInterval)) .
\"urn:uuid:58d6e33f-2e07-4115-ba36-380b92930d73"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(QuotientFn, ScalarInterval)) .
\"urn:uuid:5a4f81c2-f5f4-4aea-9259-40506281a436"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(QuotientFn, (2))) .
\"urn:uuid:2cf06897-c93e-4833-82f7-8bb53319857a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RealNumber, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:4df68b03-3d37-4988-aca3-a7514aad1fe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(RealNumber, ScalarPointValue)) .
\"urn:uuid:17dbd951-e759-448e-a5f3-87e141078c1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(RealNumber, SubLSymbolFn(("CYC-REAL-NUMBER"^^_string)))) .
\"urn:uuid:ed3e933f-1d49-4aa3-b52a-24db103dcd09"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReflexiveBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ed339099-1f5b-445a-a564-a660c3371a93"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ReflexiveBinaryPredicate, 'RemovalModuleSupportedCollection-Generic')) .
\"urn:uuid:d17adf81-3c0f-41aa-b817-95b1e105e729"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ReflexiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:a8152e5d-2daf-4c24-8034-c7a6896d3531"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulationBackwardDirection, Thing)) .
\"urn:uuid:eaca1add-4605-4355-9e8c-d68a827c22dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulationForwardDirection, Thing)) .
\"urn:uuid:30d943f7-4247-4d37-a640-16bc59fe1864"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulationNeitherDirection, Thing)) .
\"urn:uuid:0f424787-b5f8-4267-91b6-ccc65fd4c0c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulatorDirectivePredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6d2c9deb-476f-4117-90c4-3404f5fce5ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ReformulatorDirectivePredicate, Predicate)) .
\"urn:uuid:2ad707fc-cbfc-429d-9b62-ffa877933c7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulatorHighlyRelevantFORT, Collection)) .
\"urn:uuid:42fb24cd-3c0c-4b94-8cc6-d8aabe5b6bb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ReformulatorHighlyRelevantFORT, Thing)) .
\"urn:uuid:b0c6bca6-a08b-4e88-8b2f-e3f6bf765e06"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReformulatorIrrelevantFORT, Collection)) .
\"urn:uuid:8f63e629-9467-4ada-81c6-f182968a31e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ReformulatorIrrelevantFORT, Thing)) .
\"urn:uuid:89c31032-1309-4efd-afe1-b9eab20a8d3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ReifiableFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0fdc56bb-3d7b-483b-97fd-b7557a86a398"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ReifiableFunction, 'Function-Denotational')) .
\"urn:uuid:2e68a799-9dc2-4e63-86f9-48cad3d0b59a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Relation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:cbbc4c0d-07be-41f9-b610-7c538b838250"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Relation, Individual)) .
\"urn:uuid:c705043a-ae33-4726-afc8-0025e17a4877"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationAllExistsFn, UnreifiableFunction)) .
\"urn:uuid:27fb9bb1-2684-4683-b27a-8921bc7486ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationAllExistsFn, QuaternaryFunction)) .
\"urn:uuid:b23fc0d4-8083-498a-985a-d51d18166cf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationAllExistsFn, IndeterminateTermDenotingFunction)) .
\"urn:uuid:3e5b3f0f-8255-4184-9900-71c4d7f0b70a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RelationAllExistsFn, Thing)) .
\"urn:uuid:65fe0f08-bcc7-49fc-b6f1-3dafd718b2c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(RelationAllExistsFn, BinaryPredicate)) .
\"urn:uuid:651ed3e6-a3dd-442e-87ee-fb7263c8aff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(RelationAllExistsFn, Collection)) .
\"urn:uuid:f84069e8-5f3a-45e8-8cea-730354235b46"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(RelationAllExistsFn, Thing)) .
\"urn:uuid:0e8ea716-ad83-488e-a412-4326c438d105"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(RelationAllExistsFn, Collection)) .
\"urn:uuid:f94199dc-a409-4bf8-b6c8-a1cd1042cefd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Genl(RelationAllExistsFn, Thing)) .
\"urn:uuid:b3855b1a-3c38-491d-8b70-2b40d74b2966"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RelationAllExistsFn, Thing)) .
\"urn:uuid:c5efe192-c949-44c6-b22e-8b8b35ae169c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RelationAllExistsFn, (4))) .
\"urn:uuid:8d27277d-c381-4658-ba6e-aaea4d925e50"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsAllFn, QuaternaryFunction)) .
\"urn:uuid:e365f4ed-1622-491f-9558-53c3cf9728c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsAllFn, UnreifiableFunction)) .
\"urn:uuid:bc013f88-35c1-47bd-8af4-221159268a62"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsAllFn, IndeterminateTermDenotingFunction)) .
\"urn:uuid:cec21b1f-ba86-4456-80bf-ad59348f88a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RelationExistsAllFn, Thing)) .
\"urn:uuid:91bd7787-5613-4bd9-bb93-61ee36d031e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(RelationExistsAllFn, BinaryPredicate)) .
\"urn:uuid:32b5388c-4057-4a2a-8482-a86a5e5ea862"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(RelationExistsAllFn, Collection)) .
\"urn:uuid:0d5b79c1-51e3-489d-9850-a156c4401802"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(RelationExistsAllFn, Thing)) .
\"urn:uuid:a309e2ff-a373-43d6-8a89-e273f126374f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(RelationExistsAllFn, Collection)) .
\"urn:uuid:95288e39-9c9d-4858-af1e-a4d654b28456"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Genl(RelationExistsAllFn, Thing)) .
\"urn:uuid:edd2febf-a86a-4668-9fb0-43c34f0876cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RelationExistsAllFn, Thing)) .
\"urn:uuid:d7c31047-9576-44d8-beb0-39dc5b950659"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RelationExistsAllFn, (4))) .
\"urn:uuid:e07002c9-6534-4ed4-b1ca-26e033580a8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsInstanceFn, TernaryFunction)) .
\"urn:uuid:45376f59-626f-4abb-a768-1f5d8b2c7439"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsInstanceFn, UnreifiableFunction)) .
\"urn:uuid:00aca263-e218-47f0-9686-4e674d542580"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationExistsInstanceFn, IndeterminateTermDenotingFunction)) .
\"urn:uuid:9cd27fea-661d-43b5-bfcf-569ca3337104"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RelationExistsInstanceFn, BinaryPredicate)) .
\"urn:uuid:77ec7daa-8a38-4208-ad9a-e2662f859ea3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(RelationExistsInstanceFn, Collection)) .
\"urn:uuid:c3649d9c-32f9-4f0b-930d-c49598f2b3da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(RelationExistsInstanceFn, Thing)) .
\"urn:uuid:31c98389-6cfe-4497-9c04-b0323e8df8cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(RelationExistsInstanceFn, Thing)) .
\"urn:uuid:15751b7e-4d0f-4829-a776-12377c07ab6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RelationExistsInstanceFn, Thing)) .
\"urn:uuid:0986095b-27e1-44ef-8f32-8646d360286e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RelationExistsInstanceFn, (3))) .
\"urn:uuid:fafdc314-3f99-46b9-98bd-787ecb263ec5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationInstanceExistsFn, TernaryFunction)) .
\"urn:uuid:b1db9ebb-2dae-497e-847d-7c423c9fcb24"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationInstanceExistsFn, UnreifiableFunction)) .
\"urn:uuid:ef763c71-f6fd-400e-8d2e-c98201ab577b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelationInstanceExistsFn, IndeterminateTermDenotingFunction)) .
\"urn:uuid:2b4cbb64-3f40-410f-8765-9abf5c74d247"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RelationInstanceExistsFn, BinaryPredicate)) .
\"urn:uuid:28c55946-094c-4fb4-ab64-2640581032de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(RelationInstanceExistsFn, Thing)) .
\"urn:uuid:eced71f7-4bc5-48cd-ad13-6f0757224617"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(RelationInstanceExistsFn, Collection)) .
\"urn:uuid:36dde30c-8efe-4265-a321-0668452c8b34"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(RelationInstanceExistsFn, Thing)) .
\"urn:uuid:51278046-4429-4fbc-8c39-931bbe563ea8"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RelationInstanceExistsFn, Thing)) .
\"urn:uuid:6dc217b2-c8e2-43a8-b1ed-38bf1c74e7d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RelationInstanceExistsFn, (3))) .
\"urn:uuid:68d9320e-a61b-4fc0-a723-598df3a33a32"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RelaxArgTypeConstraintsForVariables, WFFDirectivePredicate)) .
\"urn:uuid:c6ef9818-c8fd-4982-a5f3-d6ffc676ebb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedCollection-Generic', Collection)) .
\"urn:uuid:6427e2c2-078e-4062-bd23-2355a6a0ef09"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedCollection-Generic', CycLExpressionType)) .
\"urn:uuid:64141cd7-9d3c-4918-a0bc-e142aa26fad9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('RemovalModuleSupportedCollection-Generic', InferenceSupportedCollection)) .
\"urn:uuid:7863e0f9-7cb3-4bd4-9e1e-36d40decd1b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedPredicate-Generic', Collection)) .
\"urn:uuid:eba28e01-a303-4619-a0db-89f26fd2ff73"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedPredicate-Generic', CycLExpressionType)) .
\"urn:uuid:a6f60de6-1d3c-4dd5-bbb2-69258c1cf7db"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('RemovalModuleSupportedPredicate-Generic', CycLTerm)) .
\"urn:uuid:d1f4c7e7-802f-4522-99ad-0b348890ea8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('RemovalModuleSupportedPredicate-Generic', InferenceSupportedPredicate)) .
\"urn:uuid:a062ffff-bd5a-4c0b-852d-13c1012a76f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedPredicate-Specific', Collection)) .
\"urn:uuid:8f3b4fe4-0977-4a94-aef3-8b23e396dda8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('RemovalModuleSupportedPredicate-Specific', CycLExpressionType)) .
\"urn:uuid:964cb728-12ae-428c-804d-a4c45eb80721"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('RemovalModuleSupportedPredicate-Specific', InferenceSupportedPredicate)) .
\"urn:uuid:db0afe5d-d19f-4950-b465-184cda4ab458"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('RemovalModuleSupportedPredicate-Specific', CycLTerm)) .
\"urn:uuid:006e029b-4bc8-456d-882c-4de086004e30"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundClosestFn, UnaryFunction)) .
\"urn:uuid:9d84b69c-e7d2-45fd-8598-21137d405e5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundClosestFn, EvaluatableFunction)) .
\"urn:uuid:0939bb11-d02b-4253-8e72-272e09e296fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RoundClosestFn, ScalarInterval)) .
\"urn:uuid:82b5fde8-9008-4ffc-9ed0-f46c44c35835"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RoundClosestFn, ScalarInterval)) .
\"urn:uuid:4008b506-9263-48b4-9452-c253d4230e9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RoundClosestFn, (1))) .
\"urn:uuid:e7e1c2a7-3747-46d8-9694-aec94f74a16f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundDownFn, UnaryFunction)) .
\"urn:uuid:1f2c85cd-a2ba-4eed-bcfe-934fd9223e1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundDownFn, EvaluatableFunction)) .
\"urn:uuid:26ef3b18-00e3-4912-b528-9a8299ade86b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RoundDownFn, ScalarInterval)) .
\"urn:uuid:df94ac07-41cc-46fa-969e-bc2409288d5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RoundDownFn, ScalarInterval)) .
\"urn:uuid:33b92f1f-cc1d-45fa-a884-e0b381496d31"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RoundDownFn, (1))) .
\"urn:uuid:a098e4fe-8582-444d-9f9b-e4dd107e7245"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundUpFn, UnaryFunction)) .
\"urn:uuid:bd5ec844-65f8-4809-a851-75a1eeb336d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RoundUpFn, EvaluatableFunction)) .
\"urn:uuid:17d95705-19be-4ee8-b138-c03a456cdb8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(RoundUpFn, ScalarInterval)) .
\"urn:uuid:55af3942-5c74-4296-ab15-2b265008d665"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(RoundUpFn, ScalarInterval)) .
\"urn:uuid:38eb50d4-74b5-47de-bdf5-7e9a0be852b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(RoundUpFn, (1))) .
\"urn:uuid:36f8517a-4bc9-49df-b5ea-eefba2ecd200"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(RuleTemplate, Collection)) .
\"urn:uuid:4d104755-fc0f-47ae-9356-3f2a3f5bbc30"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(RuleTemplate, Individual)) .
\"urn:uuid:ad394024-8421-4437-92aa-fc91bbc86387"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Saturday, DayOfWeekType)) .
\"urn:uuid:55c7591a-042a-41a4-a447-9a0570f73719"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Saturday, Individual)) .
\"urn:uuid:b7519eff-e68b-4904-9819-5c3f0a332793"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Saturday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:3220f97f-1d5d-4868-98e6-8e250f81d06a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ScalarIntegralValue, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b4d9afe0-8034-4685-a38c-46b51fe1e891"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ScalarIntegralValue, ScalarPointValue)) .
\"urn:uuid:e988a50a-847e-498d-81e7-cee01ac74d63"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ScalarInterval, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:9c8cbf36-3e37-46f2-bd7d-42cebd30e864"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ScalarInterval, Individual)) .
\"urn:uuid:9e29a00d-89bd-40b7-8af0-9519c1d72c62"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(ScalarInterval, SubLSymbolFn(("IBQE?"^^_string)))) .
\"urn:uuid:7756eccd-58e1-4aa7-9eab-dc09aef61fc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ScalarPointValue, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:83cee1e2-ae8c-4031-8783-0eff30bfc236"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ScalarPointValue, ScalarInterval)) .
\"urn:uuid:04f985be-59e5-4f7b-8d9c-f4a41370efa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(ScalarPointValue, SubLSymbolFn(("SCALAR-POINT-VALUE?"^^_string)))) .
\"urn:uuid:b78b5908-cb98-4686-a2e5-35a3ec74a84d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ScopingRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ebbac8e2-046e-4dc9-8a29-653eb93452f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(ScopingRelation, Relation)) .
\"urn:uuid:c7f5896a-1f00-4839-98e4-6d178c7a4751"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SententialRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5e466101-297c-40cd-8f0f-a6331d15719f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SententialRelation, TruthFunction)) .
\"urn:uuid:a6a132a1-5420-4751-ba84-773b8a6f926d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(September, MonthOfYearType)) .
\"urn:uuid:4cd86f56-7ff8-4333-a200-52175a64c8f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(September, Individual)) .
\"urn:uuid:e6793547-e737-42e7-a8fb-32ae92751442"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Set-Mathematical', AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:507a439b-718c-4ca2-8fbc-0b3be43b171c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls('Set-Mathematical', SetOrCollection)) .
\"urn:uuid:aa1fbb9b-4515-4365-9926-0229d68111ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnNecessary('Set-Mathematical', SubLSymbolFn(("CYC-SET-OF-TYPE-NECESSARY"^^_string)))) .
\"urn:uuid:d9824a08-c687-4f34-9b11-005781694844"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SetOrCollection, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:06e07681-5ba6-4990-bfe5-659f8e419a13"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SetOrCollection, Thing)) .
\"urn:uuid:19ebc854-f5ec-4ced-900c-df4cae8911b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SetTheFormat, Format)) .
\"urn:uuid:70223d99-578a-4cd5-8b9c-e84eeeb0212c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SetTheFormat, WFFSupportedTerm)) .
\"urn:uuid:eb100373-dd8e-4a97-8297-1beaf8318d00"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SiblingDisjointAttributeType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b8e30443-1bdf-440f-ac3f-3bbbce436d30"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SiblingDisjointAttributeType, Collection)) .
\"urn:uuid:4307435a-64b7-4e5d-92fa-d3fb53d7cb9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SiblingDisjointCollectionType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:46081fad-c8ef-48a7-939b-f45ab7d5550b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SiblingDisjointCollectionType, Collection)) .
\"urn:uuid:1b52868d-6ee1-4a84-a187-b6df7968c4a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SingleEntry, Format)) .
\"urn:uuid:4492eae1-3535-43e2-ba09-95ea491e64e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SingleEntry, WFFSupportedTerm)) .
\"urn:uuid:10c33934-bcfb-4f61-92c9-95e15b03f570"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFuncN, Collection)) .
\"urn:uuid:e03ff773-bd99-42b1-8194-7fa80f8673d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SkolemFuncN, SkolemFunction)) .
\"urn:uuid:68941920-87aa-4811-a286-98cc1396c729"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFuncNFn, QuaternaryFunction)) .
\"urn:uuid:cca468e7-6657-475d-818d-86214d4d5bcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(SkolemFuncNFn, NonNegativeScalarInterval)) .
\"urn:uuid:84584590-0a72-4865-8827-38708f7cf328"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(SkolemFuncNFn, SubLList)) .
\"urn:uuid:bbd8df44-3247-427a-bf15-7293f63ad8b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(SkolemFuncNFn, CycLVariable)) .
\"urn:uuid:4ebbabd5-8d5c-44c8-9a65-dd4e7e6adb81"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(SkolemFuncNFn, SubLSymbol)) .
\"urn:uuid:12a23aff-9913-4c57-a4be-cc0761fdc29b"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(SkolemFuncNFn, Thing)) .
\"urn:uuid:37f9c075-4933-4b39-abea-182289fd9f21"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(SkolemFuncNFn, (4))) .
\"urn:uuid:d9915017-cd34-4b0d-9ba8-2618ae87bf72"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d2d5e4a1-b4a3-455e-af36-dd9c63ac1fdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SkolemFunction, ReifiableFunction)) .
\"urn:uuid:217214b3-fe73-4ead-83c8-2dc150327abf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SkolemFunction, IndeterminateTermDenotingFunction)) .
\"urn:uuid:ee088823-01a2-45a0-8ffb-ec0d840f9ccb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFunctionFn, ReifiableFunction)) .
\"urn:uuid:cf041834-8505-4ddb-8f59-02ac0f62495c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFunctionFn, ReformulatorIrrelevantFORT)) .
\"urn:uuid:1545df79-67e5-4339-bcfd-42ab3f5a02de"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SkolemFunctionFn, TernaryFunction)) .
\"urn:uuid:6b479c72-0dc4-4e60-8744-d18c57e1b3ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(SkolemFunctionFn, SubLList)) .
\"urn:uuid:4e3589f3-8094-4352-b06f-edf2a13e2e57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(SkolemFunctionFn, CycLVariable)) .
\"urn:uuid:dd9f132e-4263-477e-84a1-1b421a02b33a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(SkolemFunctionFn, SubLSymbol)) .
\"urn:uuid:628a928b-8025-485d-8529-d4064d12b6e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(SkolemFunctionFn, Thing)) .
\"urn:uuid:d60ae4e0-6cc0-4c4a-821f-24b2f50a9f23"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(SkolemFunctionFn, (3))) .
\"urn:uuid:1c3366bd-e1d1-43e7-a18a-eca48e64598c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SortFn, EvaluatableFunction)) .
\"urn:uuid:727dd0c3-6059-4dee-91a5-a47a7e4da6c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SortFn, TernaryFunction)) .
\"urn:uuid:7b769e42-10ef-4b11-95b6-a71cf6032205"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(SortFn, SetOrCollection)) .
\"urn:uuid:bb9265a1-fdf3-472e-858f-8e5d857018a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(SortFn, BinaryPredicate)) .
\"urn:uuid:0b95651e-b476-43db-8b93-2e4070e49488"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(SortFn, UnaryFunction)) .
\"urn:uuid:7bbe83d6-00cc-4655-9aa1-0fa126d620c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(SortFn, List)) .
\"urn:uuid:d9573fe5-9e2e-43e0-b523-52c2dcfae860"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(SortFn, (3))) .
\"urn:uuid:51c05f36-83ed-4fe3-a10b-724c3e9f2a93"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLAtom, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:1c6acff5-559d-4ecf-801b-d84f2326bebc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLAtom, SubLExpressionType)) .
\"urn:uuid:4e47ca2d-cc66-4473-9e1d-8a7121f901ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLAtom, CycLTerm)) .
\"urn:uuid:e2fa94e0-4b6a-498f-a884-f5ac239c5657"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLAtom, SubLSymbolFn(("CYC-SYSTEM-ATOM"^^_string)))) .
\"urn:uuid:d1fb01e7-fdc4-4ee2-9033-d9a336089a8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLAtomicTerm, CycLExpressionType)) .
\"urn:uuid:03999305-4657-41a7-bc5b-76540939ecb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLAtomicTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3d50433e-da9d-403a-a83f-24eff25f6533"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLAtomicTerm, CycLClosedAtomicTerm)) .
\"urn:uuid:66af2c72-1ecc-451f-89b5-57493e94ceba"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLAtomicTerm, SubLSymbolFn(("CYC-SYSTEM-TERM-P"^^_string)))) .
\"urn:uuid:5fb6634c-2c39-416d-95d2-8c316ad7d852"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLCharacter, CycLExpressionType)) .
\"urn:uuid:9a4fa469-d33a-41a2-a545-8684a82a34d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLCharacter, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5bb66a67-a8b0-42f8-8ed6-0aaa75fd79e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLCharacter, SubLAtomicTerm)) .
\"urn:uuid:dcc0db40-3d8a-47f8-8f70-21e800175fb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLCharacter, Thing)) .
\"urn:uuid:3423dedd-e466-484c-94fa-86a5f36d4a0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLCharacter, SubLSymbolFn(("CYC-SYSTEM-CHARACTER-P"^^_string)))) .
\"urn:uuid:43cdb11c-ad03-42b5-8b79-d71537e92eb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLExpressionType, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:5f85a0b0-ca7a-4192-a15c-635e62a58eee"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLExpressionType, Collection)) .
\"urn:uuid:671b2fec-c47c-4732-807b-4d84ac309f29"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLInteger, CycLExpressionType)) .
\"urn:uuid:bd84f9b0-acfa-4a93-a65c-b7e020081bc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLInteger, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8602aa88-cb9c-411e-b639-71a2af7b4c10"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLInteger, SubLRealNumber)) .
\"urn:uuid:a8b89431-7bc0-4350-a911-f0da25806180"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLInteger, SubLSymbolFn(("CYC-SYSTEM-INTEGER"^^_string)))) .
\"urn:uuid:7f545ad7-85b6-4320-90c8-90b8d760a234"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLKeyword, CycLExpressionType)) .
\"urn:uuid:a8391b2d-3b4d-4ae7-bb60-1852429c7c17"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLKeyword, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:a53e185c-ddb1-46e7-8107-24cd9a338c33"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLKeyword, Thing)) .
\"urn:uuid:046235e9-7733-4b42-9116-bafaace73674"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLKeyword, SubLNonVariableSymbol)) .
\"urn:uuid:bce70b3f-5d32-4f2e-a268-c467b8fdb97f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLKeyword, SubLSymbol)) .
\"urn:uuid:461a7d64-bba2-4672-8a1a-8352fcbc56b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLKeyword, SubLSymbolFn(("KEYWORDP"^^_string)))) .
\"urn:uuid:15a3e7dc-833d-4a10-8c21-ed611e432e60"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLList, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:379b9b45-1f1e-4aa6-ab63-811d5eb83c19"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLList, SubLExpressionType)) .
\"urn:uuid:7dcce90d-bf46-4678-86be-a3d693d5db45"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLList, CycLTerm)) .
\"urn:uuid:ee9db28a-4d36-44cd-a06c-93f5b6dd471a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLList, SubLSymbolFn(("LISTP"^^_string)))) .
\"urn:uuid:6e45d1a9-e8ae-4127-8abb-0d7a069e6d42"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonNegativeInteger, CycLExpressionType)) .
\"urn:uuid:24468b9f-b84c-4ac6-ab4f-b7a5c7880bb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonNegativeInteger, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:71707f4f-6bbd-49b2-bf91-707bfd694496"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonNegativeInteger, CycLExpression)) .
\"urn:uuid:1764a434-f936-4e1f-a79f-8c88806c17d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonNegativeInteger, SubLInteger)) .
\"urn:uuid:cdc5e521-7a4d-4697-ae30-6678c67ded0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLNonNegativeInteger, SubLSymbolFn(("CYC-NON-NEGATIVE-INTEGER"^^_string)))) .
\"urn:uuid:98856c58-8c6c-4d62-9bce-1fe513981f35"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonVariableNonKeywordSymbol, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3f436193-3772-4cb9-96ff-dbfdc9858dd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonVariableNonKeywordSymbol, CycLExpressionType)) .
\"urn:uuid:e4bb4dc0-af61-4ff6-9bbc-8524d1996501"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonVariableNonKeywordSymbol, SubLNonVariableSymbol)) .
\"urn:uuid:748396be-d5c4-4324-af45-c45ce48b346e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLNonVariableNonKeywordSymbol, SubLSymbolFn(("SUBL-NON-VARIABLE-NON-KEYWORD-SYMBOL-P"^^_string)))) .
\"urn:uuid:84e6a0cb-4d2b-44be-a3be-060ab8000418"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonVariableSymbol, CycLExpressionType)) .
\"urn:uuid:37c07a46-a088-434c-b4da-deacf28fdf8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLNonVariableSymbol, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:f36a86c7-acb2-430d-98eb-1c2c89f96d6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonVariableSymbol, SubLSymbol)) .
\"urn:uuid:5704a1a8-f18b-4d8c-a284-98c6734f4c5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonVariableSymbol, SubLAtomicTerm)) .
\"urn:uuid:e06ead92-4913-49ef-af2a-debbf1ef11c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLNonVariableSymbol, Thing)) .
\"urn:uuid:73d3484d-2ff7-4e68-9331-41570dd8ba56"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLNonVariableSymbol, SubLSymbolFn(("CYC-SYSTEM-NON-VARIABLE-SYMBOL-P"^^_string)))) .
\"urn:uuid:612e7951-0ece-4533-affe-85eaede4b05e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLPositiveInteger, CycLExpressionType)) .
\"urn:uuid:1da5bb81-d78c-4a44-9671-ef92e19562ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLPositiveInteger, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8a72ee0d-615d-4d1e-b6b3-85b1b8dc836c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(SubLPositiveInteger, InferenceSupportedCollection)) .
\"urn:uuid:da4e1148-4a09-494f-9670-e1bebab21bbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLPositiveInteger, SubLNonNegativeInteger)) .
\"urn:uuid:c5232777-a22a-4e5e-abe1-6c78053b0454"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLPositiveInteger, SubLInteger)) .
\"urn:uuid:67f58d07-db17-45bc-8abd-7fc62ddb062e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLPositiveInteger, SubLSymbolFn(("CYC-POSITIVE-INTEGER"^^_string)))) .
\"urn:uuid:8fcc8f4c-6be0-4176-8160-6fb7884cd75c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLQuoteFn, UnaryFunction)) .
\"urn:uuid:c9c806fe-be7e-4d08-b8f8-d6b485233d60"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLQuoteFn, UnreifiableFunction)) .
\"urn:uuid:6a89ca1d-8e00-4182-98dd-d723fa40f6a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(SubLQuoteFn, SubLSExpression)) .
\"urn:uuid:40ca081a-71f1-4f9b-8e1a-5e3d15566fa0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(SubLQuoteFn, (1))) .
\"urn:uuid:347e7f3d-7e95-4000-a6bc-0898879153ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLRealNumber, CycLExpressionType)) .
\"urn:uuid:5d8c69e7-06f9-49b3-b322-51a4c7c06e21"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLRealNumber, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:0bda2e40-ec41-4fe8-9d1f-286874bcb237"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLRealNumber, SubLAtomicTerm)) .
\"urn:uuid:ae95d477-475c-4396-a980-b850a4168437"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLRealNumber, SubLAtom)) .
\"urn:uuid:3c8c6236-8b8c-4a82-bf1d-86b429156cda"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLRealNumber, SubLSymbolFn(("CYC-SYSTEM-REAL-NUMBER-P"^^_string)))) .
\"urn:uuid:38b42cc7-baf6-4cba-a3da-de57cf3101a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLSExpression, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:d524f26f-84f4-4a9d-90e9-67bf4ec5a0c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLSExpression, SubLExpressionType)) .
\"urn:uuid:81a3b4cc-8b07-4095-a37e-4895ef67880d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLSExpression, CharacterString)) .
\"urn:uuid:c009ca6e-3df8-44d8-8444-4297ba17485b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLSExpression, SubLSymbolFn(("CYC-SUBL-EXPRESSION"^^_string)))) .
\"urn:uuid:f1c3be3d-b1c9-4b9b-bfda-8ac921120661"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLString, CycLExpressionType)) .
\"urn:uuid:ff5a0246-69af-43a0-b112-ceae3dc8905c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLString, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:6a221dbd-6554-4921-9099-7d1068cf6a72"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLString, SubLAtomicTerm)) .
\"urn:uuid:8bf192a2-a5ea-4ec3-b0dc-d3488f811d64"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLString, SubLAtom)) .
\"urn:uuid:fc399bd8-4619-46dc-a83e-2c940835cea4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLString, SubLSymbolFn(("CYC-SYSTEM-STRING-P"^^_string)))) .
\"urn:uuid:5fe6eb55-d359-46b6-809c-af3f616d61c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLSymbol, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:86d2a5f4-685a-4f1b-a2dd-a974ad0098a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SubLSymbol, SubLExpressionType)) .
\"urn:uuid:bd9cfbcf-cd34-4f9a-85c8-acbbd03b4eb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLSymbol, CycLExpression)) .
\"urn:uuid:e6eb627e-22da-45a8-a412-5f83da7d62df"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLSymbol, Thing)) .
\"urn:uuid:72efb563-9bc3-43ab-b618-26c849507906"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SubLSymbol, SubLAtom)) .
\"urn:uuid:11067148-c275-4d50-b4ce-a16d46c11ab4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedDefnIff(SubLSymbol, SubLSymbolFn(("SYMBOLP"^^_string)))) .
\"urn:uuid:91bf0f42-9a61-459d-ba5a-26d18e7857fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Sunday, DayOfWeekType)) .
\"urn:uuid:38374847-f0e2-44ec-ac0b-a3fde20d3771"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Sunday, Individual)) .
\"urn:uuid:6e7d31c0-bf64-4748-b0bf-f828ac125170"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Sunday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:10b1aa87-82b2-47a8-9a27-44cf091eb3d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(SymmetricBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:aebf68a2-8c45-4df8-bdfc-486848949eeb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(SymmetricBinaryPredicate, 'RemovalModuleSupportedCollection-Generic')) .
\"urn:uuid:646c80ec-eda5-4180-9fab-6e7d0f4e90b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(SymmetricBinaryPredicate, TransformationModuleSupportedCollection)) .
\"urn:uuid:f5bf9253-72a7-4467-bd9f-9693b29c8694"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SymmetricBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:45a4dec8-1664-4911-90f9-e27fd7da205c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(SymmetricBinaryPredicate, CommutativeRelation)) .
\"urn:uuid:8b142665-e885-4234-8a98-0d828c64ff55"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLAssertionFn, BinaryFunction)) .
\"urn:uuid:7b831e3c-10b9-4b3e-8350-e4b8ff2becc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLAssertionFn, MicrotheoryDesignatingRelation)) .
\"urn:uuid:a9199de2-5f6d-4fbf-bbb9-645fa0ea451c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLAssertionFn, 'ELRelation-OneWay')) .
\"urn:uuid:93eebe89-ceed-429e-bd4b-04b582a1bee7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLAssertionFn, UnreifiableFunction)) .
\"urn:uuid:8e01fd13-d242-4197-a165-fe6a5769ce86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(TLAssertionFn, Microtheory)) .
\"urn:uuid:b1838b37-fe9e-483e-95f6-dcb9ba291136"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(TLAssertionFn, 'CycLSentence-Assertible')) .
\"urn:uuid:5c6fc2a6-a49b-4ba3-b5d7-dfc89a96a60a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TLAssertionFn, CycLAssertion)) .
\"urn:uuid:c5df04ee-c60b-4ca5-9d89-f1aff5ff0beb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(TLAssertionFn, (2))) .
\"urn:uuid:18659ce2-9d77-4fbd-8a92-7d1eb77b5a76"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLReifiedNatFn, UnaryFunction)) .
\"urn:uuid:9acfda56-81d7-4f7d-b61e-c6bc056ed1a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLReifiedNatFn, 'ELRelation-OneWay')) .
\"urn:uuid:9e80a95b-0ebf-41fb-9952-3285a29a09c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(TLReifiedNatFn, Thing)) .
\"urn:uuid:a228b016-598c-43ed-9906-1bd4b0f0c589"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TLReifiedNatFn, Thing)) .
\"urn:uuid:12240141-491f-4f4f-9cff-f1cc0f47ab01"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TLReifiedNatFn, CycLReifiableDenotationalTerm)) .
\"urn:uuid:57ddda3c-6bf1-4540-9b83-22cc184416b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(TLReifiedNatFn, (1))) .
\"urn:uuid:00111fbd-b8a9-4c7a-b185-40b901600add"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLVariableFn, BinaryFunction)) .
\"urn:uuid:bbf0f489-c192-4b42-8c1a-55c19f1d2cea"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLVariableFn, 'ELRelation-OneWay')) .
\"urn:uuid:227523a6-7a0f-49ac-b89b-385d78fac3c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TLVariableFn, UnreifiableFunction)) .
\"urn:uuid:35a4a26a-7c01-4d4b-85e7-ef9e3421c9a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(TLVariableFn, NonNegativeInteger)) .
\"urn:uuid:7f3974d2-161f-4719-b222-4783eff818f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(TLVariableFn, CharacterString)) .
\"urn:uuid:dc49a2c9-096b-4f21-b60c-c7c7c9948cf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(TLVariableFn, SubLString)) .
\"urn:uuid:b2894117-3cd1-4f98-b33b-288ded30905a"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TLVariableFn, Thing)) .
\"urn:uuid:9e99e56d-bf7d-4168-9fb4-3f92a4cd5a01"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TLVariableFn, SubLAtom)) .
\"urn:uuid:4ab26ecd-0167-4431-8dbb-981f64d4006b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(TLVariableFn, (2))) .
\"urn:uuid:b9f4ac39-55a7-4e6b-87e5-b839000e4091"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TemporaryEnglishParaphraseMt, Microtheory)) .
\"urn:uuid:3937cde8-97a5-4c20-bc61-f410d39e892a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TemporaryEnglishParaphraseMt, CycLTerm)) .
\"urn:uuid:b0dfc048-0ce9-490e-bfb6-2c6b68feed98"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(TemporaryEnglishParaphraseMt, EnglishParaphraseMt)) .
\"urn:uuid:cef03488-b5dc-4dfa-9ced-96721a0e9d45"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TernaryFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ce8a2358-7560-42f2-862b-8a592f94fd9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TernaryFunction, 'Function-Denotational')) .
\"urn:uuid:cd52c3f0-d524-450e-9ed0-15d7a7d1fe49"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TernaryFunction, TernaryRelation)) .
\"urn:uuid:523efb65-c55d-405b-811b-eacaa827f12a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TernaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ada5528d-3de0-4bd8-b7e0-18d5a4214978"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TernaryPredicate, PredicateTypeByArity)) .
\"urn:uuid:5e8fb2ca-05fb-4569-9f51-757c4e8bb5ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TernaryPredicate, TernaryRelation)) .
\"urn:uuid:c5882bed-c25f-452b-b14f-0d3579b81529"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TernaryPredicate, Predicate)) .
\"urn:uuid:6b3ac245-a80b-4974-b664-3cdcc2f22f80"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TernaryRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:062069b3-cd41-420c-8046-f59874755295"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TernaryRelation, FixedArityRelation)) .
\"urn:uuid:d60474b1-d9ad-4da2-9d9c-20e362f7168d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheCollectionOf, BinaryFunction)) .
\"urn:uuid:79350bfa-0a87-4dde-aefb-73c8f17c879b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheCollectionOf, CollectionDenotingFunction)) .
\"urn:uuid:de1fe196-6461-4142-a33b-1857c3c15877"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheCollectionOf, ReifiableFunction)) .
\"urn:uuid:866ee49f-991c-4a2d-a36f-637899c4d912"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheCollectionOf, ScopingRelation)) .
\"urn:uuid:632f40a1-478e-4aaa-9243-164370b527a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(TheCollectionOf, InferenceSupportedTerm)) .
\"urn:uuid:0029fd4e-96f2-44e0-9389-7b7f87e1a852"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(TheCollectionOf, CycLVariable)) .
\"urn:uuid:1630b76e-462a-4edd-aeb3-3a9d1d708ee0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(TheCollectionOf, 'CycLSentence-Askable')) .
\"urn:uuid:08ff3126-b2f9-4238-9161-8d3d17b39a56"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TheCollectionOf, Collection)) .
\"urn:uuid:91c595c0-18cf-4735-979a-700e22c340de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(TheCollectionOf, (2))) .
\"urn:uuid:c1c9c02a-dc1d-45d2-bbdd-bb5394de82a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheEmptyList, List)) .
\"urn:uuid:f20b6eae-0d14-4832-8c28-857c8c276480"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheEmptySet, 'Set-Mathematical')) .
\"urn:uuid:b02f814e-2457-4772-914b-171ff264da14"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheList, UnreifiableFunction)) .
\"urn:uuid:449c5c39-e02c-4e2c-a190-b0da2019feac"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheList, VariableArityRelation)) .
\"urn:uuid:010811cc-fe70-4728-b8e2-ed1d47211232"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(TheList, Thing)) .
\"urn:uuid:fc1b8906-1b8d-4746-91b4-d7b42f4406cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TheList, List)) .
\"urn:uuid:619c7980-2d5e-4007-8137-5d24172d8b1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSet, CommutativeRelation)) .
\"urn:uuid:920d03d0-2377-4c3a-b7de-b5ecce9bfef4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSet, UnreifiableFunction)) .
\"urn:uuid:f9cd71a3-7f3c-4bca-a1a4-e8c280e0ab8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSet, VariableArityRelation)) .
\"urn:uuid:cfffaa54-2375-4e9a-b3b2-7a584e6f978f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(TheSet, Thing)) .
\"urn:uuid:c1b354b7-5fd4-4774-a18a-2f3d897cb4f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TheSet, 'Set-Mathematical')) .
\"urn:uuid:09016338-0750-41b8-8024-d4f8a875fbe3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(TheSet, (0))) .
\"urn:uuid:9ded7248-542c-4f29-b273-ea03d61dc0bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSetOf, UnreifiableFunction)) .
\"urn:uuid:baf5f496-d48e-4478-bc98-f628409c13d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSetOf, ScopingRelation)) .
\"urn:uuid:ca5a61ee-1682-4a99-8efa-32c9a5b2b8c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheSetOf, BinaryFunction)) .
\"urn:uuid:2258d1e9-9abb-4718-98a7-23e988917572"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(TheSetOf, CycLVariable)) .
\"urn:uuid:87a24e00-9ca0-4e3c-8c61-c09267c3396a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(TheSetOf, 'CycLSentence-Assertible')) .
\"urn:uuid:2b387a21-3a3b-49ec-aa57-45424e62b0d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TheSetOf, 'Set-Mathematical')) .
\"urn:uuid:c0bd4de6-2998-4a46-8d5b-7856423afd6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(TheSetOf, (2))) .
\"urn:uuid:5ff1c963-fa06-4ab0-bd91-5144ca7db0dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheTerm, CycLExpressionType)) .
\"urn:uuid:3a8079ba-435e-492e-8c0d-f6723220a7aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheTerm, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:623c6774-3601-4b2f-9a75-8e7345313c54"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TheTerm, IndeterminateTerm)) .
\"urn:uuid:d9a65335-0a7f-4e14-b86a-566e0eb2bd7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheUser, Cyclist)) .
\"urn:uuid:df8d2a78-e2dd-475a-a58f-90093f09b97c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheUser, Individual)) .
\"urn:uuid:6839ec9f-9ee4-4345-8f74-2c94f51d477b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TheUser, HumanCyclist)) .
\"urn:uuid:afd8bce2-096e-4c3e-9f52-57731eb05a21"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(TheUser, TheTerm)) .
\"urn:uuid:c7657dea-e6b1-4878-a118-3dfe3fb1f261"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Thing, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:56ac127e-f7e8-4281-b6eb-f185e70c060e"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnIff(Thing, SubLSymbolFn(("TRUE"^^_string)))) .
\"urn:uuid:07f17032-3572-4c90-a1ab-345ad06ebd1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ThisInference, CycInference)) .
\"urn:uuid:0f70489a-86dd-47b5-bac9-465521c4e758"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ThisInference, IndeterminateTerm)) .
\"urn:uuid:ebd1e343-caeb-4eca-b81c-9eb148c95974"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ThisProblemStore, CycProblemStore)) .
\"urn:uuid:1571fb78-d2bf-4af4-9586-10104879ed0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ThisProblemStore, IndeterminateTerm)) .
\"urn:uuid:649c025b-e9df-462d-ae7b-88dca4fdb4d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Thursday, DayOfWeekType)) .
\"urn:uuid:73ca83cb-9826-4678-8ab7-3a6d13a6099a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Thursday, Individual)) .
\"urn:uuid:29b6541e-9d1f-42ad-9f33-2248e8cd550e"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Thursday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:b1c13a8a-97fb-4848-9639-52555942079b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TimesFn, CommutativeRelation)) .
\"urn:uuid:a64c2ce7-4ac7-4abe-bdd8-ec227bb67a6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TimesFn, AssociativeRelation)) .
\"urn:uuid:f86758ae-8fdc-4b1c-b744-05b2ebed8372"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TimesFn, EvaluatableFunction)) .
\"urn:uuid:dcc098d3-5957-43ec-886b-224271971763"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TimesFn, VariableArityRelation)) .
\"urn:uuid:b04ad787-c1b7-4d3d-8a83-b780ec9b52df"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(TimesFn, ScalarInterval)) .
\"urn:uuid:5d7453e8-9b73-4086-87b8-b4591bef4240"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(TimesFn, ScalarInterval)) .
\"urn:uuid:2f2c5124-831b-4c8c-b619-bf588cb0f23c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(TimesFn, (1))) .
\"urn:uuid:6ba7875d-92d0-4202-acbb-518358a19de6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TransformationModuleSupportedCollection, Collection)) .
\"urn:uuid:1206aecd-cc0e-4b6d-8a11-ddd06af2a929"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TransformationModuleSupportedCollection, CycLExpressionType)) .
\"urn:uuid:57656fa5-19c5-492c-96d0-7abf07e564a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TransformationModuleSupportedCollection, InferenceSupportedCollection)) .
\"urn:uuid:2f9e2789-2250-4353-a76b-c7291e4d39f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TransformationModuleSupportedPredicate, Collection)) .
\"urn:uuid:5be9c303-b6a2-47f3-beb2-8e8370142162"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TransformationModuleSupportedPredicate, CycLExpressionType)) .
\"urn:uuid:c551aea9-f5a7-4406-8543-23e1314ba2e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TransformationModuleSupportedPredicate, InferenceSupportedPredicate)) .
\"urn:uuid:b261fa1b-c2c4-469d-a6cc-3f6b38ae84f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TransformationModuleSupportedPredicate, CycLTerm)) .
\"urn:uuid:d0f9e6cc-999a-494a-b21c-ea81826344ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TransitiveBinaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b9248e52-5354-47c3-a658-a48ad415ff99"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(TransitiveBinaryPredicate, 'RemovalModuleSupportedCollection-Generic')) .
\"urn:uuid:b66a32e1-f9d8-450c-972e-a4fbfc3a7696"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TransitiveBinaryPredicate, BinaryPredicate)) .
\"urn:uuid:6f8afff7-5f58-4627-8864-76b80b0be83e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(True, TruthValue)) .
\"urn:uuid:63830e90-d16e-4ab0-b39b-6883c16277f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(True, CycLTruthValueSentence)) .
\"urn:uuid:82a7d888-8d70-44e0-8b71-8e52ba3d200a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(True, 'CycLSentence-Assertible')) .
\"urn:uuid:869a6fa0-eada-4ab1-b05b-6fdf63cfadd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TruthFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:b9ac90b9-a5b8-41d9-880b-37806fe474ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TruthFunction, Relation)) .
\"urn:uuid:2891752b-b8a9-41ce-915c-ec1b748caf14"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(TruthValue, Collection)) .
\"urn:uuid:917ff3c4-ecaa-46e3-9761-3e1079f8a298"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(TruthValue, Individual)) .
\"urn:uuid:aee4c8ee-99b7-4fe5-a673-2cb7941c9beb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Tuesday, DayOfWeekType)) .
\"urn:uuid:1e7f81da-43d1-4a23-be4d-afd122d0c576"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Tuesday, Individual)) .
\"urn:uuid:65508652-a321-46ee-be54-10e5ad6f7343"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Tuesday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:9f53c935-904a-480e-ab94-5eeb4550b220"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnaryFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:74056bb3-0f73-4df0-964e-318b88f582cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnaryFunction, 'Function-Denotational')) .
\"urn:uuid:a5b32d95-ae5d-49fb-bf9a-d98fa01ce725"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnaryFunction, UnaryRelation)) .
\"urn:uuid:42f4bcbb-9e60-4887-a46c-a4f8cd325571"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnaryPredicate, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:dd967178-8918-42e3-9be9-7c99f41ab80b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnaryPredicate, PredicateTypeByArity)) .
\"urn:uuid:2e7c1323-3cc5-40ce-b5ec-a669abfef174"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnaryPredicate, Predicate)) .
\"urn:uuid:72ad735e-aa1d-419a-a45c-62fad7fa7cc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnaryPredicate, UnaryRelation)) .
\"urn:uuid:3ce97a3b-5c1e-455f-b266-908b3e2d9cd2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnaryRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:a1af02df-d30f-4400-8b31-dd3b7875a80a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnaryRelation, FixedArityRelation)) .
\"urn:uuid:872a279d-b1a6-4363-af7a-96390b426b1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UncanonicalizerAssertionFn, UnaryFunction)) .
\"urn:uuid:c5a1ec10-9a4a-4384-93f1-3380d2f67542"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UncanonicalizerAssertionFn, UnreifiableFunction)) .
\"urn:uuid:f3fd51ef-3d4c-4698-908b-bbd0cdc68554"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(UncanonicalizerAssertionFn, CycLNonAtomicTerm)) .
\"urn:uuid:9f4a72a5-5fdc-4c08-a2f2-b30598caf67d"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(UncanonicalizerAssertionFn, CycLAssertion)) .
\"urn:uuid:0e7edeaf-6ddd-4851-aa64-60a67a702f37"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(UncanonicalizerAssertionFn, (1))) .
\"urn:uuid:0a84cef6-d8f2-432c-b36d-cfc4f7633c13"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnitOfMeasure, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:bbb75f5f-d51e-44aa-acbd-73cb85845656"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnitOfMeasure, UnreifiableFunction)) .
\"urn:uuid:b28f4684-b14c-4319-b864-4a63effdcb0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnitOfMeasure, VariableArityRelation)) .
\"urn:uuid:18dfbac6-9b55-4cbc-a7b4-33a47a770f8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnitProductFn, ReifiableFunction)) .
\"urn:uuid:ed16e69a-a1cd-4667-99af-e09b0c19ae32"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnitProductFn, CommutativeRelation)) .
\"urn:uuid:7d77109c-556a-464b-9774-599ca059addf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnitProductFn, BinaryFunction)) .
\"urn:uuid:366dcc59-7e63-4073-8b5f-237e88b03ba8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnitProductFn, AssociativeRelation)) .
\"urn:uuid:66ab4d38-d26d-4f9d-a01f-93dcaf715430"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(UnitProductFn, UnitOfMeasure)) .
\"urn:uuid:e74ec239-1549-4a02-a896-9a5b4f69c4a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(UnitProductFn, UnitOfMeasure)) .
\"urn:uuid:31eec643-287f-4685-8d84-9fb18cc3be66"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(UnitProductFn, UnitOfMeasure)) .
\"urn:uuid:1433dbdc-b8e3-4bde-884a-ec5ef0991e63"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(UnitProductFn, (2))) .
\"urn:uuid:fbf1b7f5-007d-4063-ba87-617cbf5ae74d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Unity, UnitOfMeasure)) .
\"urn:uuid:59210758-d6e4-4bc3-bc9e-cb57a1bf7091"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(Unity, ScalarInterval)) .
\"urn:uuid:4e11a809-c91e-45b0-8798-2be8529d0fc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsa(Unity, ScalarInterval)) .
\"urn:uuid:f57834a3-8814-4b7a-9e55-e49de0cf984b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(Unity, (1))) .
\"urn:uuid:65193127-4f7f-4c1a-b50f-1d1661a34f98"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMax(Unity, (2))) .
\"urn:uuid:7e5535db-96a3-4c80-9764-f2734c95b38b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UniversalVocabularyImplementationMt, Microtheory)) .
\"urn:uuid:9d3190e4-5a5b-4f7c-aed1-f3c6d999336c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyImplementationMt, UniversalVocabularyMt)) .
\"urn:uuid:e703e14a-3a79-47cd-bf6b-ef217f222340"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyImplementationMt, CoreCycLImplementationMt)) .
\"urn:uuid:06e1561e-8d05-407a-a967-d175866998e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyImplementationMt, BaseKB)) .
\"urn:uuid:4e2f83cf-5eb7-4bd0-ac47-36f740fbb518"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UniversalVocabularyMt, BroadMicrotheory)) .
\"urn:uuid:839af3f4-66f7-44f9-ba38-b15eeef25e6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyMt, BaseKB)) .
\"urn:uuid:7749e6b5-767b-45f9-b462-c8c2372a5032"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyMt, UniversalVocabularyImplementationMt)) .
\"urn:uuid:2e40c907-9f85-4efe-9bed-026fddd95b51"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(UniversalVocabularyMt, CoreCycLImplementationMt)) .
\"urn:uuid:32be8402-d895-4bee-98d1-6c0acde4c789"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Unknown-HLTruthValue', Individual)) .
\"urn:uuid:807a6c2c-f85c-46ad-b23c-972f43b6405d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('Unknown-HLTruthValue', CycHLTruthValue)) .
\"urn:uuid:2856d02a-0207-447a-83a6-ec5f23ed07a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnknownScalarInterval, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8d23d598-cea7-48ab-a558-25568f5bd5dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnknownScalarInterval, ScalarInterval)) .
\"urn:uuid:9c5f8bf5-6a9f-4e84-9498-1260de4bd91e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(UnreifiableFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:cb7b80d5-1555-44bc-91e3-17e3e4af3799"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(UnreifiableFunction, 'Function-Denotational')) .
\"urn:uuid:5a7eea1d-5616-4ad0-8b03-947461332acd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(VariableArityRelation, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:c0712efe-8446-4774-af3e-f548cfcd869c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableArityRelation, Relation)) .
\"urn:uuid:4885e1cb-cc5c-4934-a4af-7f28be0a931e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(VariableAritySkolemFuncN, Collection)) .
\"urn:uuid:035a6ab5-ad1c-4b91-a87e-186e2aa806cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableAritySkolemFuncN, SkolemFuncN)) .
\"urn:uuid:31bdb5a0-3274-4e2d-a57c-6fde4ca4f0ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableAritySkolemFuncN, VariableAritySkolemFunction)) .
\"urn:uuid:e9b45026-2ca3-47ea-ad55-7d608257032e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableAritySkolemFuncN, VariableArityRelation)) .
\"urn:uuid:94c0d742-b144-47ca-ae1a-3d6f45060a95"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(VariableAritySkolemFunction, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:8f24929c-c779-4a67-b17c-16dffb11d31e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableAritySkolemFunction, VariableArityRelation)) .
\"urn:uuid:84cee965-f6b0-4cf0-b477-113ecb976338"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(VariableAritySkolemFunction, SkolemFunction)) .
\"urn:uuid:c8ec2e7c-b53f-4990-8fec-75a05c91f956"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(WFFConstraintPredicate, Collection)) .
\"urn:uuid:7b677a4a-6af4-488e-ba55-08a7d58131c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(WFFConstraintPredicate, WFFSupportedPredicate)) .
\"urn:uuid:84646f4d-0831-4a5c-bc17-9ae0a3bf9de0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(WFFConstraintSatisfactionPredicate, Collection)) .
\"urn:uuid:90001f36-3049-4b64-8449-99a51c1f1bdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(WFFConstraintSatisfactionPredicate, WFFSupportedPredicate)) .
\"urn:uuid:4e6a96ad-d798-40db-b75a-64f3f2bf6fa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(WFFDirectivePredicate, Collection)) .
\"urn:uuid:c40677c5-e16f-49b0-a1c0-9d2032d59fe3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(WFFDirectivePredicate, WFFSupportedPredicate)) .
\"urn:uuid:80a58c0f-9b58-4892-9caf-7351ba178a7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(WFFSupportedPredicate, Collection)) .
\"urn:uuid:3b8c29e0-50af-4a1a-864f-939affa23045"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(WFFSupportedPredicate, WFFSupportedTerm)) .
\"urn:uuid:cac20a42-746a-481b-9532-0db1fe5afc76"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(WFFSupportedTerm, Collection)) .
\"urn:uuid:2a371d40-9041-4408-b29a-21ceead8e243"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(Wednesday, DayOfWeekType)) .
\"urn:uuid:0ff6144e-97c4-4a05-b5cb-92f5b8a8a685"[silk#strict] .
istAsserted(UniversalVocabularyMt, genls(Wednesday, Individual)) .
\"urn:uuid:7c61818d-0b39-4916-bd32-9c3d4fcee702"[silk#strict] .
istAsserted(UniversalVocabularyMt, defnSufficient(Wednesday, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) .
\"urn:uuid:e16f3630-1684-4c90-a96f-dc421f86be78"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(abnormal, DefaultMonotonicPredicate)) .
\"urn:uuid:e5f04a7b-2b30-4f45-8e40-54fc9ed0814f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(abnormal, BinaryPredicate)) .
\"urn:uuid:3d5d8804-e77b-4277-990a-1a4e1c740c11"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(abnormal, List)) .
\"urn:uuid:eae5e2d3-dc6a-4013-ad3b-1153b162e633"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(abnormal, CycLAssertion)) .
\"urn:uuid:61d60d9b-15a5-4a88-9d29-66133932f13c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(abnormal, (2))) .
\"urn:uuid:7dcc5f10-f2d4-48aa-bf3c-93cda827347b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(admittedAllArgument, TernaryPredicate)) .
\"urn:uuid:f42a0fb3-78e1-4b78-83d3-b2598546c64b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(admittedAllArgument, Collection)) .
\"urn:uuid:4e15591d-19d3-4653-a098-518d10853865"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(admittedAllArgument, Thing)) .
\"urn:uuid:19b203b8-11c2-46db-a1c9-bc580b9f7fe5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(admittedAllArgument, PositiveInteger)) .
\"urn:uuid:0d751ab8-74d0-4798-813a-da7992e292c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(admittedAllArgument, Relation)) .
\"urn:uuid:bded09ee-7190-4219-90ec-3ea4bd32c4c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(admittedAllArgument, (3))) .
\"urn:uuid:4353a7c6-96ec-418c-929b-4f72066c6d6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(admittedArgument, TernaryPredicate)) .
\"urn:uuid:f6001ea4-7074-447d-b168-d14134435029"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(admittedArgument, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:a782b860-1f63-4845-a35e-3ab5ae22ec75"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(admittedArgument, Thing)) .
\"urn:uuid:a5ff6d84-6e0e-4e59-9bd1-7337e20b69ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(admittedArgument, PositiveInteger)) .
\"urn:uuid:5e504e7e-b3db-49ec-977d-e215dfa2d833"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(admittedArgument, Relation)) .
\"urn:uuid:d4f9d437-a07d-46a9-8640-6b32bba8abbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(admittedArgument, (3))) .
\"urn:uuid:c6b3e952-146b-43ad-95fb-dcd202fb6805"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(admittedNAT, UnaryPredicate)) .
\"urn:uuid:7894dff1-b720-4fbf-a656-bd5bad71633a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(admittedNAT, Thing)) .
\"urn:uuid:aea28494-b107-431f-b4cb-ce8b68da8ea4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(admittedNAT, CycLNonAtomicTerm)) .
\"urn:uuid:9f8bc898-4b41-4b3e-bc6d-177ef8be7f3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(admittedNAT, (1))) .
\"urn:uuid:115657e8-7d3b-4c18-bb16-cadc0b21ff4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(admittedSentence, UnaryPredicate)) .
\"urn:uuid:4b1531d4-36bf-4ee4-a47b-1228b34a3136"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(admittedSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:4dd768a5-9f4c-4ead-9d39-02aeabbe4a32"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(admittedSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:fb871ab0-c7e7-4c33-bef0-c219bc7a9031"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(admittedSentence, (1))) .
\"urn:uuid:52b27cba-e092-4457-ac8e-d154ee6e807d"[silk#strict] .
istAsserted(BaseKB, isa(afterAdding, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:41394e30-eb30-48ed-95f0-c29233a43b13"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(afterAdding, BinaryPredicate)) .
\"urn:uuid:42f091e9-15f1-409d-9340-bd8d3706e80a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(afterAdding, Predicate)) .
\"urn:uuid:2c2c3555-bb37-4692-8411-4bbf7dcd9a57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(afterAdding, Predicate)) .
\"urn:uuid:56de78c9-7666-426d-8df6-7f7aa17bdc85"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(afterAdding, CycLNonAtomicTerm)) .
\"urn:uuid:29d1de68-b82e-4f87-921a-7a6d6f89ba1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(afterAdding, (2))) .
\"urn:uuid:b71d0b57-df8b-479c-9283-24d5768e9f35"[silk#strict] .
istAsserted(BaseKB, isa(afterRemoving, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:6ae4f53b-a416-4e59-9b9f-567eea8fd6f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(afterRemoving, BinaryPredicate)) .
\"urn:uuid:3d715227-4f7a-4985-873a-ce5e7e313e2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(afterRemoving, Predicate)) .
\"urn:uuid:32240b19-6cfc-4ea4-873f-512f8701f452"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(afterRemoving, CycLNonAtomicTerm)) .
\"urn:uuid:517e76b5-4933-4c4a-ac93-c249dfe5c893"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(afterRemoving, (2))) .
\"urn:uuid:bc6a49bb-72bf-4a7a-b341-4d0fad8cbf1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#and, LogicalConnective)) .
\"urn:uuid:2a90496e-d754-434e-9676-5690be94a52f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#and, VariableArityRelation)) .
\"urn:uuid:f4251f86-7fe0-4d87-8518-ee074b9f61c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#and, CommutativeRelation)) .
\"urn:uuid:94db03d6-f161-46ab-9805-823c98bcf9df"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#and, AssociativeRelation)) .
\"urn:uuid:08b3d7c1-cdef-41fa-932d-b854625ba197"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(cyc#and, 'CycLSentence-Assertible')) .
\"urn:uuid:8efc263e-3eb0-4570-9ca1-0969e7955e3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsQuotedIsa(cyc#and, 'CycLSentence-Assertible')) .
\"urn:uuid:a4448c93-9bcb-47d7-83f5-cc1f0ecc2b61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(cyc#and, (1))) .
\"urn:uuid:ea11d4df-d0d2-4e41-8ef1-9426a5628096"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Format, BinaryPredicate)) .
\"urn:uuid:66b10443-36a7-45a4-896f-9a8d3ddce630"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Format, ArgConstraintPredicate)) .
\"urn:uuid:1d21a611-da83-447c-8434-88716dd35336"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Format, WFFConstraintPredicate)) .
\"urn:uuid:c83038ec-f61b-4b0a-b0b0-6fd0d1e90255"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg1Format, Predicate)) .
\"urn:uuid:c049ae97-0874-4b7d-9627-908b78d65667"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg1Format, Individual)) .
\"urn:uuid:450644b5-57c3-475e-b622-eee2d2779f7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg1Format, (2))) .
\"urn:uuid:5acbc6c0-8c10-490d-91bb-a32ed972b0fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:0f75c35a-4a6b-4111-a721-e4f71e157cb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:0218afa5-5e7f-4d28-a973-0c0b49ce0eb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Genl, WFFConstraintPredicate)) .
\"urn:uuid:64df6200-e313-4f54-84cc-58107a1c2eef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg1Genl, Relation)) .
\"urn:uuid:b0ea9dfc-a417-4d2a-9070-e7d28de75fbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg1Genl, Collection)) .
\"urn:uuid:bccb83b9-8775-41ae-9fa5-96a60e820411"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg1Genl, Thing)) .
\"urn:uuid:2ed87898-9e6f-454a-89eb-d7dc21172f52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg1Genl, (2))) .
\"urn:uuid:d67e9887-5273-4f5b-9fbe-7f4599718e7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:0457ec89-864f-4369-bf13-8f73035b3dcb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:7b489042-b7ae-4af3-b958-c305577ae46c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1Isa, WFFConstraintPredicate)) .
\"urn:uuid:0eff351c-a87f-464f-b928-b8df6ddc498c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg1Isa, Relation)) .
\"urn:uuid:d0e4ed3c-a23c-4a23-beb8-c5878d4414ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg1Isa, Collection)) .
\"urn:uuid:4227bef1-c370-4b70-b9cb-9b7ca35b22c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg1Isa, Thing)) .
\"urn:uuid:0795c573-8adc-496a-91eb-a56b9f50ec89"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg1Isa, (2))) .
\"urn:uuid:7785652c-a8f9-4894-adc9-18140c5f94ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:e3e6fba1-3377-432f-b774-649197e42194"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:2a032667-a7b6-49ed-ae43-f2eaf12229d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:a7bdaec0-446f-4276-9197-ff1bfd8eec9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg1QuotedIsa, Relation)) .
\"urn:uuid:26104c52-3d47-4f04-9a22-21765e2219d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg1QuotedIsa, SubLExpressionType)) .
\"urn:uuid:4b9b7645-2495-401b-b476-8f7908650fdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg1QuotedIsa, SubLSExpression)) .
\"urn:uuid:b81a0b0f-1577-4d58-8237-fe7d21f2237d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg1QuotedIsa, (2))) .
\"urn:uuid:15520ead-10f1-4a77-8ad1-5323a0ccd4d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:ec0e632e-7c5f-440c-a732-1e0de2b824c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:cf96eb63-4047-4d12-ade6-89c978ad9e97"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:f64f58e8-76fd-4a23-92e3-88c794cfd4c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg1SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:ee609400-2868-4c8e-8d52-f6bcd93c7c7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg1SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:67ca0e11-e1c9-481c-9d94-4f4e901f8b4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg1SometimesIsa, Relation)) .
\"urn:uuid:fc41ad04-3923-419d-bbbf-49d43bb7c76d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg1SometimesIsa, Collection)) .
\"urn:uuid:bdd2db9d-b4a8-4eae-804c-84c0e2bb7d36"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg1SometimesIsa, Thing)) .
\"urn:uuid:19710202-e95d-414c-9cd7-610f667ba9ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg1SometimesIsa, (2))) .
\"urn:uuid:c36c08f2-da5b-4b19-861a-f7b0276afc4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Format, BinaryPredicate)) .
\"urn:uuid:c3984d2a-6854-4e52-ab9c-4fc063606fb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Format, ArgConstraintPredicate)) .
\"urn:uuid:38c547bf-df4a-482b-bda7-e760a1ef2f68"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Format, WFFConstraintPredicate)) .
\"urn:uuid:78471856-c0d5-454b-bd7a-629211b4b1a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg2Format, Predicate)) .
\"urn:uuid:276cac79-c4fd-45fa-89bb-f3d20fd0e3c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg2Format, Individual)) .
\"urn:uuid:b148483e-76f7-4b32-bc54-0a2ca76681b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg2Format, (2))) .
\"urn:uuid:b903c470-59f0-4b35-8606-efa2ee772675"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:10fad785-0197-40fe-a43c-5d8e8f726a40"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:32e30627-31f9-4c53-8df4-4e9e9c11ee32"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Genl, WFFConstraintPredicate)) .
\"urn:uuid:4a082d1d-b860-4852-98c5-b8e8b2b37005"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg2Genl, Relation)) .
\"urn:uuid:e17525e9-e6fa-461e-a707-973f0c3cbb10"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg2Genl, Collection)) .
\"urn:uuid:2e4f7d3b-26de-4e3c-a491-bed5d6e6beba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg2Genl, Thing)) .
\"urn:uuid:bdacecc0-abbd-46e9-94a5-20a2e3e8d505"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg2Genl, (2))) .
\"urn:uuid:8af2a7d0-32f2-4d8f-8fae-5e5ac0d83e8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:37890f59-3e95-453e-a32b-6553d953d682"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:11f5e35c-47dd-4243-9f30-3b77f06d2003"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2Isa, WFFConstraintPredicate)) .
\"urn:uuid:6490257c-e87e-47ab-afea-89f92f335e9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg2Isa, Relation)) .
\"urn:uuid:ac89ea12-526e-4a99-baf1-70536fdcc05f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg2Isa, Collection)) .
\"urn:uuid:5603b253-561a-4297-a70c-7bd4051ed5e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg2Isa, Thing)) .
\"urn:uuid:33abecc6-3a58-4ee8-8822-d0939d9edeca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg2Isa, (2))) .
\"urn:uuid:0f583a24-cf0d-4c0d-9c98-cfd15f812164"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:a697bd27-de08-4d28-b9c1-ce84682e6911"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:50caa9ce-04bc-4172-b329-dd449428c44d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:09d40b65-0fca-4d36-965c-5a16f6f07969"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg2QuotedIsa, Relation)) .
\"urn:uuid:9b413cfc-8b79-4bc9-ae90-114389305378"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg2QuotedIsa, SubLExpressionType)) .
\"urn:uuid:edd3d5ff-e150-4dd4-86e6-32fb010fdafd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg2QuotedIsa, SubLSExpression)) .
\"urn:uuid:d4570472-7f5b-4130-aed9-ba2f39147f50"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg2QuotedIsa, (2))) .
\"urn:uuid:f809c6dd-142d-4172-b21e-588863cd83fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:4bac8f62-cfd5-4047-a5fd-9ddad8f1f817"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:690d5c62-4a14-4805-90d4-e6149eb77658"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:bfa7eaa0-73b9-4595-b635-867f97525b9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg2SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:a4cfd11f-5932-451a-ba42-a9a6a12e83ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg2SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:f50af311-93f0-4f9c-97f9-c6a6c23edbef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg2SometimesIsa, Relation)) .
\"urn:uuid:cb56693c-c5c6-4141-993d-ddad6df53a3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg2SometimesIsa, Collection)) .
\"urn:uuid:fc311437-7fbb-4fd3-81db-c05213a25305"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg2SometimesIsa, Thing)) .
\"urn:uuid:e6189220-6331-4d7b-97c6-7f77e44affd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg2SometimesIsa, (2))) .
\"urn:uuid:7966abd2-8e2d-4efb-bd36-c506af894dfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Format, BinaryPredicate)) .
\"urn:uuid:a18119e9-78c0-4b3e-85d7-d6a47dbcee82"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Format, ArgConstraintPredicate)) .
\"urn:uuid:cfee7eb9-5feb-4106-9ec5-0442c4b60004"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Format, WFFConstraintPredicate)) .
\"urn:uuid:87834f6e-a4ea-4874-ba79-e399d3aebb68"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg3Format, Predicate)) .
\"urn:uuid:d4f38a99-f5cf-43f3-975f-12c627e86465"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg3Format, Individual)) .
\"urn:uuid:5030f906-9396-42ee-b0fd-0dd4b7ea897f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg3Format, (2))) .
\"urn:uuid:7669c359-a793-4303-8576-99bb50cf5efb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:49e1ffb4-fc1b-42b9-b69e-41c3d8d669b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:5eaac281-090d-4e5c-a53f-70c2b2e00999"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Genl, WFFConstraintPredicate)) .
\"urn:uuid:55b12561-f473-47d8-b848-dc80e045da35"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg3Genl, Relation)) .
\"urn:uuid:e3c72f99-634e-4c24-bbed-6eb23b321b35"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg3Genl, Collection)) .
\"urn:uuid:f496d840-704d-4118-a8b9-c267af3efe8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg3Genl, Thing)) .
\"urn:uuid:31ee7c6e-45bc-42c1-83e8-5e2cb1c3a267"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg3Genl, (2))) .
\"urn:uuid:f9e1d21c-57b7-4b40-b23b-b2b4b8c07f2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:2f777599-0e0a-4bfa-93f7-d8561c06e6f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:a89c0293-3738-49c9-849b-e43416fa2c88"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3Isa, WFFConstraintPredicate)) .
\"urn:uuid:bf9cc62c-a3fa-4588-96c4-fd1b9dd65436"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg3Isa, Relation)) .
\"urn:uuid:146cf6ad-de22-4860-99b7-e832ec983309"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg3Isa, Collection)) .
\"urn:uuid:7d1390f8-b9bb-4f93-89d1-d96dfc17aac5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg3Isa, Thing)) .
\"urn:uuid:2e8f5e35-e79f-4647-aadd-f7d9b3186ce3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg3Isa, (2))) .
\"urn:uuid:ccfda569-e1d4-4076-892b-938ba77b1021"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:40ca6e80-06d7-4d6b-bb49-e036f78c5338"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:a85c7eb8-23af-4624-81ee-0b54be403721"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:373f1423-5aea-4d18-91ca-57b1999797b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg3QuotedIsa, Relation)) .
\"urn:uuid:bab2f63e-7442-4010-80a5-238ba12e8c2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg3QuotedIsa, SubLExpressionType)) .
\"urn:uuid:d3f2d215-bfb4-4fd8-bc16-3aef4cc9495a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg3QuotedIsa, SubLSExpression)) .
\"urn:uuid:9c7a1d1e-bf99-4e72-8896-210eb11dd57c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg3QuotedIsa, (2))) .
\"urn:uuid:c4b5754e-b0b6-40d1-9d84-6e5bc1478d39"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:a3ceb09b-1200-4cc4-9fa5-23d14ff388c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:f5165577-cf42-4d60-9baf-471d32025cbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:9f308024-7afb-4639-9231-8aa5214eff84"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg3SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:d227edb5-f900-4e61-a3ab-f42e3c22c5c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg3SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:dfa1e780-ce34-496e-bd45-5f9858fe1074"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg3SometimesIsa, Relation)) .
\"urn:uuid:8c03e9a9-39ec-4889-80e8-3876134dc6d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg3SometimesIsa, Collection)) .
\"urn:uuid:590d6e5b-f5bd-4a59-89fa-4f8387cc5da1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg3SometimesIsa, Thing)) .
\"urn:uuid:188a6692-642c-4ff3-a0dd-577b5710b835"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg3SometimesIsa, (2))) .
\"urn:uuid:bd213719-ff1b-4bd5-8324-676eb7f6e18f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Format, BinaryPredicate)) .
\"urn:uuid:0448caec-99b0-46a4-a379-07d944044155"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Format, ArgConstraintPredicate)) .
\"urn:uuid:a534b095-0d02-431c-950c-3c1988e2cf89"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Format, WFFConstraintPredicate)) .
\"urn:uuid:b79ad8ae-3466-4da4-900f-a0fbca72ddfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg4Format, Predicate)) .
\"urn:uuid:0e550093-0c1f-4655-a3ee-0c6665324178"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg4Format, Individual)) .
\"urn:uuid:f44e2031-0a8e-4d1f-8ee6-1cdb68c7d8fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg4Format, (2))) .
\"urn:uuid:6ca509b3-d994-4787-9548-c88d9945c07f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:459122dc-cfa2-42ac-858e-180f58defabf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:44227f22-38c8-4767-ad45-f03658e7f00b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Genl, WFFConstraintPredicate)) .
\"urn:uuid:ad00c53e-3001-4600-8b0f-1aaf3e13cc7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg4Genl, Relation)) .
\"urn:uuid:465049f5-f602-40f2-9269-aabf2daeafbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg4Genl, Collection)) .
\"urn:uuid:691784bd-ba9f-42a4-98a4-40e5c912c4aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg4Genl, Thing)) .
\"urn:uuid:1cecba4a-fe96-4f0e-b436-85ee49384a95"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg4Genl, (2))) .
\"urn:uuid:0820fc8f-5382-44e6-a601-794b7e768606"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:55fc23dc-3f47-4376-ab46-e990594af8b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:4d1fbe27-b91e-46fa-8d58-1eef2dbefec3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4Isa, WFFConstraintPredicate)) .
\"urn:uuid:034db6ff-5d20-46ec-9d20-c613ef224a01"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg4Isa, Relation)) .
\"urn:uuid:68ed6c50-a3e5-45c6-91c1-7283d5c2b781"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg4Isa, Collection)) .
\"urn:uuid:d9b82642-73fd-4ca9-9b4c-8c8bd9338709"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg4Isa, Thing)) .
\"urn:uuid:8aee4aff-dac0-4490-8c2b-9c4c718ecaaa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg4Isa, (2))) .
\"urn:uuid:c251347e-5097-4cd4-97cd-c7f98f0918f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:6f600880-c282-40e8-9147-d5a2b82492c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:1bf72533-98ae-4c19-b578-11745dd7d07b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:18096215-a3a1-4f35-87d2-a369cbb74f02"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg4QuotedIsa, Relation)) .
\"urn:uuid:c0c6efba-0730-4fa5-93ba-ffd86f2b794d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg4QuotedIsa, SubLExpressionType)) .
\"urn:uuid:16127b33-0b6e-41a2-b476-220e8e88d3e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg4QuotedIsa, SubLSExpression)) .
\"urn:uuid:9d0ac5c9-5371-4241-8104-960043d9e9a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg4QuotedIsa, (2))) .
\"urn:uuid:3e5e4276-5931-4ec5-86d1-cff6335f010f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:0447e3cd-f6fc-4f87-9e2f-d8f46aad9959"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:d781140c-50e3-450f-b28f-ed057022f2b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:6a782f95-7c6d-42d2-b88d-f10ba105dd80"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg4SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:07a2725e-a287-48ee-8870-fd226a173b5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg4SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:aa3b63d6-b247-44e3-9d90-d9cb620cc7f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg4SometimesIsa, Relation)) .
\"urn:uuid:db6b4bb9-08cd-4181-ba2a-1e6ffc321365"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg4SometimesIsa, Collection)) .
\"urn:uuid:b400aad9-306b-41da-8084-c44559e96200"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg4SometimesIsa, Thing)) .
\"urn:uuid:afcea0c8-c6fb-493d-a3fa-d1dea5fe6479"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg4SometimesIsa, (2))) .
\"urn:uuid:3e88347d-8ea3-45d2-a9fb-cf29d4fc1f94"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Format, BinaryPredicate)) .
\"urn:uuid:f8f64c78-2603-406c-96f4-64dd87f93194"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Format, ArgConstraintPredicate)) .
\"urn:uuid:a498436e-1bd6-4f01-b012-23cec35d1701"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Format, WFFConstraintPredicate)) .
\"urn:uuid:283bcb9b-4a47-4f65-a99a-c9714d4395a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg5Format, Predicate)) .
\"urn:uuid:1f6c020d-ba6d-4c4d-b55b-d4e0e519e611"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg5Format, Individual)) .
\"urn:uuid:86b37c51-2eed-411e-82c7-878b95ccb0b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg5Format, (2))) .
\"urn:uuid:cf1676ab-4219-413e-8609-1e790812c2fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:b6e49008-5b42-4323-8332-5ae497e4e1bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:c0cf568a-99f4-40c7-ad85-6867b0575f50"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Genl, WFFConstraintPredicate)) .
\"urn:uuid:f0e18357-a2d2-4f38-8bfb-572b98047e4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg5Genl, Relation)) .
\"urn:uuid:8fad3e6f-8e30-4cf4-a47a-facbf6393db4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg5Genl, Collection)) .
\"urn:uuid:7ebb02ef-0e17-42dc-8213-7156ee2510e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg5Genl, Thing)) .
\"urn:uuid:10087909-f089-44c7-86f3-b934a0bbee6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg5Genl, (2))) .
\"urn:uuid:82a3a076-252e-4564-b278-aa76876e965f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:caa2da65-43f2-46fe-a152-04ab69453f18"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:84c6a3ea-acfa-4d86-9583-cac6c7a54a4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5Isa, WFFConstraintPredicate)) .
\"urn:uuid:b189ec4c-fdfb-4107-a7e3-9308a66a669f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg5Isa, Relation)) .
\"urn:uuid:4ed731c7-8e13-4901-b820-93a3957ca2c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg5Isa, Collection)) .
\"urn:uuid:33ea3873-7c0c-40ff-bdcb-9240ad876427"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg5Isa, Thing)) .
\"urn:uuid:81eb7b9a-fce5-4e4a-9830-22d2c7127911"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg5Isa, (2))) .
\"urn:uuid:03c3d239-937c-4b11-9f1e-5a63eb05fcf1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:7413d96b-edec-40fd-9f49-e2b3b171010d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:e49ae682-ed29-482f-a8a9-d718835185be"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:8e058061-c453-4cad-a20f-9df656fd0400"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg5QuotedIsa, Relation)) .
\"urn:uuid:bda3939b-757b-4a1d-9d9e-81421e5b90a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg5QuotedIsa, SubLExpressionType)) .
\"urn:uuid:84e0a882-de39-4a19-a99e-f68878baaaaf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg5QuotedIsa, SubLSExpression)) .
\"urn:uuid:7a5d45d8-9857-4ea1-834f-da3f1d525f74"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg5QuotedIsa, (2))) .
\"urn:uuid:d9e2fc76-13b4-4833-9a76-c9e49e4fdcf3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:b14f61ad-a48b-4ab3-9b62-9b91c743a24b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:6e55604b-dd79-4000-9a2d-547178227066"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:e9eab45a-ec4d-485d-9683-64f68e92d091"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg5SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:608f4aad-e608-40ea-90dd-4accca2ef95b"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg5SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:9f48b1fc-1afc-4a7f-b8e0-9ef8d7a25ef0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg5SometimesIsa, Relation)) .
\"urn:uuid:352e8bde-bd05-46cd-880c-968d08c41b87"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg5SometimesIsa, Collection)) .
\"urn:uuid:15ffe208-157a-4cb4-990e-1aeea4998f3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg5SometimesIsa, Thing)) .
\"urn:uuid:87d411a2-9269-405f-9ab2-5b4d10e1e654"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg5SometimesIsa, (2))) .
\"urn:uuid:0efe7430-ed4a-43da-8613-e4c6a2044c33"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Format, BinaryPredicate)) .
\"urn:uuid:3cc0c97d-5292-46a9-8e18-eff4c28cc544"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Format, ArgConstraintPredicate)) .
\"urn:uuid:9cc2b404-77d1-4cbd-9a6f-31b015e81090"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg6Format, Predicate)) .
\"urn:uuid:b2b6c88d-d163-4586-8fc3-2d40657217c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg6Format, Individual)) .
\"urn:uuid:8d3a5251-3ebc-409e-b64a-221c7b33c3ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg6Format, (2))) .
\"urn:uuid:4ee40edd-7e38-4a12-adbe-cfb3272593cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Genl, DefaultMonotonicPredicate)) .
\"urn:uuid:ea1c1859-bceb-4abe-b7fd-60a40c664bc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Genl, ArgGenlBinaryPredicate)) .
\"urn:uuid:46bb6686-196f-4767-ad8d-27230992db73"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg6Genl, Relation)) .
\"urn:uuid:630b02e3-2bfb-464b-8dca-ea15a45e7878"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg6Genl, Collection)) .
\"urn:uuid:9185eb4d-005b-479a-9467-6e89dc27656f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg6Genl, Thing)) .
\"urn:uuid:ad1851cb-5a4d-46eb-9f1e-84f8f7067965"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg6Genl, (2))) .
\"urn:uuid:39226d29-2448-4591-8823-aaa853f4da22"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Isa, DefaultMonotonicPredicate)) .
\"urn:uuid:bdd9ce34-c60d-4d90-bf77-c0d680fa3cd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6Isa, ArgIsaBinaryPredicate)) .
\"urn:uuid:f4c078b1-b1a7-455f-a103-690f22a65a96"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg6Isa, Relation)) .
\"urn:uuid:19317ee4-eec7-4e93-b672-04e5dd6f5db9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg6Isa, Collection)) .
\"urn:uuid:21ec9f74-3e81-48fc-82c4-01d17e224d24"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg6Isa, Thing)) .
\"urn:uuid:9ce397bc-05cf-4bea-9980-e0118d2c4651"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg6Isa, (2))) .
\"urn:uuid:6e038c21-af71-4a65-8484-fa6e8419dcc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6QuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:4996e6f8-b1a6-4565-85fd-38c97492e86a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6QuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:49cd794d-d863-470b-b413-7266b1ca3a48"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6QuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:2a0ec572-90fe-4899-ae53-2361340c6e0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg6QuotedIsa, Relation)) .
\"urn:uuid:465a86c6-0079-4e29-9055-4c3442d54485"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg6QuotedIsa, SubLExpressionType)) .
\"urn:uuid:595785dd-1175-43cd-b65e-62506135fe4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg6QuotedIsa, SubLSExpression)) .
\"urn:uuid:58624951-0168-42de-be70-0ca9eabd40a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg6QuotedIsa, (2))) .
\"urn:uuid:9c8ec749-7815-48ee-81f4-4eadddc5a546"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6SometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:e45116a6-e4dd-44e4-a3c5-00f836ece92b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6SometimesIsa, ArgTypeBinaryPredicate)) .
\"urn:uuid:1123b775-9abd-43ff-9281-ca11fefd202c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6SometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:208899b9-cb52-47da-bea4-5a2af3630ba7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arg6SometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:c446b943-45d4-415d-b2b7-36a8af17d8aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(arg6SometimesIsa, WFFSupportedPredicate))) .
\"urn:uuid:61b7b1d7-7d8c-4e57-b161-e3d693b4a50a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arg6SometimesIsa, Relation)) .
\"urn:uuid:dbfbbd0c-ffd2-4175-9f1b-7876e0479945"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arg6SometimesIsa, Collection)) .
\"urn:uuid:1f99edbb-7d43-418b-aec7-9d7c4e5ef340"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(arg6SometimesIsa, Thing)) .
\"urn:uuid:aabd92c8-7d72-413e-94ab-1273679c676a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arg6SometimesIsa, (2))) .
\"urn:uuid:d47ce90e-1f49-4746-af8a-c053352003fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestGenl, ArgGenlTernaryPredicate)) .
\"urn:uuid:f4284ced-04dc-4f65-8833-b57f70f0f919"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestGenl, DefaultMonotonicPredicate)) .
\"urn:uuid:40e7294f-b887-4c97-bdd2-072d1cc7b999"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestGenl, WFFConstraintPredicate)) .
\"urn:uuid:40d2f08a-4661-4bea-b780-b7ab30839b8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argAndRestGenl, VariableArityRelation)) .
\"urn:uuid:820d6cb8-b703-42fb-a419-af7f69e5f5d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argAndRestGenl, PositiveInteger)) .
\"urn:uuid:4ab4be47-4f9c-4b31-bb00-1b02459741ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argAndRestGenl, Collection)) .
\"urn:uuid:b5ffc695-a9ec-4922-8337-38d63dd9c07c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argAndRestGenl, Thing)) .
\"urn:uuid:5829e538-703c-41c6-9013-5ddba2ba7a7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(argAndRestGenl, argGenl)) .
\"urn:uuid:06b7bb57-f8f2-42ad-bc9a-6d1b7a5f74ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argAndRestGenl, (3))) .
\"urn:uuid:9aaa75d7-e1f3-45b0-adbb-c01799e911c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestIsa, ArgIsaTernaryPredicate)) .
\"urn:uuid:17c19c4e-b24c-4c63-b537-b1c819d5f05c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:04a2bc9f-9e2b-42f3-8269-699b2859e6c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestIsa, WFFConstraintPredicate)) .
\"urn:uuid:99fef0df-1209-4f67-9440-c150fa7dd28e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(argAndRestIsa, Predicate)) .
\"urn:uuid:6dd7e09f-f0a9-4818-8834-bb309affb584"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argAndRestIsa, VariableArityRelation)) .
\"urn:uuid:fc4d0b29-5542-48e8-b53e-32fcf7f1691b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argAndRestIsa, Relation)) .
\"urn:uuid:469b69d3-75cc-41e2-9de1-f297c24d9607"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argAndRestIsa, PositiveInteger)) .
\"urn:uuid:86156ad0-382e-402d-8a79-db977d37c7de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argAndRestIsa, NonNegativeInteger)) .
\"urn:uuid:4cb2d6ee-8909-42ef-a990-9f904b9f6e6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argAndRestIsa, Collection)) .
\"urn:uuid:ef6291fd-ae30-46bb-93a8-1ce902c6030b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argAndRestIsa, Thing)) .
\"urn:uuid:1828c901-279f-4706-b094-b4565a40937c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(argAndRestIsa, SubLPositiveInteger)) .
\"urn:uuid:56f17446-ca93-4db3-b6d7-8142b4e2a4ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(argAndRestIsa, argIsa)) .
\"urn:uuid:5718a04d-58f7-4cdb-b4be-fb1be1cd9147"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argAndRestIsa, (3))) .
\"urn:uuid:2a97800d-1172-4521-b894-46a0005e1a51"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestQuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:5856e1ec-6bb3-44b7-9447-4bb6cae49159"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argAndRestQuotedIsa, ArgQuotedIsaTernaryPredicate)) .
\"urn:uuid:1986143e-f331-4849-87b8-498bb2398ee3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argAndRestQuotedIsa, VariableArityRelation)) .
\"urn:uuid:cd45327c-2aee-4c90-b920-3f2ec9192ca5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argAndRestQuotedIsa, PositiveInteger)) .
\"urn:uuid:b003a260-9e92-44e8-81bb-1e2cbc7e2483"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argAndRestQuotedIsa, SubLExpressionType)) .
\"urn:uuid:75954336-5d38-491c-8326-fe9a98549ae7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argAndRestQuotedIsa, SubLSExpression)) .
\"urn:uuid:1def32bb-a57c-4ca8-9a05-d98aa8e13c25"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argAndRestQuotedIsa, Thing)) .
\"urn:uuid:0111de87-abed-4961-a668-25c5bdf0eda5"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(argAndRestQuotedIsa, argQuotedIsa)) .
\"urn:uuid:9d5e8716-66b6-4537-a4d4-ae430e029a28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argAndRestQuotedIsa, (3))) .
\"urn:uuid:d3fec012-5a4b-4e31-a997-7813863e841d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argGenl, ArgGenlTernaryPredicate)) .
\"urn:uuid:2fdc4c6e-d98f-445d-96db-0622f5febdbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argGenl, DefaultMonotonicPredicate)) .
\"urn:uuid:ce301ce2-f2fa-462e-8bd8-c0f9da3224e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argGenl, WFFConstraintPredicate)) .
\"urn:uuid:fe74932d-9395-4eaa-a877-e29059807afc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argGenl, Relation)) .
\"urn:uuid:a1859665-c959-4e4c-8f02-fe1e68b302b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argGenl, NonNegativeInteger)) .
\"urn:uuid:7a620128-3191-4c45-a094-c44fa4f69b76"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argGenl, Collection)) .
\"urn:uuid:bfea8150-69f8-4598-ae4a-41c0d6a7bd88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argGenl, Thing)) .
\"urn:uuid:2741bd43-67b1-468b-b2fc-8782c2cbe96b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argGenl, (3))) .
\"urn:uuid:c92c0475-5f20-42c6-82c8-91ed493bc2a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argIsa, ArgIsaTernaryPredicate)) .
\"urn:uuid:fbb99ebd-8c45-4805-9a26-6ff3e5d4eb03"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:5c7a7a26-c1f9-4535-8322-a7621735c63b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argIsa, WFFConstraintPredicate)) .
\"urn:uuid:01943397-c411-4cfc-8a8d-f15c68bca5ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argIsa, Relation)) .
\"urn:uuid:37a83c64-3c1f-4ea8-ae25-15a3e3fbe694"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argIsa, PositiveInteger)) .
\"urn:uuid:cfe7683f-d96a-4a41-974f-b11387e1331d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argIsa, NonNegativeInteger)) .
\"urn:uuid:fe66d678-4bf6-43fc-83ac-b234d00540de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argIsa, Collection)) .
\"urn:uuid:b0726e8b-894e-4096-9565-661fb8e57b13"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argIsa, Thing)) .
\"urn:uuid:f23614ec-972e-43ec-b4c0-fb41b4c8d133"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(argIsa, SubLPositiveInteger)) .
\"urn:uuid:608470df-eee8-4a30-b895-756b666403d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(argIsa, argSometimesIsa)) .
\"urn:uuid:d93f16a1-e424-495b-9f88-131e9116008d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argIsa, (3))) .
\"urn:uuid:b5bc35b5-9e2f-4993-9009-5c24f5393df9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argN, TernaryPredicate)) .
\"urn:uuid:83f749e4-6ab4-4474-81e9-a13949193595"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(argN, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:9d7ce31f-7346-43ee-952a-27a7ce28dd39"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argN, Thing)) .
\"urn:uuid:6c3a7a4e-b793-4962-aafe-7d8429d05a88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argN, NonNegativeInteger)) .
\"urn:uuid:eee472b4-ca8c-4c13-9de7-46bc8ea9d25e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argN, Thing)) .
\"urn:uuid:77cbd8d9-bbac-4b3a-a870-3e4f8d2bb974"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(argN, CycLTerm)) .
\"urn:uuid:f6987b53-65b6-4f5c-b8f1-546aea50ae0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(argN, CycLFormula)) .
\"urn:uuid:3fe8a994-d1e1-46d7-a3ad-3bfa90690ff5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argN, (3))) .
\"urn:uuid:af163c0d-9f1c-4c1d-8c97-caafdc984916"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argQuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:7fc4643a-87c0-4a84-92fe-79e28ff61c6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argQuotedIsa, ArgQuotedIsaTernaryPredicate)) .
\"urn:uuid:4a826094-e846-47f3-bfde-197ff33da5bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argQuotedIsa, WFFConstraintPredicate)) .
\"urn:uuid:f4f6df64-9e0e-42d9-a99e-1743af16c33b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argQuotedIsa, Relation)) .
\"urn:uuid:45b2965a-6184-4fd2-8850-4e01f5042332"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argQuotedIsa, NonNegativeInteger)) .
\"urn:uuid:506ea629-627d-4a32-afdd-4d41f622e443"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argQuotedIsa, SubLExpressionType)) .
\"urn:uuid:1af0554e-3252-40c4-883c-1828ddb35885"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argQuotedIsa, SubLSExpression)) .
\"urn:uuid:3a452e54-1307-4899-aa03-8161cfd45ef7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argQuotedIsa, (3))) .
\"urn:uuid:8ededcbc-8a3e-4c51-917b-cdef797bf459"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argSometimesIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:4faa9e0b-02b8-4513-aa94-1a6c1e6900ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argSometimesIsa, ArgSometimesIsaPredicate)) .
\"urn:uuid:bedfdf82-3ab2-4803-a7e5-6a1984213c97"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argSometimesIsa, ArgTypeTernaryPredicate)) .
\"urn:uuid:42277c37-fabf-4cbc-ac79-7553aceb52f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argSometimesIsa, WFFConstraintPredicate)) .
\"urn:uuid:9815c206-0049-4899-ba40-98987753832f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argSometimesIsa, Relation)) .
\"urn:uuid:75b2e557-d3e7-4fda-9f88-d1042e911841"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argSometimesIsa, PositiveInteger)) .
\"urn:uuid:4cbc760c-96e7-4a34-b48f-95d1e5799174"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argSometimesIsa, NonNegativeInteger)) .
\"urn:uuid:3851ba39-d490-4423-935d-5a62edfc8034"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(argSometimesIsa, Collection)) .
\"urn:uuid:8491e7a0-98ec-43a0-945e-9467a4dc2367"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(argSometimesIsa, Thing)) .
\"urn:uuid:adbc97f8-1a63-4f23-93de-85f6a2d7a4b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(argSometimesIsa, SubLPositiveInteger)) .
\"urn:uuid:3f40fef4-c359-442a-b3a2-cf380b3dcdad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argSometimesIsa, (3))) .
\"urn:uuid:5ede32c3-9c15-4940-965b-b90536d45432"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsGenl, ArgGenlBinaryPredicate)) .
\"urn:uuid:69835ffa-a215-4159-a8e3-580b6a7c30c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsGenl, DefaultMonotonicPredicate)) .
\"urn:uuid:db93a231-6f5a-49a2-b1ad-4b324f5eb08e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argsGenl, Relation)) .
\"urn:uuid:502e3307-58d5-4e73-a973-e6bb619a81cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argsGenl, Collection)) .
\"urn:uuid:c4fa47b1-c905-4f39-975f-4e41dc368f79"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(argsGenl, Thing)) .
\"urn:uuid:a4009ce3-f345-4fd5-94e7-30254c9a8668"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argsGenl, (2))) .
\"urn:uuid:847f68e1-10cf-4cd1-8530-52e3f5aae4c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:0db5c698-526f-4acc-9499-17a24c0ceb64"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsIsa, ArgIsaBinaryPredicate)) .
\"urn:uuid:b8f7e7ec-e286-4da3-9278-a1d67267ef34"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argsIsa, Relation)) .
\"urn:uuid:41f95793-571d-4dad-82db-d970532af232"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argsIsa, Collection)) .
\"urn:uuid:f42021d4-e6dd-4610-987f-cfa5c116d34e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(argsIsa, Thing)) .
\"urn:uuid:171285f8-cac7-4b35-8087-e5ce4c3644f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(argsIsa, arg1Isa)) .
\"urn:uuid:1d59c296-b44f-42de-b238-1e7ed3c2953b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argsIsa, (2))) .
\"urn:uuid:2ced1416-8bd1-4fd0-b1d7-1f45b8154bb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsQuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:e40216cc-8160-49e3-9365-eac700ba1fe0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(argsQuotedIsa, ArgQuotedIsaBinaryPredicate)) .
\"urn:uuid:ef13c3a3-7785-4d0c-9bc1-f18ce100e275"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(argsQuotedIsa, Relation)) .
\"urn:uuid:20bffe64-4b95-42fe-8fbc-9f9f4859d102"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(argsQuotedIsa, SubLExpressionType)) .
\"urn:uuid:77a1b8e2-80b5-4917-ae88-1dbbf5bce4a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(argsQuotedIsa, SubLSExpression)) .
\"urn:uuid:da4bee25-1fff-4fe0-bfe4-2b325a8adeb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(argsQuotedIsa, Thing)) .
\"urn:uuid:2ac7edda-2cff-4e91-9046-ecedfda4e384"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(argsQuotedIsa, (2))) .
\"urn:uuid:70e780ba-004c-4e65-a2cc-56ecc11a2519"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arity, DefaultMonotonicPredicate)) .
\"urn:uuid:aaf03571-6ed2-4428-b0bd-45aee30e06b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arity, BinaryPredicate)) .
\"urn:uuid:67050ac6-f914-4e56-b9a4-7dad4636fc5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(arity, Predicate)) .
\"urn:uuid:6e45f93e-b36e-4c97-9050-9f63c16f28b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arity, FixedArityRelation)) .
\"urn:uuid:7dfe23d2-c637-4542-954b-98e617bc9f1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arity, NonNegativeInteger)) .
\"urn:uuid:48d09465-32e9-4321-87d7-89b815ac9bac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arity, Integer)) .
\"urn:uuid:5f19480a-aeb0-4043-9fd6-a14e3000c7a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(arity, SubLNonNegativeInteger)) .
\"urn:uuid:bab24147-2639-419d-9045-31c32a979d46"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arity, (2))) .
\"urn:uuid:8e5af5b5-7f81-49bb-a3e3-e6ec923751cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arityMax, DefaultMonotonicPredicate)) .
\"urn:uuid:9ba58e94-5cca-43ad-babb-1ff16a2cedb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arityMax, BinaryPredicate)) .
\"urn:uuid:3a702413-c8e3-4bb6-aa6d-66e784832220"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(arityMax, Predicate)) .
\"urn:uuid:f0f6b520-e7d8-4d7c-824e-4d37e59f9eee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arityMax, VariableArityRelation)) .
\"urn:uuid:cd3a8f29-2acd-480f-ac7b-18794a4051d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arityMax, NonNegativeInteger)) .
\"urn:uuid:5e2372d4-fca7-4ffc-b559-a84de7fcda0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arityMax, (2))) .
\"urn:uuid:203a6e35-3fdc-40bf-b922-bb957a2adee8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arityMin, DefaultMonotonicPredicate)) .
\"urn:uuid:bb25d705-2291-4082-9ca5-82c3df4003e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(arityMin, BinaryPredicate)) .
\"urn:uuid:85206b50-4fea-4f20-8ae2-1a46c8986581"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(arityMin, VariableArityRelation)) .
\"urn:uuid:aa7e87da-a45b-4f38-a78a-3af30d9d17d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(arityMin, NonNegativeInteger)) .
\"urn:uuid:6cb5669d-1649-4303-9b41-6ada613b2db0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(arityMin, (2))) .
\"urn:uuid:b574e2ae-b56e-4acb-9327-3229854c9f63"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertedMoreSpecifically, UnaryPredicate)) .
\"urn:uuid:1228f765-aa17-4fc5-826c-be62c11f7831"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(assertedMoreSpecifically, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:7c3074c2-733c-411e-97d2-a503ea184b61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertedMoreSpecifically, 'CycLSentence-Assertible')) .
\"urn:uuid:d1857c5c-98d3-4831-8b68-05ace59350b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertedMoreSpecifically, (1))) .
\"urn:uuid:2b6eaf63-7a22-4fec-b8cb-5a639ad3962b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertedPredicateArg, TernaryPredicate)) .
\"urn:uuid:376b62e1-fbf0-4cfd-bfdf-db253e77f8bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(assertedPredicateArg, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:0b5a231f-4401-4141-965d-df02ad373988"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(assertedPredicateArg, Thing)) .
\"urn:uuid:85cb7f79-c235-4971-a316-4eda83616774"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(assertedPredicateArg, PositiveInteger)) .
\"urn:uuid:e02c137f-7b0a-40de-835a-088be80f3a24"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(assertedPredicateArg, Predicate)) .
\"urn:uuid:0983eba2-9d3d-4a67-9c57-1b4d2fd1eec9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(assertedPredicateArg, admittedArgument)) .
\"urn:uuid:f441af48-a259-4b94-8292-50ddc63b3339"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertedPredicateArg, (3))) .
\"urn:uuid:b90c8c4b-da42-4878-9447-142bf0a93bbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertedSentence, UnaryPredicate)) .
\"urn:uuid:0c160d54-4155-437f-9210-aa60f4226558"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(assertedSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6eadab77-242f-4218-8758-bbd43d1f8b14"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertedSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:ed5c68e6-f61b-406b-8f54-d3456197c921"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(assertedSentence, knownSentence)) .
\"urn:uuid:5aef195b-24b7-4749-97ae-1c3cfcc2c11e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertedSentence, (1))) .
\"urn:uuid:377dd6b8-cd19-4193-b15a-31c8a3f70b7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertedTermSentences, BinaryPredicate)) .
\"urn:uuid:ef88ce76-2cbe-48df-a392-1b5450136ebf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(assertedTermSentences, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:31d572bc-411e-41a0-b6ee-01b15a1b4d9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(assertedTermSentences, Thing)) .
\"urn:uuid:da073703-3160-4ab6-865b-316675883d36"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertedTermSentences, CycLTerm)) .
\"urn:uuid:ee89c7d3-eec7-42bd-90bf-bea1cbe4adf8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(assertedTermSentences, 'CycLSentence-Assertible')) .
\"urn:uuid:81068a4e-bd7f-490b-a797-dbac9e7e6d36"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertedTermSentences, (2))) .
\"urn:uuid:b10d50b1-c816-48d9-9299-f12e7b59ee76"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertionDirection, DefaultMonotonicPredicate)) .
\"urn:uuid:d2f4f74c-6516-438d-ae37-1f3c31361db4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertionDirection, BinaryPredicate)) .
\"urn:uuid:bddee72f-fd84-400b-8b37-b17a31e28ffd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(assertionDirection, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:2eda2007-889e-4417-8402-0f39fb24cfd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(assertionDirection, CycLAssertionDirection)) .
\"urn:uuid:cb273c97-2fbf-484a-9647-5a559c6f671f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertionDirection, CycLAssertion)) .
\"urn:uuid:77dce1e3-a80a-450a-9ede-a62c04be472f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertionDirection, (2))) .
\"urn:uuid:a291c45c-a9ad-4819-9618-fedd60c89ec0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertionUtility, BinaryPredicate)) .
\"urn:uuid:fada1ff5-1665-4dba-92a6-2b1a0977b07e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(assertionUtility, RealNumber)) .
\"urn:uuid:6e871ca2-4b2d-4989-b096-a25c2a5537bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertionUtility, CycLAssertion)) .
\"urn:uuid:52e863ad-7e95-4763-b1d5-16827ac5f699"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertionUtility, (2))) .
\"urn:uuid:fc057c2d-1be2-4a99-b7b2-7eb928a93c4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('assertionUtility-1', BinaryPredicate)) .
\"urn:uuid:64bc2d99-9675-491b-9972-6b77349dc968"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('assertionUtility-1', RealNumber)) .
\"urn:uuid:4d858d18-92ed-41bc-98f9-8565611afcee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa('assertionUtility-1', CycLAssertion)) .
\"urn:uuid:42614e4a-2a86-45b8-969d-6865e371a645"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('assertionUtility-1', (2))) .
\"urn:uuid:18c15ca1-5fe4-479d-a545-e8fd95244bfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertiveWFFEnabled, EvaluatablePredicate)) .
\"urn:uuid:70a162d7-7329-4aa5-8493-e2ea68851b14"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertiveWFFEnabled, (0))) .
\"urn:uuid:8c9732a2-79c7-4db1-95e1-a82af68c878f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(assertiveWFFRule, UnaryPredicate)) .
\"urn:uuid:edd1c264-091d-4599-a69a-d27c9b847e25"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(assertiveWFFRule, CycLRuleAssertion)) .
\"urn:uuid:02c56903-2543-4423-b19a-ab077490fbe0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(assertiveWFFRule, (1))) .
\"urn:uuid:f953f4af-0c41-498d-b2f4-4efe5622322f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(backchainForbidden, UnaryPredicate)) .
\"urn:uuid:27aefaaa-f721-4807-a186-e6f7fc4b9599"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(backchainForbidden, DefaultMonotonicPredicate)) .
\"urn:uuid:04c6d31d-662e-45d7-b3e3-6a2eda087930"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(backchainForbidden, Predicate)) .
\"urn:uuid:58bb1cc8-ca3b-4883-aa93-c4b6cd52f284"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(backchainForbidden, (1))) .
\"urn:uuid:a6c964c1-63a7-47a4-9a53-c63b6b4f3d25"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(backchainForbiddenWhenUnboundInArg, BinaryPredicate)) .
\"urn:uuid:16b622b0-0af0-449c-968f-4d8bea050ef5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(backchainForbiddenWhenUnboundInArg, Predicate)) .
\"urn:uuid:0a75002a-ff78-4cd1-a45c-f68ec43b3f1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(backchainForbiddenWhenUnboundInArg, PositiveInteger)) .
\"urn:uuid:642486e8-1194-4fb6-bf50-05af06a7ed45"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(backchainForbiddenWhenUnboundInArg, (2))) .
\"urn:uuid:a62bd87c-096a-4c1d-b234-eafd664cf986"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(backchainRequired, UnaryPredicate)) .
\"urn:uuid:7baa5ccc-66a4-4ed0-84a7-f07814591c6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(backchainRequired, DefaultMonotonicPredicate)) .
\"urn:uuid:ec7c651d-1dd1-400b-ac22-0f03d029810b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(backchainRequired, Predicate)) .
\"urn:uuid:c6cd0034-f1d6-4731-b0ed-d71f092e1101"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(backchainRequired, (1))) .
\"urn:uuid:d12b8aa4-b6dd-4c64-9ecd-176c5b87f176"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(canonicalizerDirectiveForAllArgs, BinaryPredicate)) .
\"urn:uuid:323830b7-4d79-4aa2-8e69-878ccaa9f7e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(canonicalizerDirectiveForAllArgs, Relation)) .
\"urn:uuid:b6f008c2-2e39-45f2-9e3f-a98d29223d2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(canonicalizerDirectiveForAllArgs, CanonicalizerDirective)) .
\"urn:uuid:d22cf0f0-efb5-40c6-a827-cf5f1d0ae90b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(canonicalizerDirectiveForAllArgs, (2))) .
\"urn:uuid:66a2a15d-e247-44df-8bbf-1b298adb7b41"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(canonicalizerDirectiveForArg, TernaryPredicate)) .
\"urn:uuid:f431f738-9f50-4a13-9306-7cbc5657a633"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(canonicalizerDirectiveForArg, Relation)) .
\"urn:uuid:a1377536-842d-4625-a1df-449c024842e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(canonicalizerDirectiveForArg, PositiveInteger)) .
\"urn:uuid:10ff27cc-961e-4edf-b1c4-f6f3efc8de27"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(canonicalizerDirectiveForArg, CanonicalizerDirective)) .
\"urn:uuid:ec2941f5-2abd-40d0-bb52-72198b66f340"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(canonicalizerDirectiveForArg, (3))) .
\"urn:uuid:5f1f015f-6aea-4f8b-9f15-c5ea3de22be0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(canonicalizerDirectiveForArgAndRest, TernaryPredicate)) .
\"urn:uuid:7256c366-714f-4e21-a790-da64fd6640c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(canonicalizerDirectiveForArgAndRest, Relation)) .
\"urn:uuid:2bf5a4c4-e02d-4952-925a-12325576eff9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(canonicalizerDirectiveForArgAndRest, PositiveInteger)) .
\"urn:uuid:53693012-ba06-46e9-9d33-d5caa461ddf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(canonicalizerDirectiveForArgAndRest, CanonicalizerDirective)) .
\"urn:uuid:8440219b-db9a-4d2d-a187-64614d71f0e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(canonicalizerDirectiveForArgAndRest, canonicalizerDirectiveForArg)) .
\"urn:uuid:26981be4-a19f-4d31-a1cb-c9c5d4cc51b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(canonicalizerDirectiveForArgAndRest, (3))) .
\"urn:uuid:947c293a-1cf0-41ba-83a3-5960cc6bac53"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(chooseTerm, DefaultMonotonicPredicate)) .
\"urn:uuid:26d94dda-c3ec-4b4c-acd3-090a6831d91b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(chooseTerm, UnaryPredicate)) .
\"urn:uuid:b9bc5f94-3ecc-48a1-9aee-80d6f5b7305d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(chooseTerm, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6a31a90a-f32d-4b42-9c7c-bcab2dedd58b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(chooseTerm, Thing)) .
\"urn:uuid:8ef1cfcf-8238-4cf8-a998-433190153655"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(chooseTerm, (1))) .
\"urn:uuid:bd64873c-61d5-465d-a1ca-0d6a0614acf3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(coExtensional, SymmetricBinaryPredicate)) .
\"urn:uuid:4d32c43e-7971-4636-9257-bf88eca5b6a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(coExtensional, TransitiveBinaryPredicate)) .
\"urn:uuid:e53b2480-e7da-4476-98c9-c9b151f15580"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(coExtensional, ReflexiveBinaryPredicate)) .
\"urn:uuid:1b463139-70c1-4b9d-87cf-6f6911360ee4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(coExtensional, Collection)) .
\"urn:uuid:5410958c-58a1-4a40-98b5-376dc8fd40a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(coExtensional, Thing)) .
\"urn:uuid:1d62c26b-5864-4701-8960-9d69254e13e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(coExtensional, Collection)) .
\"urn:uuid:35392d82-65f8-47ec-9d93-a09dcef2e26d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(coExtensional, Thing)) .
\"urn:uuid:aed73fd0-b072-4b21-b2e2-2921e82c84b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(coExtensional, genls)) .
\"urn:uuid:14399611-1c9d-40ae-9e07-0b240dedea53"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(coExtensional, genls)) .
\"urn:uuid:7aa6fc2e-d937-4180-af07-eb68c21f7896"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(coExtensional, coExtensional)) .
\"urn:uuid:af82c9fd-e16e-483f-b957-ca8f0f4bb72f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(coExtensional, (2))) .
\"urn:uuid:71546ea4-b691-4ec4-8e4c-b01dc6b081ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionBackchainEncouraged, UnaryPredicate)) .
\"urn:uuid:00ccd6f6-1b51-45d7-ac2a-e4ca817f9a23"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionBackchainEncouraged, DefaultMonotonicPredicate)) .
\"urn:uuid:edbf0546-3dc0-4403-b07b-0f8955a96a6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionBackchainEncouraged, Collection)) .
\"urn:uuid:77e1fd62-db70-495b-9c98-14f4216daee7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionBackchainEncouraged, Thing)) .
\"urn:uuid:35ef3048-5e98-4b6b-841b-b91ce2673129"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionBackchainEncouraged, collectionIsaBackchainEncouraged)) .
\"urn:uuid:22ec4c56-363a-463b-8fe0-2cf84a4c824e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionBackchainEncouraged, collectionGenlsBackchainEncouraged)) .
\"urn:uuid:d069790a-86ce-4858-97e5-ebe9265761da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionBackchainEncouraged, (1))) .
\"urn:uuid:f5ec5aab-3d23-4c94-9d25-1a7eff35b73c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionBackchainRequired, DefaultMonotonicPredicate)) .
\"urn:uuid:b885f9e2-d255-40a6-a880-88f79be25eb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionBackchainRequired, UnaryPredicate)) .
\"urn:uuid:b777644d-ccec-48a7-bef8-0cf0b1cf3dfa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionBackchainRequired, Collection)) .
\"urn:uuid:945c51d0-bf93-48df-b135-a385e2ba8050"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionBackchainRequired, Thing)) .
\"urn:uuid:abddfdb8-9378-45b5-afb6-5475c7d6b9b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionBackchainRequired, collectionBackchainEncouraged)) .
\"urn:uuid:e5a8f192-88f7-4e83-9339-4fb5e4338239"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionBackchainRequired, collectionGenlsBackchainRequired)) .
\"urn:uuid:9dc177ee-3fff-4b59-ac49-f18d33558f21"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionBackchainRequired, collectionIsaBackchainRequired)) .
\"urn:uuid:908028e2-ef08-4012-88d1-14faab11583a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionBackchainRequired, (1))) .
\"urn:uuid:e95c0253-bd30-45c2-8cd1-89cf42a34ad2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionCompletelyEnumerableViaBackchain, UnaryPredicate)) .
\"urn:uuid:d34692f1-0894-44b7-9da7-d73e330fb230"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionCompletelyEnumerableViaBackchain, Collection)) .
\"urn:uuid:794ccc69-59df-4f9c-bcbb-efc2905760ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionCompletelyEnumerableViaBackchain, Thing)) .
\"urn:uuid:e98145f8-b7f8-41c0-b74c-a33d04d6d412"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionCompletelyEnumerableViaBackchain, (1))) .
\"urn:uuid:33320d98-da1e-4376-882a-a82ee97cf248"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionConventionMt, BinaryPredicate)) .
\"urn:uuid:a068524d-6bf0-4a19-92b1-5a6dfbfc33b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionConventionMt, Collection)) .
\"urn:uuid:1f6bfffa-3526-4448-a64a-62f63013be62"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionConventionMt, Thing)) .
\"urn:uuid:d4fa25dc-bbc1-4aec-84e5-2d7823611d10"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(collectionConventionMt, Microtheory)) .
\"urn:uuid:25dd28f8-278e-4395-ad94-eb961a5451f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionConventionMt, (2))) .
\"urn:uuid:257e9e09-2edd-4526-ac84-f8147f3ce3aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionExpansion, BinaryPredicate)) .
\"urn:uuid:b70867c5-3e57-4865-aa31-ce4786ab6ae8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionExpansion, Collection)) .
\"urn:uuid:74db6424-c052-4a13-838f-0dd7a16c7489"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(collectionExpansion, Thing)) .
\"urn:uuid:36f7a5fc-38d4-4cae-85bc-e05283ae1a35"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(collectionExpansion, CycLExpression)) .
\"urn:uuid:0c3fb43d-bafb-4388-9c93-a085914076e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionExpansion, (2))) .
\"urn:uuid:7ddb6228-71fe-4151-a67c-2860b7bb2d61"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionGenlsBackchainEncouraged, DefaultMonotonicPredicate)) .
\"urn:uuid:308dfc69-dee4-4262-8701-55f9449f67cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionGenlsBackchainEncouraged, UnaryPredicate)) .
\"urn:uuid:1b073214-5971-4406-a147-71569d294d70"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionGenlsBackchainEncouraged, Collection)) .
\"urn:uuid:7f7788b0-7951-4b53-9bb3-fa6f38df1a03"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionGenlsBackchainEncouraged, Thing)) .
\"urn:uuid:7149007e-ba6b-4134-8d2f-a1255351c471"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionGenlsBackchainEncouraged, (1))) .
\"urn:uuid:fab2437f-661b-42ee-a246-b11e52a869de"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionGenlsBackchainRequired, UnaryPredicate)) .
\"urn:uuid:3df69f8c-0ed9-477c-a70f-8f43d6fc3afd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionGenlsBackchainRequired, DefaultMonotonicPredicate)) .
\"urn:uuid:23cfe00a-4e4f-441c-b059-eea15196d7c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionGenlsBackchainRequired, Collection)) .
\"urn:uuid:ffa1e304-07e1-438b-8f8c-cc77ef74bcca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionGenlsBackchainRequired, Thing)) .
\"urn:uuid:eb750a30-4a93-4967-8a38-5f4f3443e41d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionGenlsBackchainRequired, collectionGenlsBackchainEncouraged)) .
\"urn:uuid:1606649c-9599-4ae6-8d5a-a3e2db5fd5c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionGenlsBackchainRequired, (1))) .
\"urn:uuid:ad66521e-0bfc-40fd-adce-f3f40a05f4d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionIsaBackchainEncouraged, DefaultMonotonicPredicate)) .
\"urn:uuid:b8ed4a88-35c7-48a0-9053-621b72c95f4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionIsaBackchainEncouraged, UnaryPredicate)) .
\"urn:uuid:373d3d71-7c1a-4c00-85ec-100c47ee6c2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionIsaBackchainEncouraged, Collection)) .
\"urn:uuid:b3941d3b-1178-43d5-86b7-538533861657"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionIsaBackchainEncouraged, Thing)) .
\"urn:uuid:d13a5c38-43b6-48e2-95b5-66a288565953"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionIsaBackchainEncouraged, (1))) .
\"urn:uuid:ae24ae9d-da5e-40a8-be01-9c5f9f04cc28"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionIsaBackchainRequired, UnaryPredicate)) .
\"urn:uuid:ec471e7b-4de0-45d0-8752-feb32ae60022"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(collectionIsaBackchainRequired, DefaultMonotonicPredicate)) .
\"urn:uuid:3f8d4b86-0d8c-4e94-b439-3177771c0934"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(collectionIsaBackchainRequired, Collection)) .
\"urn:uuid:ffd60375-933d-4bec-ba7b-3a3bbe24acaf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(collectionIsaBackchainRequired, Thing)) .
\"urn:uuid:c873bcfe-1058-4f23-94a0-feb99350e856"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(collectionIsaBackchainRequired, collectionIsaBackchainEncouraged)) .
\"urn:uuid:a9f8f752-6196-44c7-821b-2af1b8bd5597"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(collectionIsaBackchainRequired, (1))) .
\"urn:uuid:a3231665-4f94-48d5-a935-f9a56a778aa5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(comment, BinaryPredicate)) .
\"urn:uuid:24de737d-8233-46e8-a772-b400a000c718"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(comment, DistributingMetaKnowledgePredicate)) .
\"urn:uuid:693c1d9c-8cf4-41d3-be88-eebf4633437d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(comment, DefaultMonotonicPredicate)) .
\"urn:uuid:525311e8-f865-4cb2-9853-b66ac4ee0b5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(comment, DocumentationPredicate)) .
\"urn:uuid:f6c1b23b-c79a-4ecb-a35d-653a9372b7a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(comment, Predicate)) .
\"urn:uuid:75be9b34-c572-4366-b0d5-6e22264c97c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(comment, Thing)) .
\"urn:uuid:ab0f1ad4-39b8-4d04-859e-a6cb47d5246c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(comment, CharacterString)) .
\"urn:uuid:2b8b6304-6955-4353-b7e1-df3d991da3b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(comment, CycLIndexedTerm)) .
\"urn:uuid:0cede494-2e23-4c52-998d-a11c0f140e66"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(comment, SubLString)) .
\"urn:uuid:8a9e66f7-a015-438d-884b-eed5841217a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(comment, (2))) .
\"urn:uuid:7d6f347f-d0a9-4959-a769-0e68c1128fef"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgs, DefaultMonotonicPredicate)) .
\"urn:uuid:d8e9c90d-4f8e-4399-9c0d-85dac6a61792"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgs, PartiallyCommutativeRelation)) .
\"urn:uuid:accb4f2a-f806-4664-b008-510e695a9775"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgs, VariableArityRelation)) .
\"urn:uuid:0a29e514-4e94-4fc5-8b5d-906337d38e42"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(commutativeInArgs, Relation)) .
\"urn:uuid:17ac5fc2-da82-46a3-b2ee-3e49bf6612aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(commutativeInArgs, PositiveInteger)) .
\"urn:uuid:f25feefb-ca70-41c2-850c-e4091f5b15d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(commutativeInArgs, PositiveInteger)) .
\"urn:uuid:a914a7b2-fa25-445a-baf9-840d5536a96f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(commutativeInArgs, (3))) .
\"urn:uuid:453f3135-dd5c-490f-91ad-f7701a49d54c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgsAndRest, PartiallyCommutativeRelation)) .
\"urn:uuid:19ddccb4-d521-4734-89b1-4619b8c37071"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgsAndRest, Predicate)) .
\"urn:uuid:33dcf477-2f0a-4819-a02d-676de52cf5b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(commutativeInArgsAndRest, VariableArityRelation)) .
\"urn:uuid:5a4c08dd-cae4-4b46-877b-0b99b1926af5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(commutativeInArgsAndRest, PartiallyCommutativeRelation)) .
\"urn:uuid:9c818900-e84c-4bde-9210-32621e6a72ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(commutativeInArgsAndRest, PositiveInteger)) .
\"urn:uuid:f6b0f24d-b360-4bca-81d4-9eb1c6a6883f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(commutativeInArgsAndRest, commutativeInArgs)) .
\"urn:uuid:af278168-b5b3-4994-9bac-9d5135e8c1d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(commutativeInArgsAndRest, (2))) .
\"urn:uuid:64a11b8c-7480-4aa7-a2f2-0af622cb12a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentAsserted, UnaryPredicate)) .
\"urn:uuid:e200a0a0-b5c0-4d39-b4fc-89b0da29d1ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentAsserted, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:5e1e670f-f82f-4c8f-b7a4-061a41c59a30"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentAsserted, Predicate)) .
\"urn:uuid:962c91ed-aa5f-4f70-a567-ed3d4a006c03"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentAsserted, completeExtentEnumerable)) .
\"urn:uuid:bf34147c-2a4a-499e-a094-1f137f8a8f2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentAsserted, (1))) .
\"urn:uuid:a6bc5727-6ba8-4353-be9d-8421571c0a62"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentAssertedForValueInArg, TernaryPredicate)) .
\"urn:uuid:f6ca6a35-4ce9-41be-81fc-caf0c6ed124d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentAssertedForValueInArg, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:12e651ba-0a7f-4e50-9c15-121e6cc0660d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentAssertedForValueInArg, Predicate)) .
\"urn:uuid:9259957b-ff57-4ae6-8182-bd4efe1a74ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(completeExtentAssertedForValueInArg, Thing)) .
\"urn:uuid:a2a3e7bf-b5d6-4dc7-a45f-b6b34957487a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(completeExtentAssertedForValueInArg, NonNegativeInteger)) .
\"urn:uuid:d7babaf9-af57-4293-9d70-55588a52f3d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentAssertedForValueInArg, completeExtentEnumerableForValueInArg)) .
\"urn:uuid:db3f888b-4da6-40db-b0da-4a263a12c719"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentAssertedForValueInArg, (3))) .
\"urn:uuid:43b422b3-e2d9-4f46-9b63-5cb2215c6902"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentDecidable, UnaryPredicate)) .
\"urn:uuid:ce0b6ead-68c5-42ab-9260-504e406f4801"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentDecidable, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:dc61a8c2-32e1-448d-bdcb-c5971ed93fad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentDecidable, Predicate)) .
\"urn:uuid:32fdf7cc-a8f6-4f9b-b613-d615f98e6b36"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentDecidable, backchainForbidden)) .
\"urn:uuid:d5db5d1f-8d9d-49d2-90a3-c3f59b9330e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentDecidable, (1))) .
\"urn:uuid:15227358-539d-41b2-86ad-a42177fad0cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentDecidableForValueInArg, TernaryPredicate)) .
\"urn:uuid:5fe53ee2-87db-404e-a327-28e5d0628372"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentDecidableForValueInArg, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:c71a5e8c-e6c2-4810-ae87-1d13da29295a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentDecidableForValueInArg, Predicate)) .
\"urn:uuid:609859a3-c8ef-43b5-9d73-8a6fcf4922d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(completeExtentDecidableForValueInArg, Thing)) .
\"urn:uuid:16a1d1d8-8d36-4cf6-8a03-bc35d3983fc0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(completeExtentDecidableForValueInArg, NonNegativeInteger)) .
\"urn:uuid:729d92cd-de63-4850-a332-9cd5ed366217"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentDecidableForValueInArg, (3))) .
\"urn:uuid:c0ddeeb4-7e37-4395-b989-fcc0a0b3219e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerable, UnaryPredicate)) .
\"urn:uuid:50b8a49a-1fcf-4eeb-8ff6-c270c1bcffbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerable, DefaultMonotonicPredicate)) .
\"urn:uuid:aed01f74-6f86-4407-bb08-896453bd2eb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentEnumerable, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:20d5aed6-ca36-49c6-ac0f-a9aee497f716"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentEnumerable, Predicate)) .
\"urn:uuid:e515a8e4-f0e7-48fe-b064-759aa9b1f2fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentEnumerable, minimizeExtent)) .
\"urn:uuid:586bc2a9-4969-4a89-936a-92a079b012a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentEnumerable, completeExtentDecidable)) .
\"urn:uuid:ee398862-bbc7-4e73-b33c-0862838ec1ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentEnumerable, (1))) .
\"urn:uuid:8c43a159-59ff-471e-aa86-713c3eb0cdad"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerableForArg, BinaryPredicate)) .
\"urn:uuid:ee5f9d42-dfb9-42ea-820e-863c6ceffcc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentEnumerableForArg, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:a33e0451-5e66-4a50-b13f-b6f95475cc68"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentEnumerableForArg, Predicate)) .
\"urn:uuid:c51da162-5bd2-492d-983b-46f17c21eea6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(completeExtentEnumerableForArg, NonNegativeInteger)) .
\"urn:uuid:f59ca839-08ba-4b23-b85a-6df80cc92735"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentEnumerableForArg, (2))) .
\"urn:uuid:fd4965da-6709-4293-819d-85a61e52202e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerableForValueInArg, TernaryPredicate)) .
\"urn:uuid:2dbc4a68-95da-4ad3-9e8c-0d035bdc41e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(completeExtentEnumerableForValueInArg, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:ad643edb-bf01-47fb-a24b-518d72fc2926"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentEnumerableForValueInArg, Predicate)) .
\"urn:uuid:29baf455-f75e-495c-a0e4-4b6c0297ba25"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(completeExtentEnumerableForValueInArg, Thing)) .
\"urn:uuid:b4cdface-bc1a-4d27-9845-2542b27a7247"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(completeExtentEnumerableForValueInArg, PositiveInteger)) .
\"urn:uuid:a6951567-7850-431c-9290-7a5bcb2ec81d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentEnumerableForValueInArg, completeExtentDecidableForValueInArg)) .
\"urn:uuid:6fa56590-c3c7-4690-9fdf-1dc4989d8b67"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentEnumerableForValueInArg, nonAbducibleWithValueInArg)) .
\"urn:uuid:3f5abde8-abfc-46e1-8f8b-f1fe8c6e7899"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentEnumerableForValueInArg, (3))) .
\"urn:uuid:0c862715-4480-4b55-8461-091d559cf149"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerableViaBackchain, DefaultMonotonicPredicate)) .
\"urn:uuid:67d85917-47ae-4703-8385-c883594f2b63"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completeExtentEnumerableViaBackchain, UnaryPredicate)) .
\"urn:uuid:cc26e706-1de1-4547-aa28-ddbc491c91b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completeExtentEnumerableViaBackchain, Predicate)) .
\"urn:uuid:5b29b0fc-c9de-4397-961d-000b1f697ed4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completeExtentEnumerableViaBackchain, minimizeExtent)) .
\"urn:uuid:b8d21574-6658-47eb-aa30-93d2fb94f901"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completeExtentEnumerableViaBackchain, (1))) .
\"urn:uuid:58c3728a-c47e-43ce-af6d-7eb5ecb86166"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completelyDecidableCollection, UnaryPredicate)) .
\"urn:uuid:c2a26bd6-2222-41af-8b69-ba1c7ffaa4d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completelyDecidableCollection, Collection)) .
\"urn:uuid:9f530f58-9894-4253-bfaa-fe661e660a65"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(completelyDecidableCollection, Thing)) .
\"urn:uuid:6f0e420b-d8b7-4469-8160-7ff0dc853c81"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completelyDecidableCollection, (1))) .
\"urn:uuid:ef8a45a2-9cdd-4418-84d9-cf2b036006ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(completelyEnumerableCollection, UnaryPredicate)) .
\"urn:uuid:a7254c70-c10f-4929-b782-7842d64483a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(completelyEnumerableCollection, Collection)) .
\"urn:uuid:e451b1bd-8ad9-48f0-88be-16b47a6afbf8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(completelyEnumerableCollection, Thing)) .
\"urn:uuid:b7361fb9-8863-4fa6-acab-ff9d359b2b65"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(completelyEnumerableCollection, completelyDecidableCollection)) .
\"urn:uuid:60a967bc-54b7-47f7-bc9b-ca62eea635c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(completelyEnumerableCollection, (1))) .
\"urn:uuid:c45f6137-05b6-4572-b699-52d5001fde79"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(conceptuallyRelated, IrreflexiveBinaryPredicate)) .
\"urn:uuid:9f574eb4-f6c9-4826-aa64-8e963775ba93"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(conceptuallyRelated, SymmetricBinaryPredicate))) .
\"urn:uuid:f792f3a4-7df1-41f7-9a4a-ae91fe378c91"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(conceptuallyRelated, TransitiveBinaryPredicate))) .
\"urn:uuid:8516b5ed-ac23-477e-a802-7c04c7ddfb10"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(conceptuallyRelated, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:f6de958e-c8ef-447e-9f01-4560604073ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(conceptuallyRelated, Thing)) .
\"urn:uuid:ca62e0b2-d026-476c-b6ca-140c391feb81"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(conceptuallyRelated, Thing)) .
\"urn:uuid:24d8bc33-7a54-4db4-9942-8236f8612646"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(conceptuallyRelated, (2))) .
\"urn:uuid:dd030995-189f-4a86-927f-31fa331d3a02"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(consistent, UnaryPredicate)) .
\"urn:uuid:603bc0fc-97e8-46d6-990c-5315cc8e2929"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(consistent, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6591afda-9a54-4319-a565-47bbabbc511d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(consistent, 'CycLSentence-Assertible')) .
\"urn:uuid:19a9380a-0792-4ef5-8e6f-68826ce9000d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(consistent, admittedSentence)) .
\"urn:uuid:a610716c-b4f5-4f34-8573-78183790f013"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(consistent, (1))) .
\"urn:uuid:5187daad-3ea9-472d-a5a7-c7135d132d51"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constantGUID, BinaryPredicate)) .
\"urn:uuid:9626d13e-6fa0-471f-8e89-cc016fa823e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(constantGUID, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:3de34fd2-86cc-48eb-b09c-1e0e2a765913"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(constantGUID, Thing)) .
\"urn:uuid:bb014e7b-bd3a-4c2d-9fbe-4d07cddf6055"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(constantGUID, SubLString)) .
\"urn:uuid:8501ed91-de2d-410b-b2a3-68d5af2f5e00"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(constantGUID, CycLConstant)) .
\"urn:uuid:41a4e39e-ad52-4aa2-a663-b094b494d4f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(constantGUID, (2))) .
\"urn:uuid:cdea35a0-bf50-427f-a524-1e4b968eeddc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constantID, BinaryPredicate)) .
\"urn:uuid:13434f0c-d214-4562-9c27-b264a7d7a301"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(constantID, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:d97ee00a-0c76-4b7f-bc0e-2ec198b282a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(constantID, Thing)) .
\"urn:uuid:d6cf199b-5ea1-46b4-8c6a-827b382afdf1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(constantID, NonNegativeInteger)) .
\"urn:uuid:39d143a3-1f11-4ced-8eb1-b61c088bd16e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(constantID, CycLConstant)) .
\"urn:uuid:8eae4f0a-c16d-4c1d-9278-440134f12a9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(constantID, (2))) .
\"urn:uuid:9704dab4-4737-40c7-bd9f-a87c951218e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constantName, BinaryPredicate)) .
\"urn:uuid:65c7a090-dadc-4294-8cce-62f2da85fbf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(constantName, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:b5849201-9056-4f02-866e-16a52e676b86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(constantName, Thing)) .
\"urn:uuid:ff60f91e-1a11-4750-89d4-fd93015df229"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(constantName, CharacterString)) .
\"urn:uuid:b208fcc3-9a2f-48fb-a5be-81ec9b5ae7fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(constantName, CycLConstant)) .
\"urn:uuid:3c3a91b1-6201-43ef-80e9-f9d4e6e746f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(constantName, SubLString)) .
\"urn:uuid:64c84e7f-f78b-4007-b4c4-56dc0015d872"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(constantName, (2))) .
\"urn:uuid:9cd07922-f4a6-447f-922a-0f2798bb85c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constrainsArg, DefaultMonotonicPredicate)) .
\"urn:uuid:a171a7e2-c95a-423f-a2d5-2e05ef4ab05d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constrainsArg, BinaryPredicate)) .
\"urn:uuid:a70bbeba-6c97-4912-a1f5-2d315b520153"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(constrainsArg, Predicate)) .
\"urn:uuid:a5ba8405-514b-4af3-999a-e1dbd14914e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(constrainsArg, NonNegativeInteger)) .
\"urn:uuid:ee728492-630c-4907-9bc7-457b09cc834d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(constrainsArg, (2))) .
\"urn:uuid:87acf7a1-1413-4efd-ab1d-f0a02cdc4c00"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(constraint, UnaryPredicate)) .
\"urn:uuid:38e52648-0364-47b5-b3f3-e5c740b8edfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(constraint, WFFSupportedPredicate))) .
\"urn:uuid:03150a46-595f-4b54-abd5-714b4fbebf4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(constraint, CycLAssertion)) .
\"urn:uuid:abe0ce27-65cd-4567-aeed-0efe3fe0f251"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(constraint, (1))) .
\"urn:uuid:83f5df4f-bf19-4eca-b893-89525e862515"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycInferenceAnswerLink, BinaryPredicate)) .
\"urn:uuid:21389ca1-b6af-47ee-8a72-d7d6a10a8bb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycInferenceAnswerLink, CycInference)) .
\"urn:uuid:257aa06c-43d5-4373-b6fa-5e51e119b1dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycInferenceAnswerLink, 'CycProblemLink-AnswerLink')) .
\"urn:uuid:b4fe4062-a39d-41d7-a9b9-2fb0326affa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycInferenceAnswerLink, (2))) .
\"urn:uuid:95e3245c-093e-4dd2-8766-f3cff6a7b45e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycInferenceRelevantProblems, BinaryPredicate)) .
\"urn:uuid:5b4ebc0e-86b3-43a4-ad2e-8e9d82151f5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycInferenceRelevantProblems, CycInference)) .
\"urn:uuid:d3fcfeaa-9b92-4947-9d4d-045fce076673"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycInferenceRelevantProblems, CycProblem)) .
\"urn:uuid:a4203229-b9ce-4afd-b25b-d638105aec94"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycInferenceRelevantProblems, (2))) .
\"urn:uuid:94873f67-40b9-4f87-9daa-c6779e82211e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemArgumentLinks, BinaryPredicate)) .
\"urn:uuid:3ba0cc20-e378-4522-890f-e663a3e7b018"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemArgumentLinks, CycProblem)) .
\"urn:uuid:28cc563a-eab2-4516-8daf-eb32bb26b1fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemArgumentLinks, CycProblemLink)) .
\"urn:uuid:860a193f-83e9-4593-94d6-c8a8181c0069"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemArgumentLinks, (2))) .
\"urn:uuid:5778f2c9-7af2-4234-893d-d01007e9a79b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemDependentLinks, BinaryPredicate)) .
\"urn:uuid:8fad6ae1-ee05-47ab-b2d4-e467a74b7734"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemDependentLinks, CycProblem)) .
\"urn:uuid:a42037c4-9ba2-433f-a67e-b74d021b3c35"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemDependentLinks, CycProblemLink)) .
\"urn:uuid:9a1b1917-ab21-4b7b-bdd3-114fdeb6d039"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemDependentLinks, (2))) .
\"urn:uuid:8d23b282-1eb7-432c-baf2-452a0dd5cb96"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemID, TernaryPredicate)) .
\"urn:uuid:f1cadacc-2627-4c15-8abb-ef6bc671c549"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemID, CycProblem)) .
\"urn:uuid:9586eba3-66a8-4a0b-84b7-6a59ac05443c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemID, CycProblemStore)) .
\"urn:uuid:7d007169-f12e-42bf-92c4-03b303417556"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(cycProblemID, NonNegativeInteger)) .
\"urn:uuid:9339f584-a412-44d2-aa99-ed9580a498a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemID, (3))) .
\"urn:uuid:b17cd011-202e-4f79-828c-2c493e8b2608"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemLinkID, TernaryPredicate)) .
\"urn:uuid:31bf23b9-d121-44d9-a843-84e6a6eff133"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemLinkID, CycProblemLink)) .
\"urn:uuid:1c604a6b-7631-4806-aec4-db6769b78ed4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemLinkID, CycProblemStore)) .
\"urn:uuid:99d9babd-689a-44da-b213-fc1b10cb2d86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(cycProblemLinkID, NonNegativeInteger)) .
\"urn:uuid:febfdb8d-ceb8-474f-bbb3-95327331bcec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemLinkID, (3))) .
\"urn:uuid:031a0568-b697-48ac-b037-8c977e37848e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemProvabilityStatus, BinaryPredicate)) .
\"urn:uuid:222d1ac6-d847-4014-8039-4a993452f71c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemProvabilityStatus, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:ea6c5911-78e0-45f3-b847-25235a5d8eff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemProvabilityStatus, CycProblem)) .
\"urn:uuid:ba1686e1-dee7-4302-af19-af587bacd73c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemProvabilityStatus, Collection)) .
\"urn:uuid:a27be532-8f1c-46fa-b9e7-02ae827fe5b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(cycProblemProvabilityStatus, CycProvabilityStatus)) .
\"urn:uuid:6487d2af-104d-46b9-a025-0e9cd93571f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemProvabilityStatus, (2))) .
\"urn:uuid:19c576ee-2c71-4177-a03e-f742a61ed325"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemQuerySentence, BinaryPredicate)) .
\"urn:uuid:f452391a-4dba-485f-8896-d90ae95ed6e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemQuerySentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:0b237020-a5d4-4e2e-b705-cc6f34eee146"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemQuerySentence, CycProblem)) .
\"urn:uuid:098a5a58-e7fd-4fea-843f-988fa8638dba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(cycProblemQuerySentence, 'CycLSentence-Askable')) .
\"urn:uuid:54002ac0-ab38-491f-a347-08fcc6ac02aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemQuerySentence, (2))) .
\"urn:uuid:1f1a7a70-61b2-40fa-945b-7654cec05028"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemQueryTerms, BinaryPredicate)) .
\"urn:uuid:b49a9e83-11de-445e-a1bd-2ac92e59d3cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemQueryTerms, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:b3c5900d-4a86-496a-a1e2-a389a0ab3cf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemQueryTerms, CycProblem)) .
\"urn:uuid:dd19d185-2bda-435e-9877-8642e7eb164b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemQueryTerms, Thing)) .
\"urn:uuid:255df13f-0d33-496e-a2df-a5457484646f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(cycProblemQueryTerms, CycLClosedDenotationalTerm)) .
\"urn:uuid:904b1baa-886c-418f-b4ae-2030780ce3b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemQueryTerms, (2))) .
\"urn:uuid:5e6333e4-6b4e-44bc-b842-bf6e1afd02ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreID, BinaryPredicate)) .
\"urn:uuid:c1a7f18c-333f-438c-a8aa-3115c4a6b90e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreID, CycProblemStore)) .
\"urn:uuid:a78022a8-d7b0-46f2-a81d-5e9f74654691"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreID, NonNegativeInteger)) .
\"urn:uuid:5586619c-2501-4404-aad9-c56081fcde9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreID, (2))) .
\"urn:uuid:a33ff60b-9902-48ac-beda-ee8f5c4c77c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreInferenceCount, BinaryPredicate)) .
\"urn:uuid:37420e55-faf7-4c67-906e-741316ac5743"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreInferenceCount, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:36ebceaf-c2f8-4d1a-9a88-93c45019f262"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreInferenceCount, CycProblemStore)) .
\"urn:uuid:21a91774-23d2-4260-b71c-dd4051474503"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreInferenceCount, NonNegativeInteger)) .
\"urn:uuid:0605083c-f17b-4c79-85c4-f4d47fd85508"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreInferenceCount, (2))) .
\"urn:uuid:6f921116-ceb5-419f-8795-a5f52c9aea5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreInferences, BinaryPredicate)) .
\"urn:uuid:6ab86386-d067-41f4-82da-ed20e9ac9b0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreInferences, CycProblemStore)) .
\"urn:uuid:3db2cdf4-1171-464e-8d28-cd04872f3e2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreInferences, CycInference)) .
\"urn:uuid:b63c75f1-0faa-4364-a452-7c6584e239bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreInferences, (2))) .
\"urn:uuid:cbf64ad7-ad2f-496c-b8d9-25b65de9f48a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreLinkCount, BinaryPredicate)) .
\"urn:uuid:27217b04-6f75-4be7-829e-870bd3504c16"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreLinkCount, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:eff16e67-4121-43af-8b80-6c0f0df2f45c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreLinkCount, CycProblemStore)) .
\"urn:uuid:54281fcd-5cfb-47bb-8256-61ed368ce56c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreLinkCount, NonNegativeInteger)) .
\"urn:uuid:96975fec-1cca-45db-ab93-5e5a1105303c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreLinkCount, (2))) .
\"urn:uuid:d62386c9-8017-47b9-a9df-9e4ced3e1503"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreLinks, BinaryPredicate)) .
\"urn:uuid:d07e1430-d73a-4fc1-95e0-494085bd6aac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreLinks, CycProblemStore)) .
\"urn:uuid:294c9fcb-bec2-486e-bb35-435e765c6747"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreLinks, CycProblemLink)) .
\"urn:uuid:1d195b92-7411-4466-a7f9-b0013c375fca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreLinks, (2))) .
\"urn:uuid:9956886f-3f25-4701-82fe-32723a296166"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreProblemCount, BinaryPredicate)) .
\"urn:uuid:f0fb9dcf-faee-48fd-99ad-d78ab87b9fcb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreProblemCount, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:7b7e8c63-d04e-4f07-b56d-79fda2590934"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreProblemCount, CycProblemStore)) .
\"urn:uuid:3da40b68-81f8-4b47-843d-0c062da2b5a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreProblemCount, NonNegativeInteger)) .
\"urn:uuid:784ba1ed-0cff-4d9a-8b28-48999b4de1e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreProblemCount, (2))) .
\"urn:uuid:ae3fc942-11b0-48fc-98dd-80c82480fd41"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreProblems, BinaryPredicate)) .
\"urn:uuid:765cc307-60f2-4ed5-82dc-95ec93549a13"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreProblems, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:4351322c-dc41-4c5a-89a3-41683d1ea395"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreProblems, CycProblemStore)) .
\"urn:uuid:771473c8-bfbf-4560-a16f-b7aaecd4b045"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreProblems, CycProblem)) .
\"urn:uuid:402f1d59-968b-4575-bdf3-d1748aa483f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreProblems, (2))) .
\"urn:uuid:62649903-2855-4c6a-ae1c-b184893bfcda"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreProofCount, BinaryPredicate)) .
\"urn:uuid:ac9bd806-21bf-4678-9ef5-062960a6e055"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreProofCount, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:c2e3a519-7f88-4b98-8fbc-2376d16f2bd2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreProofCount, CycProblemStore)) .
\"urn:uuid:4703f841-e340-4d7c-8144-55a1bce18312"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreProofCount, NonNegativeInteger)) .
\"urn:uuid:35ef5ebf-3720-4e2a-9caf-d431658cc496"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreProofCount, (2))) .
\"urn:uuid:04b6b6f9-61ef-41cb-9382-11745d02d0b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreProofs, BinaryPredicate)) .
\"urn:uuid:d1b8b3f6-5551-416a-917e-8b15bc65db4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreProofs, CycProblemStore)) .
\"urn:uuid:2ceb4aea-9096-45ac-b04e-94511c338b0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreProofs, CycProof)) .
\"urn:uuid:0bee2c12-e297-4583-84d9-9da1290a0c99"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreProofs, (2))) .
\"urn:uuid:da5e41d9-b40d-463c-aa78-231e61b4876f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProblemStoreTerms, BinaryPredicate)) .
\"urn:uuid:0d3c45f1-0cac-4a56-97c8-0d48337111fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycProblemStoreTerms, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:3d2f0ec1-5cb2-42b5-bdb0-2a0010fac3e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProblemStoreTerms, CycProblem)) .
\"urn:uuid:714fe7fc-9e34-4ae2-8495-896038a46f10"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProblemStoreTerms, Thing)) .
\"urn:uuid:09c4ff29-bf14-43e1-9d91-c57fba6c0d9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(cycProblemStoreTerms, CycLClosedDenotationalTerm)) .
\"urn:uuid:a78101f2-23a8-4189-9235-80eeabfab161"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProblemStoreTerms, (2))) .
\"urn:uuid:b8d9a72c-2389-4cfd-9a87-0a01d104f653"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycProofID, TernaryPredicate)) .
\"urn:uuid:9dd83231-110a-4669-bbb3-5f71c56ec876"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycProofID, CycProof)) .
\"urn:uuid:f7006cc9-cf5b-4535-b31c-d29d7c7bb7cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycProofID, CycProblemStore)) .
\"urn:uuid:2996a236-53fe-45ca-bcb6-90fe1c336073"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(cycProofID, NonNegativeInteger)) .
\"urn:uuid:d9897afd-a97f-4348-bff3-19906163155c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycProofID, (3))) .
\"urn:uuid:ba407a36-84ff-41d3-a634-5a50a619f1ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycTacticID, TernaryPredicate)) .
\"urn:uuid:88f8ff7d-d838-4f0b-99b5-f5a1357bc8f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycTacticID, CycTactic)) .
\"urn:uuid:4bbe92de-9356-4cdc-b7d8-12b565ec6afd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycTacticID, CycProblem)) .
\"urn:uuid:18a8eab5-00b1-4aeb-ace6-89a48ce2269c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(cycTacticID, NonNegativeInteger)) .
\"urn:uuid:763ff340-92ed-4b5f-86da-b255c55370e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycTacticID, (3))) .
\"urn:uuid:14224961-34bc-412f-b822-2d2bf3a92378"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycTransformationProofBindings, BinaryPredicate)) .
\"urn:uuid:bd75cc51-c5c8-4398-980b-0e30816c252e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycTransformationProofBindings, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:91332646-b942-4cbb-83b9-236d0af0be1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycTransformationProofBindings, CycTransformationProof)) .
\"urn:uuid:d0694c69-0ce4-4d09-8711-cf28e23c164d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(cycTransformationProofBindings, List)) .
\"urn:uuid:a450273c-2a20-426c-9374-3ec063353365"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycTransformationProofBindings, (2))) .
\"urn:uuid:5a77bf8b-520d-4934-8d5e-abd272f8a249"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cycTransformationProofRule, BinaryPredicate)) .
\"urn:uuid:2f4064e5-240b-4e77-bfe9-2968f2a6c5e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(cycTransformationProofRule, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:3dc8d8f7-4c3f-4fe0-8591-6872192499e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(cycTransformationProofRule, CycTransformationProof)) .
\"urn:uuid:bdb5a6c6-91e3-41d0-ab1d-f5bf22325c47"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(cycTransformationProofRule, CycLRuleAssertion)) .
\"urn:uuid:5dde07d7-e31b-490f-9ef9-2efb2b3d6871"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(cycTransformationProofRule, (2))) .
\"urn:uuid:24a1f8d2-1fb4-4a7f-ac84-aef3c14480dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(decontextualizedCollection, UnaryPredicate)) .
\"urn:uuid:899b6992-bf7e-4505-8c22-2eed9ebb6e5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(decontextualizedCollection, Collection)) .
\"urn:uuid:f5989daf-a0bf-4c73-a753-2e9e2c262d8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(decontextualizedCollection, Thing)) .
\"urn:uuid:39de4e63-4e61-4244-95f1-1046a66fa954"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(decontextualizedCollection, (1))) .
\"urn:uuid:1f06b934-12b1-4c34-85b8-fc52e5a2f35a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(decontextualizedPredicate, UnaryPredicate)) .
\"urn:uuid:a890eeb6-441f-48e1-98f2-1d6d83bf95c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(decontextualizedPredicate, DefaultMonotonicPredicate)) .
\"urn:uuid:62a07ad6-89dd-4afb-b365-81fa5df46c5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(decontextualizedPredicate, Predicate)) .
\"urn:uuid:86fa7109-7dea-4ce7-bbda-32853bf106c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(decontextualizedPredicate, (1))) .
\"urn:uuid:9cada22f-e5d7-40f6-a48f-ad9686e3019f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defaultReformulationDirectionInModeForPred, TernaryPredicate)) .
\"urn:uuid:36b5de75-4313-4703-aa55-091ac07a3d3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defaultReformulationDirectionInModeForPred, ReformulatorDirectivePredicate)) .
\"urn:uuid:b0a1df9f-11e1-49bb-af1b-c449659c6642"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(defaultReformulationDirectionInModeForPred, Thing)) .
\"urn:uuid:edd85ece-6745-48b5-989f-1f06d9467543"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(defaultReformulationDirectionInModeForPred, Individual)) .
\"urn:uuid:4a680f17-6c24-461a-ad55-855efce23aea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(defaultReformulationDirectionInModeForPred, ReformulatorDirectivePredicate)) .
\"urn:uuid:bcb513dc-448d-4a2f-9582-1340713c14df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(defaultReformulationDirectionInModeForPred, (3))) .
\"urn:uuid:0a376cbf-1f1f-4c8a-820b-de62eb70364c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defaultReformulatorModePrecedence, ReformulatorDirectivePredicate)) .
\"urn:uuid:fe044085-def7-4136-afc1-8744ba4431eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defaultReformulatorModePrecedence, VariableArityRelation)) .
\"urn:uuid:c80da528-3466-48cf-80ed-1319003ba363"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(defaultReformulatorModePrecedence, Individual)) .
\"urn:uuid:c7d1be4c-c1b2-466c-9e1d-7871213b5b26"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(definingMt, DefaultMonotonicPredicate)) .
\"urn:uuid:872cea10-5f1a-4e63-8cca-db83bf7450c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(definingMt, BinaryPredicate)) .
\"urn:uuid:f779e8ae-4438-44f5-8e4f-d4375538debb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(definingMt, Thing)) .
\"urn:uuid:f33b0ae8-3f7c-427c-a555-dc5474b8b0c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(definingMt, Microtheory)) .
\"urn:uuid:9dcdfd2d-7790-4866-b8be-4abd93e032bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(definingMt, CycLReifiableDenotationalTerm)) .
\"urn:uuid:697e7f2c-0f35-4a9c-aa02-53aac0d25187"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(definingMt, termDependsOn)) .
\"urn:uuid:9d5aa4fd-86f2-4b92-9722-a8bd75b71a8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(definingMt, (2))) .
\"urn:uuid:d8de9735-00d0-4294-a942-72a1044e2073"[silk#strict] .
istAsserted(BaseKB, isa(defnIff, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:f932d311-6d4f-4997-a121-e6452cbe0356"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnIff, BinaryPredicate)) .
\"urn:uuid:0551b0a4-faf7-44a7-9256-8c725c8065c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnIff, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:3f9143a5-6b5b-4262-9639-44dbd6848dfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(defnIff, Collection)) .
\"urn:uuid:e6bf3b0a-ef3f-41a5-b039-a41c70ee03b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(defnIff, Thing)) .
\"urn:uuid:3cd5855e-0543-4c8b-b541-4c97b9da8bc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(defnIff, CycLNonAtomicTerm)) .
\"urn:uuid:c13bc600-bf8c-4fb4-a500-9f3f9e2f205f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(defnIff, defnNecessary)) .
\"urn:uuid:7abbc670-a330-4089-b245-70468cebc636"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(defnIff, defnSufficient)) .
\"urn:uuid:a8175d71-18b3-400a-a64f-c7c5fa29df51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(defnIff, (2))) .
\"urn:uuid:233e87a9-1775-4c59-b401-141d134acae3"[silk#strict] .
istAsserted(BaseKB, isa(defnNecessary, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:6278f186-3b15-4816-ac4c-e0da29e379b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnNecessary, BinaryPredicate)) .
\"urn:uuid:e78da6ac-1b1c-42c2-907e-dfcab10fb0e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnNecessary, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:f42559be-8b6a-4319-98f9-7b6ea869960e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(defnNecessary, Collection)) .
\"urn:uuid:59387cec-8836-424a-b2ec-c2c66759caf1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(defnNecessary, Thing)) .
\"urn:uuid:b9435cad-4809-4ec1-abd1-ea557ca7cc0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(defnNecessary, CycLNonAtomicTerm)) .
\"urn:uuid:9ef75dd0-aee8-4e4e-8071-9c89d411a59d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(defnNecessary, (2))) .
\"urn:uuid:c267bc3e-d797-45d8-b02d-53faf95fb1c0"[silk#strict] .
istAsserted(BaseKB, isa(defnSufficient, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:6f29124b-f941-4250-adc0-5a4c6eb673c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnSufficient, BinaryPredicate)) .
\"urn:uuid:9fdaf821-9b39-4fcc-b9c5-bf663d14a8ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(defnSufficient, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:f34885f4-992d-44c2-9880-55fdb2103afd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(defnSufficient, Collection)) .
\"urn:uuid:4d50bc74-430e-41a7-90a1-d9910b9c9f26"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(defnSufficient, Thing)) .
\"urn:uuid:c700f9fd-ab6f-4f45-b3ac-5b0b77443d2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(defnSufficient, CycLNonAtomicTerm)) .
\"urn:uuid:1cf1403c-593a-4e16-b494-6edda2fbd592"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(defnSufficient, (2))) .
\"urn:uuid:94d0069f-ccfd-485f-ac1e-95b096354f19"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(denotes, AsymmetricBinaryPredicate)) .
\"urn:uuid:fedd6f15-1788-4ac1-9845-bd52c1b55e72"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(denotes, AntiTransitiveBinaryPredicate)) .
\"urn:uuid:776215f1-1bb4-47b8-b645-0d9095b1a269"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(denotes, CycLDenotationalTerm)) .
\"urn:uuid:956da566-ab37-4435-9824-e195e8549f98"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(denotes, Thing)) .
\"urn:uuid:85085754-62e2-4027-8a3d-dd47ed39bc5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(denotes, means)) .
\"urn:uuid:a79b2530-e00c-461e-8a0c-aba66157330b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(denotes, (2))) .
\"urn:uuid:78fab066-a44d-483f-a7b7-8fefb8ed6d39"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(different, EvaluatablePredicate)) .
\"urn:uuid:b22dd021-da0b-49f9-9a28-4d94137decd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(different, CommutativeRelation)) .
\"urn:uuid:1e9a2da7-3517-4a6c-afb8-fc20a542276a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(different, VariableArityRelation)) .
\"urn:uuid:dc65b33e-7832-41c4-9018-b031ce7c8551"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(different, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:f9dfe9db-0d42-47bc-8514-8e0d943f3a3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsIsa(different, Thing)) .
\"urn:uuid:9f648cbd-db89-4a95-96ff-b6fd6aaf1c87"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(different, differentSymbols)) .
\"urn:uuid:32d19b12-16fa-4685-a8f7-de2ffc003697"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(different, (2))) .
\"urn:uuid:a3059d0f-8df5-4ab2-8bc7-052633178fc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(differentSymbols, EvaluatablePredicate)) .
\"urn:uuid:fb1d8bd3-f14b-4428-9ec4-744260c74f65"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(differentSymbols, CommutativeRelation)) .
\"urn:uuid:efc15c32-60b1-49e6-b544-635e909d7b7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(differentSymbols, VariableArityRelation)) .
\"urn:uuid:bc0682ec-0ce3-4930-af1f-d61b9a2b5848"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(differentSymbols, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:94dde9b4-bfe5-4f9d-836a-b7079c615f4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsQuotedIsa(differentSymbols, CycLExpression)) .
\"urn:uuid:821b20c7-89eb-4765-a1e7-f76ec0cd3362"[silk#strict] .
istAsserted(UniversalVocabularyMt, arityMin(differentSymbols, (2))) .
\"urn:uuid:46beef88-33fc-4995-8b17-8ec606a726c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(disjointWith, SymmetricBinaryPredicate)) .
\"urn:uuid:9dd8e969-6187-48b9-ba7a-7448bad267ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(disjointWith, DefaultMonotonicPredicate)) .
\"urn:uuid:8928c34c-92dd-442a-bddd-6b22eb7f1dae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(disjointWith, WFFConstraintPredicate)) .
\"urn:uuid:3865a1a4-0a41-43cf-a0ad-f4ccebb6bca2"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(disjointWith, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:5a67804c-c8e7-4db1-affd-73861ed98d93"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(disjointWith, IrreflexiveBinaryPredicate))) .
\"urn:uuid:b4e8d28b-69f2-4d0e-828b-0c2ad93a9d85"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(disjointWith, TransitiveBinaryPredicate))) .
\"urn:uuid:41fd35b0-0845-41a5-8788-4c5d3520aef0"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(disjointWith, Predicate)) .
\"urn:uuid:8e2a254c-1250-4b94-9779-f3660776dfb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(disjointWith, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:b90c1516-5eb2-4a57-b898-53beb5b2dc1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(disjointWith, Collection)) .
\"urn:uuid:4ccd7184-9459-414e-8d80-672fb0a0b4c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(disjointWith, Thing)) .
\"urn:uuid:0da222c2-8548-4dad-9e6d-52c722fb3c1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(disjointWith, Collection)) .
\"urn:uuid:b6f4bdf5-aa6f-4510-9c81-8dfa6ae702f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(disjointWith, Thing)) .
\"urn:uuid:db49afdb-e1d3-4a36-87b0-93896a2da8d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(disjointWith, disjointWith)) .
\"urn:uuid:06f465de-2413-4c32-965a-d3f1834285bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(disjointWith, (2))) .
\"urn:uuid:1ed05f3d-4371-4637-8144-0675f19ad447"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(distributesOutOfArg, TernaryPredicate)) .
\"urn:uuid:4d311b00-b706-4744-92d5-189fce480115"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(distributesOutOfArg, Relation)) .
\"urn:uuid:201618df-4536-497f-9667-556557ae9612"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(distributesOutOfArg, Predicate)) .
\"urn:uuid:c02e0daa-2983-4cde-bdb6-44c8cb22948e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(distributesOutOfArg, PositiveInteger)) .
\"urn:uuid:df7aa6b6-f5e8-43f8-b208-82fb77c355d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(distributesOutOfArg, (3))) .
\"urn:uuid:7abd3dbb-76e8-4cdb-8d67-f29995b309db"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(elInverse, AsymmetricBinaryPredicate)) .
\"urn:uuid:e1924849-fa54-4673-9cc1-a9d15599bfdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(elInverse, DefaultMonotonicPredicate)) .
\"urn:uuid:c9170b9d-baee-4794-9c36-6b29f48c7196"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(elInverse, AntiTransitiveBinaryPredicate)) .
\"urn:uuid:2a16d7a4-447a-421c-a16f-eb2c9012afa6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(elInverse, Predicate)) .
\"urn:uuid:a96dd7c4-cf99-4cba-8f6f-b24b99f1c75d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(elInverse, BinaryPredicate)) .
\"urn:uuid:91a98d64-294c-4c13-a8cc-e14a6f6c89df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(elInverse, 'ELRelation-OneWay')) .
\"urn:uuid:690c32f1-35bf-4aac-baa6-321af03af0e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(elInverse, BinaryPredicate)) .
\"urn:uuid:f6885c61-6d52-408f-9cbe-82c9017f183b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(elInverse, genlInverse)) .
\"urn:uuid:de40a18d-d733-457c-83ee-58213da7480a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(elInverse, genlInverse)) .
\"urn:uuid:bf3896bd-9cb9-4e2f-9694-e60898029261"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(elInverse, (2))) .
\"urn:uuid:ff906e5a-80dc-4f9d-a723-f842a2ed0320"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(elementOf, BinaryPredicate)) .
\"urn:uuid:046883c6-6a8b-4d67-aa15-58da416d6240"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:da89cf92-33ce-4174-a1f2-24028fb6eaf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, TransitiveBinaryPredicate))) .
\"urn:uuid:be957dff-7676-419e-a115-7cf5d752d1ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, ReflexiveBinaryPredicate))) .
\"urn:uuid:d8130077-72f8-4559-8fac-5c1016db5aca"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, AsymmetricBinaryPredicate))) .
\"urn:uuid:d232ced9-12ac-46f4-84b9-c8ddbe9ff0d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, IrreflexiveBinaryPredicate))) .
\"urn:uuid:29623188-abe3-4ec3-ae41-b4db11db6816"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(elementOf, SymmetricBinaryPredicate))) .
\"urn:uuid:c3e150db-e003-496c-8939-ba45dcc0300c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(elementOf, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:a5724f98-538c-4ea3-8a13-f5f9ec7f0c16"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(elementOf, Thing)) .
\"urn:uuid:ae6535fe-4236-4a8a-8100-66ae9074cd6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(elementOf, SetOrCollection)) .
\"urn:uuid:b9f05492-c6f5-4006-9db3-26be75b92eab"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(elementOf, (2))) .
\"urn:uuid:c1c9cdfa-ef9f-42fa-9d6f-5b53e5a74fa2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ephemeralTerm, BookkeepingPredicate)) .
\"urn:uuid:d89c6f16-59bc-4099-80a3-3fbb6756500a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ephemeralTerm, UnaryPredicate)) .
\"urn:uuid:80bb74d7-558d-42dc-9eae-a1317958b648"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ephemeralTerm, Thing)) .
\"urn:uuid:bd62b770-e715-41d1-815b-7ab239895ffc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(ephemeralTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:872c9119-2d7c-400b-b06d-ce788c363532"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ephemeralTerm, (1))) .
\"urn:uuid:91bebda6-7eef-4cf9-92a6-f9ce1198837b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('equalStrings-CaseInsensitive', ReflexiveBinaryPredicate)) .
\"urn:uuid:c82129f2-06ff-4e19-9606-060cd84ba19d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('equalStrings-CaseInsensitive', SymmetricBinaryPredicate)) .
\"urn:uuid:2a58a786-8939-4f36-a97d-f59e06955a8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('equalStrings-CaseInsensitive', TransitiveBinaryPredicate)) .
\"urn:uuid:46fe4d38-5fda-402d-a4a8-12c9e532f738"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa('equalStrings-CaseInsensitive', 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:9091a944-ef05-4d2b-9225-d915e6fdbb5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('equalStrings-CaseInsensitive', CharacterString)) .
\"urn:uuid:25c1e862-f17e-4981-bfb6-4c429f5d6016"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('equalStrings-CaseInsensitive', CharacterString)) .
\"urn:uuid:afcf4916-4291-4a92-b084-97e700aa88bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds('equalStrings-CaseInsensitive', 'substring-CaseInsensitive')) .
\"urn:uuid:cdeffe94-bfa5-4401-941f-f79df0b9c32f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds('equalStrings-CaseInsensitive', equals)) .
\"urn:uuid:8c665c80-4c47-4493-8a39-191c618dc2f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse('equalStrings-CaseInsensitive', 'substring-CaseInsensitive')) .
\"urn:uuid:ae4b319c-dcae-46ee-a390-e0dbe41ae72c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse('equalStrings-CaseInsensitive', 'equalStrings-CaseInsensitive')) .
\"urn:uuid:f1f1ab32-e89d-415c-9414-6c8b5480c44a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('equalStrings-CaseInsensitive', (2))) .
\"urn:uuid:b605553d-dc37-4d25-aee4-795811c2264d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equalSymbols, SymmetricBinaryPredicate)) .
\"urn:uuid:131da304-c6f9-4535-a2e5-d5ffa1bb992a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equalSymbols, TransitiveBinaryPredicate)) .
\"urn:uuid:d75d23b8-6e0f-4e7a-895e-07def227dcb3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equalSymbols, ReflexiveBinaryPredicate)) .
\"urn:uuid:50754c27-2eda-42fc-86a9-41873ad774ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(equalSymbols, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:c3b349a8-8e40-4a75-ae55-00d571643408"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(equalSymbols, Thing)) .
\"urn:uuid:51c2bac7-e6da-4bab-aabc-f7f26c9d0bca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(equalSymbols, Thing)) .
\"urn:uuid:7c4aff9c-fa92-4152-99c2-8264e131e2ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(equalSymbols, equals)) .
\"urn:uuid:26cc2693-0281-4d20-a5af-df4fd402d8d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(equalSymbols, equalSymbols)) .
\"urn:uuid:9bf72b1f-3099-4f93-8f56-a21e0d84266e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(equalSymbols, (2))) .
\"urn:uuid:3a2d9aff-a6ac-43ed-8197-a18bb49df1a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equals, SymmetricBinaryPredicate)) .
\"urn:uuid:f43fc3eb-72b5-4d51-836f-a6fec8a5088c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equals, TransitiveBinaryPredicate)) .
\"urn:uuid:a854e276-2af2-43ba-bf0a-e218082c8b5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equals, ReflexiveBinaryPredicate)) .
\"urn:uuid:bcc5ade2-0a07-4c88-b8df-7c908806c32c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equals, DefaultMonotonicPredicate)) .
\"urn:uuid:2719bf30-ed3c-413c-b98f-ea84ed387296"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(equals, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:1b136cee-4a8c-491c-b07f-8dfb99d38818"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(equals, Thing)) .
\"urn:uuid:bfa0772a-2b49-4f8d-9bc2-9fd8b51d6465"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(equals, Thing)) .
\"urn:uuid:3874dfc4-bb94-4000-80a4-486ac48d691e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(equals, equals)) .
\"urn:uuid:a5ed8a1d-5d09-4b8f-afbe-513acbe7d13b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(equals, (2))) .
\"urn:uuid:b256b1fd-0ee0-4d35-b636-da3e6171bae3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equiv, LogicalConnective)) .
\"urn:uuid:f46b77f6-398f-48e2-8647-0e0519260199"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equiv, CommutativeRelation)) .
\"urn:uuid:1c9dc1a9-948a-417e-b1b3-02fe4cef90e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equiv, 'ELRelation-OneWay')) .
\"urn:uuid:0f2e2202-1bf0-43ef-85f6-2ff82c4cd1de"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equiv, AssociativeRelation)) .
\"urn:uuid:1e0af215-6488-4513-ac7b-eaee5072fd11"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(equiv, BinaryRelation)) .
\"urn:uuid:d18b93f9-fcb9-4bb4-869f-ee740c25ffcc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(equiv, 'CycLSentence-Assertible')) .
\"urn:uuid:4c3866f7-bff2-4b9b-b9bf-f790e7adbd06"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(equiv, 'CycLSentence-Assertible')) .
\"urn:uuid:c855a56c-a6cd-4137-a2f4-15883627cef4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(equiv, (2))) .
\"urn:uuid:3b88bb4b-9e1b-4de2-a841-fdb370d26cf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluate, BinaryPredicate)) .
\"urn:uuid:38e85ea7-4c58-4a99-88cf-2ff5a113ab7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(evaluate, SymmetricBinaryPredicate))) .
\"urn:uuid:e3d1a7b2-e4b7-4ed6-ab21-2652a461f9f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(evaluate, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:cb0ccb16-2238-446d-8b59-8563ac5c63a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(evaluate, Thing)) .
\"urn:uuid:36e9b0cc-e589-4c6b-9944-c56f8ff2b3f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(evaluate, Thing)) .
\"urn:uuid:6db6000a-d4ab-4b1e-9830-5bd95cf75832"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(arg2Isa(evaluate, 'CycLNonAtomicTerm-Askable'))) .
\"urn:uuid:b170587e-a65e-4975-bcb2-2039e82b43e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(evaluate, (2))) .
\"urn:uuid:c3fb2db7-85cc-4605-817a-04ca242771fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluateAtEL, UnaryPredicate)) .
\"urn:uuid:846f7540-da15-45bb-9815-6aa9e653e1a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(evaluateAtEL, EvaluatableFunction)) .
\"urn:uuid:9a4ea4dc-2df7-4fc6-bc50-1095b2116427"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(evaluateAtEL, (1))) .
\"urn:uuid:d3b2c436-d86f-4425-b730-b6147f674f33"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluateImmediately, UnaryPredicate)) .
\"urn:uuid:704caad0-284a-4968-84a3-578b9dae30d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(evaluateImmediately, EvaluatableFunction)) .
\"urn:uuid:085fdd89-0543-4484-9b91-af9e5d0581cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(evaluateImmediately, (1))) .
\"urn:uuid:21c03974-504c-4c5c-832f-be724af397ac"[silk#strict] .
istAsserted(BaseKB, isa(evaluationDefn, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:94425af3-534a-42b2-9684-9160f2407600"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluationDefn, DefaultMonotonicPredicate)) .
\"urn:uuid:8e9c75db-4a61-4f17-b043-a50b9be09d9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluationDefn, BinaryPredicate)) .
\"urn:uuid:42749cec-afcf-4625-80dd-35306a0ed7b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(evaluationDefn, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:f163b32a-8441-4162-b6a5-9c93a2d06e67"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(evaluationDefn, EvaluatableRelation)) .
\"urn:uuid:a173f847-45c6-40ce-8cd5-e2082f667abc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(evaluationDefn, CycLNonAtomicTerm)) .
\"urn:uuid:32a3db59-af63-4906-8aa2-ea4fa902b895"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(evaluationDefn, (2))) .
\"urn:uuid:bacee2f5-e014-4811-9122-776878d1c571"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluationResultQuotedIsa, BinaryPredicate)) .
\"urn:uuid:6a5a57ed-0fee-4dcc-bb1b-d4ddcc986adb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(evaluationResultQuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:666743cd-75dc-42cd-80db-530f2b580b76"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(evaluationResultQuotedIsa, WFFSupportedPredicate))) .
\"urn:uuid:882eb923-a3e0-45fc-a934-3a6dc31deaa1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(evaluationResultQuotedIsa, EvaluatableRelation)) .
\"urn:uuid:584ca065-b674-4ae0-b969-47239d3fd27a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(evaluationResultQuotedIsa, SubLExpressionType)) .
\"urn:uuid:9947b1af-f0cc-42bd-9ce3-0b04681253ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(evaluationResultQuotedIsa, SubLSExpression)) .
\"urn:uuid:0f43d59c-dec2-47f1-81e2-56ec728297d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(evaluationResultQuotedIsa, (2))) .
\"urn:uuid:c0912164-ee2f-459e-b554-610bbd62e1dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exactlyAssertedSentence, UnaryPredicate)) .
\"urn:uuid:e6adeaa6-fede-424f-9ed7-b4c25104d151"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(exactlyAssertedSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:437cbc0d-3048-46e0-acc0-b5a4632b1662"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(exactlyAssertedSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:254c2de3-94b1-43ce-9120-46d1e29aea1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(exactlyAssertedSentence, assertedSentence)) .
\"urn:uuid:ef80c0b2-8a20-43f5-8ac8-201fc555c65b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(exactlyAssertedSentence, (1))) .
\"urn:uuid:ba387672-a74a-4e73-8e88-5ffb7333c87e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exampleAssertions, BinaryPredicate)) .
\"urn:uuid:2267e6bd-478d-4293-8ad0-4d4e8d88ce6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exampleAssertions, DocumentationPredicate)) .
\"urn:uuid:b1a44b95-1700-4dc8-a84f-05416aa6debe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(exampleAssertions, Thing)) .
\"urn:uuid:56c4ba65-8339-4e68-a4ec-0afc2183af8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(exampleAssertions, CycLReifiableDenotationalTerm)) .
\"urn:uuid:6f579c1d-f709-4faa-b6ab-5899c9a03da4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(exampleAssertions, CycLAssertion)) .
\"urn:uuid:77465ba1-62df-47fc-8020-579361a04862"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(exampleAssertions, (2))) .
\"urn:uuid:98641bb7-c359-4ef7-8c23-4d665fee809b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(except, UnaryPredicate)) .
\"urn:uuid:6eb932df-f5d6-4732-aa14-5dd9f3d715b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(except, CycLAssertion)) .
\"urn:uuid:68c7f071-eb6a-481b-a667-03c2ef9a2d4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(except, (1))) .
\"urn:uuid:cfb16519-b61e-4cb3-8f06-269d06845f41"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exceptFor, BinaryRelation)) .
\"urn:uuid:8465111b-4b94-4eb5-9a34-c2563d8b2bf9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exceptFor, ExceptionPredicate)) .
\"urn:uuid:b26f7ab0-0a33-41f2-b23a-af8e4d90cd93"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(exceptFor, Thing)) .
\"urn:uuid:cb797f1b-1cf2-405b-877f-a0e28f6ede03"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(exceptFor, CycLReifiableDenotationalTerm)) .
\"urn:uuid:dfecd705-5971-4d93-891c-53f1d975873d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(exceptFor, CycLAssertion)) .
\"urn:uuid:69a86704-1910-4de0-96d2-1f07a6bb10ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(exceptFor, (2))) .
\"urn:uuid:c3d277f2-4b81-4378-b466-02c36125aebb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exceptMt, UnaryPredicate)) .
\"urn:uuid:885dbf01-42e9-40ef-8d63-874352d7c6dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(exceptMt, Microtheory)) .
\"urn:uuid:d5ae3b2e-2143-4798-ad67-88b3a0611646"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(exceptMt, (1))) .
\"urn:uuid:3563d70e-40d7-4a1d-8539-1199e6bd8213"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exceptWhen, BinaryRelation)) .
\"urn:uuid:cbee51fa-a910-436f-b795-ff61ad3989aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(exceptWhen, ExceptionPredicate)) .
\"urn:uuid:3809a0d4-7322-497f-89a1-78ff5cdd6374"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(exceptWhen, 'CycLSentence-Assertible')) .
\"urn:uuid:4415d10c-b30b-4d88-bf7d-8fc7cd8228df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(exceptWhen, CycLAssertion)) .
\"urn:uuid:bb601cbc-07d8-4832-ba01-4160e8bb9d79"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(exceptWhen, (2))) .
\"urn:uuid:e1a98c66-0f85-403d-a5c3-64a364ed1dc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(expansion, ReformulatorDirectivePredicate)) .
\"urn:uuid:b615eabf-ef4a-4acb-93de-1703af2accf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(expansion, CycLReformulationRulePredicate)) .
\"urn:uuid:51607fd6-fc02-4359-8fd8-def226e82cdc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(expansion, BinaryPredicate)) .
\"urn:uuid:6408cf5f-e774-44fd-a047-d06b5ea5f2ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(expansion, Relation)) .
\"urn:uuid:542b2245-3693-42d2-9bef-70b6bec7657e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(expansion, Thing)) .
\"urn:uuid:e88f64b0-c219-4e44-a396-d05f9948107f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(expansion, CycLExpression)) .
\"urn:uuid:48efd954-3982-4ca7-91dd-099f24a2bdb7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(expansion, (2))) .
\"urn:uuid:186e94ef-57a0-4c3c-9094-63118466972e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(expansionDefn, BinaryPredicate)) .
\"urn:uuid:8dd824cd-4684-4301-9f88-8d0aa00a0a61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(expansionDefn, Relation)) .
\"urn:uuid:add6247d-a263-4b3d-a195-fad121753f74"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(expansionDefn, CycLNonAtomicTerm)) .
\"urn:uuid:d6be5a80-30da-4371-ba0c-b00e476afea1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(expansionDefn, (2))) .
\"urn:uuid:ef781392-0e8a-4f59-83da-87621cf17d55"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(expresses, BinaryPredicate)) .
\"urn:uuid:8b4e23c2-2be3-4fe3-9ba4-41909a2365fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(expresses, CycLSentence)) .
\"urn:uuid:c75706c6-be73-43f9-9120-1a91ffdbc105"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(expresses, Thing)) .
\"urn:uuid:19ffb779-248b-4a25-9d34-7fa8d7997e7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(expresses, means)) .
\"urn:uuid:7abd6902-a362-441d-92e3-143854b41fec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(expresses, (2))) .
\"urn:uuid:96833d28-2166-47bf-9a4f-96e0e2715e45"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(extConceptOverlapsColAndReln, QuaternaryPredicate)) .
\"urn:uuid:9b1f0d9c-f1b0-4d82-b52c-6ff7b7b09c1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(extConceptOverlapsColAndReln, Collection)) .
\"urn:uuid:19d58986-5382-4788-a019-e030a7381639"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(extConceptOverlapsColAndReln, Thing)) .
\"urn:uuid:a1795c2b-d903-4746-964b-e985cf3d5bc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(extConceptOverlapsColAndReln, BinaryPredicate)) .
\"urn:uuid:e7fd6bdb-d484-4a71-b470-bd0bf1e8907f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(extConceptOverlapsColAndReln, Individual)) .
\"urn:uuid:d79e0a3b-25a9-4385-bb53-44b4f21a4029"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(extConceptOverlapsColAndReln, CharacterString)) .
\"urn:uuid:c283e74c-df69-472d-8786-54a2d84350ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(extConceptOverlapsColAndReln, (4))) .
\"urn:uuid:f8931b70-abdb-4897-a52d-c729af79cf83"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(extentCardinality, BinaryPredicate)) .
\"urn:uuid:f15970bd-1762-4291-97f7-2cd421085026"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(extentCardinality, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:db63dc6c-8288-4a87-b360-8e2dd06ce8e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(extentCardinality, SetOrCollection)) .
\"urn:uuid:85727f9b-0a22-4259-a0dc-aa18bbf0fcc2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(extentCardinality, NonNegativeInteger)) .
\"urn:uuid:ca07ce56-0fec-4a2a-b4f2-500081e9ca9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(extentCardinality, (2))) .
\"urn:uuid:c173657c-aaaa-4806-86f5-9ed3274da018"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(fanOutArg, DefaultMonotonicPredicate)) .
\"urn:uuid:217c9da8-b5a0-4859-8d01-23b831c8c2c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(fanOutArg, BinaryPredicate)) .
\"urn:uuid:dd33e00c-3f3f-478d-a4a4-fba9fc37bd89"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(fanOutArg, BinaryPredicate)) .
\"urn:uuid:ccbe0b93-827f-415e-931b-1c9a9ba30b39"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(fanOutArg, PositiveInteger)) .
\"urn:uuid:10baa021-7834-4e3b-95ed-c792d3396594"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(fanOutArg, (2))) .
\"urn:uuid:f6971f41-8b90-4970-8eec-ffabbbb69e1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(followingValue, AsymmetricBinaryPredicate)) .
\"urn:uuid:98f1c4b3-4f7a-4a0d-b9aa-ef31e8ea7cfb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(followingValue, TransitiveBinaryPredicate)) .
\"urn:uuid:e9abc160-13ac-4e45-a52d-a7314f59cf70"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(followingValue, ScalarInterval)) .
\"urn:uuid:9cd003d0-b298-465e-bd9f-6cf3890d427c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(followingValue, ScalarInterval)) .
\"urn:uuid:73239028-17bf-46d9-bfac-255f60d9a147"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(followingValue, lessThan)) .
\"urn:uuid:c0b513e7-8ae3-42e8-a231-b4f22eecca76"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(followingValue, different)) .
\"urn:uuid:253923ea-ebd0-43c8-81b8-fbf7f8110809"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(followingValue, greaterThan)) .
\"urn:uuid:36c483db-691d-4d38-92e0-847d2e789f9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(followingValue, (2))) .
\"urn:uuid:9cc60e6e-46a1-471e-9960-422ecc3303b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(forAll, Quantifier)) .
\"urn:uuid:4b5d32d5-b175-4d0a-8c31-9ea1ce4c5dbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(forAll, BinaryRelation)) .
\"urn:uuid:50024445-2f82-4ce2-9005-a84ccef2095e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(forAll, CycLVariable)) .
\"urn:uuid:75b22fa6-6e80-46f3-b91f-489ecaaae325"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(forAll, 'CycLSentence-Assertible')) .
\"urn:uuid:76c47321-1999-4de8-a1de-9686085dbec4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(forAll, (2))) .
\"urn:uuid:ed9c2649-0572-46cc-8243-3d8734a2b9de"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(formulaArity, BinaryPredicate)) .
\"urn:uuid:853570dc-4afe-45e9-845f-c199b5276d6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(formulaArity, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:3f8a4eaf-d159-4d08-bad0-1aadede2b699"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(formulaArity, Thing)) .
\"urn:uuid:62fe98f8-d5f7-4223-a656-31fdf5433747"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(formulaArity, PositiveInteger)) .
\"urn:uuid:d5f9f59a-b762-4522-9661-c8297dfb0264"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(formulaArity, CycLFormula)) .
\"urn:uuid:1c141f49-c6a0-442f-a076-943907c4280a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(formulaArity, (2))) .
\"urn:uuid:e0eb1b72-ae97-48ff-ba82-22de0ca04287"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(forwardNonTriggerLiteral, UnaryPredicate)) .
\"urn:uuid:642d4d86-02bd-43dd-a519-96c80c3e968e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(forwardNonTriggerLiteral, InferenceSupportedPredicate)) .
\"urn:uuid:7f9e4e78-90a2-4d9a-87f6-a291b4523c71"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(forwardNonTriggerLiteral, CycLOpenSentence)) .
\"urn:uuid:0f9d2622-5756-4ca1-8445-8012b966d40d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(forwardNonTriggerLiteral, (1))) .
\"urn:uuid:0548c7bd-5276-4140-9aaa-7a9d70f0e415"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genFormat, TernaryPredicate)) .
\"urn:uuid:e37a0748-e524-4400-90b3-272fdee24158"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genFormat, Relation)) .
\"urn:uuid:1a079203-0cf1-4c2b-968a-d516683e90be"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genFormat, CharacterString)) .
\"urn:uuid:d8f2d99d-66c2-440c-93e0-d41097fa37ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(genFormat, List)) .
\"urn:uuid:48fc1adc-c2a5-4253-961d-bf9b228cda2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(genFormat, SubLString)) .
\"urn:uuid:db66eba9-01be-4af3-8811-0adf68fbb7ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genFormat, (3))) .
\"urn:uuid:f599a50c-e7d7-485e-be71-731fdc9df9f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genKeyword, BinaryPredicate)) .
\"urn:uuid:522a9362-16f2-4688-8a4c-ebbc8e1024eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genKeyword, Thing)) .
\"urn:uuid:467e9b59-415d-4bbe-a075-3054206332eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(genKeyword, CycLReifiableDenotationalTerm)) .
\"urn:uuid:fc850be3-44a3-474a-abe7-33754dbe05de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(genKeyword, SubLKeyword)) .
\"urn:uuid:7a5f51fe-3e36-497f-94ce-27b77449d398"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genKeyword, (2))) .
\"urn:uuid:ca25a9f7-0995-4882-8418-8f83933415a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genMassNoun, UnaryPredicate)) .
\"urn:uuid:b13340b7-0e9a-4ed8-9a93-f2af42a9a64e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genMassNoun, Thing)) .
\"urn:uuid:db21bd5f-24c1-48da-995f-ad3b3183e794"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(genMassNoun, CycLReifiableDenotationalTerm)) .
\"urn:uuid:976ad87b-4b23-4d0e-89f6-2766a2335fec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genMassNoun, (1))) .
\"urn:uuid:272c389e-2963-4641-bc9b-3de94b77b755"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlCanonicalizerDirectives, TransitiveBinaryPredicate)) .
\"urn:uuid:ae2b14d3-bdb0-4e0d-98d2-bdec30485e8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genlCanonicalizerDirectives, CanonicalizerDirective)) .
\"urn:uuid:77a888ad-43b4-4ad1-bef5-f6b50d2c6354"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genlCanonicalizerDirectives, CanonicalizerDirective)) .
\"urn:uuid:3ad02754-18b4-4cf9-b88e-0a472e754da6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genlCanonicalizerDirectives, (2))) .
\"urn:uuid:b1a527d1-74f2-4146-b20e-64cc70d0c3a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlInverse, DefaultMonotonicPredicate)) .
\"urn:uuid:8b8f9e58-7529-4a1f-86d4-9d844a5d1bcf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlInverse, BinaryPredicate)) .
\"urn:uuid:9c0c1eb3-a1ad-42e7-89ba-574c4cc032eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlInverse, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:58623e5f-61ef-4e88-a70f-3bf64ea47da1"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:e3d7c8a2-4673-47e7-bacd-8d39e94beca1"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, IrreflexiveBinaryPredicate))) .
\"urn:uuid:71879e28-73e6-4185-aa40-62cc916cbe68"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, ReflexiveBinaryPredicate))) .
\"urn:uuid:70ec9234-202d-45d0-b5ee-ee55d83eb0e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, TransitiveBinaryPredicate))) .
\"urn:uuid:fb7b8418-cee1-42e6-8385-53329bd8f7f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, AsymmetricBinaryPredicate))) .
\"urn:uuid:dc5b88f2-c79d-4029-a03b-28bd32462c31"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlInverse, SymmetricBinaryPredicate))) .
\"urn:uuid:e65011a0-3bd3-47ef-8c94-85c8608667c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlInverse, Predicate)) .
\"urn:uuid:3c41d22c-c5b5-4282-b3d4-c21410903fb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlInverse, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:abc715e5-7948-4767-a784-269a10df7595"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlInverse, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:48c983a4-20d2-4ca2-8e96-66329d638614"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genlInverse, BinaryPredicate)) .
\"urn:uuid:d715416a-b978-4390-895a-3b4699ea4356"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genlInverse, BinaryPredicate)) .
\"urn:uuid:14879844-2304-48b7-8298-8d960c178e66"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genlInverse, (2))) .
\"urn:uuid:73e72642-92c1-45ea-a8ba-83d9e0a9e359"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlMt, DefaultMonotonicPredicate)) .
\"urn:uuid:68e3c7b9-4348-441e-af1b-b55457772a8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlMt, TransitiveBinaryPredicate)) .
\"urn:uuid:3e736162-5e2e-4f2b-b38d-ae28a1af0b7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlMt, ReflexiveBinaryPredicate)) .
\"urn:uuid:6b01a58b-15c6-4fa1-b443-c0eb3a7f33a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlMt, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:92140edc-11b7-4e65-b73d-93ce841a3b56"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlMt, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:3286b9de-3ebe-49d9-8e0d-d81cd0459332"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlMt, TransformationModuleSupportedPredicate)) .
\"urn:uuid:a0fa327c-a333-4564-8bdf-e4d1f2fea86f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlMt, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:cdf5d263-1b91-4b98-af7e-9bac3d40a9d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genlMt, Microtheory)) .
\"urn:uuid:a54fdb13-48a2-4302-9d7c-9e563e087219"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genlMt, Microtheory)) .
\"urn:uuid:163319f7-35cc-41ea-be50-d36f1159020f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genlMt, (2))) .
\"urn:uuid:e352d174-8a3b-4bdc-80b0-4b589bb25a8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlPreds, TransitiveBinaryPredicate)) .
\"urn:uuid:f3e2fb89-cccc-42ee-af89-1acd183eb8c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlPreds, ReflexiveBinaryPredicate)) .
\"urn:uuid:1c6addac-1bb4-4941-b802-49320075274d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlPreds, DefaultMonotonicPredicate)) .
\"urn:uuid:7dc5602d-be70-4dc6-9a52-8c82b70506c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlPreds, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:feee33eb-bb8c-45dc-8b7c-7f1c778ad1b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genlPreds, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:ea79203c-29ba-48da-8689-fd6960b6c837"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlPreds, Predicate)) .
\"urn:uuid:d1843947-2de8-4ec7-8287-e58df0f636a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlPreds, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:2e040026-6224-4766-9c9a-ab0da37011af"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlPreds, TransformationModuleSupportedPredicate)) .
\"urn:uuid:8f1a1dd2-af98-400a-b415-fdc9ae3a3bdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genlPreds, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:c3e629c0-eb65-4743-bbfe-0256d47909ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genlPreds, Predicate)) .
\"urn:uuid:487b3d4b-8004-4dee-b00f-e4f28f4b1b03"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genlPreds, Predicate)) .
\"urn:uuid:017335c3-113b-4d35-a72d-7830d4d173b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genlPreds, (2))) .
\"urn:uuid:95c7e5a8-72dd-49fd-a131-338175e947ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genlRules, TransitiveBinaryPredicate)) .
\"urn:uuid:07dd38ef-7df5-4b88-bd11-0f8b0852db13"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(genlRules, CycLRuleAssertion)) .
\"urn:uuid:3669af00-1711-4531-be06-54a9017987b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(genlRules, CycLRuleAssertion)) .
\"urn:uuid:857ba94b-ad53-4478-acee-69e81248a11f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genlRules, (2))) .
\"urn:uuid:9f2bfc7e-c120-45d7-a7e1-a3e9e253f900"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genls, TransitiveBinaryPredicate)) .
\"urn:uuid:e5ebdb05-ae7e-484a-a54b-4ae44ecbb28f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genls, ReflexiveBinaryPredicate)) .
\"urn:uuid:86edc712-c19c-4b08-8802-5832279b4ce4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genls, DefaultMonotonicPredicate)) .
\"urn:uuid:a380572e-35d7-4d91-bb6c-3ccd896275dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genls, ReformulatorIrrelevantFORT)) .
\"urn:uuid:98c31e00-5901-467e-90e7-fc3a53514ea2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(genls, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:7b69bca3-cc28-4f93-ba57-3bba188ea6d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genls, SymmetricBinaryPredicate))) .
\"urn:uuid:14329038-a8c9-44cb-a0ad-373a2ac808d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genls, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:54bc0a04-7b50-4be9-89a6-8b9dc03bb2c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(genls, AsymmetricBinaryPredicate))) .
\"urn:uuid:4249cecd-3636-47df-9ca0-6e13ff7392ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genls, Predicate)) .
\"urn:uuid:1870cbac-33ad-4cfe-b2f5-535bc7ef92a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genls, TransformationModuleSupportedPredicate)) .
\"urn:uuid:ba2c7f97-d8cd-4899-a65d-c0b340a2ce2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(genls, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:11303105-1d82-4a8b-9717-dfe307973f01"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(genls, Collection)) .
\"urn:uuid:4be7941a-6448-4006-866e-e65f6f615e1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(genls, Thing)) .
\"urn:uuid:e238e7b6-f091-4e62-8b5f-4cfcbca227c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(genls, Collection)) .
\"urn:uuid:2fbc70cd-11a4-46f8-a6b8-99551136dacd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(genls, Thing)) .
\"urn:uuid:f3ef09e7-f01b-4d1b-993a-d6ee6d884875"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(genls, subsetOf)) .
\"urn:uuid:9ea1b47a-6e5a-466a-83d9-c2349ed5060c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(genls, (2))) .
\"urn:uuid:0c8ae5d5-fa6c-410a-aede-da6aaf25b73b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('genls-GenlDenotesSpecInstances', BinaryPredicate)) .
\"urn:uuid:7bbd509f-6a25-4824-be8e-0a9051475232"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('genls-GenlDenotesSpecInstances', DefaultMonotonicPredicate)) .
\"urn:uuid:d7847ca0-28ef-4ad9-999f-d75324514eb5"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', TransitiveBinaryPredicate))) .
\"urn:uuid:8688eaa2-df34-4cb1-8ae0-cc0b60b97e45"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', ReflexiveBinaryPredicate))) .
\"urn:uuid:91a6db68-c766-4a1f-a426-194f7540e69f"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', SymmetricBinaryPredicate))) .
\"urn:uuid:afa4c4ab-00e5-45a4-9445-fc719fa3da61"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', AsymmetricBinaryPredicate))) .
\"urn:uuid:c13c1094-34aa-4434-8c95-d2c037f58777"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', AntiSymmetricBinaryPredicate))) .
\"urn:uuid:1ec6a998-a48b-4f62-8039-2a46f08f0f1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-GenlDenotesSpecInstances', WFFSupportedPredicate))) .
\"urn:uuid:dd589c01-a43b-4710-9745-397692ea3c46"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa('genls-GenlDenotesSpecInstances', Predicate)) .
\"urn:uuid:bdd67fc4-cd1d-4d0a-9ce5-ce75d3d26449"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('genls-GenlDenotesSpecInstances', Collection)) .
\"urn:uuid:feb67130-3fba-49ee-985f-41872ae9dca5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('genls-GenlDenotesSpecInstances', SubLExpressionType)) .
\"urn:uuid:864e750d-a5c1-45dd-b46e-22a1cd505077"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('genls-GenlDenotesSpecInstances', SubLSExpression)) .
\"urn:uuid:052b3a9e-6b26-4582-942f-50aa25105726"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('genls-GenlDenotesSpecInstances', (2))) .
\"urn:uuid:6182722f-096d-4e9c-82ec-f684418ba7d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('genls-SpecDenotesGenlInstances', BinaryPredicate)) .
\"urn:uuid:702471e1-9fcb-4d14-a197-4cb33bc7e171"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('genls-SpecDenotesGenlInstances', DefaultMonotonicPredicate)) .
\"urn:uuid:302c4755-c063-4a20-929d-d46802573964"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', TransitiveBinaryPredicate))) .
\"urn:uuid:3d44e09f-2cce-42ee-9b69-03de6b26a61d"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', ReflexiveBinaryPredicate))) .
\"urn:uuid:fda57c8b-c6ac-49d9-95e3-1d202f177e76"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', SymmetricBinaryPredicate))) .
\"urn:uuid:e6340864-c250-4173-9951-aea70761563a"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', AsymmetricBinaryPredicate))) .
\"urn:uuid:87eed4e9-7d02-478c-9406-21aa937e9d98"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', AntiSymmetricBinaryPredicate))) .
\"urn:uuid:8c510850-b224-4a43-8a2d-18291702c589"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa('genls-SpecDenotesGenlInstances', WFFSupportedPredicate))) .
\"urn:uuid:1cd32896-5fe0-484c-baf1-9ba7cce5a9ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa('genls-SpecDenotesGenlInstances', Predicate)) .
\"urn:uuid:f33e06db-59da-4ec0-857c-4f41cc96d407"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('genls-SpecDenotesGenlInstances', SubLExpressionType)) .
\"urn:uuid:a1029aa9-e876-4740-b559-c587f1124624"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl('genls-SpecDenotesGenlInstances', SubLSExpression)) .
\"urn:uuid:85f65a46-cf99-4998-b5f5-15b02a82174d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('genls-SpecDenotesGenlInstances', Collection)) .
\"urn:uuid:ab247821-d19c-4168-886c-18a4e80679f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('genls-SpecDenotesGenlInstances', (2))) .
\"urn:uuid:708e3791-d9d4-4cf0-ba23-79ad6e566fd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThan, AsymmetricBinaryPredicate)) .
\"urn:uuid:5a2bd8de-12d4-4527-80a8-51a45fdd9940"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThan, TransitiveBinaryPredicate)) .
\"urn:uuid:3281ca91-a5a8-4681-a57c-9dc0777d5cbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThan, EvaluatablePredicate)) .
\"urn:uuid:edd07f52-0332-4752-b8ff-7fce8cc1d22e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(greaterThan, ScalarInterval)) .
\"urn:uuid:78a66739-3d8b-4f93-8fc6-c37a3cea632c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(greaterThan, NonNegativeInteger)) .
\"urn:uuid:2b9c6067-a335-472c-a893-38b0b6985dbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(greaterThan, ScalarInterval)) .
\"urn:uuid:cd5050b2-e822-4be5-ae72-29de6cca66ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(greaterThan, NonNegativeInteger)) .
\"urn:uuid:d9c587cc-740d-4209-8cb3-8349f4344c8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(greaterThan, greaterThanOrEqualTo)) .
\"urn:uuid:4827d84a-22a3-4a7e-b7f4-c18dc40c1f29"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(greaterThan, different)) .
\"urn:uuid:63d6ae6d-acd7-4844-92ae-99f5db566340"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(greaterThan, different)) .
\"urn:uuid:42dcfb2a-8050-43f3-97d2-e24270156a39"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(greaterThan, (2))) .
\"urn:uuid:35d33ebb-d799-43de-93ed-37e11389de7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThanOrEqualTo, ReflexiveBinaryPredicate)) .
\"urn:uuid:ee81c807-f335-4592-b461-855ee746b114"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThanOrEqualTo, TransitiveBinaryPredicate)) .
\"urn:uuid:fd0db503-9407-4379-8cb6-28e0b68a6a96"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThanOrEqualTo, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:e5c5c18d-dfc3-4a34-8e33-a0ccd9b0a072"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(greaterThanOrEqualTo, EvaluatablePredicate)) .
\"urn:uuid:8da391ca-5a30-40a6-b197-134a7e0a6a4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(greaterThanOrEqualTo, ScalarInterval)) .
\"urn:uuid:5d36e809-4f31-463f-8476-8760b0ce6e6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(greaterThanOrEqualTo, NonNegativeInteger)) .
\"urn:uuid:e3dbc4af-bf6b-4cba-bce1-17e6ca7b17c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(greaterThanOrEqualTo, ScalarInterval)) .
\"urn:uuid:63701b48-ae63-4572-a500-cb7a7750202e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(greaterThanOrEqualTo, NonNegativeInteger)) .
\"urn:uuid:f155c0f4-4ba5-4a71-83f2-3fc57b575a2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(greaterThanOrEqualTo, (2))) .
\"urn:uuid:cd54c911-b92d-441e-b540-23dee08dff04"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(highlyRelevantAssertion, UnaryPredicate)) .
\"urn:uuid:092a7695-a524-412e-a37a-8fcfae375876"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(highlyRelevantAssertion, CycLAssertion)) .
\"urn:uuid:f87d6f67-cf8b-49f8-be2d-8ed4a60b45c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(highlyRelevantAssertion, (1))) .
\"urn:uuid:1ca580b4-cbd9-46d2-bc02-3fdc7718f054"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(highlyRelevantMt, UnaryPredicate)) .
\"urn:uuid:c5ab879f-7afa-48dd-8924-02f0c52a57c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(highlyRelevantMt, Microtheory)) .
\"urn:uuid:18d503c4-0660-4aa1-9d6b-ec36341a62a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(highlyRelevantMt, (1))) .
\"urn:uuid:5cda97f5-9bec-4dac-a1e7-145f1b41f87b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(highlyRelevantPredAssertion, BinaryPredicate)) .
\"urn:uuid:c7fcb732-e3c9-4b7b-a0a0-c4369c1ae52f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(highlyRelevantPredAssertion, Predicate)) .
\"urn:uuid:46f066cf-2723-4987-9b24-da99261f3253"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(highlyRelevantPredAssertion, CycLAssertion)) .
\"urn:uuid:e9fcd67d-0b37-45b5-b5bc-9dbedad93643"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(highlyRelevantPredAssertion, (2))) .
\"urn:uuid:5e01356a-0b51-4fbe-b295-6f3c579d1bb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(highlyRelevantTerm, UnaryPredicate)) .
\"urn:uuid:e95b47d2-9f76-4b86-a45a-0fa08d634245"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(highlyRelevantTerm, Thing)) .
\"urn:uuid:73bb2ee7-d8f3-4b48-84f1-8161a19946a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(highlyRelevantTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:6b49eee0-58f5-4c53-ba2d-60c142eb6290"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(highlyRelevantTerm, (1))) .
\"urn:uuid:7e498a44-44dd-4130-96e1-3b8f4205d4fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(hlPrototypicalInstance, BinaryPredicate)) .
\"urn:uuid:47f43fd4-ab8c-40d6-999b-c1fb186fa23c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(hlPrototypicalInstance, InferenceSupportedPredicate)) .
\"urn:uuid:4714e5bf-4d14-4777-810e-e66e98fa1e45"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(hlPrototypicalInstance, Thing)) .
\"urn:uuid:6cc8fae5-2b56-45fc-b0dd-11ea39d83d41"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(hlPrototypicalInstance, Collection)) .
\"urn:uuid:bb505201-d5f7-4909-873a-52a8ac6a0589"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(hlPrototypicalInstance, CycLIndexedTerm)) .
\"urn:uuid:5ca66360-eca9-47ed-8429-32dd280eadad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(hlPrototypicalInstance, HLPrototypicalTerm)) .
\"urn:uuid:c60864ce-6092-400a-a94a-119323d11175"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(genlPreds(hlPrototypicalInstance, isa))) .
\"urn:uuid:ed4d10ca-e600-40ee-91ea-83f95fe1eb35"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(hlPrototypicalInstance, (2))) .
\"urn:uuid:796af398-e167-4a78-85e2-eb85a8888205"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(holdsIn, BinaryPredicate)) .
\"urn:uuid:5392ebb4-3b03-4921-b0c9-c5497cec1566"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(holdsIn, Individual)) .
\"urn:uuid:ac910695-0baf-432e-a265-1b42a6fa8d90"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(holdsIn, 'CycLSentence-Assertible')) .
\"urn:uuid:da95df4b-8a75-458a-9370-3efb89f4ad2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(holdsIn, (2))) .
\"urn:uuid:1a1b61f0-e13b-497b-852c-021164b71b0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(hypotheticalTerm, BookkeepingPredicate)) .
\"urn:uuid:77d8d95b-cfd8-414a-b935-9a812ac2ab68"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(hypotheticalTerm, UnaryPredicate)) .
\"urn:uuid:b92cd0da-9538-4190-a1b3-57e47ee0956b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(hypotheticalTerm, Thing)) .
\"urn:uuid:571ab213-79f8-4f24-a1eb-216d8dd10644"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(hypotheticalTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:4d1d54b5-42c8-42ab-b86c-53339db4f940"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(hypotheticalTerm, (1))) .
\"urn:uuid:2826202a-1c3b-4fba-94f4-03e9fbd1ab68"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(implies, LogicalConnective)) .
\"urn:uuid:978b919a-52fc-4b9b-8819-e6dce2200f49"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(implies, BinaryRelation)) .
\"urn:uuid:ac0e539d-003e-4ca9-a835-ca2b326fb98a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(implies, 'CycLSentence-Assertible')) .
\"urn:uuid:2ce5c6e1-dafe-46d8-8160-f901eb70be0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(implies, 'CycLSentence-Assertible')) .
\"urn:uuid:85f08d3d-c892-4e9f-ad9f-49ca313c2a68"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(implies, (2))) .
\"urn:uuid:77a1d549-e85f-4f71-bb18-65390d0ee373"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(independentArg, BinaryPredicate)) .
\"urn:uuid:b8166b6c-8971-40df-b9e9-62db42a57b8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(independentArg, TernaryPredicate)) .
\"urn:uuid:d8ae4871-5208-4d4f-b24c-886002c14239"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(independentArg, ArgConstraintPredicate)) .
\"urn:uuid:e293e76b-8dd5-4dbe-91c6-5cad1203e23a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(independentArg, NonNegativeInteger)) .
\"urn:uuid:b8fa8606-0085-45bc-b43e-29da5d18645b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(independentArg, (2))) .
\"urn:uuid:4f77db47-2c6c-4fde-9358-69cb7b4bf80f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(indexicalReferent, BinaryPredicate)) .
\"urn:uuid:69b6df43-1137-44cb-afe5-6fe86a7dff90"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(indexicalReferent, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:45adc02d-8d5d-40cf-8e5e-20e3d9174775"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(indexicalReferent, Thing)) .
\"urn:uuid:edaebf1b-808b-416d-8c05-de8d57f4f613"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(indexicalReferent, Thing)) .
\"urn:uuid:27898bfe-f3b2-4a3e-8b5a-d416c361e72c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(indexicalReferent, IndeterminateTerm)) .
\"urn:uuid:f3efe6ef-780a-4724-a60d-9c7e08788615"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(indexicalReferent, equals)) .
\"urn:uuid:fc4fb7e4-a048-4d2b-ade8-4c46753be458"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(indexicalReferent, (2))) .
\"urn:uuid:9b7744b4-a5a5-4cc6-8727-83bd4f133cc7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(instanceElementType, BinaryPredicate)) .
\"urn:uuid:5bb61e35-dd55-48f0-8b86-b87065fa4b6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(instanceElementType, DefaultMonotonicPredicate)) .
\"urn:uuid:a5ba8d94-1ba3-4335-8103-4f39e04a55de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(instanceElementType, Collection)) .
\"urn:uuid:43ce9d6b-9fd3-41bf-bd34-78964596e859"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(instanceElementType, 'Set-Mathematical')) .
\"urn:uuid:7bcc94e8-81a5-47d2-84a1-5aff70a5480f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(instanceElementType, Collection)) .
\"urn:uuid:b03ce791-2087-4178-b96f-eff15ebcdb32"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(instanceElementType, Thing)) .
\"urn:uuid:546ebc28-e491-4b1a-bf35-049923cb1503"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(instanceElementType, (2))) .
\"urn:uuid:1b98be48-b7f9-4913-a2b3-d9ab19855fff"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(integerBetween, TernaryPredicate)) .
\"urn:uuid:691cd191-3146-4f83-98d8-c18a7f3c20d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(integerBetween, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:d36faa6e-fd38-4372-a7d4-55a1deb2bc0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(integerBetween, Integer)) .
\"urn:uuid:81c34977-d4d4-4189-917a-792988f8b715"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(integerBetween, Integer)) .
\"urn:uuid:a04e1d8f-1300-4091-ac49-f35b2a89d090"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(integerBetween, Integer)) .
\"urn:uuid:f4fec1c3-9a05-4786-96c6-910f7fedc23d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(integerBetween, (3))) .
\"urn:uuid:da162fc6-6618-4f53-bd0a-67502b29309c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgDifferent, TernaryPredicate)) .
\"urn:uuid:354dcbed-9dd4-4f06-9fbc-e58bb8207b71"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgDifferent, DefaultMonotonicPredicate)) .
\"urn:uuid:df6394b6-630d-41e9-8b02-0d60fe8128e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgDifferent, PartiallyCommutativeRelation)) .
\"urn:uuid:70be541a-d0ae-4258-8481-93035e493c62"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgDifferent, ArgConstraintPredicate)) .
\"urn:uuid:d4cebc0a-9748-424f-950b-424028d3b07a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgDifferent, WFFConstraintPredicate)) .
\"urn:uuid:f0986219-1615-4562-abef-32bedb74e0ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(interArgDifferent, Predicate)) .
\"urn:uuid:ee5d174b-47f6-4821-a6f2-ff5c69c1bbd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgDifferent, Relation)) .
\"urn:uuid:1c94ea4f-e531-45a4-93fa-1d8c1eb9e858"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgDifferent, PositiveInteger)) .
\"urn:uuid:21b3064d-ee6b-473a-9c95-e731bb34a4f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgDifferent, PositiveInteger)) .
\"urn:uuid:fa2261e7-cfab-4bdc-a210-50ee535bb0d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgDifferent, (3))) .
\"urn:uuid:0032c95f-c63a-4047-9f33-c6c349df93da"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgFormat1-2', InterArgFormatPredicate)) .
\"urn:uuid:6617b3d4-6ca8-4478-91de-753641d7a59d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgFormat1-2', WFFConstraintPredicate)) .
\"urn:uuid:23c7b453-7b9a-4ebe-8286-5d2e73527f8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgFormat1-2', Predicate)) .
\"urn:uuid:4a60a753-c3d5-42a8-82c5-516b93744971"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgFormat1-2', Collection)) .
\"urn:uuid:7f1106e6-b4c0-4f09-ae72-6e7f5dfea11e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgFormat1-2', Thing)) .
\"urn:uuid:da058eae-00c0-4683-8f98-a998794f528e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgFormat1-2', Individual)) .
\"urn:uuid:64acfa11-c20a-4f0e-90d5-6c7992254e24"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgFormat1-2', (3))) .
\"urn:uuid:a54ce645-22fb-40fa-a2d0-2b1892d1bada"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgGenl1-2', TernaryPredicate)) .
\"urn:uuid:fa866814-a7bf-43e2-bf0a-5612fda63c7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgGenl1-2', ArgTypePredicate)) .
\"urn:uuid:b2b96605-84db-4205-9885-2d311f1d79e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgGenl1-2', WFFConstraintPredicate)) .
\"urn:uuid:724e6b1f-b662-42c3-957e-c28c5fdcc7c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgGenl1-2', Relation)) .
\"urn:uuid:ecb876e8-c8d4-4507-8ad1-9d761a81d70f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgGenl1-2', Collection)) .
\"urn:uuid:fc8786df-bf2f-45f7-bf2f-e6d994935ea6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgGenl1-2', Collection)) .
\"urn:uuid:2cb6b9fc-0bee-4a92-bdb1-4ebc9c9e1800"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgGenl1-2', (3))) .
\"urn:uuid:c21d99ef-c489-48b2-bdee-af43e782c5bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgIsa, QuintaryPredicate)) .
\"urn:uuid:a2a8f633-c317-45cd-b2f6-21eea1d105da"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgIsa, InterArgIsaPredicate)) .
\"urn:uuid:450889f1-4936-498a-b4bd-cb7b1ed33cc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgIsa, WFFConstraintPredicate)) .
\"urn:uuid:ab57fc94-a913-45fe-b3fc-c35ecfd3cd50"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgIsa, Relation)) .
\"urn:uuid:a48ddf69-d9e4-4530-9fab-91747c57f8b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgIsa, PositiveInteger)) .
\"urn:uuid:b3c8eb22-c17d-4c6d-ad4d-f9dc5498fc15"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgIsa, Collection)) .
\"urn:uuid:992084d7-f8ee-4dd5-8117-f54c568bd9c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(interArgIsa, Thing)) .
\"urn:uuid:4669fe6a-c6f0-4e1e-988e-a7cce0236fb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(interArgIsa, PositiveInteger)) .
\"urn:uuid:14198852-1986-44a7-aeb3-7a91722b88a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Isa(interArgIsa, Collection)) .
\"urn:uuid:5fc5217c-0f00-4853-937a-ae18b5b3d3fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Genl(interArgIsa, Thing)) .
\"urn:uuid:0bb749d9-169f-4793-a45d-9e6620943816"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgIsa, (5))) .
\"urn:uuid:22a89179-159c-42df-8cf6-6df079d4f813"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-2', TernaryPredicate)) .
\"urn:uuid:ba8ba13f-94bf-43ea-8093-be4118a8bec6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-2', InterArgIsaPredicate)) .
\"urn:uuid:6328ea12-22d0-4b4e-bcda-c4ae629ca3d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-2', WFFConstraintPredicate)) .
\"urn:uuid:4254e4c8-ecad-4d6d-a6d0-1506d0beca12"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa1-2', Relation)) .
\"urn:uuid:96eb5197-1db0-44f5-83a4-3cbc83dc07fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa1-2', Collection)) .
\"urn:uuid:5ac13d87-4b23-4ec5-8f0b-4237ada524c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa1-2', Thing)) .
\"urn:uuid:1cff6e80-b6d6-4542-80e1-9713f798e2c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa1-2', Collection)) .
\"urn:uuid:17715761-e0d1-4c65-8c8b-f2ad006f702b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa1-2', Thing)) .
\"urn:uuid:cf537293-7f4d-499f-b24f-296813a53945"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa1-2', (3))) .
\"urn:uuid:bccc4a4b-608d-4908-8fb5-ddad02bdff7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-3', TernaryPredicate)) .
\"urn:uuid:0d4d8567-0afe-46bf-a6f0-42491904a3dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-3', InterArgIsaPredicate)) .
\"urn:uuid:3ece7175-5e6d-4169-95c6-ad808377bfaa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-3', WFFConstraintPredicate)) .
\"urn:uuid:69878aae-fb41-4f87-8fc6-2507199c1081"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa1-3', Relation)) .
\"urn:uuid:fedac434-0417-4300-96a2-c5f68d7817ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa1-3', Collection)) .
\"urn:uuid:ea6d59fc-07fb-4fef-973b-8c45f81045ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa1-3', Thing)) .
\"urn:uuid:160d4ea3-cf1d-4c43-abe4-c7d1deed8664"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa1-3', Collection)) .
\"urn:uuid:ccf61c16-8f66-4734-9e80-c70ac570486b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa1-3', Thing)) .
\"urn:uuid:22e2af49-af4c-4255-8a43-8f6dd6158aaf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa1-3', (3))) .
\"urn:uuid:e663da16-6d47-4fb8-a187-10ae16602d9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-4', TernaryPredicate)) .
\"urn:uuid:76b3ba01-b4c5-43aa-b5e2-1e3835cc65dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-4', InterArgIsaPredicate)) .
\"urn:uuid:d7190e2a-0dfb-4ef4-860e-512e7b5b03cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-4', WFFConstraintPredicate)) .
\"urn:uuid:4a44c48e-08f4-410d-a225-fb01483f4660"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa1-4', Relation)) .
\"urn:uuid:b51c13d7-f453-4cdd-88c5-ec629841616a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa1-4', Collection)) .
\"urn:uuid:f09f79e5-8c44-48b0-8f5c-bb9c138a5420"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa1-4', Thing)) .
\"urn:uuid:51b18a03-478c-462a-a474-e58eb3334ddb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa1-4', Collection)) .
\"urn:uuid:f2779166-0c56-4c84-8578-d358254e7140"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa1-4', Thing)) .
\"urn:uuid:898bf1d0-f1b1-4409-bb26-30d03cbcbcf0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa1-4', (3))) .
\"urn:uuid:af1f24bd-06d7-425a-9db1-b5a27bb8c83a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-5', TernaryPredicate)) .
\"urn:uuid:76836430-b753-41f1-9c61-48f29072be9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-5', InterArgIsaPredicate)) .
\"urn:uuid:65784365-383b-4ad6-b157-be3efb80dcae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa1-5', WFFConstraintPredicate)) .
\"urn:uuid:46e980ee-2c81-4458-a0c3-1558a3d0ffda"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa1-5', Relation)) .
\"urn:uuid:648636dd-2d8f-4636-9b14-14b013106d39"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa1-5', Collection)) .
\"urn:uuid:192c6b7e-14a3-472f-a67c-ac6016497296"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa1-5', Thing)) .
\"urn:uuid:4b931903-54d1-493b-a021-d5933579a06d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa1-5', Collection)) .
\"urn:uuid:a7df539d-e5d6-4026-b461-3e48b9c3d3b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa1-5', Thing)) .
\"urn:uuid:9b55b43f-076f-479f-ae3c-47de2f32ea6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa1-5', (3))) .
\"urn:uuid:caf5ab35-5174-44dc-a6d6-89943aaa529f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-1', TernaryPredicate)) .
\"urn:uuid:f4c51238-96cb-4fe0-be5a-8bea02b7c6d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-1', InterArgIsaPredicate)) .
\"urn:uuid:fab4af2a-137e-4f17-b654-fd7bba4d8ddd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-1', WFFConstraintPredicate)) .
\"urn:uuid:4d1a6532-9bb8-4bd9-a843-9ca1babb2c14"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa2-1', Relation)) .
\"urn:uuid:3ea86337-e1c6-4f60-bfe4-6ca48ea610ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa2-1', Collection)) .
\"urn:uuid:12b459c0-623a-42ba-8fa8-dcc9a12111cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa2-1', Thing)) .
\"urn:uuid:21046bce-d82d-4dec-a481-b95ebc0834b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa2-1', Collection)) .
\"urn:uuid:b82e98f1-d83e-44b9-aff2-27747b3444c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa2-1', Thing)) .
\"urn:uuid:8e150dfd-6412-4f07-be98-29263ba5fc97"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa2-1', (3))) .
\"urn:uuid:1f080b6a-c11e-45f1-9e06-2834c324282f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-3', TernaryPredicate)) .
\"urn:uuid:53838a54-6997-4b74-bafc-de57db999997"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-3', InterArgIsaPredicate)) .
\"urn:uuid:5a881104-66c3-403d-8daf-05eb5fa875a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-3', WFFConstraintPredicate)) .
\"urn:uuid:2edd7c5b-b8c5-41c0-9a5a-6acfff8d09c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa2-3', Relation)) .
\"urn:uuid:64f738cf-e619-4f45-b3e4-6b328f4d2d8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa2-3', Collection)) .
\"urn:uuid:71cfe60d-4ace-4ad3-9f7d-2b6705ae799b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa2-3', Thing)) .
\"urn:uuid:40c7b434-7026-465b-9dcf-0febc178b012"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa2-3', Collection)) .
\"urn:uuid:96286ccc-858e-4363-8daa-6788a8417155"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa2-3', Thing)) .
\"urn:uuid:6d8d41bf-ed0a-4653-aa22-6c5723c2bded"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa2-3', (3))) .
\"urn:uuid:ff68bc85-5dc0-43f9-9932-df38d8db482f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-4', InterArgIsaPredicate)) .
\"urn:uuid:4fd3b07d-d5f7-4a9e-972a-89711c05dd76"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-4', TernaryPredicate)) .
\"urn:uuid:74b4dad8-ad92-4a4a-8e62-bb4b98e72049"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-4', WFFConstraintPredicate)) .
\"urn:uuid:84e4bb51-b702-4fcb-baf0-96c13ccd2930"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa2-4', Relation)) .
\"urn:uuid:35cca460-e0b4-4346-95e9-582e3f064bfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa2-4', Collection)) .
\"urn:uuid:d4aed2fd-882d-47f2-8404-560616a4a082"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa2-4', Thing)) .
\"urn:uuid:92644e7d-2503-4696-b0bf-89425840611a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa2-4', Collection)) .
\"urn:uuid:384912af-63a3-4479-8523-b92810ca7361"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa2-4', Thing)) .
\"urn:uuid:524841c5-cbe6-4aa7-841a-292d6827194c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa2-4', (3))) .
\"urn:uuid:76ccd478-c9f7-43d5-8ff3-4adf050588fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-5', TernaryPredicate)) .
\"urn:uuid:7c8e93a4-b8d5-49b1-970e-0d47fbd8374c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-5', InterArgIsaPredicate)) .
\"urn:uuid:3922e7b9-85a2-48b7-b83b-103bd4be5d64"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa2-5', WFFConstraintPredicate)) .
\"urn:uuid:812e5761-d063-495c-aacd-ae5dcc4773ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa2-5', Relation)) .
\"urn:uuid:2437996a-8559-4bf0-ace8-4b9c9f5c1c64"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa2-5', Collection)) .
\"urn:uuid:cac63642-044b-437e-9a07-55adce6e2e62"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa2-5', Thing)) .
\"urn:uuid:3f6f66e1-23ff-4f66-bf64-c261c4d2ef5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa2-5', Collection)) .
\"urn:uuid:fc1df843-9b01-411f-8062-f349fe72f529"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa2-5', Thing)) .
\"urn:uuid:e3e9f178-2704-438d-8c62-b8de22e4f8e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa2-5', (3))) .
\"urn:uuid:4abd6815-287a-43a5-ba15-e483c76231b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-1', TernaryPredicate)) .
\"urn:uuid:351dd137-faf0-4ef0-97b9-932d54f23da6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-1', InterArgIsaPredicate)) .
\"urn:uuid:b3cf1583-bede-4140-acd0-de5c79263d67"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-1', WFFConstraintPredicate)) .
\"urn:uuid:22947b19-ab34-4eb7-a622-5f83c66763f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa3-1', Relation)) .
\"urn:uuid:877ff031-70b2-4c39-ba45-d0081d0258ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa3-1', Collection)) .
\"urn:uuid:87060fb9-8acd-44c6-8b26-9974f771bb19"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa3-1', Thing)) .
\"urn:uuid:8eff1176-81c0-4c41-b6e7-023ffc2d5f8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa3-1', Collection)) .
\"urn:uuid:097fd50a-2f2c-4658-8a3a-aefa75e74d7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa3-1', Thing)) .
\"urn:uuid:53bc55af-dd34-41f7-ae3e-34c09d8ad36e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa3-1', (3))) .
\"urn:uuid:b62c0604-5ace-428d-bebf-50f5ae8f119f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-2', TernaryPredicate)) .
\"urn:uuid:3fd9affb-d00a-4701-bd31-c5575ca88a39"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-2', InterArgIsaPredicate)) .
\"urn:uuid:68e5fef8-3631-49b3-b6df-cbbf368ef65d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-2', WFFConstraintPredicate)) .
\"urn:uuid:1a7a8420-3d50-4621-bef2-0fe49fcb9781"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa3-2', Relation)) .
\"urn:uuid:a97ff09f-b61d-4a63-9125-c240083d1105"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa3-2', Collection)) .
\"urn:uuid:e19680a9-c232-4619-a55f-8e6318801f28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa3-2', Thing)) .
\"urn:uuid:ac8cbd47-7536-408a-a68f-fcd9641df50d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa3-2', Collection)) .
\"urn:uuid:c8aeb2c6-72e9-4195-8d1d-e5fc9d8af00a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa3-2', Thing)) .
\"urn:uuid:5ebc330e-11ff-40b6-8db9-206003601d30"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa3-2', (3))) .
\"urn:uuid:d24f1fd2-b779-4bdd-9a17-b87203976f7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-4', InterArgIsaPredicate)) .
\"urn:uuid:cb8e2818-dcb3-4afc-b40f-2caaef550d25"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-4', TernaryPredicate)) .
\"urn:uuid:e3e4f5a8-0bec-4ac4-8e96-b105d9303901"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-4', WFFConstraintPredicate)) .
\"urn:uuid:9f4f81f6-30eb-480e-990d-064147d5acd9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa3-4', Relation)) .
\"urn:uuid:34eab08b-ddbb-4dd8-ac1d-4e8914062d58"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa3-4', Collection)) .
\"urn:uuid:9b989cf1-780f-48db-8c4d-9b11bfcaf8b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa3-4', Thing)) .
\"urn:uuid:1d7570e6-d098-4708-a741-d3aabdc253ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa3-4', Collection)) .
\"urn:uuid:d1809654-6435-46df-9a55-3d7ecc957c05"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa3-4', Thing)) .
\"urn:uuid:135898cf-bb1d-4abf-81ec-f4db43a95a27"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa3-4', (3))) .
\"urn:uuid:074743b6-1a34-468d-b6a6-a7fa35e37f7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-5', InterArgIsaPredicate)) .
\"urn:uuid:a3a3098a-102b-46b0-b13d-105ff0906c28"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-5', TernaryPredicate)) .
\"urn:uuid:b5a28736-fce7-426f-b2b5-97df213a31ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa3-5', WFFConstraintPredicate)) .
\"urn:uuid:4ec3288c-c05a-4b17-a659-e8f793337064"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa3-5', Relation)) .
\"urn:uuid:bff544a1-df28-4e73-8d22-26b51a9c30b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa3-5', Collection)) .
\"urn:uuid:8b38ed55-8804-4980-9520-e603e697c379"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa3-5', Thing)) .
\"urn:uuid:57fd945c-6b35-4ae9-b158-423e5733d10f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa3-5', Collection)) .
\"urn:uuid:5ea78ec0-02ed-4b1e-9b65-a1468c2ccdc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa3-5', Thing)) .
\"urn:uuid:e5d44075-181c-42e9-acc4-deb51d192558"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa3-5', (3))) .
\"urn:uuid:68deb9e0-cca2-40e3-9648-026e89c86914"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-1', TernaryPredicate)) .
\"urn:uuid:5aa7c843-6cca-4ee6-8e24-1186ec58201a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-1', InterArgIsaPredicate)) .
\"urn:uuid:4e9d9171-1b88-4a9c-9282-7110ae7e12da"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-1', WFFConstraintPredicate)) .
\"urn:uuid:36aca332-f85a-47d1-a935-7bc955046b0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa4-1', Relation)) .
\"urn:uuid:90b3b30b-4374-496a-9101-eb2ffcff0dcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa4-1', Collection)) .
\"urn:uuid:e080ec6d-e129-4be2-a1cf-f6a65ae814b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa4-1', Thing)) .
\"urn:uuid:3d698797-3001-482d-9087-e5d280ae0a51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa4-1', Collection)) .
\"urn:uuid:8bf974a6-c116-44bb-a6e4-3ec3b7abf2af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa4-1', Thing)) .
\"urn:uuid:06b6cad8-f7b4-417a-b913-0930eef05c05"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa4-1', (3))) .
\"urn:uuid:72d3f5c9-6e0d-46b6-8f3c-f43e5e113399"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-2', TernaryPredicate)) .
\"urn:uuid:3ebf0547-683d-4651-b996-a4b45ac7e487"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-2', InterArgIsaPredicate)) .
\"urn:uuid:3407929a-dbd1-4123-8f92-4c6928801e2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-2', WFFConstraintPredicate)) .
\"urn:uuid:a917f231-5ce1-4973-8a46-5269d02bf1cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa4-2', Relation)) .
\"urn:uuid:57b6f157-4f83-46bd-b9e2-dd55cd160fc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa4-2', Collection)) .
\"urn:uuid:e33e3514-b824-4904-a2dc-4c363e27f426"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa4-2', Thing)) .
\"urn:uuid:87a18f74-308f-48d5-a895-a88c858bd659"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa4-2', Collection)) .
\"urn:uuid:b5866e28-77a1-4703-bd98-0aec4bbfda88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa4-2', Thing)) .
\"urn:uuid:7a430e1f-121e-4f40-aee5-7d90cbddd035"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa4-2', (3))) .
\"urn:uuid:171ebb37-c999-4cc3-8962-43b841d89adb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-3', TernaryPredicate)) .
\"urn:uuid:16968f34-8601-428d-a609-1572ab948413"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-3', InterArgIsaPredicate)) .
\"urn:uuid:cdd3bcfe-9855-4a1a-a10a-fd2a0279630f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-3', WFFConstraintPredicate)) .
\"urn:uuid:34f7f53e-45a0-4f15-bca8-42db39a3489b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa4-3', Relation)) .
\"urn:uuid:4c4384f3-c26d-47c9-964f-8dbd22b4d24b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa4-3', Collection)) .
\"urn:uuid:a7ae5326-cdf5-4d4d-a824-108f23ce1f4f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa4-3', Thing)) .
\"urn:uuid:28c235de-20b0-416c-b22d-9ecabd750a44"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa4-3', Collection)) .
\"urn:uuid:33130171-dae7-45d7-92c8-c5b7ec1b5c6d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa4-3', Thing)) .
\"urn:uuid:60274ae3-8986-4c6a-9259-dd15ab7eb918"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa4-3', (3))) .
\"urn:uuid:97e1b9d5-3fe3-496b-b7d2-40cecb3f3798"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-5', TernaryPredicate)) .
\"urn:uuid:7f09c6c4-20f5-410f-8ba5-6a39183c9f36"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-5', InterArgIsaPredicate)) .
\"urn:uuid:5e053b45-1d75-43e0-8de8-208a90d02554"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa4-5', WFFConstraintPredicate)) .
\"urn:uuid:fa92e798-cc58-4c2e-88f3-ece707bda534"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa4-5', Relation)) .
\"urn:uuid:a354f7ac-1999-4eaa-9786-f0e635b0ef40"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa4-5', Collection)) .
\"urn:uuid:988e162d-b181-4611-921b-ee5f2c3a535e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa4-5', Thing)) .
\"urn:uuid:d13b3d8c-e410-42e6-8854-bcc3c293d868"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa4-5', Collection)) .
\"urn:uuid:af1ace6a-ec7e-4456-ad63-75f0f30bca19"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa4-5', Thing)) .
\"urn:uuid:d574c1a1-321f-4ffb-b824-0e2023fcefee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa4-5', (3))) .
\"urn:uuid:1b844918-d111-4c8f-a9cd-3baef192ac15"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-1', TernaryPredicate)) .
\"urn:uuid:29d5e5eb-401a-4669-88dc-157ba10b2ba7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-1', InterArgIsaPredicate)) .
\"urn:uuid:bbaaa5bf-1d94-430e-863d-e81d74742ab7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-1', WFFConstraintPredicate)) .
\"urn:uuid:3d24d3a1-a093-4637-a097-0a9cc6020caa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa5-1', QuintaryRelation)) .
\"urn:uuid:c3e55556-889a-453a-b3d8-41a9567fc037"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa5-1', Collection)) .
\"urn:uuid:155157a9-fcce-4193-8e8b-48fd273cd571"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa5-1', Thing)) .
\"urn:uuid:f3692893-a937-45e3-b1a1-231cbacfdd25"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa5-1', Collection)) .
\"urn:uuid:eab5900f-afb5-4f85-b099-fbe41c04c936"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa5-1', Thing)) .
\"urn:uuid:55bf5738-f3dd-4809-ac81-045ffd845f0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa5-1', (3))) .
\"urn:uuid:3c7d6839-ca75-4262-b514-fff89f10626e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-2', TernaryPredicate)) .
\"urn:uuid:003ceb37-d898-4d77-89c4-21ef58b8dc8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-2', InterArgIsaPredicate)) .
\"urn:uuid:6d7ee004-eb46-4e56-9bd6-575d42426d17"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-2', WFFConstraintPredicate)) .
\"urn:uuid:b6ef82ff-783a-4a20-a312-7cbea394e0bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa5-2', QuintaryRelation)) .
\"urn:uuid:69c00b09-5447-4f15-a4e4-d87ac3306a81"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa5-2', Collection)) .
\"urn:uuid:3529194c-2bec-4b60-9711-d7ed2d5d799c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa5-2', Thing)) .
\"urn:uuid:cccdf026-99e5-4835-8d4d-01cee69f2e71"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa5-2', Collection)) .
\"urn:uuid:0f7837f7-c32c-4462-9842-2429e273c22f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa5-2', Thing)) .
\"urn:uuid:c081d8e7-be9d-4247-8d51-e52cf7846ad4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa5-2', (3))) .
\"urn:uuid:cb8efa8e-920f-4712-82e9-5bd3461eff2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-3', TernaryPredicate)) .
\"urn:uuid:8a07b055-8ed8-492c-9fe6-c270b968d08d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-3', InterArgIsaPredicate)) .
\"urn:uuid:0a2cd0b9-dc4d-4735-99e3-c8be936e9b5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-3', WFFConstraintPredicate)) .
\"urn:uuid:bc90259d-cc4a-4155-ad78-7a68766f00c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa5-3', Relation)) .
\"urn:uuid:ba1f2467-c9df-4426-b1ff-2e5622a31767"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa5-3', QuintaryRelation)) .
\"urn:uuid:fa2a37e6-dfa3-4700-9b75-4b35bb3c2732"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa5-3', Collection)) .
\"urn:uuid:98d3cc77-fe3d-4b67-9005-eeea7325d21f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa5-3', Thing)) .
\"urn:uuid:e2d01c2e-dcdb-4b4e-a701-9b0bc3a7b50c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa5-3', Collection)) .
\"urn:uuid:848b0241-c53f-4ed1-9ffd-42d5f643b46e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa5-3', Thing)) .
\"urn:uuid:5e813716-ced5-4b84-a2ab-60f4d07888c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa5-3', (3))) .
\"urn:uuid:cae09f83-80c6-44a8-87ce-98e56f2c4a8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-4', TernaryPredicate)) .
\"urn:uuid:ccb96f53-b2ac-4cc8-a913-7e22e28aba51"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-4', InterArgIsaPredicate)) .
\"urn:uuid:c0ea08a4-6788-48c5-a370-cbe154834d64"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('interArgIsa5-4', WFFConstraintPredicate)) .
\"urn:uuid:adbae745-b5a5-4c32-89bf-068d16293e8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('interArgIsa5-4', QuintaryRelation)) .
\"urn:uuid:a206a05d-77ca-4f3d-b6f1-fdeb957ceec0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('interArgIsa5-4', Collection)) .
\"urn:uuid:590e4b88-06ac-47f5-92fd-997aad286e15"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl('interArgIsa5-4', Thing)) .
\"urn:uuid:e3dd84de-c5a8-4c0c-b5e2-e58308241608"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa('interArgIsa5-4', Collection)) .
\"urn:uuid:7d6e913c-b972-43d3-81b3-ab1e3727e6c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl('interArgIsa5-4', Thing)) .
\"urn:uuid:d9a4d316-4434-46c4-b818-e775edeabee6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('interArgIsa5-4', (3))) .
\"urn:uuid:f74f25de-88d9-4fdb-bacf-3d4892752fbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultGenl, QuaternaryPredicate)) .
\"urn:uuid:96531118-735d-4cd1-a5ad-d1eb2b96b1ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultGenl, WFFConstraintPredicate)) .
\"urn:uuid:52dca2ee-e7d0-4ba2-959e-d3701f115034"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgResultGenl, 'Function-Denotational')) .
\"urn:uuid:9afebf31-6b97-443f-977d-ec922e2811f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgResultGenl, PositiveInteger)) .
\"urn:uuid:6703e90f-5a43-4cd7-84f2-0139d4a7147c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgResultGenl, Collection)) .
\"urn:uuid:da76c37a-ce8a-403f-b395-8909730066d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(interArgResultGenl, Thing)) .
\"urn:uuid:2e3995ea-625c-48fc-8c01-fc225a97b63d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(interArgResultGenl, Collection)) .
\"urn:uuid:da7ccc96-670e-4003-afd5-88dfaccd9e86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Genl(interArgResultGenl, Thing)) .
\"urn:uuid:d4f67793-2098-44aa-8509-815cfbc0732c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgResultGenl, (4))) .
\"urn:uuid:baecc554-b196-48bc-b5f3-d982aa8b61d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultGenlReln, QuintaryPredicate)) .
\"urn:uuid:45147cf1-300e-4e26-a49c-9e6167e4e65e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultGenlReln, WFFConstraintPredicate)) .
\"urn:uuid:7cb23974-04a1-4ed1-8a3d-6d072ec066b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgResultGenlReln, 'Function-Denotational')) .
\"urn:uuid:c038ebad-c992-434a-bf7d-6c45c02191f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgResultGenlReln, PositiveInteger)) .
\"urn:uuid:5dfc5dff-9dc5-4a66-aaa0-16eb2a772a37"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgResultGenlReln, Predicate)) .
\"urn:uuid:98d95447-4d73-4a3f-bc84-e1fcfd50d0f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(interArgResultGenlReln, PositiveInteger)) .
\"urn:uuid:8705cb2a-9c39-4a15-8974-96c325a2cb5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Isa(interArgResultGenlReln, PositiveInteger)) .
\"urn:uuid:64777450-4cfb-43c9-8c0f-db8019980843"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgResultGenlReln, (5))) .
\"urn:uuid:d5704c79-328b-423e-8bcd-78e134f1cb64"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultIsa, QuaternaryPredicate)) .
\"urn:uuid:a48e91ac-4d8c-4ae5-822a-b9d47c405c43"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultIsa, WFFConstraintPredicate)) .
\"urn:uuid:d6f4298b-6e06-4639-be60-95cfcb5e3a88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgResultIsa, 'Function-Denotational')) .
\"urn:uuid:8a4432a6-d1e1-4e0d-9261-e0ea5a571fe5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgResultIsa, PositiveInteger)) .
\"urn:uuid:317f7683-8eec-4f4c-b644-3fa94bb6584c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgResultIsa, Collection)) .
\"urn:uuid:773d0d59-3aa0-4738-8d1d-1e623a00f54d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(interArgResultIsa, Thing)) .
\"urn:uuid:2e7a75a3-d477-4d04-b304-b656961cb9df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(interArgResultIsa, Collection)) .
\"urn:uuid:bdc30b3e-2777-4cb9-b3f5-e2ad6245088e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Genl(interArgResultIsa, Thing)) .
\"urn:uuid:f7696372-f8e9-4fcd-bd71-488fb683a2c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgResultIsa, (4))) .
\"urn:uuid:5a2434c5-2812-4a42-9535-d395c2b49151"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultIsaReln, QuintaryPredicate)) .
\"urn:uuid:47e335e6-7b82-47e9-9d38-ab3c227f145c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(interArgResultIsaReln, WFFConstraintPredicate)) .
\"urn:uuid:a8552da3-d0db-469a-bbf3-c04da3fa2f37"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(interArgResultIsaReln, 'Function-Denotational')) .
\"urn:uuid:0512130c-0c4b-41e0-939e-758d315200e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(interArgResultIsaReln, PositiveInteger)) .
\"urn:uuid:b2e2f303-18d0-4022-bc24-22cfcb2de9da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(interArgResultIsaReln, Predicate)) .
\"urn:uuid:e06b151a-91aa-407f-bbd3-9e34e1242aa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(interArgResultIsaReln, PositiveInteger)) .
\"urn:uuid:abc419a5-20ed-4280-b765-79978c8b6656"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Isa(interArgResultIsaReln, PositiveInteger)) .
\"urn:uuid:954e40e0-756c-4c24-82e3-e959a6d5991f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(interArgResultIsaReln, (5))) .
\"urn:uuid:84305f64-c04e-4a43-8b16-0b32a4693291"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(irrelevantAssertion, UnaryPredicate)) .
\"urn:uuid:8136b727-e3ad-40d7-ad28-79abf8d19618"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(irrelevantAssertion, CycLAssertion)) .
\"urn:uuid:c299933d-0996-49a8-ae92-bd25c229bd47"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(irrelevantAssertion, (1))) .
\"urn:uuid:bba92bc2-2ca0-40c3-8ec8-c4fdaccc8fed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(irrelevantMt, UnaryPredicate)) .
\"urn:uuid:267b3d6e-e9c5-4aa6-bbb6-65a365d77c56"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(irrelevantMt, Microtheory)) .
\"urn:uuid:49a2006a-4fc2-496e-8427-0d6da50112cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(irrelevantMt, (1))) .
\"urn:uuid:6ede6cb2-7d08-497a-bf71-bdd4eff080d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(irrelevantPredAssertion, BinaryPredicate)) .
\"urn:uuid:b4687d52-97cb-4b0a-8a99-7922beed79e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(irrelevantPredAssertion, Predicate)) .
\"urn:uuid:65d49e32-fae6-40ce-9280-9895a4e81ae5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(irrelevantPredAssertion, CycLAssertion)) .
\"urn:uuid:9c7d7931-c43d-4e4d-a73f-459cfc628ed7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(irrelevantPredAssertion, (2))) .
\"urn:uuid:db7b25ba-a997-4242-b8bf-690667e27e01"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(irrelevantTerm, UnaryPredicate)) .
\"urn:uuid:a7b59cfb-7d14-4f94-8937-77298bd1335f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(irrelevantTerm, Thing)) .
\"urn:uuid:7364c64a-ccbc-4693-99ec-1596611043cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(irrelevantTerm, CycLReifiableDenotationalTerm)) .
\"urn:uuid:70f6fdc5-8999-4501-9629-2a3456aee9c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(irrelevantTerm, (1))) .
\"urn:uuid:2ab5e0ad-4f5b-41bf-8823-9060609baaf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(isa, DefaultMonotonicPredicate)) .
\"urn:uuid:a9a5544a-3879-488e-a6f5-ac8a25b006a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(isa, BinaryPredicate)) .
\"urn:uuid:6284add5-f402-484d-b002-e608b5148c89"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(isa, ReformulatorIrrelevantFORT)) .
\"urn:uuid:57f3a4ce-3019-4a16-aeb3-0ca53d4216c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(isa, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:46254cbb-d6ea-420e-a6f8-54902e918b83"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(isa, ReflexiveBinaryPredicate))) .
\"urn:uuid:3fdaa02d-9f26-4af1-817d-6483a35d56ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(isa, IrreflexiveBinaryPredicate))) .
\"urn:uuid:879ec1c1-f057-4941-87e7-6a15c15772f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(isa, TransitiveBinaryPredicate))) .
\"urn:uuid:5bdd3692-d946-474a-bcf9-86046c3e9e17"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(isa, Predicate)) .
\"urn:uuid:6937962e-76a4-44c2-8681-cdc01ff90edf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(isa, TransformationModuleSupportedPredicate)) .
\"urn:uuid:fb2421c2-f736-4158-bfc9-5e7adeca3297"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(isa, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:b4ff908c-7331-49d1-b0dc-d5a48540d764"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(isa, Thing)) .
\"urn:uuid:d595c3e6-a517-4ea6-b9ff-cd4003c23d9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(isa, Collection)) .
\"urn:uuid:c6c078a7-f733-4063-b4b7-a14069fecb0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(isa, Thing)) .
\"urn:uuid:227f8aa6-4056-4af8-9fb8-286f42e1b9a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(isa, elementOf)) .
\"urn:uuid:df45b12d-e90f-4813-b9a6-2d0e36122648"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(isa, (2))) .
\"urn:uuid:9829d0dd-f1be-4a2b-bbff-dc2881e9fdf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ist, BinaryPredicate)) .
\"urn:uuid:eb6d0fa0-f23c-44be-83ca-12e93b9efec9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ist, MicrotheoryDesignatingRelation)) .
\"urn:uuid:f5c7c1a6-cf30-4b2d-a08b-45b1fa942d0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ist, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:9356d581-1a32-48fb-a3da-1cadd586138d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ist, Microtheory)) .
\"urn:uuid:8755a073-b9b1-4633-a2d1-cef3f03c7c97"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(ist, 'CycLSentence-Assertible')) .
\"urn:uuid:f4a150af-7dda-4a47-959f-57c2892fc85b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ist, (2))) .
\"urn:uuid:38293533-b76f-4770-9641-fcb5293d6cdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(istAsserted, BinaryPredicate)) .
\"urn:uuid:269bdb72-7095-43b2-9b8c-72c0439c9e68"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(istAsserted, MicrotheoryDesignatingRelation)) .
\"urn:uuid:8da121e8-2546-4698-a5e7-9dd990c0f777"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(istAsserted, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6e223655-cc09-4fad-b469-8887babd8f63"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(istAsserted, Microtheory)) .
\"urn:uuid:54a9953a-8ce0-44c1-b1f7-da66d67f7574"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(istAsserted, 'CycLSentence-Assertible')) .
\"urn:uuid:d8763873-7cc9-468e-aa26-af43e20445df"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(istAsserted, ist)) .
\"urn:uuid:1aa46399-55bf-4fba-a934-bfcd3f9a9081"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(istAsserted, (2))) .
\"urn:uuid:d5c019c2-4b57-4a58-be6c-194c74b345d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(knownAntecedentRule, DefaultMonotonicPredicate)) .
\"urn:uuid:c0758ba1-be97-4c70-aba5-16dc3222bedc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(knownAntecedentRule, UnaryPredicate)) .
\"urn:uuid:7c5fdd03-b6ab-427c-b4a5-b333ddf82393"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(knownAntecedentRule, InferenceSupportedPredicate))) .
\"urn:uuid:6324250a-c83c-4293-b362-038122ec62da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(knownAntecedentRule, CycLRuleAssertion)) .
\"urn:uuid:a1c5f198-9d1f-40ed-897e-06bddbc78b9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(knownAntecedentRule, highlyRelevantAssertion)) .
\"urn:uuid:6a322a71-1a2c-4e08-80aa-b9f31dd85d62"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(knownAntecedentRule, (1))) .
\"urn:uuid:1093bec7-4a01-4562-a74d-b37a85d7e416"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(knownSentence, UnaryPredicate)) .
\"urn:uuid:60fc6a6d-c766-442d-acb1-d4bcf4b524a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(knownSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:df9542b8-b1b1-4f3c-8aec-13af49daf302"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(knownSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:50505e02-1dd8-4302-b188-87ee4397bf54"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(knownSentence, trueSentence)) .
\"urn:uuid:c0711ceb-9516-4c4d-bf09-1a0c10750d0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(knownSentence, (1))) .
\"urn:uuid:a71648a4-529a-40d9-bd33-b022984d1934"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThan, AsymmetricBinaryPredicate)) .
\"urn:uuid:9bc84cfb-101b-4b8e-9f7f-55328b2f2d96"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThan, 'ELRelation-OneWay')) .
\"urn:uuid:10c7e2c2-56ac-4645-be7e-ca345d702efa"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThan, TransitiveBinaryPredicate)) .
\"urn:uuid:34e1a6e5-c0e6-46e0-b4cd-aacbb4a5198d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThan, EvaluatablePredicate)) .
\"urn:uuid:36a6ba16-10ee-498c-98a6-f7c89c30bca8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(lessThan, ScalarInterval)) .
\"urn:uuid:089e467a-3746-47cb-b4f6-d24ddb1cbcb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(lessThan, NonNegativeInteger)) .
\"urn:uuid:e6c8a45e-3198-4b99-90db-e608462c98a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(lessThan, ScalarInterval)) .
\"urn:uuid:8dde8c9d-332f-4a52-a47e-592a62a3e0e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(lessThan, NonNegativeInteger)) .
\"urn:uuid:37577838-8656-4388-b8e7-e97f83d48634"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(lessThan, lessThanOrEqualTo)) .
\"urn:uuid:cca84706-61fe-41a3-ad2c-1ddfaa0e3cb3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(lessThan, (2))) .
\"urn:uuid:17551069-89cf-4296-8dde-3535c70344bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThanOrEqualTo, ReflexiveBinaryPredicate)) .
\"urn:uuid:14ea592d-6480-4c4a-82a3-2e26973deb6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThanOrEqualTo, 'ELRelation-OneWay')) .
\"urn:uuid:56616f1a-9f17-418e-98ab-a0076f14d5e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThanOrEqualTo, TransitiveBinaryPredicate)) .
\"urn:uuid:d90cbaf8-1ea0-441c-8c5c-ce01f8dedc04"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThanOrEqualTo, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:f56d00c9-ffb9-4bf5-957b-036d4cdc190b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(lessThanOrEqualTo, EvaluatablePredicate)) .
\"urn:uuid:561c26df-8277-462d-974e-b25c94acc291"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(lessThanOrEqualTo, ScalarInterval)) .
\"urn:uuid:4bb39864-3a6e-4d68-ac83-14ef7cb82ac2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(lessThanOrEqualTo, NonNegativeInteger)) .
\"urn:uuid:f709f1c5-e164-4103-a016-dbacc33ee92e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(lessThanOrEqualTo, ScalarInterval)) .
\"urn:uuid:a1c70ea7-fa45-4bfd-8b16-9894b69b1b8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(lessThanOrEqualTo, NonNegativeInteger)) .
\"urn:uuid:aa53affe-a9d0-411a-8951-e39317ba742b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(lessThanOrEqualTo, (2))) .
\"urn:uuid:f7519a3f-5701-4234-9487-f03dfc0adadd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(maxQuantValue, ReflexiveBinaryPredicate)) .
\"urn:uuid:9effba29-0b43-4500-bdb1-5f509e2adc0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(maxQuantValue, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:d45413cf-8093-4c65-8ea1-d0f6683d98c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(maxQuantValue, ScalarInterval)) .
\"urn:uuid:6d9850cc-db0d-4a8c-98de-a5857c764047"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(maxQuantValue, ScalarPointValue)) .
\"urn:uuid:c3c9020c-2d94-4afc-aa42-943b3c314bb7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(maxQuantValue, quantitySubsumes)) .
\"urn:uuid:09581785-1694-4621-a1cf-33f4e36dfd4f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(maxQuantValue, quantityIntersects)) .
\"urn:uuid:4e0f1b64-44e2-40f0-8513-840683cea1e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(maxQuantValue, (2))) .
\"urn:uuid:0f3209a7-bf90-4503-9f88-5b14daaf5d78"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(means, AntiTransitiveBinaryPredicate)) .
\"urn:uuid:82a25ad1-86d9-413c-8a10-853c757e9604"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(means, AsymmetricBinaryPredicate)) .
\"urn:uuid:28e112d1-2f6b-4222-8503-a13f9cba4f7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(means, SubLSExpression)) .
\"urn:uuid:474e02df-3d95-4c59-8465-c21eec03b5ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(means, Thing)) .
\"urn:uuid:0c7f16e4-fe9e-4666-8158-895f083ee1e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(means, (2))) .
\"urn:uuid:b2958eba-d5fd-42b8-b62e-44d74b670e0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(meetsPragmaticRequirement, BinaryPredicate)) .
\"urn:uuid:e16bd355-7f64-4559-a532-363e8ba84668"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(meetsPragmaticRequirement, DefaultMonotonicPredicate)) .
\"urn:uuid:84804a0e-9264-4125-a2e8-0b4eb773d823"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(meetsPragmaticRequirement, List)) .
\"urn:uuid:74e58b83-43b8-42f6-aec8-ba2eaa34936c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(meetsPragmaticRequirement, CycLAssertion)) .
\"urn:uuid:26c406a3-2ff5-49a3-abee-68edd7abfd1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(meetsPragmaticRequirement, (2))) .
\"urn:uuid:bfb420c8-67e6-435a-935a-3336180fdeb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(microtheoryDesignationArgnum, BinaryPredicate)) .
\"urn:uuid:3b0308fc-ff90-42c7-aeb9-b11bc1f063b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(microtheoryDesignationArgnum, MicrotheoryDesignatingRelation)) .
\"urn:uuid:c25827d4-49bb-43ed-b956-22fb0efe76c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(microtheoryDesignationArgnum, PositiveInteger)) .
\"urn:uuid:eef638ee-f1b1-471b-a29e-0e81db1ee213"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(microtheoryDesignationArgnum, (2))) .
\"urn:uuid:17a65f5e-6818-4493-8be1-342c666d4306"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(minQuantValue, ReflexiveBinaryPredicate)) .
\"urn:uuid:140fdd42-42fe-4925-8042-ba2c55218eee"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(minQuantValue, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:db0846f9-2e49-4e33-bb72-5cff58d5c958"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(minQuantValue, ScalarInterval)) .
\"urn:uuid:76de8bf4-ed77-49e3-9f31-c6b35b878fbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(minQuantValue, ScalarPointValue)) .
\"urn:uuid:d6bef14a-54d4-4fb9-ad56-b1fc29f486c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(minQuantValue, quantitySubsumes)) .
\"urn:uuid:dad0b755-cbbf-46ff-b790-2b35dd6fb57a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(minQuantValue, quantityIntersects)) .
\"urn:uuid:1d478559-c95f-473b-88df-576a0440b343"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(minQuantValue, (2))) .
\"urn:uuid:78dc1701-d4ca-433e-8529-5b3f35bb8577"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(minimize, UnaryPredicate)) .
\"urn:uuid:df51714a-e7ca-4c75-87dd-a0caee3aac28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(minimize, 'CycLSentence-Assertible')) .
\"urn:uuid:cc32dade-4c10-404b-9ee0-3c34dc846fd9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(minimize, (1))) .
\"urn:uuid:94df8111-0d43-4ee5-8137-e195e9d2534e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(minimizeExtent, UnaryPredicate)) .
\"urn:uuid:8a121cd5-ce49-4595-9e03-ff1481acce75"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(minimizeExtent, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:06bde1d6-6517-4918-a9a6-058e94901f82"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(minimizeExtent, Predicate)) .
\"urn:uuid:9018f279-02e9-4d8a-b9e0-c7808087db97"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(minimizeExtent, (1))) .
\"urn:uuid:17bcb267-0d2a-4c5e-b6d7-025c2ccc4f11"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(mtVisible, UnaryPredicate)) .
\"urn:uuid:6170dab5-5c62-406a-baf3-878912935f6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(mtVisible, EvaluatablePredicate)) .
\"urn:uuid:27262615-958f-4cc7-ace7-eb50670cb52c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(mtVisible, Microtheory)) .
\"urn:uuid:c900fcb8-4459-4ecc-ab02-24565336f00f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(mtVisible, (1))) .
\"urn:uuid:2b153419-f172-42d3-bad6-6647bcc9c9ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(multiplicationUnits, TernaryPredicate)) .
\"urn:uuid:25354340-71f4-4f50-9108-262e605c92c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(multiplicationUnits, PartiallyCommutativeRelation)) .
\"urn:uuid:f74319d0-ddcf-401c-bdb9-3d61da1bf0e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(multiplicationUnits, UnitOfMeasure)) .
\"urn:uuid:22ebe51c-d597-4f1f-b88a-c3343a45b330"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(multiplicationUnits, UnitOfMeasure)) .
\"urn:uuid:0627ead1-9494-45c7-8966-2d57d73d7d28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(multiplicationUnits, UnitOfMeasure)) .
\"urn:uuid:02344a8c-a9ba-4d5c-bcd7-a382b88b762c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(multiplicationUnits, (3))) .
\"urn:uuid:4bbb6674-f44f-4a47-a14d-427e961f24c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationPurpose, BinaryPredicate)) .
\"urn:uuid:8dc9f5f2-ad81-4144-bacc-97769aaa80f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationPurpose, BookkeepingPredicate)) .
\"urn:uuid:0ea66187-d6b1-4c4f-909e-da6096a8abeb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationPurpose, DocumentationConstant)) .
\"urn:uuid:405b191f-1bfb-4f54-8a51-a899c62c3453"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationPurpose, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:387cc1ea-eb4a-40b6-b7b1-da2a31eeb285"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(myCreationPurpose, Thing)) .
\"urn:uuid:0be4ac6c-8488-4091-9b67-673d5c02db69"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(myCreationPurpose, Individual)) .
\"urn:uuid:1a8e83fc-fbbb-48bb-978c-26f8467e3673"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(myCreationPurpose, CycLReifiableDenotationalTerm)) .
\"urn:uuid:985838db-d879-489c-9949-a663c6936042"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(myCreationPurpose, (2))) .
\"urn:uuid:c4e98084-ae9c-4c2f-b5e8-929336bf4763"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationSecond, BookkeepingPredicate)) .
\"urn:uuid:7481129e-3bcf-4f1a-84c0-d8fc8d14f718"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationSecond, BinaryPredicate)) .
\"urn:uuid:3bd712d3-bad0-4944-995e-762002dd1fc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationSecond, DocumentationConstant)) .
\"urn:uuid:6511d0ad-368a-41db-b864-22389f63c158"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationSecond, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:e3ccbec4-62f8-4820-adec-7deba9fbf4c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(myCreationSecond, Thing)) .
\"urn:uuid:b4251249-9baf-4837-b2cd-c66a7b95dff4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(myCreationSecond, NonNegativeInteger)) .
\"urn:uuid:e6526cd6-7a66-4a49-aae7-316c198e915d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(myCreationSecond, CycLConstant)) .
\"urn:uuid:0c13e8aa-572e-4e2c-853a-dd988e7d45c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(myCreationSecond, (2))) .
\"urn:uuid:119bce59-61bd-4975-b39e-41a820aaaeff"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationTime, BookkeepingPredicate)) .
\"urn:uuid:8cf22eaf-f4c3-4b41-8082-466fc3b13f7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreationTime, BinaryPredicate)) .
\"urn:uuid:dfa5f1f7-5d5c-431b-8ffd-31dbd68376b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationTime, DocumentationConstant)) .
\"urn:uuid:0dca42ba-b1cb-4d50-aaf1-98866cd511c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreationTime, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:f9476505-8b52-41f5-ae57-dab940a06a2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(myCreationTime, Thing)) .
\"urn:uuid:74183d1c-1267-40d6-96ca-aeb59acac225"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(myCreationTime, Integer)) .
\"urn:uuid:788bb2d6-839f-46ca-a839-ebcdb3c2c286"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(myCreationTime, CycLConstant)) .
\"urn:uuid:12f866d0-031c-417f-ad65-03479b328d1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(myCreationTime, (2))) .
\"urn:uuid:78906067-92f1-481f-a013-812227ec2985"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreator, BookkeepingPredicate)) .
\"urn:uuid:116c1b13-cb8c-4d80-bc04-6bf8e7a53cb3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreator, BinaryPredicate)) .
\"urn:uuid:6c491866-addf-4b67-9646-158a9107262b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(myCreator, DefaultMonotonicPredicate)) .
\"urn:uuid:06bea4fb-5e7a-439e-bb59-adb603c12c89"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreator, DocumentationConstant)) .
\"urn:uuid:459d6689-c0c0-4887-a058-71034bb46113"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(myCreator, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:94a06edd-3d38-494e-991f-274b969a3eb4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(myCreator, Thing)) .
\"urn:uuid:a17203dd-eefc-48b9-9d7f-88237b254284"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(myCreator, Cyclist)) .
\"urn:uuid:199537c4-87a9-427a-a67a-c41b8a6d9af0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(myCreator, CycLReifiableDenotationalTerm)) .
\"urn:uuid:d9a5d76f-d1f0-403d-b7b9-28101640a02a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(myCreator, (2))) .
\"urn:uuid:a29dafdd-3531-4883-a535-ea5af765030e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nand, CommutativeRelation)) .
\"urn:uuid:27e87faf-c5fb-451a-8dce-1180982b44a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nand, BinaryRelation)) .
\"urn:uuid:4b63afbe-7871-43f2-89f2-8ae103638a1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nand, LogicalConnective)) .
\"urn:uuid:f9b6dddd-2fb8-495a-bae0-eeed3989eca6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nand, 'ELRelation-OneWay')) .
\"urn:uuid:003a55a9-d125-47f7-8799-a44dd21d1532"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(nand, 'CycLSentence-Assertible')) .
\"urn:uuid:4a1f08f7-d923-4131-9a58-5563b84d0d6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(nand, 'CycLSentence-Assertible')) .
\"urn:uuid:e6f80daf-6005-46f2-b9b7-465153bab82b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nand, (2))) .
\"urn:uuid:a8287810-29ab-4943-a516-e43155840d65"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(natArgument, TernaryPredicate)) .
\"urn:uuid:de1a5487-7c6e-4d23-ac20-6afaf091634c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(natArgument, DefaultMonotonicPredicate)) .
\"urn:uuid:7976b46a-bb3c-4829-a95c-bc502041e2ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(natArgument, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:12b92d1b-ac2d-4c09-9ca7-e66bae1286a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(natArgument, Thing)) .
\"urn:uuid:9665a173-ea7e-4103-8c86-3b3d34207973"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(natArgument, NonNegativeInteger)) .
\"urn:uuid:a7537a8c-384f-4d26-afb0-11d958057032"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(natArgument, Thing)) .
\"urn:uuid:9640e7f5-6814-4ddb-84a3-58e9d9fe3045"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(natArgument, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:49d06ddc-2ece-41be-8868-7026c3d60099"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(natArgument, (3))) .
\"urn:uuid:9ec2b1b6-9596-4e59-8909-e6cbe86b0d58"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(natArgumentsEqual, BinaryPredicate)) .
\"urn:uuid:e4989f5d-3134-49ae-b42b-4b62b21bc6cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(natArgumentsEqual, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:1ae20ce9-4475-4267-b05d-b26275fd2e09"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(natArgumentsEqual, Thing)) .
\"urn:uuid:9e8f6c49-d786-4cee-9aec-e92190623b97"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(natArgumentsEqual, Thing)) .
\"urn:uuid:b146ab5b-f03a-4659-84bb-d98485c5b9ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(natArgumentsEqual, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:245a873b-599c-4938-8ef3-877dd7a9448b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(natArgumentsEqual, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:6de476b4-5c2b-423b-a0f9-e42e34111f00"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(natArgumentsEqual, (2))) .
\"urn:uuid:e54ba393-ea2b-455e-9ddc-fc099de05bb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(natFunction, DefaultMonotonicPredicate)) .
\"urn:uuid:2749165c-4f15-45fa-bbba-c88fdf74004e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(natFunction, BinaryPredicate)) .
\"urn:uuid:4a8b73a0-00d5-4828-8418-80c2427f7b9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(natFunction, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:5c315884-95e1-4171-b1c4-9263f6f25582"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(natFunction, Thing)) .
\"urn:uuid:87abcec1-c8b5-4fd6-8d36-3c2f5a5284e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(natFunction, ReifiableFunction)) .
\"urn:uuid:d2070359-e64a-4979-8284-5a8b9acecbcc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(natFunction, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:5619f29f-2182-41b3-b664-b8fc2f3397f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(natFunction, termDependsOn)) .
\"urn:uuid:a7559757-976a-4fb8-8e87-3297ea05e86d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(natFunction, operatorFormulas)) .
\"urn:uuid:42ecc2a2-df91-412a-b360-2a7a9b79d9db"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(natFunction, (2))) .
\"urn:uuid:ae8d1d11-587a-4558-a604-c72347149abb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestCommonGenlMt, TernaryPredicate)) .
\"urn:uuid:584119ff-9837-4c9a-bc41-c6180d5ccb5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestCommonGenlMt, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6f4197bd-a50a-488f-a400-2fa11d1950dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestCommonGenlMt, Microtheory)) .
\"urn:uuid:2a27e849-a8f5-4536-86f0-3f13846c1a3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestCommonGenlMt, Microtheory)) .
\"urn:uuid:ab4111ad-ae28-4475-b2ce-ff02765c7f50"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestCommonGenlMt, Microtheory)) .
\"urn:uuid:6b4a9499-a32f-4e35-bae6-b555a231a766"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestCommonGenlMt, (3))) .
\"urn:uuid:4d7eff05-e99e-4993-825c-e8e934fd36a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestCommonGenls, TernaryPredicate)) .
\"urn:uuid:5c74b9c9-8f80-49e8-b667-6cba1caff15e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestCommonGenls, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:baff8207-9d90-4079-b4b5-9a01db86f606"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestCommonGenls, Collection)) .
\"urn:uuid:fb9b4ed3-c068-4ede-a1ad-2c8fd9445c74"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(nearestCommonGenls, Thing)) .
\"urn:uuid:5d9e23aa-a6e0-4b7c-81b9-9ada9a411bd9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestCommonGenls, Collection)) .
\"urn:uuid:734befea-20bc-464d-8fd6-47f94db9c3be"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(nearestCommonGenls, Thing)) .
\"urn:uuid:39964690-6bab-411c-bfd7-e235d3617d96"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestCommonGenls, Collection)) .
\"urn:uuid:94b2be75-d2cf-4cd3-88b9-17385106f9f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(nearestCommonGenls, Thing)) .
\"urn:uuid:c8d12183-8cc2-4c6c-a683-381ead82bb0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestCommonGenls, (3))) .
\"urn:uuid:a705f4b6-dbe5-46be-b457-0079b8f36e30"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestCommonIsa, TernaryPredicate)) .
\"urn:uuid:a9795536-cc8a-473e-97db-595ccab5f2b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestCommonIsa, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:f0c75262-1a83-4709-8afa-63fe8a444939"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestCommonIsa, Thing)) .
\"urn:uuid:fa2b51f7-b7b1-4f62-8680-67924cd9478a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestCommonIsa, Thing)) .
\"urn:uuid:d56f5480-0457-4588-9a1d-5f2ebbf77cdf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestCommonIsa, Collection)) .
\"urn:uuid:6f7bf2c3-d6ef-41d0-8e25-77ce0ec89f43"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(nearestCommonIsa, Thing)) .
\"urn:uuid:b2186f44-24e2-4fe0-90db-7d243603504b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestCommonIsa, (3))) .
\"urn:uuid:6b23e36a-ccb6-4c5b-b9f3-af8deeb3765f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestCommonSpecs, TernaryPredicate)) .
\"urn:uuid:897d7558-14e2-4d0a-8601-021867a5349a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestCommonSpecs, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:484abe18-8d90-4d02-9671-60d9c29cb5f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestCommonSpecs, Collection)) .
\"urn:uuid:8f9ac651-c651-4a30-86b4-149ae437350a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(nearestCommonSpecs, Thing)) .
\"urn:uuid:a52da89d-1b35-44f3-a8b7-81f9233bab19"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestCommonSpecs, Collection)) .
\"urn:uuid:7312d916-21cc-414b-99de-feb2e25f325d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(nearestCommonSpecs, Thing)) .
\"urn:uuid:c1ee42be-a688-49d6-acf5-e142b0923642"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestCommonSpecs, Collection)) .
\"urn:uuid:83587e43-ada7-4cc4-b34c-c170a5b1223c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(nearestCommonSpecs, Thing)) .
\"urn:uuid:14944ed1-33e9-4d91-9f99-16da167eb9a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestCommonSpecs, (3))) .
\"urn:uuid:210cd627-fca1-4c07-a9bd-842b664f697f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestDifferentGenls, TernaryPredicate)) .
\"urn:uuid:9e0d0eff-c86b-4a87-86d2-735d39502a13"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestDifferentGenls, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:8e39fab7-8527-4b6b-a85d-fe9ef890f178"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestDifferentGenls, Collection)) .
\"urn:uuid:52a78d99-b0e5-4a5a-8727-4491a2c685d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(nearestDifferentGenls, Thing)) .
\"urn:uuid:88602f50-6647-41ca-b545-3d29a3a1f81b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestDifferentGenls, Collection)) .
\"urn:uuid:60eea1f4-e699-4113-867a-dce97e60ab5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(nearestDifferentGenls, Thing)) .
\"urn:uuid:21ef7a52-0763-4a86-8329-33fa9427cdaf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestDifferentGenls, Collection)) .
\"urn:uuid:a1304a84-5f42-4382-8c4f-0b7a458a97ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(nearestDifferentGenls, Thing)) .
\"urn:uuid:a729332a-4d87-4180-8198-4bf636176bc3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestDifferentGenls, (3))) .
\"urn:uuid:d12ba553-990c-4bf2-b660-a95a636dd2be"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestDifferentIsa, TernaryPredicate)) .
\"urn:uuid:0ab4d1ed-d5e6-4e22-83de-0eb2ca01ff45"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestDifferentIsa, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:d1967f2c-a90c-4be3-9df9-fc974432a023"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestDifferentIsa, Thing)) .
\"urn:uuid:75d819ad-5990-49b8-9d72-b5f520e42430"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestDifferentIsa, Thing)) .
\"urn:uuid:3568b3b7-1173-4323-a5c1-e7643ab0f7a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nearestDifferentIsa, Collection)) .
\"urn:uuid:32a62114-e3d6-4c75-b086-02bb580ebcb7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(nearestDifferentIsa, Thing)) .
\"urn:uuid:af3952f8-e7d8-4162-aeeb-1d49778a59ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestDifferentIsa, (3))) .
\"urn:uuid:ebad0a28-b9de-49ad-be77-4c0720a06543"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestGenlMt, AsymmetricBinaryPredicate)) .
\"urn:uuid:2bd86fdb-0a5d-47f4-8e98-d567f4ca3b81"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestGenlMt, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:c4150612-6695-4353-a01a-c8ef3d9cd66f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestGenlMt, Microtheory)) .
\"urn:uuid:57665b12-fefb-495a-8c7f-0c6d6eb1cce7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestGenlMt, Microtheory)) .
\"urn:uuid:bebbe129-4f1d-4cae-ad7e-91ef53aa52f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(nearestGenlMt, genlMt)) .
\"urn:uuid:75623464-531e-4570-8351-bc080ff09f7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestGenlMt, (2))) .
\"urn:uuid:de575953-3d27-4b44-8f74-76bae65a657e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestGenlPreds, AsymmetricBinaryPredicate)) .
\"urn:uuid:244e625a-84f3-4cef-861d-eaca46db2521"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestGenlPreds, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:8a896a2e-8106-4675-a6d1-e1234ace7f16"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestGenlPreds, Predicate)) .
\"urn:uuid:1299c63f-b2e7-407d-bf1d-9dd1af8386d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestGenlPreds, Predicate)) .
\"urn:uuid:6d88796a-bb9b-4df3-aa99-1b365baae7b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(nearestGenlPreds, genlPreds)) .
\"urn:uuid:7e796c16-f578-4643-a34e-38e544536341"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestGenlPreds, (2))) .
\"urn:uuid:aa4f305e-3dd3-49ef-8a81-52b3b462e525"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestGenls, BinaryPredicate)) .
\"urn:uuid:272e019e-de3d-439a-8cce-29e7981c49a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestGenls, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:698a6d02-22fe-45de-8d5f-e3f1e7ebb3be"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestGenls, Collection)) .
\"urn:uuid:d5d4284f-c5f3-405f-b4a4-742c95a8d555"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(nearestGenls, Thing)) .
\"urn:uuid:8eef15de-06e5-488d-b6ff-eff58652d589"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestGenls, Collection)) .
\"urn:uuid:488e6f8e-ac7e-43be-9936-88d24c14899c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(nearestGenls, Thing)) .
\"urn:uuid:57467c11-6e28-4b19-b10a-f232ab854923"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(nearestGenls, genls)) .
\"urn:uuid:f3b6a206-6f87-468a-a885-f9e701191329"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestGenls, (2))) .
\"urn:uuid:09bd8753-4981-4648-b291-963255a8812a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nearestIsa, BinaryPredicate)) .
\"urn:uuid:d14608b0-d742-48c5-9964-60d7abfbac3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nearestIsa, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:73fa6227-1735-4581-b815-40fcedff2fe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nearestIsa, Thing)) .
\"urn:uuid:bb83c145-8db9-49c5-b551-184283c7483b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nearestIsa, Collection)) .
\"urn:uuid:aecd8b86-3069-48be-9260-63849e878f19"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(nearestIsa, Thing)) .
\"urn:uuid:5e300b45-b342-4b8c-a570-213b73d2c6e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(nearestIsa, isa)) .
\"urn:uuid:561ef6ad-52c7-4b4f-ac7a-9ebd0b5c43f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nearestIsa, (2))) .
\"urn:uuid:9bd10cba-193b-4803-8cbd-d7264169344b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationInverse, SymmetricBinaryPredicate)) .
\"urn:uuid:e81ad202-90f3-4248-83e8-8b658025eb17"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationInverse, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:a61e0e5d-c29a-495b-a6b0-3c08e97bc385"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(negationInverse, IrreflexiveBinaryPredicate))) .
\"urn:uuid:afad3ecf-2d35-4beb-babb-88177ba73065"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(negationInverse, TransitiveBinaryPredicate))) .
\"urn:uuid:05978bb0-5932-413f-bf6d-282627b05799"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(negationInverse, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:29ebc4cf-eb74-4fd2-aaa1-69511694aec8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(negationInverse, BinaryPredicate)) .
\"urn:uuid:fccd5dea-1a45-45e1-9d39-dc7582fe62d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(negationInverse, BinaryPredicate)) .
\"urn:uuid:80120bff-b752-45ca-bf26-f47b63ecdc15"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(negationInverse, negationInverse)) .
\"urn:uuid:1f5d7339-8f4c-43b9-a11b-a6a0e318bad9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(negationInverse, (2))) .
\"urn:uuid:6429a53b-a03b-499c-b2c3-e0d699996e96"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationMt, IrreflexiveBinaryPredicate)) .
\"urn:uuid:f8c8612f-7cea-494e-90bb-13573096d283"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationMt, SymmetricBinaryPredicate)) .
\"urn:uuid:ae032596-26ca-4611-894c-094f89b1502b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(negationMt, Microtheory)) .
\"urn:uuid:c230964f-3f45-413c-a41c-f80867a12c57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(negationMt, Microtheory)) .
\"urn:uuid:20fbca4e-ac3e-45c5-8ba5-da45a91aec5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(negationMt, negationMt)) .
\"urn:uuid:1ded44ad-c1b2-4350-9029-6bcad11e6dba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(negationMt, (2))) .
\"urn:uuid:23c2588f-3e2f-4bbb-b631-fd6f05ec0649"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationPreds, IrreflexiveBinaryPredicate)) .
\"urn:uuid:6cfe1985-868e-4aa7-98b7-90c1e629f189"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationPreds, SymmetricBinaryPredicate)) .
\"urn:uuid:d2476430-1366-4f65-b392-eef0e9f4fdad"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationPreds, DefaultMonotonicPredicate)) .
\"urn:uuid:e21583c3-cead-44b7-9052-3b49832decc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(negationPreds, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:2ae21f15-e795-43f1-985a-d9c17552318a"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(negationPreds, TransitiveBinaryPredicate))) .
\"urn:uuid:0dc719b4-2897-4737-853a-01378ed14479"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(negationPreds, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:de19bccf-b58f-40fd-a6a3-6ab5aeb95d8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(negationPreds, TransformationModuleSupportedPredicate)) .
\"urn:uuid:bee30228-75a8-4d9e-9106-46ccacda98a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(negationPreds, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:484bb03e-168b-46a4-b5bf-36cfb4f943f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(negationPreds, Predicate)) .
\"urn:uuid:99176f71-6642-47cd-a173-1b2f843d37db"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(negationPreds, Predicate)) .
\"urn:uuid:b1c3e3fa-1b12-4bd4-8152-9b6bd8907e7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(negationPreds, negationPreds)) .
\"urn:uuid:bfb40c28-075b-4d5b-a17c-9c2d95197114"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(negationPreds, (2))) .
\"urn:uuid:85a4dc2b-a302-4480-97a7-83e8e76bedad"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nonAbducibleWithValueInArg, TernaryPredicate)) .
\"urn:uuid:aa65d8e5-ef51-47b4-96cc-2403a6467df0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nonAbducibleWithValueInArg, Predicate)) .
\"urn:uuid:0ee2e65a-9cfa-40f3-b1fe-ab71cbb408cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nonAbducibleWithValueInArg, Thing)) .
\"urn:uuid:5102ced8-e6e4-41a5-8876-ffeb61275b70"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nonAbducibleWithValueInArg, PositiveInteger)) .
\"urn:uuid:c91fa303-2a7e-41d3-b8fa-8dd4048d9d05"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nonAbducibleWithValueInArg, (3))) .
\"urn:uuid:baac37dd-bfa6-4bc0-a0e0-5f291b6bda69"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nor, 'ELRelation-OneWay')) .
\"urn:uuid:a57429db-94fe-42cd-a5d4-5ffacde248fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nor, LogicalConnective)) .
\"urn:uuid:45e5122f-a86e-4008-ad78-976b8756e0ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nor, BinaryRelation)) .
\"urn:uuid:f4454bcf-8144-486b-b298-bc73b277a87a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nor, CommutativeRelation)) .
\"urn:uuid:eaecd277-ea7c-4b1a-a9dc-c9b10d8c1228"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(nor, 'CycLSentence-Assertible')) .
\"urn:uuid:c12343a0-a81f-46db-aea6-6df97c5db97e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(nor, 'CycLSentence-Assertible')) .
\"urn:uuid:e74d457d-ba28-4fb9-a3e5-96ab69423fb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nor, (2))) .
\"urn:uuid:56537d3d-125a-4c63-910a-5705e6c3370a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(not, LogicalConnective)) .
\"urn:uuid:37f4b264-4b83-4c31-9782-4459d40d08a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(not, UnaryRelation)) .
\"urn:uuid:d0e70073-5a67-4c2a-8ca0-327f587fdd69"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(not, 'CycLSentence-Assertible')) .
\"urn:uuid:50986fb8-2a6c-493b-8933-8acd8b3d22e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(not, (1))) .
\"urn:uuid:a1fcf894-c56f-491b-a547-578134ff313b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertible, UnaryPredicate)) .
\"urn:uuid:e698def5-5ee5-4155-a3cc-423c306c9e18"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertible, DefaultMonotonicPredicate)) .
\"urn:uuid:235f8e14-389b-440f-aeb7-cc9e59b729cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(notAssertible, Predicate)) .
\"urn:uuid:60acb52c-7501-4e43-8317-085f715d3685"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(notAssertible, (1))) .
\"urn:uuid:2d5cea3b-3257-4d76-9f1e-6ea2e681231c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertibleCollection, UnaryPredicate)) .
\"urn:uuid:ea2343df-da38-4098-8719-774688ca98f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertibleCollection, DefaultMonotonicPredicate)) .
\"urn:uuid:e6d7d450-d617-4d39-87a5-afb7608c004f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(notAssertibleCollection, Collection)) .
\"urn:uuid:a38e5683-5af6-4237-b282-b0aec4179712"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(notAssertibleCollection, Thing)) .
\"urn:uuid:71307fc5-5b0a-4e4c-bd88-eb9d00409d47"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(notAssertibleCollection, (1))) .
\"urn:uuid:d95c63de-5da4-43f7-a5ff-9ddc118b7fc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertibleMt, DefaultMonotonicPredicate)) .
\"urn:uuid:e0d7bf70-d6f4-4d1d-99ac-29709fc25cf9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(notAssertibleMt, UnaryPredicate)) .
\"urn:uuid:da0e2727-28f3-4236-a134-fd6afff16b5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(notAssertibleMt, Microtheory)) .
\"urn:uuid:fd910f72-6baa-4991-b8c8-34c48a3d83a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(notAssertibleMt, (1))) .
\"urn:uuid:816362cd-332c-4664-975d-0b23ae875799"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nthLargestElement, QuaternaryPredicate)) .
\"urn:uuid:7ee18fe5-f48c-4a1a-8c3d-a2c8cb100a39"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nthLargestElement, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:54c39f8e-0b32-4afa-8c4e-44a907261d17"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nthLargestElement, Thing)) .
\"urn:uuid:f109788c-5469-4935-b9d9-5b0b9fb389ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nthLargestElement, PositiveInteger)) .
\"urn:uuid:6960e041-1943-40ab-9bf6-67eb344e5ca6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nthLargestElement, SetOrCollection)) .
\"urn:uuid:684f4cae-9a43-41cd-b9f7-30c43845e738"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(nthLargestElement, UnaryFunction)) .
\"urn:uuid:6b47cd98-a183-4aa9-8be0-a5705688779d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nthLargestElement, (4))) .
\"urn:uuid:e829ffd9-b4e8-462c-a495-55a2f98b1401"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(nthSmallestElement, QuaternaryPredicate)) .
\"urn:uuid:f3981477-520e-4830-9fb6-a00aff8e0695"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(nthSmallestElement, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:a894619b-3fb1-41f5-b3a1-90e2ca9a8ca8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(nthSmallestElement, Thing)) .
\"urn:uuid:38a32d56-d2e0-4c5d-a96c-ef5ea8981187"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(nthSmallestElement, PositiveInteger)) .
\"urn:uuid:f9e2ac5f-212d-4fa8-b0d7-42fd31337d7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(nthSmallestElement, SetOrCollection)) .
\"urn:uuid:f649e212-69d7-444b-9dd3-aa391fd00b92"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(nthSmallestElement, UnaryFunction)) .
\"urn:uuid:c902feca-31da-4f56-a417-19177e084bf8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(nthSmallestElement, (4))) .
\"urn:uuid:be1505b2-1897-49e0-8c5d-599ef8ddb820"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(numericallyEquals, SymmetricBinaryPredicate)) .
\"urn:uuid:1d1e0ecc-0992-49e2-a081-947a77b31324"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(numericallyEquals, TransitiveBinaryPredicate)) .
\"urn:uuid:94e89608-fd65-4c2f-b04d-6176a1aee855"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(numericallyEquals, ReflexiveBinaryPredicate)) .
\"urn:uuid:d83d1c88-c222-4a2e-bffc-9926d0233672"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(numericallyEquals, EvaluatablePredicate)) .
\"urn:uuid:09ad6f5c-3b26-404a-aae1-f99ea3ea489a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(numericallyEquals, ScalarInterval)) .
\"urn:uuid:c4a6182c-8802-41be-984a-54108242a24c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(numericallyEquals, NonNegativeInteger)) .
\"urn:uuid:0070dc74-de5b-4aca-aa34-94abb7a67058"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(numericallyEquals, ScalarInterval)) .
\"urn:uuid:333808bd-9070-4a6e-8873-b7f9f89b0006"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(numericallyEquals, NonNegativeInteger)) .
\"urn:uuid:0c5f630a-ca11-4c2a-b00b-0b0f87d3ddfb"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(numericallyEquals, greaterThanOrEqualTo)) .
\"urn:uuid:b98cefa8-703d-4e25-84ce-d67436aed2fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(numericallyEquals, lessThanOrEqualTo)) .
\"urn:uuid:89eebae9-435e-45ad-b6ce-a62439199a2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(numericallyEquals, quantitySubsumes)) .
\"urn:uuid:654fd722-9cd1-4ee3-b527-df4e4e8be4a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(numericallyEquals, numericallyEquals)) .
\"urn:uuid:501031eb-3757-4ece-9d80-36c1d476d6e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(numericallyEquals, (2))) .
\"urn:uuid:1db0f462-0144-4c40-976a-bfc590ec9c9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(oldConstantName, BookkeepingPredicate)) .
\"urn:uuid:d95879b4-8ce3-4778-a8aa-0c0f196d2a1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(oldConstantName, BinaryPredicate)) .
\"urn:uuid:35958408-a741-4587-8c2b-3509737156c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(oldConstantName, DocumentationPredicate)) .
\"urn:uuid:19fa9f9d-6387-4f4c-a0b3-3f8595334efc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(oldConstantName, Thing)) .
\"urn:uuid:29ef83cf-0121-45fe-8de3-29571c8545c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(oldConstantName, CharacterString)) .
\"urn:uuid:6f18c824-b5b3-4cca-bb3f-80d255093f5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(oldConstantName, CycLConstant)) .
\"urn:uuid:225130f0-1e0d-46f8-9135-d62b2411c155"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(oldConstantName, SubLString)) .
\"urn:uuid:8bb7fb3f-117a-4ab2-af9f-fb7ba3729db4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(oldConstantName, (2))) .
\"urn:uuid:fd5038c1-c03e-4c84-b77d-0c7980f488b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(omitArgIsa, BinaryPredicate)) .
\"urn:uuid:75fd54d7-d56f-4054-a932-fed54a79815f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(omitArgIsa, Relation)) .
\"urn:uuid:79e250c4-2987-4d7a-ab39-74a29d973d62"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(omitArgIsa, NonNegativeInteger)) .
\"urn:uuid:dd3ea206-b8ac-467b-b8aa-549849409ef2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(omitArgIsa, (2))) .
\"urn:uuid:9d795bbf-29d5-499a-996c-88eb6f71a9bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(opaqueArgument, BinaryPredicate)) .
\"urn:uuid:936001b2-5e35-4513-8e2c-50e480511f2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(opaqueArgument, Relation)) .
\"urn:uuid:483092fa-73f6-4c14-a49c-a755f06dc66e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(opaqueArgument, PositiveInteger)) .
\"urn:uuid:a0543d10-197c-42b7-b9e5-bc8695bbdeb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(opaqueArgument, (2))) .
\"urn:uuid:2e7e6e06-7480-4f35-8904-e3ed54e5a864"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(openEntryFormatInArgs, BinaryPredicate)) .
\"urn:uuid:a46fd5c6-1a53-4824-ad14-bb0142f21018"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(openEntryFormatInArgs, ArgConstraintPredicate)) .
\"urn:uuid:ada865eb-4ebf-4259-84e6-654d5a9f273b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(openEntryFormatInArgs, WFFSupportedPredicate)) .
\"urn:uuid:9c8c44ea-7b8c-4070-b336-7608d8e919ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(openEntryFormatInArgs, Predicate)) .
\"urn:uuid:14fc1dc7-74f4-490c-857a-032ff9fa276c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(openEntryFormatInArgs, PositiveInteger)) .
\"urn:uuid:d97204b6-098e-4e7e-8106-151e9bc84b72"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(openEntryFormatInArgs, (2))) .
\"urn:uuid:9c249579-ac85-4316-bf58-2cefdcf24abf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(operatorFormulas, BinaryPredicate)) .
\"urn:uuid:32eb7997-30b9-4bf0-8efa-a80da8f07e53"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(operatorFormulas, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:924f73a3-9321-42e1-8b67-e1fe7dd9ee61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(operatorFormulas, Relation)) .
\"urn:uuid:ee8bbaa3-6f26-4c1a-99f9-47f7192a7552"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(operatorFormulas, Thing)) .
\"urn:uuid:fb879e87-897e-49a4-8f95-dad669ed9ec4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(operatorFormulas, Thing)) .
\"urn:uuid:39d7eef4-acbf-4bb9-82b5-e18c1bb778de"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(operatorFormulas, CycLClosedDenotationalTerm)) .
\"urn:uuid:2f8b7d3c-160c-4e62-80f6-2b03118c02f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(operatorFormulas, CycLFormula)) .
\"urn:uuid:7f86580d-fc67-4592-b4c7-85c11a0d4f9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(operatorFormulas, (2))) .
\"urn:uuid:e907254a-e49b-4642-bd5e-297979d3e008"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#or, LogicalConnective)) .
\"urn:uuid:ca8f29dc-e5cd-4f8a-99db-869a5e027d00"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#or, VariableArityRelation)) .
\"urn:uuid:2fd8b321-c52b-41f0-b40c-9585f5c64e13"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#or, CommutativeRelation)) .
\"urn:uuid:724d7542-a81a-4dcf-8db1-d88fd117ce31"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(cyc#or, AssociativeRelation)) .
\"urn:uuid:c7d28e3e-43b1-4f65-a00c-3ab862eb9edf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(cyc#or, 'CycLSentence-Assertible')) .
\"urn:uuid:1a443419-0e50-4f17-8a08-45131186d02a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argsQuotedIsa(cyc#or, 'CycLSentence-Assertible')) .
\"urn:uuid:b697adfc-ef8a-4bde-bd0f-38c27667b73d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(overlappingExternalConcept, TernaryPredicate)) .
\"urn:uuid:237a9f82-fba2-4c2c-892a-a3dae17a62d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(overlappingExternalConcept, Individual)) .
\"urn:uuid:983466c4-b3cc-4e73-9db3-961c590e375c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(overlappingExternalConcept, CharacterString)) .
\"urn:uuid:ccf06f82-f5d8-4d51-80bd-eea7a4eb00d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(overlappingExternalConcept, (3))) .
\"urn:uuid:1e6a2341-257a-47cb-806f-8b71cf40ea7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(performSubL, UnaryPredicate)) .
\"urn:uuid:f818eabc-9f7d-480b-b990-0663528fd511"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(performSubL, DefaultMonotonicPredicate)) .
\"urn:uuid:8e44f6f4-66fc-4ef7-aeaa-0605cc19f54f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(performSubL, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:ea79569f-5001-4f06-b9f1-b9a1718686e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(performSubL, CycLNonAtomicTerm)) .
\"urn:uuid:8ea0d140-3cb4-4ad2-a1e5-9c6c442b6603"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(performSubL, (1))) .
\"urn:uuid:59f78d5b-da7e-4651-a2bc-ae0f175bc215"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pointQuantValue, BinaryPredicate)) .
\"urn:uuid:5d023e54-62da-44e6-a5bc-93d539fdf391"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(pointQuantValue, ScalarPointValue)) .
\"urn:uuid:ff6b4ee9-f3fe-4181-8cbc-1ac2b4b82025"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(pointQuantValue, Thing)) .
\"urn:uuid:240aef3c-9f1b-406f-92a2-413863e1fa36"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(pointQuantValue, ScalarPointValue)) .
\"urn:uuid:adbbd663-7391-4fd1-bf62-221bbd5b6563"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(pointQuantValue, CycLReifiableDenotationalTerm)) .
\"urn:uuid:0613fb03-b02c-49f9-83b6-a45fa291b998"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(pointQuantValue, numericallyEquals)) .
\"urn:uuid:3731a1a1-260c-41a6-a044-02e432c91f71"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(pointQuantValue, maxQuantValue)) .
\"urn:uuid:4f45ec4e-bd88-428a-a954-15bff23bc263"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(pointQuantValue, minQuantValue)) .
\"urn:uuid:05c7f4f8-5d06-47b2-906c-583ab5f23dfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(pointQuantValue, (2))) .
\"urn:uuid:bd0de2dd-1919-4295-a39c-234a962d872b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticRequirement, BinaryPredicate)) .
\"urn:uuid:6bda37b1-469d-4060-b311-9fdff189b54f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticRequirement, DefaultMonotonicPredicate)) .
\"urn:uuid:e315537b-f836-47fc-8da8-834e0fe59449"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticRequirement, ExceptionPredicate)) .
\"urn:uuid:04ff359f-804d-4b7a-9bdd-eae13076c72d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticRequirement, WFFSupportedPredicate)) .
\"urn:uuid:2f7bc16a-2b40-4443-aca4-2d1ef70581a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(pragmaticRequirement, InferenceSupportedPredicate)) .
\"urn:uuid:0b34eeee-9824-4fe5-9ad5-a4c1bac07471"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(pragmaticRequirement, 'CycLSentence-Askable')) .
\"urn:uuid:292ce526-801c-40c0-8e91-7923ced93cf9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(pragmaticRequirement, CycLRuleAssertion)) .
\"urn:uuid:350995a6-d60e-40f4-8260-afcc4d1b6254"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(pragmaticRequirement, (2))) .
\"urn:uuid:7ea64406-988c-4330-bb40-79372327b71a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticallyNormal, BinaryPredicate)) .
\"urn:uuid:0087b259-45ce-40c4-acb1-69f13b3e3918"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(pragmaticallyNormal, DefaultMonotonicPredicate)) .
\"urn:uuid:0a78ac83-4030-4821-ac70-63959fd4113a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(pragmaticallyNormal, List)) .
\"urn:uuid:390df30b-b4ab-4651-b603-fc427c4c2751"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(pragmaticallyNormal, CycLAssertion)) .
\"urn:uuid:3918f321-59bd-4c8e-8def-986e87a0fd4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(pragmaticallyNormal, (2))) .
\"urn:uuid:0ff6eb89-0050-4efe-9c8a-81738d12ea97"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(predicateConventionMt, BinaryPredicate)) .
\"urn:uuid:2ee7dcab-9dba-481f-9b21-ed0bc0245ef6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(predicateConventionMt, DefaultMonotonicPredicate)) .
\"urn:uuid:b5c80375-04a6-4e10-ad0e-ce9d5624ddd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(predicateConventionMt, Predicate)) .
\"urn:uuid:c3b01952-6ccf-462d-9d50-650f1815378c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(predicateConventionMt, Microtheory)) .
\"urn:uuid:2eb37b47-692e-494a-b690-a1a0f88f418a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(predicateConventionMt, (2))) .
\"urn:uuid:b6a1f28f-35c8-46ae-92f6-7f861793f63c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(preservesGenlsInArg, BinaryPredicate)) .
\"urn:uuid:ddac392f-8b30-4d94-9be3-8ad197115aef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(preservesGenlsInArg, CollectionDenotingFunction)) .
\"urn:uuid:f089210b-68e4-485c-ac1a-5160bbe24fd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(preservesGenlsInArg, PositiveInteger)) .
\"urn:uuid:00a1a1bc-0c44-4769-a8ca-e78cc6179fc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(preservesGenlsInArg, (2))) .
\"urn:uuid:8e648b9f-0f02-4db8-9daa-7ea7abe1128c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(prettyString, BinaryPredicate)) .
\"urn:uuid:d49ecd8d-c510-45bf-abd3-ec2d1a1ae875"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(prettyString, Thing)) .
\"urn:uuid:b45296f4-9781-4487-b31e-5236aab63fe2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(prettyString, SubLSExpression)) .
\"urn:uuid:c862aae9-f934-4845-a092-553a4dcc42fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(prettyString, SubLString)) .
\"urn:uuid:6a4a1e2c-217b-414b-b31e-e1d571abde51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(prettyString, (2))) .
\"urn:uuid:776d2e1f-2b29-40f9-b82d-05f2e72d2394"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('prettyString-Canonical', BinaryPredicate)) .
\"urn:uuid:da9abbe7-79cf-42d3-a0ea-e717ce5a6182"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('prettyString-Canonical', Thing)) .
\"urn:uuid:422a9f74-6a19-4454-8fd8-6b4fcd375ce0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('prettyString-Canonical', SubLSExpression)) .
\"urn:uuid:76e27769-81b6-41cf-a0ca-03c52a7c3b6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa('prettyString-Canonical', SubLString)) .
\"urn:uuid:ea850ef3-5ecf-4fde-b330-b1998966ee30"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('prettyString-Canonical', (2))) .
\"urn:uuid:46b943ff-b32c-496b-aa98-b44215400b74"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(provableViaDefns, EvaluatablePredicate)) .
\"urn:uuid:a78d5c49-8f6a-4601-a32a-7ae0debbc47c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(provableViaDefns, UnaryPredicate)) .
\"urn:uuid:56506ac1-7ae4-42da-afdd-863a67d3b1a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(provableViaDefns, CycLSentence)) .
\"urn:uuid:bcfe43ce-f2eb-4f96-963c-fa620f7f3f9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(provableViaDefns, (1))) .
\"urn:uuid:25bd03ec-c456-4ad7-bf6a-2d3d33aac754"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantityIntersects, ReflexiveBinaryPredicate)) .
\"urn:uuid:35334dca-f42a-4f5a-97e6-b718373085d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantityIntersects, SymmetricBinaryPredicate)) .
\"urn:uuid:6b5a42f4-a103-4138-9245-baac2f85ef6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantityIntersects, EvaluatablePredicate)) .
\"urn:uuid:09b6b41f-435c-41c3-868d-b8c1d13e6986"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quantityIntersects, TransitiveBinaryPredicate))) .
\"urn:uuid:19f4cb65-2062-41f2-922c-8fc317eb1b4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quantityIntersects, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:9d63d1cf-9c63-4886-84b5-4c71edbb294c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quantityIntersects, ScalarInterval)) .
\"urn:uuid:eb09cd09-8028-41b6-ba68-74d3604303bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(quantityIntersects, ScalarInterval)) .
\"urn:uuid:a447f403-777d-4d03-9201-e27341297ef7"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(quantityIntersects, quantityIntersects)) .
\"urn:uuid:d82e348a-04ac-42ad-a35d-bb5ac57e8b44"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quantityIntersects, (2))) .
\"urn:uuid:c5620a5b-aef8-4d9b-bda3-8c566fbbe1e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantitySubsumes, TransitiveBinaryPredicate)) .
\"urn:uuid:27ee7deb-ee9a-45a9-aa9e-c1a74ad39249"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantitySubsumes, ReflexiveBinaryPredicate)) .
\"urn:uuid:3dd90288-6cdd-493b-8e1e-ccc5fc07a2da"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantitySubsumes, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:f34022a4-828f-44d8-a5c4-ac1cd0948bd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quantitySubsumes, EvaluatablePredicate)) .
\"urn:uuid:805f5ee9-6915-4a70-a43b-2b8389a55c55"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quantitySubsumes, ScalarInterval)) .
\"urn:uuid:8b9cdfdc-d468-475f-80ab-527fb44e0dd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(quantitySubsumes, ScalarInterval)) .
\"urn:uuid:fde59875-7abe-4d04-bfa9-4dbbce60c479"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(quantitySubsumes, quantityIntersects)) .
\"urn:uuid:85b47e80-96ee-4333-b352-8778a3214091"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(quantitySubsumes, quantityIntersects)) .
\"urn:uuid:2d4e755f-2284-4c4e-9531-0863859ddf08"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quantitySubsumes, (2))) .
\"urn:uuid:1df0d316-4ba6-4723-95c3-4459c466de35"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(querySentence, UnaryPredicate)) .
\"urn:uuid:bb26d0f8-09ce-4da0-9ae7-65ebfcba6b38"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(querySentence, CycLSentence)) .
\"urn:uuid:7c2c444d-d848-4755-9fcd-0e9f5ac474d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(querySentence, (1))) .
\"urn:uuid:07212a2b-6139-4487-a8ca-064ace0db6b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedArgument, BinaryPredicate)) .
\"urn:uuid:5b075b29-0998-4e69-91e5-4cbfc9f0b01c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedArgument, WFFSupportedPredicate)) .
\"urn:uuid:5edc9f7f-2b91-4184-a9e3-f0cee948d25f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(quotedArgument, Predicate)) .
\"urn:uuid:ae07629d-1b56-49f7-8e1b-f6d7ede10cf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quotedArgument, Relation)) .
\"urn:uuid:b1c0effb-aa84-47f1-93d6-fe1d13c93dbb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(quotedArgument, PositiveInteger)) .
\"urn:uuid:bca78b4a-ae4a-4e8b-8303-b97b1863948c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(quotedArgument, opaqueArgument)) .
\"urn:uuid:81f4a503-85bf-40fa-b759-603c248aad15"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quotedArgument, (2))) .
\"urn:uuid:e0f67e8f-abaf-40da-a766-8a7ae92bfed6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnIff, BinaryPredicate)) .
\"urn:uuid:0dec386e-2aa7-491c-ad6b-7807e580e4a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnIff, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:62ad5d39-4388-41f4-95dc-4751088e939f"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedDefnIff, InferenceSupportedPredicate))) .
\"urn:uuid:33edda0b-7a58-46e1-ad62-e5493bf3a0d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quotedDefnIff, SubLExpressionType)) .
\"urn:uuid:11950566-d070-4092-85ce-e920e9af1cfb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(quotedDefnIff, SubLSExpression)) .
\"urn:uuid:9be303f6-92ca-4f18-95f8-7dbe00c0a3e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(quotedDefnIff, CycLNonAtomicTerm)) .
\"urn:uuid:44a53ed6-5fa4-4d19-8c6f-ff175bda4332"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quotedDefnIff, (2))) .
\"urn:uuid:66f6dbb4-274e-4e26-bd38-1dce62b41a97"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnNecessary, BinaryPredicate)) .
\"urn:uuid:e66c403e-237d-4533-a061-501b1db18434"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnNecessary, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:0fca17c6-ccb0-4d0b-aa4b-0334d0c93b9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedDefnNecessary, InferenceSupportedPredicate))) .
\"urn:uuid:23b1cf71-ad1c-44a1-b852-f99b3d525156"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quotedDefnNecessary, SubLExpressionType)) .
\"urn:uuid:b951294b-6d42-4e54-bdd4-0c8b62079e7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(quotedDefnNecessary, SubLSExpression)) .
\"urn:uuid:5a3ea7c4-dbca-47e5-8243-db96f3cd708f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(quotedDefnNecessary, CycLNonAtomicTerm)) .
\"urn:uuid:d4178601-05e3-467d-8d8e-9f255b40c340"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quotedDefnNecessary, (2))) .
\"urn:uuid:72accb45-5303-4fff-9c55-1708a6f9bf96"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnSufficient, BinaryPredicate)) .
\"urn:uuid:153d01cd-3e4f-4f13-b5c7-b1a744427486"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedDefnSufficient, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:d96e8921-be7b-4145-b17f-0ad5de01e1ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedDefnSufficient, InferenceSupportedPredicate))) .
\"urn:uuid:d084040c-89fd-4e11-8686-05c23e318acf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quotedDefnSufficient, SubLExpressionType)) .
\"urn:uuid:61e5b119-d879-4bbe-8a89-09ae70ff4ba3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(quotedDefnSufficient, SubLSExpression)) .
\"urn:uuid:24c18634-5335-4827-8257-1a478f0b7832"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(quotedDefnSufficient, CycLNonAtomicTerm)) .
\"urn:uuid:c6acfed3-baee-41d9-81ca-63e6bc070b8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quotedDefnSufficient, (2))) .
\"urn:uuid:f79ef4b5-06ae-46f5-906a-5155c64a608a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedIsa, BinaryPredicate)) .
\"urn:uuid:2b5e4183-72a6-43c4-8c82-d2054c050743"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:ed1fd54b-4ddb-4d90-a07a-50253660197b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(quotedIsa, WFFConstraintSatisfactionPredicate)) .
\"urn:uuid:f54739a4-2217-44af-b7b0-bf8697a26a1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedIsa, TransitiveBinaryPredicate))) .
\"urn:uuid:cc3b3b23-6e97-4f40-8297-c9f25da32c4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedIsa, IrreflexiveBinaryPredicate))) .
\"urn:uuid:62471aa2-ea5b-4470-ae59-8e853d22fff9"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(quotedIsa, ReflexiveBinaryPredicate))) .
\"urn:uuid:eae68385-6c2d-4acb-b726-580e300f8f9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(quotedIsa, InferenceSupportedPredicate)) .
\"urn:uuid:4afca138-e9d1-4097-aa46-ff1addfe2874"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(quotedIsa, Thing)) .
\"urn:uuid:dc8c44af-8641-47a6-9ebb-f4013b3be010"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(quotedIsa, SubLExpressionType)) .
\"urn:uuid:a7ea6e02-0bd0-4473-86ae-9b07d872886f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(quotedIsa, SubLSExpression)) .
\"urn:uuid:9f2ef4bb-ba09-4f3b-b3e5-5953d1e040ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(quotedIsa, (2))) .
\"urn:uuid:5d999f8a-07c7-4ef3-b6c0-54c853a47d69"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ratioOfTo, TernaryPredicate)) .
\"urn:uuid:ca8d2754-9ff1-43ba-b0b3-9dd20e27e523"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ratioOfTo, ScalarInterval)) .
\"urn:uuid:1a622837-afff-434f-91f2-07083777e78f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(ratioOfTo, ScalarInterval)) .
\"urn:uuid:f7b05d9a-bbdd-4954-8c69-ba1b48282e0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(ratioOfTo, ScalarInterval)) .
\"urn:uuid:f9377059-d308-4d4b-9bd5-8ac4a78e7bd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ratioOfTo, (3))) .
\"urn:uuid:677f07b8-0a0a-479f-9c0c-a67226240ed6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulationDirectionInMode, TernaryPredicate)) .
\"urn:uuid:b463f5c2-bed3-4f34-88c4-47a29ad27695"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulationDirectionInMode, ReformulatorDirectivePredicate)) .
\"urn:uuid:3a0f6375-997b-4a9e-9207-1591b5c1f60c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(reformulationDirectionInMode, Thing)) .
\"urn:uuid:3096c631-f2f9-4945-8659-7778cd48e4df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(reformulationDirectionInMode, Individual)) .
\"urn:uuid:59d79805-d0f1-4a11-bb01-eb3f9817ce84"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(reformulationDirectionInMode, CycLAtomicAssertion)) .
\"urn:uuid:7ee42fa6-5646-4dde-88f5-8f00be385feb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulationDirectionInMode, (3))) .
\"urn:uuid:c7e48bb2-2e8b-4925-b645-fcb122a70dde"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulationPrecondition, TernaryPredicate)) .
\"urn:uuid:d4c3126a-085a-4a36-91db-cc78badcfa8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulationPrecondition, ReformulatorDirectivePredicate)) .
\"urn:uuid:7efeb16b-2eb3-499f-9a9b-204dbde4e5e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(reformulationPrecondition, Thing)) .
\"urn:uuid:b9d1a5bc-bc07-4924-9368-4eca6e288a18"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(reformulationPrecondition, Thing)) .
\"urn:uuid:9e673301-d45a-4186-95e2-79d8b4012a3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(reformulationPrecondition, CycLAtomicAssertion)) .
\"urn:uuid:878c4b5b-6282-4d80-9cea-313be2515820"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulationPrecondition, (3))) .
\"urn:uuid:8f41a24a-4dc6-4a70-8684-c5858aef26c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquals, IrreflexiveBinaryPredicate)) .
\"urn:uuid:89779633-f7de-4167-afd3-034e5b03f9d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquals, ReformulatorDirectivePredicate)) .
\"urn:uuid:85ce8975-b4e4-425f-8817-6659fba2cc85"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquals, CycLReformulationRulePredicate)) .
\"urn:uuid:d138bc66-b646-4918-840f-f2424eccf5f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(reformulatorEquals, Thing)) .
\"urn:uuid:458bd72e-9480-48ec-b7cb-e0c488d8bf86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(reformulatorEquals, Thing)) .
\"urn:uuid:5bd30f6c-40af-472e-8be9-d80ae46afd12"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(reformulatorEquals, CycLDenotationalTerm)) .
\"urn:uuid:b14442b0-be54-455f-9390-ec96b421385a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(reformulatorEquals, CycLDenotationalTerm)) .
\"urn:uuid:fbad91b9-18c0-48f5-be6a-299e08d3de46"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(reformulatorEquals, reformulatorRule)) .
\"urn:uuid:939b680c-5202-4cab-a4bc-cf09fad60d76"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(genlPreds(reformulatorEquals, equals))) .
\"urn:uuid:776bbd23-d7df-48d7-bb71-42371301a043"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulatorEquals, (2))) .
\"urn:uuid:f5bd78c0-a690-47d1-984b-463de866b9bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquiv, IrreflexiveBinaryPredicate)) .
\"urn:uuid:80ce4e59-f1b8-4dc7-8853-cf3a41598c9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquiv, ReformulatorDirectivePredicate)) .
\"urn:uuid:52ed44a7-85e6-432a-afe0-7bfcbd9be9bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorEquiv, CycLReformulationRulePredicate)) .
\"urn:uuid:9ead76f1-6ca8-48a9-ac82-7b9d9ff5562b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(reformulatorEquiv, CycLSentence)) .
\"urn:uuid:9ce2d90d-060e-4ae8-a3c1-fa99d487c634"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(reformulatorEquiv, CycLSentence)) .
\"urn:uuid:7f065de7-5088-47d8-8668-298df40acb57"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(reformulatorEquiv, reformulatorRule)) .
\"urn:uuid:4e78fe5c-88c5-4ec0-bc2a-de83effb5eea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulatorEquiv, (2))) .
\"urn:uuid:615dd957-7918-4d75-ac7c-b1a32d717aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorRule, IrreflexiveBinaryPredicate)) .
\"urn:uuid:f79f7ed6-a005-46e5-8cb7-b8f07b761ab8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorRule, ReformulatorDirectivePredicate)) .
\"urn:uuid:1f5cf3cf-1723-4e11-b778-db0e35279611"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorRule, CycLReformulationRulePredicate)) .
\"urn:uuid:c8a7555a-c630-4f0e-85e2-269621703129"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(reformulatorRule, Thing)) .
\"urn:uuid:0cc44b8d-7325-4461-b646-54d75bc2b234"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(reformulatorRule, Thing)) .
\"urn:uuid:95abd65e-eaa9-4348-aa53-e503d6c20ef4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(reformulatorRule, CycLExpression)) .
\"urn:uuid:e36e5033-c85a-4509-9b6c-0b3a9945accf"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(reformulatorRule, CycLExpression)) .
\"urn:uuid:84b561f0-b3cc-4dac-bf02-c05021327fca"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulatorRule, (2))) .
\"urn:uuid:c2970708-2af0-4464-9507-1522680bde23"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorRuleProperties, BinaryPredicate)) .
\"urn:uuid:9699363c-90ca-454e-962d-4aa844e46150"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(reformulatorRuleProperties, ReformulatorDirectivePredicate)) .
\"urn:uuid:2683ae9d-bd74-49c6-94db-815adef44bb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(reformulatorRuleProperties, Collection)) .
\"urn:uuid:44dbb0f3-2979-4af5-aadd-3da28e352ebe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(reformulatorRuleProperties, CycLAtomicAssertion)) .
\"urn:uuid:21267f9c-b129-40b2-ad94-0631e9d6109e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(reformulatorRuleProperties, isa)) .
\"urn:uuid:6ed42033-d090-41ed-925e-4a2bd8441067"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(reformulatorRuleProperties, (2))) .
\"urn:uuid:059df857-45ed-404c-943b-c254f4c2f093"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAll, BinaryPredicate)) .
\"urn:uuid:3de55a72-79b7-4b87-be6a-8b175c157763"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationAll, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:771e5ed3-9f70-44ce-8f0e-cbbff886c34a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAll, UnaryPredicate)) .
\"urn:uuid:7dee858e-f3d4-4340-a964-6ac36d88ee65"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAll, Collection)) .
\"urn:uuid:15687ab8-e0c6-494c-ab2e-5d2e8c9cac08"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAll, Thing)) .
\"urn:uuid:b51be4e3-cc70-4777-9880-f1d1426942e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAll, (2))) .
\"urn:uuid:0e7c7524-8b6b-4159-9f80-bbc5c00af3a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAllExists, TernaryPredicate)) .
\"urn:uuid:f948d0f1-a4f6-4720-b41e-6aea46bb9316"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationAllExists, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:66947743-0c8b-4af7-95d3-d832977dbf06"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAllExists, BinaryPredicate)) .
\"urn:uuid:d050f3f2-db8b-45a8-90ad-18724d7fa7a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAllExists, Collection)) .
\"urn:uuid:d52b509b-b480-4a3e-aa3b-51ab65dc7bc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAllExists, Thing)) .
\"urn:uuid:c79f5076-eedf-4fc7-9b22-96e831592f60"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationAllExists, Collection)) .
\"urn:uuid:6f3b241b-a7a3-426e-934e-3c5c5768ee80"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationAllExists, Thing)) .
\"urn:uuid:4c6702be-2c7d-4c6e-bd60-6f9061d91dbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAllExists, (3))) .
\"urn:uuid:da52265b-17df-4161-af90-ff287bcbcf9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAllExistsCount, QuaternaryPredicate)) .
\"urn:uuid:998b9d02-6582-48a1-a8e9-ca15dd6bea19"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAllExistsCount, BinaryPredicate)) .
\"urn:uuid:81c8a687-ce64-40ed-9b3b-dc2d75faf6eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAllExistsCount, Collection)) .
\"urn:uuid:4733fe05-0645-4d53-86de-800104f9537e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAllExistsCount, Thing)) .
\"urn:uuid:75e7d2fa-5e40-4b3c-90d0-f225c33b1b23"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationAllExistsCount, Collection)) .
\"urn:uuid:5c7f1353-ab43-443f-bb59-ac3e0cc070e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationAllExistsCount, Thing)) .
\"urn:uuid:338e494c-a3e0-46c7-8eb0-0c3babefe4af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationAllExistsCount, NonNegativeInteger)) .
\"urn:uuid:b4ea7559-4881-4845-9f33-ed9f03074a5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(relationAllExistsCount, relationAllExistsMax)) .
\"urn:uuid:0ac9c070-c019-499d-8057-d95dd85b5dfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(relationAllExistsCount, relationAllExistsMin)) .
\"urn:uuid:d23f5234-a6b1-4304-8733-91facc6e0a80"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAllExistsCount, (4))) .
\"urn:uuid:ecccb8b6-7e0c-43b0-8999-5a5f02d21c6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAllExistsMax, QuaternaryPredicate)) .
\"urn:uuid:abab5fb1-4698-4662-b910-ecb0d8a9ab3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAllExistsMax, BinaryPredicate)) .
\"urn:uuid:e526d25a-97e2-4485-bd7f-f6e6cdac0dfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAllExistsMax, Collection)) .
\"urn:uuid:e6c1b365-cf56-4fde-b171-21c2f930ed0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAllExistsMax, Thing)) .
\"urn:uuid:604434c3-ff02-44ae-96e7-98a7296318b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationAllExistsMax, Collection)) .
\"urn:uuid:5f6ccb2f-f71a-4b4d-9d3d-343b18455a90"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationAllExistsMax, Thing)) .
\"urn:uuid:cb7881dc-8acb-407c-9896-99e8d3e7323d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationAllExistsMax, NonNegativeInteger)) .
\"urn:uuid:252cc8a2-1fc1-47a6-8db6-1736d89eda21"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAllExistsMax, (4))) .
\"urn:uuid:559bbc1f-9d04-49a6-8ced-dfb79675454f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAllExistsMin, QuaternaryPredicate)) .
\"urn:uuid:10f998e6-85a9-40bc-8421-51a09df7bd85"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAllExistsMin, BinaryPredicate)) .
\"urn:uuid:4903cb9e-90cf-4aeb-b685-845365ed8de7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAllExistsMin, Collection)) .
\"urn:uuid:44a8e6a6-a5e1-4b36-bcc9-ffda83863980"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAllExistsMin, Thing)) .
\"urn:uuid:f67d9bd3-2719-45a5-8c6b-d60fa46e5494"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationAllExistsMin, Collection)) .
\"urn:uuid:5fdbbc48-b2f1-4ad8-a0ab-79814b6472ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationAllExistsMin, Thing)) .
\"urn:uuid:c15eb640-3e76-4960-b550-7ff0c8e11a4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationAllExistsMin, NonNegativeInteger)) .
\"urn:uuid:0c995b08-8bf5-4bef-bd85-e59c6f5fd4ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAllExistsMin, (4))) .
\"urn:uuid:03eb8e46-aeab-4808-a4df-38e1d3864f6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationAllInstance, TernaryPredicate)) .
\"urn:uuid:52f05bae-f65e-4471-937a-b8224467685e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationAllInstance, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:2840a501-113d-47bf-b540-7db7fa7aec6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationAllInstance, BinaryPredicate)) .
\"urn:uuid:8ada0c0a-8646-4718-8673-7abb74f1ed2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationAllInstance, Collection)) .
\"urn:uuid:2b397164-3567-4382-b962-44d6370a9863"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationAllInstance, Thing)) .
\"urn:uuid:52a4a8e4-8f56-4a3b-8486-294040f1b83a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationAllInstance, Thing)) .
\"urn:uuid:1cab5d55-79a8-4a14-bcec-fa360ac6913d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationAllInstance, (3))) .
\"urn:uuid:d63adefa-4ab8-440a-92ff-53721ae7b823"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExistsAll, TernaryPredicate)) .
\"urn:uuid:d9c7801e-b7c1-487b-9a77-4ddae5d70d79"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationExistsAll, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:78865795-35f3-47b2-9c23-6ad64f6b459d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExistsAll, BinaryPredicate)) .
\"urn:uuid:cf513a82-9603-4a02-a21c-eace1c645f79"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationExistsAll, Collection)) .
\"urn:uuid:7b26d67e-402b-4866-9ba0-945443bcfaea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationExistsAll, Thing)) .
\"urn:uuid:af741394-3bf5-4d76-ae49-2b6aad05756d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationExistsAll, Collection)) .
\"urn:uuid:34ba4dc4-5848-4c9e-b7ef-91bf6cf7ded0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationExistsAll, Thing)) .
\"urn:uuid:4278abcb-b932-48bd-b225-0ea1e7678358"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExistsAll, (3))) .
\"urn:uuid:afc0c2c0-3f9f-42fe-95e9-6b150b55413c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExistsCountAll, QuaternaryPredicate)) .
\"urn:uuid:c69f3773-f522-4970-a413-47b97abe871f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExistsCountAll, BinaryPredicate)) .
\"urn:uuid:c9b351c5-1129-4341-867f-b05cf346646c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationExistsCountAll, Collection)) .
\"urn:uuid:71a5acc6-a34e-4b95-9553-a4c83d183160"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationExistsCountAll, Thing)) .
\"urn:uuid:56c9328b-ffdb-4e27-b003-07c02cf03ead"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationExistsCountAll, Collection)) .
\"urn:uuid:5d6c0c29-8ab4-4f85-ba97-107233435fe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationExistsCountAll, Thing)) .
\"urn:uuid:0b96a26d-1f47-46d5-abd4-41cea11a7c20"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationExistsCountAll, NonNegativeInteger)) .
\"urn:uuid:5a9c0568-8971-47e5-b3d2-880da1a66f8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExistsCountAll, (4))) .
\"urn:uuid:3ea91a96-7c5f-4473-955d-d3cbd1278efd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExistsInstance, TernaryPredicate)) .
\"urn:uuid:dddd23fd-0855-42d8-a81c-71386fa87b77"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationExistsInstance, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:df9f6415-4ff4-4e85-9bb8-96127d373f87"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExistsInstance, BinaryPredicate)) .
\"urn:uuid:5830630a-446e-41a4-84ca-3e53dfa5bb9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationExistsInstance, Collection)) .
\"urn:uuid:87d14f05-4c34-44e7-a6e5-cf03f1f2d8b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationExistsInstance, Thing)) .
\"urn:uuid:2913aba6-d9df-40a7-8a5f-5bf698e64941"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationExistsInstance, Thing)) .
\"urn:uuid:71ea0ed9-8b74-4bc1-be3b-84a83ec03ed8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExistsInstance, (3))) .
\"urn:uuid:863e7897-f7dd-4681-b67d-676ef0fd7d83"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExistsMaxAll, QuaternaryPredicate)) .
\"urn:uuid:b739c48d-edfb-4f78-92b6-8afc0c7e40ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExistsMaxAll, BinaryPredicate)) .
\"urn:uuid:fa4f3dbc-4049-4686-b181-6021af871719"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationExistsMaxAll, Collection)) .
\"urn:uuid:7ea45a67-019f-4a48-96c4-30ccd35e8140"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationExistsMaxAll, Thing)) .
\"urn:uuid:2c1f494a-c029-4d54-8e13-752b9c1c1fc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationExistsMaxAll, Collection)) .
\"urn:uuid:d1f90bfe-229e-46b6-86e7-1412ff212dd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationExistsMaxAll, Thing)) .
\"urn:uuid:67128826-c0db-4fd8-b672-e8bed5e5836d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationExistsMaxAll, NonNegativeInteger)) .
\"urn:uuid:041c10cd-d937-422c-aab9-f1119bdc40cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExistsMaxAll, (4))) .
\"urn:uuid:9748e268-b9a0-4073-b452-730dad369225"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExistsMinAll, QuaternaryPredicate)) .
\"urn:uuid:b398e2bf-bd07-47b0-8ceb-470d7fb2ca1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExistsMinAll, BinaryPredicate)) .
\"urn:uuid:1cb43606-7a3a-481c-b682-7e4aaa0f9c88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationExistsMinAll, Collection)) .
\"urn:uuid:f927b3cf-16ea-43e3-abbe-7525c72eac07"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(relationExistsMinAll, Thing)) .
\"urn:uuid:c8cd8fbc-b8b6-420d-b840-f13c13575be9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationExistsMinAll, Collection)) .
\"urn:uuid:3f467d18-8907-49da-80f0-b40cc8df790c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationExistsMinAll, Thing)) .
\"urn:uuid:662b73c6-f91e-4b1a-9289-c5d4cbe198ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Isa(relationExistsMinAll, NonNegativeInteger)) .
\"urn:uuid:52ae6509-c56c-4c63-8a86-ec1118a20c33"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExistsMinAll, (4))) .
\"urn:uuid:506b1b07-7982-4be8-8c45-e2eb683b7cd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationExpansion, BinaryPredicate)) .
\"urn:uuid:0edc857e-7d59-4a79-bb74-ee250370d056"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationExpansion, Predicate)) .
\"urn:uuid:3bc65ae9-c6ed-4555-8670-c1c060c039e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(relationExpansion, 'CycLSentence-Assertible')) .
\"urn:uuid:0331e5a3-efa5-4559-96af-316d7929f081"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationExpansion, (2))) .
\"urn:uuid:7f046e59-0ae3-4f28-b2bb-b1a47303e921"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationInstanceAll, TernaryPredicate)) .
\"urn:uuid:9d1f61f7-06fd-45c3-81bc-c5f668858b44"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationInstanceAll, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:8f5dcb7b-417d-4469-a8da-5100ed48ae62"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationInstanceAll, BinaryPredicate)) .
\"urn:uuid:742c706e-4e19-4f35-822e-eba78bf3d10a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationInstanceAll, Thing)) .
\"urn:uuid:1a3ef795-fd35-4455-bba6-7bcfc198a5e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationInstanceAll, Collection)) .
\"urn:uuid:e300b407-f78f-46f0-bd78-25fc007f1c17"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationInstanceAll, Thing)) .
\"urn:uuid:d1e7e993-d0d7-402b-b839-e68385fc48c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationInstanceAll, (3))) .
\"urn:uuid:ba6b5b93-39a6-4066-9372-4a73462b2840"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationInstanceExists, TernaryPredicate)) .
\"urn:uuid:fd7940b1-d044-4b00-8831-a7961880d1fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(relationInstanceExists, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:6270edc6-f12c-43b6-85c8-385eac33ad68"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationInstanceExists, BinaryPredicate)) .
\"urn:uuid:026a1320-5981-42f6-b3c5-ee57ed4029fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationInstanceExists, Thing)) .
\"urn:uuid:836a7f38-5387-4b83-904b-323941d33eda"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationInstanceExists, Collection)) .
\"urn:uuid:4d24e9f5-e351-4257-af41-0ef5e728a7cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Genl(relationInstanceExists, Thing)) .
\"urn:uuid:3bf3d049-5d80-4c04-a8cd-92a43da00609"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationInstanceExists, (3))) .
\"urn:uuid:e6f76cfc-b673-4915-964f-2f2543af878b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationInstanceMember, TernaryPredicate)) .
\"urn:uuid:033e1565-2f23-4cb9-a859-51a4241f9eed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationInstanceMember, BinaryPredicate)) .
\"urn:uuid:afb6e480-df02-4cdf-9f2d-ab7193840373"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationInstanceMember, Thing)) .
\"urn:uuid:1b0c848c-e0b3-498c-8a38-21709bdabb03"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationInstanceMember, Individual)) .
\"urn:uuid:a6aa91a7-f975-4f5e-bb95-bc9300b211a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationInstanceMember, (3))) .
\"urn:uuid:f0ef2f34-ec73-47aa-b38f-175bd486feed"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(relationMemberInstance, TernaryPredicate)) .
\"urn:uuid:32305f0c-342e-434d-82cc-8c0799e62387"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(relationMemberInstance, BinaryPredicate)) .
\"urn:uuid:3113f656-a07f-406a-b5f1-2ad7512409ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(relationMemberInstance, Individual)) .
\"urn:uuid:17d024a6-5fa0-49a4-b824-b6a4a1f03fb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(relationMemberInstance, Thing)) .
\"urn:uuid:88acb5ff-7bfb-4107-8378-55926fe2bf11"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(relationMemberInstance, (3))) .
\"urn:uuid:f95428ef-8f34-42e4-bd33-a4e737ed17cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(requiredArg1Pred, BinaryPredicate)) .
\"urn:uuid:d7c5f884-a530-4399-9ca4-6ed2e80be769"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(requiredArg1Pred, Collection)) .
\"urn:uuid:9b017fc8-8ef3-4f4d-af66-147c6e54a9d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(requiredArg1Pred, Thing)) .
\"urn:uuid:4edf441e-8e1a-4f3a-85bc-8497ff344ed3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(requiredArg1Pred, Predicate)) .
\"urn:uuid:add8f60c-b945-41e1-aad5-5096eccbf82e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(requiredArg1Pred, (2))) .
\"urn:uuid:12eb12ea-a6f7-4c89-b3b5-14315547f422"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(requiredArg2Pred, BinaryPredicate)) .
\"urn:uuid:52843c94-874c-4efe-aea4-b6254cdf9907"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(requiredArg2Pred, Collection)) .
\"urn:uuid:3d659509-e173-4042-8063-561c0e5b9b83"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(requiredArg2Pred, Thing)) .
\"urn:uuid:c682fc60-d72c-43e7-bc89-3ecc7587eb51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(requiredArg2Pred, Predicate)) .
\"urn:uuid:b2827db0-5dba-485e-b8fe-f80bfb169208"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(requiredArg2Pred, (2))) .
\"urn:uuid:def9d246-ff15-4666-9762-5eaf18cfa0dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(requiredArg3Pred, BinaryPredicate)) .
\"urn:uuid:aede2913-9b04-4fe4-9e4c-29b557f5dba1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(requiredArg3Pred, Collection)) .
\"urn:uuid:2294d2ff-d0de-4bdb-a1b4-10ba92d251da"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(requiredArg3Pred, Thing)) .
\"urn:uuid:7f3a3844-669c-48b3-b8bf-cc163cfc44ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(requiredArg3Pred, Predicate)) .
\"urn:uuid:24dfe113-d72a-4e43-abae-83d9d6be5f31"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(requiredArg3Pred, (2))) .
\"urn:uuid:9e312ae1-830c-41c1-9a3d-3074b6ad3747"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultGenl, BinaryPredicate)) .
\"urn:uuid:1d2c0e5e-04e7-4299-80b0-a2a82a0e5706"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultGenl, DefaultMonotonicPredicate)) .
\"urn:uuid:770111ab-6dde-4405-8a4f-0e634a1fbf91"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultGenl, WFFConstraintPredicate)) .
\"urn:uuid:f572b61e-a734-4fa5-ba95-336092e88f05"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultGenl, CollectionDenotingFunction)) .
\"urn:uuid:5cf58fc6-98c6-44ef-b0c9-837c320f365a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultGenl, Relation)) .
\"urn:uuid:f4b8a097-d4d2-409e-b0aa-8c17523d791e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultGenl, Collection)) .
\"urn:uuid:2d7f8bb6-45b7-4521-8db1-4ac4f50542db"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(resultGenl, Thing)) .
\"urn:uuid:0b71be5b-ffdf-4895-8c9f-6644af7cb39f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultGenl, (2))) .
\"urn:uuid:5e4862fb-9934-4189-8c97-a6a25336c379"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultGenlArg, BinaryPredicate)) .
\"urn:uuid:fb5a7b96-f63b-4538-90a0-0ee250a03f33"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultGenlArg, DefaultMonotonicPredicate)) .
\"urn:uuid:1314d726-7926-41e7-92aa-32eaf99c3e37"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultGenlArg, CollectionDenotingFunction)) .
\"urn:uuid:82f97109-65fc-48b7-b46d-5ad421884ff7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultGenlArg, PositiveInteger)) .
\"urn:uuid:f442b820-16d4-446a-9846-f8d006adb0bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultGenlArg, (2))) .
\"urn:uuid:1cf37515-c627-4fe9-afbc-7f1702ee42c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsa, BinaryPredicate)) .
\"urn:uuid:9544798b-48d3-4a7a-923c-6ac08cd77f3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:76ed1d0b-98a7-4f47-a080-1f184dd3b63f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsa, WFFConstraintPredicate)) .
\"urn:uuid:5b84fc50-3433-4e9f-a19f-4c859b954686"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultIsa, Relation)) .
\"urn:uuid:c7ca839d-fe47-4cd5-9bec-f7245f7fa630"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultIsa, 'Function-Denotational')) .
\"urn:uuid:9df5e6cb-481c-4ddf-918d-030ec48dc238"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultIsa, Collection)) .
\"urn:uuid:9177ef9f-7a9d-4503-add9-87d4b550bfc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(resultIsa, Thing)) .
\"urn:uuid:b47de838-920b-42f7-9334-a6b57b734576"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultIsa, (2))) .
\"urn:uuid:92fe837a-baad-492e-a1c2-53178b2c9ed3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsaArg, BinaryPredicate)) .
\"urn:uuid:ca6dd275-5e48-46c0-8a86-fdfb520c8b66"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsaArg, DefaultMonotonicPredicate)) .
\"urn:uuid:46f3f06a-a3b1-4aa6-a40b-481301418e12"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultIsaArg, 'Function-Denotational')) .
\"urn:uuid:b72c9b88-da30-483a-adfb-7a4ecfd78c0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultIsaArg, PositiveInteger)) .
\"urn:uuid:bc2728d4-5f3a-44db-9d14-dea7afb86f40"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultIsaArg, (2))) .
\"urn:uuid:50131753-7827-48d6-914e-5fb68fb6ec1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsaArgIsa, BinaryPredicate)) .
\"urn:uuid:dea84266-a57d-4be0-8c2d-7c0f273a0f76"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsaArgIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:6e8b52ec-fa49-4960-b7e2-3dd90654c701"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultIsaArgIsa, WFFSupportedPredicate)) .
\"urn:uuid:feb508ca-2550-4676-a7b8-088946571acd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultIsaArgIsa, 'Function-Denotational')) .
\"urn:uuid:5c0f4927-3c92-475c-9e6b-e5939cf95c9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultIsaArgIsa, PositiveInteger)) .
\"urn:uuid:19ad0bb0-a090-473a-a2c6-9b8fcc1a6809"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultIsaArgIsa, (2))) .
\"urn:uuid:a2e734df-11cc-46e8-bacf-ced4005327cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultQuotedIsa, BinaryPredicate)) .
\"urn:uuid:c4b3ae13-a0c3-4541-8e52-10a87aabbfe2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(resultQuotedIsa, DefaultMonotonicPredicate)) .
\"urn:uuid:6612852b-9883-4fcb-a755-c19eb0b1d64e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(resultQuotedIsa, 'Function-Denotational')) .
\"urn:uuid:f3e19bd4-d503-48e5-92bf-5cd92c23bf00"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(resultQuotedIsa, SubLExpressionType)) .
\"urn:uuid:8c1a440c-709b-4899-8ef1-7b57456fcc09"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(resultQuotedIsa, SubLSExpression)) .
\"urn:uuid:9042b160-b234-4dd0-ba52-49269e4914eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(resultQuotedIsa, (2))) .
\"urn:uuid:7b956364-b6b8-489c-b224-eaa3eb75b6a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(rewriteOf, TransitiveBinaryPredicate)) .
\"urn:uuid:c2fcf824-e8b9-4902-bc8a-5dcec07e1ea6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(rewriteOf, ReformulatorDirectivePredicate)) .
\"urn:uuid:9804106e-2baa-4fb8-bd1b-9235a1f4ce07"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(rewriteOf, DefaultMonotonicPredicate)) .
\"urn:uuid:99a92514-339e-4fb8-bf38-dded6c93bee7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(rewriteOf, CycLReformulationRulePredicate)) .
\"urn:uuid:8eda25ad-47bc-45a7-aba1-4aedcd6ef7e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(rewriteOf, Thing)) .
\"urn:uuid:e08ef188-a0cd-4bcc-80a9-c876d99a778d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(rewriteOf, Thing)) .
\"urn:uuid:4296aa79-fd75-4cf3-80ff-ddfc3d68d936"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(rewriteOf, CycLReifiableDenotationalTerm)) .
\"urn:uuid:ee0e45ea-f2eb-43ef-94ff-aca0c2369e49"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(rewriteOf, CycLClosedDenotationalTerm)) .
\"urn:uuid:536e99d8-3c1d-4f67-9fe1-9af5dd3e3f36"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(rewriteOf, equals)) .
\"urn:uuid:6b970c94-9079-4efd-9ced-b4c980ce28c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(rewriteOf, (2))) .
\"urn:uuid:861ce777-c58b-45a2-bf62-0c5ac03e470e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ruleAfterAdding, BinaryPredicate)) .
\"urn:uuid:9acd967c-c5c2-4449-8b87-22cb22f3146c"[silk#strict] .
istAsserted(BaseKB, isa(ruleAfterAdding, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:4d65d5fa-bfab-467c-84f2-b94a2e6b9561"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ruleAfterAdding, Predicate)) .
\"urn:uuid:8fe36236-80b9-498b-8424-5de2b034f9ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ruleAfterAdding, Predicate)) .
\"urn:uuid:c55a06f5-1d2b-4432-acb5-e8e9cb33c94c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(ruleAfterAdding, CycLNonAtomicTerm)) .
\"urn:uuid:044cff25-b19a-43ce-bc31-6b062b58054c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ruleAfterAdding, (2))) .
\"urn:uuid:9edc64f0-2764-4712-832c-1bf8e82d92ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ruleAfterRemoving, BinaryPredicate)) .
\"urn:uuid:d5791413-ea61-4e11-9e21-b9a07bab8a32"[silk#strict] .
istAsserted(BaseKB, isa(ruleAfterRemoving, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:dfb9d33b-d066-4769-a161-f2ded443f524"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(ruleAfterRemoving, Predicate)) .
\"urn:uuid:18cfccda-4bd2-4814-a1c5-c033b9b7a00c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ruleAfterRemoving, Predicate)) .
\"urn:uuid:48fbc70a-215f-4d1a-9a38-c9e5113f5bd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(ruleAfterRemoving, CycLNonAtomicTerm)) .
\"urn:uuid:05bd9e95-9a5e-4c8c-b583-f0063f2fb8ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ruleAfterRemoving, (2))) .
\"urn:uuid:146f7060-649f-43af-a608-7f0d375cd61e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ruleTemplateDirection, BinaryPredicate)) .
\"urn:uuid:081bff99-3d98-4aa4-9621-2d0e62410058"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(ruleTemplateDirection, DefaultMonotonicPredicate)) .
\"urn:uuid:3cc7ae24-d469-46d0-94e1-3e69472ce0b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(ruleTemplateDirection, RuleTemplate)) .
\"urn:uuid:13a43d07-4ba8-41d2-af98-f57b327f233a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(ruleTemplateDirection, CycLAssertionDirection)) .
\"urn:uuid:a869c800-ec4f-4787-8db5-9b2443b95793"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(ruleTemplateDirection, (2))) .
\"urn:uuid:1b1dbd7c-7dd5-4779-a1ab-b7b244b01bc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(salientAssertions, BinaryPredicate)) .
\"urn:uuid:7dff4524-8849-4dc7-b563-3233d4cb4632"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(salientAssertions, DistributingMetaKnowledgePredicate)) .
\"urn:uuid:d7823030-a41e-4811-9d27-4d7b807bc801"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(salientAssertions, DocumentationPredicate)) .
\"urn:uuid:e1d2ea75-5768-4427-b3c0-97e703091d18"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(salientAssertions, Thing)) .
\"urn:uuid:7b5effd1-3d44-4f22-83aa-46fa0ed44597"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(salientAssertions, CycLReifiableDenotationalTerm)) .
\"urn:uuid:c35a8c82-fdb6-4291-a7f6-9344fe8a470c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(salientAssertions, CycLAssertion)) .
\"urn:uuid:aa0ddf16-2efb-4fea-bea5-10b73c8d5a52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(salientAssertions, (2))) .
\"urn:uuid:b907cc97-ed65-466f-acc5-eaafd3bae39e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(scopingArg, BinaryPredicate)) .
\"urn:uuid:bc21aabf-419e-4163-8252-3089200d0953"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(scopingArg, ScopingRelation)) .
\"urn:uuid:cc7866d5-66ac-4074-9900-f9c5b470e6b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(scopingArg, NonNegativeInteger)) .
\"urn:uuid:365e7c8b-31fa-4867-90a2-311828003b09"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(scopingArg, (2))) .
\"urn:uuid:0715d113-8f82-492d-b08f-c3580aebe7d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceDesignationArgnum, BinaryPredicate)) .
\"urn:uuid:1e121fa4-aa88-4600-9382-1050f3dfc7e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(sentenceDesignationArgnum, MicrotheoryDesignatingRelation)) .
\"urn:uuid:db256a56-86a8-4418-a18e-5952b05e5902"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(sentenceDesignationArgnum, PositiveInteger)) .
\"urn:uuid:1d485044-7b3d-4a30-9705-62370c273f06"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(sentenceDesignationArgnum, (2))) .
\"urn:uuid:11eaf4a9-cbbe-4392-a578-a6d5a69e9f9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceEquiv, SymmetricBinaryPredicate)) .
\"urn:uuid:d11f6e40-196b-473b-8095-134fa79d9578"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceEquiv, TransitiveBinaryPredicate)) .
\"urn:uuid:1a0448c4-ec0d-40b3-9443-16caa5a06c18"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceEquiv, ReflexiveBinaryPredicate)) .
\"urn:uuid:91b20521-38fa-402e-8796-8f2ddde547e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceEquiv, AssociativeRelation)) .
\"urn:uuid:07680954-aaa0-4231-b814-ed1c5a478990"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(sentenceEquiv, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:2f24174a-4a66-4c7b-aabb-5530b299d781"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(sentenceEquiv, 'CycLSentence-Assertible')) .
\"urn:uuid:26933efe-2dde-4a36-a9f6-06f03c8a63aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(sentenceEquiv, 'CycLSentence-Assertible')) .
\"urn:uuid:d70bd60d-396e-44b6-97b5-fbe344b813aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(sentenceEquiv, sentenceImplies)) .
\"urn:uuid:89e5c3fa-d1ab-48d4-912e-7d5cc538dc1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(sentenceEquiv, sentenceImplies)) .
\"urn:uuid:c5d6059b-67ca-48cf-97b5-32e0a506b868"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(sentenceEquiv, sentenceEquiv)) .
\"urn:uuid:6f0dddbc-900a-45ce-b02c-7e4099c38811"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(sentenceEquiv, (2))) .
\"urn:uuid:664a68c2-1709-4bf1-b462-675990560016"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceImplies, ReflexiveBinaryPredicate)) .
\"urn:uuid:ad2e58cf-53b9-4065-8fad-c73162010e03"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceImplies, TransitiveBinaryPredicate)) .
\"urn:uuid:6d2e984f-5065-409b-8397-ac029a2a1326"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(sentenceImplies, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:5bfabaa6-9c73-40b0-84a3-6a49a8b3555f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(sentenceImplies, 'CycLSentence-Assertible')) .
\"urn:uuid:0d980aad-2673-40fa-badd-1e1a765315e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(sentenceImplies, 'CycLSentence-Assertible')) .
\"urn:uuid:503c4338-6209-4b40-b30a-aaebae578b64"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(sentenceImplies, (2))) .
\"urn:uuid:9be9b47e-df58-4981-959d-3e866796c999"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sentenceTruth, BinaryPredicate)) .
\"urn:uuid:991e4b75-5b26-4309-8e6d-c026d7c40b61"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(sentenceTruth, TruthValue)) .
\"urn:uuid:83351b0e-80af-43ef-9dac-91fc0c37d03e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(sentenceTruth, (2))) .
\"urn:uuid:e63eaa8c-147e-4e55-9f29-d4b7ca2ae560"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sharedNotes, BinaryPredicate)) .
\"urn:uuid:2a9a50b6-1720-41be-a391-0927451d90a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sharedNotes, DistributingMetaKnowledgePredicate)) .
\"urn:uuid:c92013d6-5487-4795-8c47-212f1d627d4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(sharedNotes, DocumentationPredicate)) .
\"urn:uuid:b44cda42-72ce-4277-95cd-ae54252bafd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(sharedNotes, Thing)) .
\"urn:uuid:749b0df9-c56e-477e-9f83-d02a088c234e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(sharedNotes, Individual)) .
\"urn:uuid:1b036c07-6306-4b39-9015-d0b60bc90d5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(sharedNotes, CycLIndexedTerm)) .
\"urn:uuid:ad2f436f-17a5-42c0-aafa-ea335483547d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(sharedNotes, DocumentationConstant)) .
\"urn:uuid:0c3e058f-7668-4556-bffb-918397a1b34d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(sharedNotes, (2))) .
\"urn:uuid:64af5c9a-1113-4509-879a-73d14cbe0f58"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(siblingDisjointExceptions, IrreflexiveBinaryPredicate)) .
\"urn:uuid:a9fbf4d6-70f0-422b-8f13-0f529ded1827"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(siblingDisjointExceptions, SymmetricBinaryPredicate)) .
\"urn:uuid:b4826343-1ef5-4283-a15e-c5275905d4bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(siblingDisjointExceptions, TransitiveBinaryPredicate))) .
\"urn:uuid:f416a73f-166e-41f4-acd8-2404063305e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(siblingDisjointExceptions, Predicate)) .
\"urn:uuid:e8e0fff3-a504-4886-b002-318d06875088"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(siblingDisjointExceptions, SetOrCollection)) .
\"urn:uuid:8aa8eb31-4d37-4389-920d-9774da9db1cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Genl(siblingDisjointExceptions, Thing)) .
\"urn:uuid:f6f46405-1d70-497a-99c2-d217fc89bd2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(siblingDisjointExceptions, SetOrCollection)) .
\"urn:uuid:87b7ff98-7c39-402e-849c-3c7b5984038e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Genl(siblingDisjointExceptions, Thing)) .
\"urn:uuid:f27c27d7-a39e-4e58-9bc0-2cb196a86a48"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(siblingDisjointExceptions, different)) .
\"urn:uuid:c113995c-79e8-4b6c-a7d8-b5042b786786"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlInverse(siblingDisjointExceptions, siblingDisjointExceptions)) .
\"urn:uuid:47ef1798-a7ec-4c31-8acd-847fd5e172cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(siblingDisjointExceptions, (2))) .
\"urn:uuid:b5b9c8c8-50a2-430c-9ae4-31f00a022b44"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(singleEntryFormatInArgs, BinaryPredicate)) .
\"urn:uuid:456b5351-8fde-493c-bf9b-e7cd76893d5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(singleEntryFormatInArgs, ArgConstraintPredicate)) .
\"urn:uuid:244ee964-447e-4c35-ab32-fc841d4cc9e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(singleEntryFormatInArgs, WFFSupportedPredicate)) .
\"urn:uuid:cdf316c8-f8d1-467c-8c0b-a0d586d1e6a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(singleEntryFormatInArgs, Predicate)) .
\"urn:uuid:b8db6a75-6c58-4d6d-84c9-14d65f60afcb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(singleEntryFormatInArgs, PositiveInteger)) .
\"urn:uuid:87c525ef-6c39-4357-bba8-56122da44a24"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(singleEntryFormatInArgs, (2))) .
\"urn:uuid:65bebbe5-400b-4549-bb37-e9562f37752b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(skolem, UnaryPredicate)) .
\"urn:uuid:0773c307-5814-472d-ac3b-1b79d20f917a"[silk#strict] .
istAsserted(BaseKB, isa(skolem, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:d5a15bb9-a502-408c-900b-03933fb0ce32"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(skolem, SkolemFunction)) .
\"urn:uuid:2f85d588-d67b-49a6-8745-b7a1502aff02"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(skolem, (1))) .
\"urn:uuid:a7e64c8f-52b5-4881-952b-b1cb1a33cbf8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(skolemizeForward, UnaryPredicate)) .
\"urn:uuid:3495d989-578e-41dc-9270-ac81f122a580"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(skolemizeForward, InferenceSupportedPredicate)) .
\"urn:uuid:d7ed0b54-08d7-42b4-ba5a-bb6b2e627e58"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(skolemizeForward, ReifiableFunction)) .
\"urn:uuid:63002039-3aea-4764-b514-3b319df65be7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(skolemizeForward, (1))) .
\"urn:uuid:6a19b75d-3b23-4088-916e-434f42459b48"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(stringPrecedes, EvaluatablePredicate)) .
\"urn:uuid:51bd92ed-a9cf-46f0-a19b-a84e1dfc9993"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(stringPrecedes, TransitiveBinaryPredicate)) .
\"urn:uuid:960cc80d-5a7d-4041-889a-66597c9442f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(stringPrecedes, IrreflexiveBinaryPredicate)) .
\"urn:uuid:bcf7dac2-7d24-4817-ab57-9dd31cd566d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(stringPrecedes, CharacterString)) .
\"urn:uuid:59791be3-4558-402a-b726-febab039bd94"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(stringPrecedes, CharacterString)) .
\"urn:uuid:5372952d-e87b-41f8-9215-0ee277c61327"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(genlPreds(stringPrecedes, 'stringPrecedes-CaseInsensitive'))) .
\"urn:uuid:0e175627-e3bd-488b-812e-4944d0c0c21c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(stringPrecedes, (2))) .
\"urn:uuid:13c8fffc-f91c-4aca-9656-b6807967810c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('stringPrecedes-CaseInsensitive', IrreflexiveBinaryPredicate)) .
\"urn:uuid:df4923ef-e23d-485f-ad11-acf2abf85f07"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('stringPrecedes-CaseInsensitive', TransitiveBinaryPredicate)) .
\"urn:uuid:bce37acf-a899-4983-90f0-dc35c67af8fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('stringPrecedes-CaseInsensitive', EvaluatablePredicate)) .
\"urn:uuid:6f70c999-b2f3-40f2-acf5-57c340e7c4b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('stringPrecedes-CaseInsensitive', CharacterString)) .
\"urn:uuid:a1e1e543-801a-4b01-b4b9-9fb390f55e52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('stringPrecedes-CaseInsensitive', CharacterString)) .
\"urn:uuid:4893cd82-4529-448f-ac9d-050a15c53d95"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('stringPrecedes-CaseInsensitive', (2))) .
\"urn:uuid:f4b315d9-4a8e-4a16-894d-c6dbc6599aa1"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(strongestAssertedSentence, UnaryPredicate)) .
\"urn:uuid:3b4d7f23-7b4a-4005-8c2c-17a54142ced4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(strongestAssertedSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:91f8052d-246d-4e9c-8380-d5baf1d16444"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(strongestAssertedSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:d4bb685b-8d76-4e8b-8a86-07fcbde5ddbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(strongestAssertedSentence, assertedSentence)) .
\"urn:uuid:2c949c34-cc7b-4bca-b907-d380e9e4b4c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(strongestAssertedSentence, (1))) .
\"urn:uuid:3ae49471-4eae-4f7d-87da-9a7b4b178116"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(subsetOf, TransitiveBinaryPredicate)) .
\"urn:uuid:d5cc61f9-dece-4351-9fb7-c42e4a3442a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(subsetOf, ReflexiveBinaryPredicate)) .
\"urn:uuid:7ff80cae-2024-4cc7-bc33-42acef459ed8"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(subsetOf, SymmetricBinaryPredicate))) .
\"urn:uuid:e234bc45-1255-4c57-aab2-624630dbd399"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(isa(subsetOf, AntiSymmetricBinaryPredicate))) .
\"urn:uuid:f8be423d-eb97-4b9b-b45d-7b70d7826f2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(subsetOf, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:6320430d-ee00-45b7-80cb-1e4035097849"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(subsetOf, SetOrCollection)) .
\"urn:uuid:0e1a4e0d-fa35-43bd-ac5d-9808974183cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(subsetOf, SetOrCollection)) .
\"urn:uuid:fa81d755-16e9-4b57-8c94-9b2ee6a78287"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(subsetOf, (2))) .
\"urn:uuid:2ccd6d21-b124-4bb1-973f-5d2d1b769314"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(substring, ReflexiveBinaryPredicate)) .
\"urn:uuid:f1eef562-3e07-426a-8014-0a3876877013"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(substring, TransitiveBinaryPredicate)) .
\"urn:uuid:b0d4bc62-6876-4397-abb6-006844793e99"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(substring, AntiSymmetricBinaryPredicate)) .
\"urn:uuid:c170a6b6-347b-4fc0-b3ec-005b1a5c155e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(substring, EvaluatablePredicate)) .
\"urn:uuid:0c192051-e0f7-4f16-ad3c-261a1d19703b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(substring, CharacterString)) .
\"urn:uuid:6b0f7b07-9696-46f9-97ff-de2e16f807c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(substring, CharacterString)) .
\"urn:uuid:3c65e49a-6607-43f9-99c5-157ed465fe06"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(substring, 'substring-CaseInsensitive')) .
\"urn:uuid:2bff2249-d470-4528-8d15-5244fc55d798"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(substring, (2))) .
\"urn:uuid:0bdc4b39-5093-4484-ba38-58d8a43a913f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('substring-CaseInsensitive', TransitiveBinaryPredicate)) .
\"urn:uuid:e6a23224-e8a5-4bbd-a4be-aa3162b0df13"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('substring-CaseInsensitive', ReflexiveBinaryPredicate)) .
\"urn:uuid:3d4cbebe-8cb3-4bb6-a04d-6a3a14a57436"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('substring-CaseInsensitive', AntiSymmetricBinaryPredicate)) .
\"urn:uuid:71c215e5-68e0-4bcf-8048-51701c071d5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa('substring-CaseInsensitive', EvaluatablePredicate)) .
\"urn:uuid:e50a2e09-c5de-4a36-8918-dc2c8eed54f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa('substring-CaseInsensitive', CharacterString)) .
\"urn:uuid:61c4ce3c-d9bd-40a5-98fd-d9cd7738a349"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa('substring-CaseInsensitive', CharacterString)) .
\"urn:uuid:a20b14da-453d-4b44-8210-b266a028f8e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity('substring-CaseInsensitive', (2))) .
\"urn:uuid:f42c678f-76e2-43b0-bb63-2bde41748400"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(synonymousExternalConcept, TernaryPredicate)) .
\"urn:uuid:2f648b4f-9b72-4a22-ab4e-708b0ceffdbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(synonymousExternalConcept, Thing)) .
\"urn:uuid:5e30650a-ba33-4700-81cd-7f4cbcbfc9d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(synonymousExternalConcept, Individual)) .
\"urn:uuid:c0531587-8c7f-4b1e-813f-305557ddd531"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(synonymousExternalConcept, CharacterString)) .
\"urn:uuid:db5a2fa0-5778-4951-9462-1b6481266e5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(synonymousExternalConcept, overlappingExternalConcept)) .
\"urn:uuid:85f4e558-c4f4-4aba-a3bb-867700741de8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(synonymousExternalConcept, (3))) .
\"urn:uuid:9e5631f0-77a0-41c1-8aca-5bff7fc53023"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termChosen, UnaryPredicate)) .
\"urn:uuid:b467d9b8-8fe4-4af2-96a0-48d7d65a6a5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termChosen, DefaultMonotonicPredicate)) .
\"urn:uuid:12f97776-260d-4577-8e7d-c9e33c389534"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(termChosen, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:309fe509-f6d7-4b6c-9afe-b8b5676dde26"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(termChosen, Thing)) .
\"urn:uuid:2655db2d-d085-41cd-96ed-e2455da30a93"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(termChosen, (1))) .
\"urn:uuid:640caeb6-bd48-4841-ac92-50edf48fdbf7"[silk#strict] .
istAsserted(BaseKB, isa(termDependsOn, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:a3a50db1-9250-49e0-a327-140f81f7e489"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termDependsOn, BinaryPredicate)) .
\"urn:uuid:3f72d628-0c5e-4896-a05b-26ff880643a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(termDependsOn, Thing)) .
\"urn:uuid:19b2761f-3a31-4711-ac43-1c501ed7449c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(termDependsOn, Thing)) .
\"urn:uuid:2564160e-8c50-415f-b94c-f478eb60ed4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(termDependsOn, CycLReifiableDenotationalTerm)) .
\"urn:uuid:5b370976-9406-4b67-8733-702fa63a0340"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(termDependsOn, CycLReifiableDenotationalTerm)) .
\"urn:uuid:f78da1de-8ad9-468e-94a8-249d65ef7aa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(termDependsOn, (2))) .
\"urn:uuid:d93d6b8e-abdf-4255-a704-43a8169e97d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termExternalIDString, BinaryPredicate)) .
\"urn:uuid:6ad30e95-78e5-4850-b1ee-d7eeb464835f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(termExternalIDString, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:b01e758a-0649-469d-9b2a-88d4c8d6dab4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(termExternalIDString, Thing)) .
\"urn:uuid:7aa3cfed-fc79-472a-ac16-b07e174dcb82"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(termExternalIDString, HLExternalIDString)) .
\"urn:uuid:62f22136-d52e-4183-a0b6-bd456b189407"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(termExternalIDString, CycLExpression)) .
\"urn:uuid:e176ed0a-cbf3-412d-a6cc-f29753dafd00"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(termExternalIDString, (2))) .
\"urn:uuid:f6160dbc-fe2b-45a3-beaa-fcfca22f6db2"[silk#strict] .
istAsserted(BaseKB, isa(termOfUnit, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:c08007c6-1a8a-4e2c-8b4b-811a9eef6771"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termOfUnit, DefaultMonotonicPredicate)) .
\"urn:uuid:3ffa712d-b330-4dab-8c48-542e0f85f1f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termOfUnit, ReformulatorIrrelevantFORT)) .
\"urn:uuid:10e4b9da-e6c3-40ec-91a4-78290184dbd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(termOfUnit, BinaryPredicate)) .
\"urn:uuid:94c65aee-9b04-4f7f-bb78-588b69d9a521"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(termOfUnit, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:ddea2260-d49a-4176-9099-39e646a3b0db"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(termOfUnit, Thing)) .
\"urn:uuid:23f6d117-ecf5-4078-894c-50c9edf38213"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(termOfUnit, Thing)) .
\"urn:uuid:81d74f0b-d913-477f-bc77-4adde8a0b322"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(termOfUnit, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:a9c889d2-cf38-4f7d-94d3-2243231fb404"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(termOfUnit, CycLReifiableNonAtomicTerm)) .
\"urn:uuid:0b3d0fe3-be18-464e-bebe-46e843276b06"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(termOfUnit, (2))) .
\"urn:uuid:7bec370b-4c06-49a3-85ae-5710ba2ab75f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(thereExistAtLeast, 'ExistentialQuantifier-Bounded')) .
\"urn:uuid:319b5433-5434-45f0-aa02-1fe70d013a44"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(quotedIsa(thereExistAtLeast, InferenceSupportedTerm))) .
\"urn:uuid:15c3c44b-a109-42ba-895e-70df233b2e56"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(thereExistAtLeast, PositiveInteger)) .
\"urn:uuid:9b933338-34b8-4d2c-a9f3-7d09a96676ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(thereExistAtLeast, CycLVariable)) .
\"urn:uuid:a67ef695-e3f0-4836-b463-880190623536"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(thereExistAtLeast, 'CycLSentence-Assertible')) .
\"urn:uuid:17678e49-3ec5-4674-8dc7-722fa9e8b76c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(thereExistAtLeast, (3))) .
\"urn:uuid:004ce3f8-a35c-493a-a4ef-c1f1cf283063"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(thereExistAtMost, 'ExistentialQuantifier-Bounded')) .
\"urn:uuid:dd6a80ff-a7ba-404d-acee-68efdf9171ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(quotedIsa(thereExistAtMost, InferenceSupportedTerm))) .
\"urn:uuid:6642dd1e-6513-4e2b-92dd-ad0a958ada56"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(thereExistAtMost, PositiveInteger)) .
\"urn:uuid:7a439118-57cf-4ef6-b7e9-a17982146bef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(thereExistAtMost, CycLVariable)) .
\"urn:uuid:27f6fc7a-1b02-4a26-8364-c2744c22f198"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(thereExistAtMost, 'CycLSentence-Assertible')) .
\"urn:uuid:6233310b-39b6-4e7c-bd6a-daa8f6fa19bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(thereExistAtMost, (3))) .
\"urn:uuid:0f9c5ea9-fa88-4950-9f5c-fe95a80f878f"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(thereExistExactly, 'ExistentialQuantifier-Bounded')) .
\"urn:uuid:44a41fdd-cca1-44f6-b505-5d8da8c2d371"[silk#strict] .
istAsserted(UniversalVocabularyMt, not(quotedIsa(thereExistExactly, InferenceSupportedTerm))) .
\"urn:uuid:c0395a8b-11a8-45ae-8ed4-4ca68ea89cb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(thereExistExactly, NonNegativeInteger)) .
\"urn:uuid:d9351083-5aea-45e4-a6c6-eda7cd1dff25"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(thereExistExactly, CycLVariable)) .
\"urn:uuid:725b08fb-d06d-4988-b5e3-547d74a67e4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3QuotedIsa(thereExistExactly, 'CycLSentence-Assertible')) .
\"urn:uuid:a78afa73-ef49-45cd-adce-db088b565d51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(thereExistExactly, (3))) .
\"urn:uuid:db0a3ebf-a998-4df4-87ca-593390c08a2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(thereExists, BinaryRelation)) .
\"urn:uuid:92b9b583-29fc-47bc-b596-00abf5cdfa0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(thereExists, ExistentialQuantifier)) .
\"urn:uuid:9f629c4b-de89-466e-b7c6-c3267bab116c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(thereExists, CycLVariable)) .
\"urn:uuid:62f8197b-ae6c-4fb6-93d6-cbb8299a0fce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(thereExists, 'CycLSentence-Assertible')) .
\"urn:uuid:c50e8459-1c99-43c6-a8ef-004ab518da3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(thereExists, (2))) .
\"urn:uuid:9d1e43ed-6ade-4b8c-9e34-d41f24491199"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(transitiveViaArg, TernaryPredicate)) .
\"urn:uuid:5788e93d-499c-40fe-abbd-07ac9f42296a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(transitiveViaArg, DefaultMonotonicPredicate)) .
\"urn:uuid:b362f48e-41d4-4806-83e7-fbd6db450001"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(transitiveViaArg, Predicate)) .
\"urn:uuid:12b653e4-84ed-4a52-af14-916fd5c65d7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(transitiveViaArg, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:e13364e2-4bd2-4b70-9abc-ceb1f61ad390"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(transitiveViaArg, Predicate)) .
\"urn:uuid:fad427ba-9196-410f-a1b3-3e55ffff4708"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(transitiveViaArg, TransitiveBinaryPredicate)) .
\"urn:uuid:1462e522-94a2-4261-8312-798cd9632913"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(transitiveViaArg, PositiveInteger)) .
\"urn:uuid:f2365891-e863-4aa4-96b0-2d0a83087951"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(transitiveViaArg, (3))) .
\"urn:uuid:eddb8fd6-ea23-4e05-80cb-810f0252cccb"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(transitiveViaArgInverse, TernaryPredicate)) .
\"urn:uuid:64d40b06-2a00-45dd-9168-1f823f94a9f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(transitiveViaArgInverse, DefaultMonotonicPredicate)) .
\"urn:uuid:3c66aff5-27a9-4864-be2e-8a9d0d729455"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(transitiveViaArgInverse, 'RemovalModuleSupportedPredicate-Generic')) .
\"urn:uuid:dc5d6a40-451e-4388-89ea-b37bc1296343"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(transitiveViaArgInverse, Predicate)) .
\"urn:uuid:94867c2c-393d-4e3f-8812-8a78cab5d9a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(transitiveViaArgInverse, TransitiveBinaryPredicate)) .
\"urn:uuid:bd271096-9d47-43e6-8de9-a549caee6ba8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(transitiveViaArgInverse, PositiveInteger)) .
\"urn:uuid:6c8bde68-00a9-4656-a041-11e78b1b893b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(transitiveViaArgInverse, (3))) .
\"urn:uuid:2d8aed17-0c02-4e16-adf8-00cd3c663bfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(trueRule, BinaryPredicate)) .
\"urn:uuid:e11519e6-bbbb-4f0b-83bf-fff9366f2f22"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(trueRule, RuleTemplate)) .
\"urn:uuid:e0570d2f-c6fc-4ea9-913a-7bae5d15e5e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(trueRule, 'CycLSentence-Assertible')) .
\"urn:uuid:1c278e6f-d6c3-4253-abd2-4393a22fdc40"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(trueRule, (2))) .
\"urn:uuid:3e93cd73-8d72-4c88-9396-e8b08eafd29d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(trueSentence, UnaryPredicate)) .
\"urn:uuid:d5e2ffd3-8fe7-488c-90d8-ddd0d74ef918"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(trueSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:d7b471a0-c533-4de9-928b-7783776a6862"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(trueSentence, 'CycLSentence-Assertible')) .
\"urn:uuid:5b578ddf-b894-4604-a310-40f5097e638d"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlPreds(trueSentence, consistent)) .
\"urn:uuid:126fc940-6c91-4b40-8010-d88b9436bf52"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(trueSentence, (1))) .
\"urn:uuid:1dd46baa-9b0f-4e6d-a015-71606cb18f5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(trueSubL, UnaryPredicate)) .
\"urn:uuid:b0822332-934b-42c1-a75e-5dee7458050a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(trueSubL, DefaultMonotonicPredicate)) .
\"urn:uuid:ebf710f8-21b6-4ef8-8515-38ecce12f3e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(trueSubL, EvaluatablePredicate)) .
\"urn:uuid:0c2030dc-c301-4ef4-bd69-c53a9db2caf9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(trueSubL, CycLNonAtomicTerm)) .
\"urn:uuid:7c4eb388-7d35-4a55-ac25-35d395161311"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(trueSubL, (1))) .
\"urn:uuid:49e95bc1-3a8c-47cf-9adb-2cf0e68c2e53"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(unitMultiplicationFactor, TernaryPredicate)) .
\"urn:uuid:d89fa722-eb6d-4174-9835-336fc24f536f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Isa(unitMultiplicationFactor, UnitOfMeasure)) .
\"urn:uuid:9af5d75e-8a0a-4798-bff5-6eeb8d0f0f84"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Isa(unitMultiplicationFactor, UnitOfMeasure)) .
\"urn:uuid:8a5bae87-dc79-44dd-97c0-85d67b3b6b57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(unitMultiplicationFactor, RealNumber)) .
\"urn:uuid:37a3ab3c-60f1-4956-9229-c6287482b68d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Isa(unitMultiplicationFactor, NonNegativeScalarInterval)) .
\"urn:uuid:f00b7860-64f3-44e0-bef0-18e0854753a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(unitMultiplicationFactor, (3))) .
\"urn:uuid:07a578d2-816a-491b-92ab-f535c3ab91a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(unknownSentence, UnaryPredicate)) .
\"urn:uuid:c77d3a74-fa4f-4cde-8bc4-e9eafcb78fe2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedIsa(unknownSentence, 'RemovalModuleSupportedPredicate-Specific')) .
\"urn:uuid:f244b160-e6e2-4730-9a88-f1f53968380e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(unknownSentence, CycLSentence)) .
\"urn:uuid:fb2e2eab-b58f-4e94-b0da-0c7a7d864098"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(unknownSentence, (1))) .
\"urn:uuid:dd303068-f4b9-4a35-b46c-64bde0d8e67a"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(xor, LogicalConnective)) .
\"urn:uuid:44f5347a-5cfb-4657-8a91-d9dce03474e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(xor, CommutativeRelation)) .
\"urn:uuid:2df633d0-0423-4191-80f8-e3ad2bb685c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(xor, BinaryRelation)) .
\"urn:uuid:08bf77f3-50c9-43d7-a382-534abeddcfc7"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(xor, 'ELRelation-OneWay')) .
\"urn:uuid:e0c837c3-5fb8-4d3e-bb9d-63b776aaac7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(xor, AssociativeRelation)) .
\"urn:uuid:be1afc10-c942-4077-8da1-0b867529aa17"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1QuotedIsa(xor, 'CycLSentence-Assertible')) .
\"urn:uuid:36b8e081-28eb-4d28-86b8-94c804622fab"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2QuotedIsa(xor, 'CycLSentence-Assertible')) .
\"urn:uuid:352bcc21-9cab-42fe-b0fd-07e3afa23ab3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arity(xor, (2))) .
\"urn:uuid:f1bc7994-49d7-40c5-944c-7d3afad52056"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn(ArgIsaPredicate), RuleTemplate)) .
\"urn:uuid:89351c55-f7b9-4b31-a570-59e46cba1ada"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn(ArgIsaPredicate), Individual)) .
\"urn:uuid:1a31fef3-2c49-4625-948b-f331130fa0e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn(HypotheticalContext), RuleTemplate)) .
\"urn:uuid:c6886db6-6a78-4b7e-98b3-b5282e2799d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, isa(CollectionRuleTemplateFn(HypotheticalContext), Individual)) .
\"urn:uuid:c70e6d44-2170-4979-b7e9-00ddbfb5302d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AbsoluteValueFn, ("#$AbsoluteValueFn is the unary mathematical function that returns the absolute value of its argument; e.g., (#$AbsoluteValueFn -2) returns 2, and (#$AbsoluteValueFn 2) returns 2."^^_string))) .
\"urn:uuid:4cdbedf6-cd85-4c27-9cc6-69eb9046d0c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(AbsoluteValueFn, (1), ScalarInterval)) .
istAsserted(BookkeepingMt, oldConstantName(AbsoluteValueFn, ("AbsoluteValue"^^_string))) .
\"urn:uuid:5037b10e-e7e9-4775-a6d0-382da8723f07"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(AbsoluteValueFn, SubLSymbolFn(("CYC-ABSOLUTE-VALUE"^^_string)))) .
\"urn:uuid:ebec4622-9d6f-4b4b-8cbd-8d401cdedc56"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(AllowGenericArgVariables, ("A #$CanonicalizerDirective (q.v.) that directs the #$CycCanonicalizer to allow ''generic argument keyword variables'' (e.g. `:ARG1' and `:ARG2') to appear in CycL assertions and  to treat them as if they were #$CycLVariables.  For a specialization (see #$genlCanonicalizerDirectives) of this directive that is used to  direct the canonicalizer to allow _all_ keyword variables, see #$AllowKeywordVariables."^^_string))) .
\"urn:uuid:bf6aca0f-4b2b-4c5b-b17e-7f7bd4aeb0de"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(AllowKeywordVariables, ("A #$CanonicalizerDirective (q.v.)  that is a specialization (see #$genlCanonicalizerDirectives) of  #$AllowGenericArgVariables.  #$AllowKeywordVariables directs the  #$CycCanonicalizer to allow all ''keyword variables'' (e.g. `:NOUN'  and `:ARG1') to appear in CycL assertions and to treat them as if they  were #$CycLVariables."^^_string))) .
\"urn:uuid:4894ecfa-9aed-4eab-9411-61955b0fb40c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AntiSymmetricBinaryPredicate, ("A #$BinaryPredicateTypeByLogicalFeature and thus a specialization of #$BinaryPredicate.  A binary predicate <code>PRED</code> is an #$AntiSymmetricBinaryPredicate if and only if it has the following two properties.  (i) For any <code>THING1</code> and <code>THING2</code> such that both <code>(PRED THING1 THING2)</code> and <code>(PRED THING2 THING1)</code> hold, <code>THING1</code>  = <code>THING2</code>.  (ii) <code>PRED</code>'s two argument-places must be ''co-satisfiable'' with respect to their (single-argument) type constraints (see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nInstances of #$AntiSymmetricBinaryPredicate include #$greaterThanOrEqualTo, #$parts, and #$subEvents.  See also the specialization #$AsymmetricBinaryPredicate; and cf. #$SymmetricBinaryPredicate."^^_string))) .
\"urn:uuid:35b4c2c9-7db3-4e29-976c-d173258e8741"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AntiTransitiveBinaryPredicate, ("A #$BinaryPredicateTypeByLogicalFeature and a specialization of  #$IrreflexiveBinaryPredicate (q.v.).  A binary predicate PRED is an instance of  #$AntiTransitiveBinaryPredicate only if it has this property: for any THING1, THING2, and THING3 such that both (PRED THING1 THING2) and (PRED THING2 THING3) hold, (#$not (PRED THING1 THING3)) holds.  Equivalently: for every X, Y, and Z that satisfy the (single-argument) argument-type constraints  (see #$admittedArgument) for the relevant argument positions of PRED,  (#$not (#$and (PRED X Y)(PRED Y Z)(PRED X Z))) holds.  Note that  PRED's two agument-positions must also be ''co-satisfiable'' with respect to their type constraints; see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement.\n<p>\nFor example, #$divorcedFrom is an instance of #$AntiTransitiveBinaryPredicate.\n<p>\nNote also that, while not strictly disjoint with #$TransitiveBinaryPredicate (q.v.), in practice few if any reified predicates should be instances of both of these collections. An important specialization of #$AntiTransitiveBinaryPredicate is #$DirectBinaryPredicate (q.v.)."^^_string))) .
\"urn:uuid:f58cf0e7-ab65-4844-abc7-ee1c7f8ef5c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(April, ("The collection of all Aprils, \nthe fourth month of the year in the #$GregorianCalendar."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(April, MetaVariableFn(("APRIL"^^_string)))) .
\"urn:uuid:c19e5023-af77-4470-afb6-520e965d39bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgConstraintPredicate, ("The collection of #$MetaRelations whose instances are used to put semantic well-formedness or entry-format constraints on one or more argument-places of a given #$Relation.  Such a constraint might concern an argument's <i>type</i>, an argument-place's #$Format (q.v.), a conditional relationship between two argument(-place)s' types or formats, or some other sort of relationship between two arguments.  For a fuller account, see the various specializations of #$ArgConstraintPredicate."^^_string))) .
\"urn:uuid:437786a0-3337-4dcf-b791-dcc37090357d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgGenlBinaryPredicate, ("Those instances of both #$BinaryPredicate and #$ArgGenlPredicate used to specify the required #$genls of an argument of a #$Relation; the arg1 is the #$Relation; the arg2 is the required #$genls #$Collection."^^_string))) .
\"urn:uuid:20187d3a-ced7-4154-af2b-a1cc0641f9ac"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ArgGenlBinaryPredicate)) .
\"urn:uuid:aadac9cb-8dc9-4978-98db-124411d12e57"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgGenlQuantityBinaryPredicate, ("Those instances of both #$ArgTypeBinaryPredicate and #$ArgGenlAttributePredicate used to specify the required quantity of an argument of #$Relation.  Each instance PRED of this collection is a binary predicate with the following properties: ARG1 is an instance of #$Relation, and ARG2 is an instance of #$Quantity.  (PRED ARG1 ARG2) means that some argument of ARG1 is constrained to be subsumed by (via #$quantitySubsumes) ARG2, where PRED determines the argument place in question."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(ArgGenlQuantityBinaryPredicate, ("ArgGenlQuanityBinaryPredicate"^^_string))) .
\"urn:uuid:9c5a13d2-8c56-4f84-a84c-a5c92e3ccde0"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ArgGenlQuantityBinaryPredicate)) .
\"urn:uuid:df6c5b9e-ce5b-4eb4-af10-a5702cd73740"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgGenlQuantityTernaryPredicate, ("A specialization of both #$ArgTypeTernaryPredicate and #$ArgGenlAttributePredicate.  Each instance of #$ArgGenlAttributeTernaryPredicate is a ternary predicate used to place a ''#$quantitySubsumes'' constraint on (and thereby specify an argument-type for) one or more argument-places of a relation.  To be more precise, each instance PRED of #$ArgGenlAttributeTernaryPredicate takes a #$Relation RELN as its first argument, a #$NonNegativeInteger N as its second argument, and an #$Quantity QUANT as its third argument. PRED places a ''#$quantitySubsumes'' constraint on RELN's Nth argument-place that is based on QUANT, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is subsumed by QUANT (in the sense that (#$quantitySubsumes QUANT ARGN) holds).  An important instance of #$ArgGenlAttributeTernaryPredicate is #$argGenlQuantity."^^_string))) .
\"urn:uuid:dfd8c974-4a79-422e-b5c2-2e36649ab937"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ArgGenlQuantityTernaryPredicate)) .
\"urn:uuid:f460a8f4-6dc0-44fe-8a85-dc8cc6760aa0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgGenlTernaryPredicate, ("A specialization of #$ArgTypeTernaryPredicate and #$ArgGenlPredicate.  Each instance of #$ArgGenlTernaryPredicate is used to specify that a certain collection is required to stand in the #$genls relation to anything that is acceptable in a particular argument slot of a given instance of #$Relation.  With each instance of #$ArgGenlTernaryPredicate, the first argument is the relation constrained; the second argument is the argument constrained; and the third argument is the required collection that the relation's specified argument is required to be a specialization of."^^_string))) .
\"urn:uuid:04d09079-0bc1-43b3-b7ac-d6027bd33e57"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgIsaBinaryPredicate, ("A specialization of both #$ArgTypeBinaryPredicate and #$ArgIsaPredicate.  Each instance of #$ArgIsaBinaryPredicate takes a #$Relation RELN as its first argument, and a #$Collection COL as its second argument, and places a constraint based on COL on at least one of the argument-places of RELN.  To be more precise, suppose that PRED is an #$ArgIsaBinaryPredicate that specifies an argument-type for the Nth argument-place of RELN.  Then a sentence of the form (PRED RELN COL) entails that a closed formula of the form (RELN ... ARGN ...) is semantically well-formed only if  ARGN is an instance of COL."^^_string))) .
\"urn:uuid:df83fc11-2d2a-428b-b9b5-04b67fa80c8a"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ArgIsaBinaryPredicate)) .
\"urn:uuid:06fd79d6-a4c7-4d64-a29b-740188fdbe1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgIsaPredicate, ("The collection of #$ArgTypePredicates (q.v.) that specify argument-types directly (by referencing certain collections) and impose constraints that require a thing's being an instance of a collection thus specified.  More precisely, each instance of #$ArgIsaPredicate PRED takes a #$Relation RELN as its first argument (or ''arg1''), and has at least one other argument-place (say the Mth) for specifying an argument-type for one of RELN's argument-places (say the Nth).  (The value of N might be fixed or might be given by yet another of PRED's arguments.)  Suppose M=2 and N=1.  PRED then takes a #$Collection as its second argument, and a closed atomic sentence (or ''GAF'') of the form (PRED RELN COL ..) puts an ''#$isa'' constraint on RELN's first argument-place that is based on COL.  If PRED is a ''single-argument'' constraint predicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is semantically well-formed only if ARG1 is an instance of (i.e. #$isa) COL.  If PRED is an ''inter-argument'' constraint predicate, the GAF expresses a slightly more complicated, conditional #$isa constraint on a pair of RELN's argument-places (see #$InterArgIsaPredicate)."^^_string))) .
\"urn:uuid:ba1f47bc-ea43-4d79-9b53-7d7094b5f8e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgIsaTernaryPredicate, ("A specialization of both #$ArgTypeTernaryPredicate and #$ArgIsaPredicate (q.v.).  Each instance of #$ArgIsaTernaryPredicate is a ternary predicate used to place an ''#$isa'' constraint on (and thereby specify an argument-type for) one or more argument-places of a relation.  To be more precise, each instance PRED of #$ArgIsaTernaryPredicate takes a #$Relation RELN as its first argument, a #$NonNegativeInteger N as its second argument, and a #$Collection COL as its third argument.  PRED places an ''#$isa'' constraint on RELN's Nth argument-place that is based on COL, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is an instance of COL. (Note that (i) if N = 0 then this same constraint is placed on _all_ of RELN's argument-places and (ii) if PRED is #$argAndRestIsa then this constraint is placed on all of RELN's argument-places whose ordinal positions are greater than or equal to the Nth.)  An important instance of #$ArgIsaTernaryPredicate is #$argIsa."^^_string))) .
\"urn:uuid:e3b919fb-da90-428b-a71c-71397dbb374b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgQuotedIsaBinaryPredicate, ("A specialization of #$ArgQuotedIsaPredicate . Each instance of #$ArgQuotedIsaBinaryPredicate takes a #$Relation RELN as its first argument, and a #$SubLExpressionType #$Collection COL as its second argument, and places a constraint based on COL on at least one of the argument-places of RELN. To be more precise, suppose that PRED is an #$ArgIsaBinaryPredicate that specifies an argument-type for the Nth argument-place of RELN. Then a sentence of the form (PRED RELN COL) entails that a closed formula of the form (RELN ... ARGN ...) is semantically well-formed only if ARGN is an instance (i.e. #$quotedIsa) of COL."^^_string))) .
\"urn:uuid:543a1b87-dd0f-45cb-8c6d-90c22f342ed2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgQuotedIsaPredicate, ("The collection of #$ArgTypePredicates (q.v.) that specify argument-types directly (by referencing certain collections) and impose constraints that require a thing's being an instance of a #$SubLExpressionType collection thus specified. More precisely, each instance of #$ArgQuotedIsaPredicate PRED takes a #$Relation RELN as its first argument (or ''arg1''), and has at least one other argument-place (say the Mth) for specifying an argument-type for one of RELN's argument-places (say the Nth). (The value of N might be fixed or might be given by yet another of PRED's arguments.) Suppose M=2 and N=1. PRED then takes a #$SubLExpressionType #$Collection as its second argument, and a closed atomic sentence (or ''GAF'') of the form (PRED RELN COL ..) puts an ''quoted isa'' constraint on RELN's first argument-place that is based on COL. If PRED is a ''single-argument'' constraint predicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is semantically well-formed only if ARG1 is an instance of (i.e. #$quotedIsa) #$SubLExpressionType COL."^^_string))) .
\"urn:uuid:9ef43180-d502-491e-b378-a20824ccc259"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgQuotedIsaTernaryPredicate, ("A specialization of #$ArgQuotedIsaPredicate (q.v.). Each instance of #$ArgQuotedIsaTernaryPredicate. is a ternary predicate used to place an ''quoted isa'' constraint on (and thereby specify an argument-type for) one or more argument-places of a relation. To be more precise, each instance PRED of #$ArgQuotedIsaTernaryPredicate takes a #$Relation RELN as its first argument, a #$NonNegativeInteger N as its second argument, and a #$SubLExpressionType collection COL as its third argument. PRED places an ''quoted isa'' constraint on RELN's Nth argument-place that is based on COL, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is a quoted instance of COL. (Note that if N = 0 then this same constraint is placed on _all_ of RELN's argument-places. An important instance of #$ArgQuotedIsaTernaryPredicate is #$argQuotedIsa."^^_string))) .
\"urn:uuid:ee626437-73e9-476d-9664-c35691ed6378"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgSometimesIsaPredicate, ("The collection of ArgTypePredicates (q.v.) that specify argument-types\ndirectly (by referencing certain collections) and impose constraints that\nrequire an argument of a predicate being an instance of a SubLExpressionType\ncollection at some time.  More precisely, each instance\nof ArgSometimesIsaPredicate PRED takes a Relation RELN as its first argument (or\n''arg1''), and has at least one other argument-place (say the Mth) for\nspecifying an argument-type for one of RELN's argument-places (say the\nNth). (The value of N might be fixed or might be given by yet another of PRED's\narguments.) Suppose M=2 and N=1. PRED then takes a SubLExpressionType Collection\nas its second argument, and a closed atomic sentence (or ''GAF'') of the form\n(PRED RELN COL ..) puts a ''sometimes isa'' constraint on RELN's first\nargument-place that is based on COL. If PRED is a ''single-argument'' constraint\npredicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is\nsemantically well-formed only if ARG1 is an instance of \nSubLExpressionType COL in some time interval\n(including #$Always-TimeInterval)."^^_string))) .
\"urn:uuid:838f92e5-975a-47ee-ad66-d5a35d0e618d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgTypeBinaryPredicate, ("Those instances of both #$BinaryPredicate and #$ArgTypePredicate used to specify the required #$isa or #$genls or #$quotedIsa of an argument of a #$Relation; the arg1 is the #$Relation; the arg2 is the required type, a #$Collection."^^_string))) .
\"urn:uuid:83cd7709-a356-4fdd-bc21-8bd9c973474a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgTypePredicate, ("The collection of #$ArgConstraintPredicates used to put semantic well-formedness constraints on the type of argument(s) appropriate for a given argument-place (or -places) of a given relation.  A ''type'' of argument can be specified in terms of #$isa or #$genls; see the various specializations of #$ArgTypePredicate for more detail. Violation of such a constraint results in an expression that is semantically malformed.  For a general explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations."^^_string))) .
\"urn:uuid:c9bab6de-5626-41f2-aa00-c845408cf51d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ArgTypeTernaryPredicate, ("Those instances of both #$TernaryPredicate and #$ArgTypePredicate used to specify the required #$isa or #$genls or #$quotedIsa of an argument of a #$Relation; the arg1 is the Relation; the arg2 is the argument constrained; the arg3 is the required type: a #$Collection."^^_string))) .
\"urn:uuid:c25bfec6-83e0-4cc2-a340-f643022d3d5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AssociativeRelation, ("The collection of polyadic #$Relations having the property of <i>associativity</i>.  Roughly speaking, a relation is associative if certain different sequences of recursive applications of it lead to the same final result.\n<p>\nMore precisely:  If <b>RELN</b> is binary, it is an instance of #$AssociativeRelation if and only if (for any appropriate arguments <b>A</b>, <b>B</b>, and <b>C</b>) the corresponding formulas <b>(RELN A (RELN B C))</b> and <b>(RELN (RELN A B) C)</b> are (extensionally) equivalent: if <b>RELN</b> is a #$Function-Denotational both formulas have the same denotatum (or both have no denotatum), while if <b>RELN</b> is a #$Predicate or #$LogicalConnective both formulas have the same truth value.  If <b>RELN</b> has a higher arity than two, the definition is similar, but with the relevant formula schemata appropriately rewritten.  If <b>RELN</b> is variable-arity (see #$VariableArityRelation), it is an #$AssociativeRelation if and only of it behaves associatively with respect to each of the particular arities it subsumes (its #$arityMin to #$arityMax).  No unary relation is associative. \n<p>\nIt follows from the above definition that that each argument-place of an associative relation must admit exactly the same class of arguments (see #$admittedArgument), and that its results must also be of that same class (so that it can be applied recursively).\n<p>\nExamples of associative relations include #$PlusFn, #$TimesFn, #$JoinListsFn, #$SpatialSumFn, #$or, and #$and.\n<p>\nNote that, while many #$AssociativeRelations are #$CommutativeRelations (q.v.), this is not always the case.  Consider for example #$ConcatenateStringsFn.  Since it is associative, (('c'^'a')^'t') = ('c'^('a'^'t')) = 'cat'.  But it is certainly <i>not</i> commutative: 'cat' =/ 'act'."^^_string))) .
\"urn:uuid:1604d437-8b5c-458b-85c1-02f34e502879"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AsymmetricBinaryPredicate, ("An instance of #$BinaryPredicateTypeByLogicalFeature and a specialization of #$AntiSymmetricBinaryPredicate (q.v.).  A binary predicate <code>BINPRED</code> is an instance of #$AsymmetricBinaryPredicate if and only if (i) for any <code>THING1</code> and <code>THING2</code>, <code>(BINPRED THING1 THING2)</code> implies <code>(#$not (BINPRED THING2 THING1))</code> and (ii) the single-argument argument type (i.e. #$argIsa and #$argGenl) constraints on <code>BINPRED</code>'s two respective argument-places are ''co-satisfiable'' (see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nExamples of asymmetric binary predicates include #$northOf, #$children, #$greaterThan, and #$overrides.  Cf. #$SymmetricBinaryPredicate."^^_string))) .
\"urn:uuid:0c9838a7-58e0-42a2-b86d-cd510583aa0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(AtemporalNecessarilyEssentialCollectionType, ("A collection of collections.  Each instance <code>COL</code> of #$AtemporalNecessarilyEssentialCollectionType (<i>ANECT</i>) is a collection satisfying three conditions: (1) <code>COL</code> is disjoint with (see #$disjointWith) #$TemporalThing, (2) every instance <code>INST</code> of <code>COL</code> is an instance of <code>COL</code> essentially (i.e. <code>INST</code> is an instance of <code>COL</code>, and could not exist without being an instance of <code>COL</code>), and (3) condition (2) is a necessary truth about <code>COL</code>.\n<p>\nPositive examples of ANECTs include #$Collection, #$Integer, and #$Relation (each of which is a collection of atemporals and is such that, necessarily, all of its instances are in it essentially).  Negative examples include #$SpatialThing (though arguably it is necessary that all of its instances are essentially instances of it, it is not disjoint with #$TemporalThing) and #$UniqueAnatomicalPartType (which, though disjoint with #$TemporalThing, has instances, such as #$Heart, that could exist even if they weren't instances of it; e.g. it might have been the case that every creature with a heart had at least two hearts).  There are no known examples of Cyc-reified collections satisfying conditions (1) and (2) but not (3), but one can be contrived.  Suppose that all of today's winning lottery numbers were primes.  Now consider the collection:\n<p>\n (#$CollectionUnionFn \n   (#$TheSet #$PrimeNumber <i>TodaysWinningLotteryNumbers</i>))\n<p>\nThis collection is clearly disjoint with #$TemporalThing and, by hypothesis, all of its instances are in it essentially (as each prime number is essentially a prime number).  But this last fact is not <i>necessarily</i> true of this collection: the collection might have had instances that belonged to it only contingently (i.e. not essentially), as it might have been the case that one of today's winning lottery numbers was non-prime, and no number is such that it is essentially one of today's winning lottery numbers.\n<p>\nWhen asserting that something is an instance or specialization of a given instance of ANECT, it is appropriate to do so in the #$UniversalVocabularyMt (q.v.).  Indeed, ANECT was specially defined to facilitate the movement of appropriate assertions to that microtheory.\n<p>\nCf. #$PragmaticallyDecontextualizedCollection."^^_string))) .
\"urn:uuid:99d2ff46-8e0a-4b69-b9ca-65ff76349246"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:ad04188a-fc8b-44cb-9204-5d011836ae8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(August, ("The collection of all Augusts,\n the eighth month of the year in the #$GregorianCalendar."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(August, MetaVariableFn(("AUGUST"^^_string)))) .
\"urn:uuid:4e896f31-a16a-4e49-a947-38f920158979"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Average, ("Computes the average of the function values over all elements in the Set."^^_string))) .
\"urn:uuid:83708754-8e5a-440d-a30b-d677ccc6e7ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Average, (1), SetOrCollection)) .
\"urn:uuid:4cdd182c-6526-41d2-9e99-ecc9d23ba251"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Average, (2), UnaryFunction)) .
\"urn:uuid:c1c260bc-ab83-4c99-ad88-d64545247ece"[silk#strict] .
istAsserted(BaseKB, argIsa(Average, (1), SetOrCollection)) .
\"urn:uuid:ee728b15-fc46-4aba-a556-aa0119a372a1"[silk#strict] .
istAsserted(BaseKB, argIsa(Average, (2), UnaryFunction)) .
\"urn:uuid:5dde827f-6aa1-4808-9145-88b2bba3c874"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(Average, SubLSymbolFn(("CYC-AVERAGE"^^_string)))) .
\"urn:uuid:06aa2fb9-1f5e-4d84-b1c6-2d47ee0705f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('Backward-AssertionDirection', ("An instance of #$CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the #$Backward-AssertionDirection can only be used in inferences that \nare carried out when a query is asked. This is the default direction for \nrule assertions.  Contrast with #$Forward-AssertionDirection and #$Code-AssertionDirection.  Also see #$assertionDirection."^^_string))) .
\"urn:uuid:8156b103-2769-4303-a6e2-9bc58fee672c"[silk#strict] .
istAsserted(BaseKB, comment(BaseKB, ("#$BaseKB is the most general #$Microtheory currently in use.  Assertions in this context are `accessible' from any other #$Microtheory via the #$genlMt relation.  In the partial order of microtheories, all microtheories have access to #$BaseKB.  An assertion which is true here will by default be true in every context.  The `content' of #$BaseKB consists of very general assertions which are expected to be usable in most or all applications of Cyc, as well as Cyc's most fundamental assertions that it uses in inference, and all completely universal, timeless truths."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(BaseKB, MetaVariableFn(("BASE-K-B"^^_string)))) .
\"urn:uuid:7acaa85e-83f7-4c77-ba1c-116186b59766"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(BinaryFunction, ("A specialization of both #$BinaryRelation and #$Function-Denotational.  An instance of #$Function-Denotational FUNC is an instance of #$BinaryFunction if and only if FUNC has an #$arity of 2."^^_string))) .
\"urn:uuid:e02d8806-9202-4078-8041-1aafc6f3592a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(BinaryPredicate, ("A specialization of both #$BinaryRelation and #$Predicate.  #$BinaryPredicate is the collection of all predicates whose arity (see #$arity) is 2."^^_string))) .
\"urn:uuid:1e491bfe-8dff-449b-91e6-924e3f710ed0"[silk#strict] .
istAsserted(BaseKB, disjointWith(BinaryPredicate, UnaryPredicate)) .
\"urn:uuid:98495085-3f8e-49ba-868e-754b44651361"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(BinaryRelation, ("The collection of all fixed-arity relations of arity 2 (see #$arity).  The most notable specializations of #$BinaryRelation are #$BinaryPredicate and #$BinaryFunction (qq.v.)."^^_string))) .
\"urn:uuid:eb0badbd-3032-43d2-ba40-f9652bf39069"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(BinaryRelation, PartiallyCommutativeRelation)) .
\"urn:uuid:5b25f587-8b71-4c71-b888-dadff6fb5236"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(BinaryRelation, arg2Isa)) .
\"urn:uuid:1db7eb4c-e19a-4198-ba05-b018b7e67558"[silk#strict] .
istAsserted(BaseKB, comment(BookkeepingMt, ("A #$Microtheory for stating basic bookkeeping information regarding the Cyc Knowledge Base, such as assertions using #$myCreator or #$myCreationTime."^^_string))) .
\"urn:uuid:e05ca1cb-87e3-43d6-9e17-97e708148251"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(BookkeepingPredicate, ("A #$PredicateType whose instances are predicates used to make assertions about the reification (or ''creation'') and internal representation of particular CycL terms (usually constants) in the Cyc system.  Bookkeeping predicates neither specify nor constrain the semantics of CycL terms.  Examples include  #$myCreator, #$myCreationTime, #$termOfUnit, and #$defnSufficient.  Many (but not all) bookkeeping predicates are also #$MetaKnowledgePredicates (q.v.)."^^_string))) .
\"urn:uuid:756ea247-946d-43cb-b6d3-785e1a9ba35f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(BroadMicrotheory, ("The collection of those microtheories that contain so many assertions that they are not useful for `relevance' focusing during inference.  (A #$BroadMicrotheory is not used internally in Cyc's indexing scheme during inference.)  Examples: #$BaseKB and #$EnglishMt."^^_string))) .
\"urn:uuid:1621c317-fd33-4d89-8d1b-745a3da4db25"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(CanonicalizerDirective, ("A specialization of #$AspatialInformationStore.  Instances  of #$CanonicalizerDirective are directives (or ''commands'') that can be  given to the #$CycCanonicalizer (via certain #$CanonicalizerDirectivePredicates) in order to control its behavior in certain ways during asserts and queries.   Examples include #$AllowGenericArgVariables and #$LeaveSomeTermsAtEL. See e.g. the directive predicate #$canonicalizerDirectiveForArg for more  information on how to use these directives."^^_string))) .
\"urn:uuid:6842f43f-2ee8-4bc2-85be-1a95f8c34343"[silk#strict] .
istAsserted(BookkeepingMt, notAssertibleCollection(CanonicalizerDirective)) .
\"urn:uuid:bf9b885c-a452-4885-8b40-fa105e9d27da"[silk#strict] .
istAsserted(CoreCycLImplementationMt, completelyEnumerableCollection(CanonicalizerDirective)) .
\"urn:uuid:f9e5067b-f219-45a2-85ce-1158809906f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CharacterString, ("A specialization of #$AbstractInformationStructure.  Each instance of #$CharacterString is a string of characters or an abstract sequence of symbols.  Note that an instance of #$CharacterString is <i>not</i> any particular physical, tangible representation, since different encodings may represent the same string of characters.  An instance of #$CharacterString is a list (see the collection #$List) of characters (instances of #$Character-Abstract) from some fixed character set. An instance of #$CharacterString may be any finite length, including zero (the zero-length string is the empty string, which has no characters).  Notable specializations of #$CharacterString include #$EMailAddress, #$AreaCode, #$PhoneNumber, and #$TelephoneCountryCode.  Note that a #$CharacterString is ordered formally as a #$List (rather than physically left-to-right or top-to-bottom); thus the 'first' character in the #$CharacterString for an Arabic word happens to be the rightmost (first pronounced) character, not the leftmost character, due to the letter-order and word-order convention for Arabic writing."^^_string))) .
\"urn:uuid:24b4bd64-5859-4f56-a7c2-5ba849434fef"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('Code-AssertionDirection', ("An instance of #$CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the #$Code-AssertionDirection cannot itself be used in either \nbackward (ask-time) or forward (assert-time) inferences, but is instead \nimplemented in the underlying code of the Cyc system.  Contrast with \n#$Backward-AssertionDirection and #$Forward-AssertionDirection.  Also \nsee #$assertionDirection."^^_string))) .
\"urn:uuid:894cfe12-56b3-401c-81a7-1d3f3dbb940d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Collection, ("A specialization of #$SetOrCollection (q.v.).  This is the collection of all collections of things.  Each #$Collection is a kind or type of thing whose instances share a certain property, attribute, or feature.  For example, #$Cat is the collection of all and only cats, and #$BinaryFunction is the collection of all and only functions taking two arguments.\n<p>\nThe notion of collection is fundamental to the Cyc ontology, and is thus difficult to define in a precise and substantive way.  But it is instructive to compare it to the mathematical notion of a set (see #$Set-Mathematical).  Like a set, a collection is an #$AbstractThing (i.e. aspatial and atemporal) that is not an #$Individual (cf.), but instead has elements (see #$elementOf).  Unlike a set, however, the elements or ''instances'' (see #$isa) of a given collection can vary from context to context, and it is possible for distinct collections to have exactly the same elements (i.e. to have the same #$extent) with respect to a given context. For example, the (non-reified) collections ''Chordate'' and ''Renate'' are co-extensional in the context of the present-day actual world, but have differring extents with respect to hypothetical contexts in which there exist creatures having hearts but not kidneys.  This difference is sometimes summarized by saying that sets are ''extensional'' things and collections are ''intensional'' things.\n<p>\nMany, though by no means all, of the collections reified in the Cyc ontology correspond to natural kinds or classes.  It is particulary useful to reify collections that are difficult to define precisely, but about which there are many common-sense rules and other things to state.  For example, it would not be worthwile to introduce a constant 'WhiteCat', both because it's easy to define the collection of white cats in terms of more general, already-reified notions (e.g. '(#$CollectionIntersection2Fn #$Cat #$WhiteColor)'), and because there's not much to say about that particular collection.  #$WhiteCollarWorker, on the other hand, is a good collection to have reified, as it is hard to define precisely, yet is a collection about which there are many things to say.\n<p>\nSome of the many reified specializations of #$Collection are #$FirstOrderCollection, #$TimeDependentCollection, and #$ObjectType."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(Collection, MetaVariableFn(("COLLECTION"^^_string)))) .
\"urn:uuid:870b089c-a81e-4ab5-a6d2-5fd9c9dfb2d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(Collection, 'Set-Mathematical')) .
\"urn:uuid:829248f5-6778-4323-af62-b2968e86a777"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(Collection, Individual)) .
\"urn:uuid:4eb73242-1a31-4541-89e3-bdec747f0518"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CollectionDenotingFunction, ("The subcollection of #$Function-Denotational whose instances return instances of #$Collection.  Examples include #$SwimmingEventFn, #$GroupFn, and #$MoleculeFn.  For example, (#$MoleculeFn #$Oxygen) denotes the collection of all oxygen molecules.  See also the collections #$IndividualDenotingFunction and #$SetDenotingFunction."^^_string))) .
\"urn:uuid:a890405b-92a8-438f-af50-912632e5dcbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(CollectionDenotingFunction, resultGenl)) .
\"urn:uuid:bab9ac0c-dbf9-42fb-bbab-ec12748d2b57"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CollectionRuleTemplateFn, ("(#$CollectionRuleTemplateFn COL) denotes the rule template unique to collection COL."^^_string))) .
\"urn:uuid:0dc9364c-145f-4bca-b1d2-f3d3e761e821"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(CollectionRuleTemplateFn, (1), Thing)) .
\"urn:uuid:b60fe014-40e7-4cbd-b64f-6d22072a2f7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CollectionRuleTemplateFn, (1), Collection)) .
\"urn:uuid:4daa79c6-1d6d-48aa-b2d6-827aee97a989"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CommutativeRelation, ("An instance of #$RelationTypeByLogicalFeature (q.v.) and a specialization of #$AtLeastPartiallyCommutativeRelation (q.v.).  Each instance of #$CommutativeRelation <code>COMRELN</code> is a predicate or function that is commutative in all of its argument-places.  That is, if <code>COMRELN</code> is a predicate (function) that holds among (has a value <code>VAL</code> for) a given sequence of arguments, then <code>COMRELN</code> also holds among (has the same value <code>VAL</code> for) any permutation of that  sequence.  \n<p>\nExamples of commutative relations include #$PlusFn, #$or, #$bordersOn, #$temporallyIntersects, and #$teammates.  Specialization include #$SymmetricBinaryPredicate.  \n<p>\nNote that most relations are <i>not</i> commutative.  Cf. the disjoint collection  #$PartiallyCommutativeRelation."^^_string))) .
\"urn:uuid:ccac8381-9ab7-45a7-9793-a7e6d5b54236"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CommutativeRelation, UnaryRelation)) .
\"urn:uuid:729e92a8-f01e-494e-b8a3-355008fa07ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CommutativeRelation, PartiallyCommutativeRelation)) .
\"urn:uuid:68c58d27-71e8-481f-9282-84ff5e47b73e"[silk#strict] .
istAsserted(BaseKB, comment(CoreCycLImplementationMt, ("This is a microtheory which contains only the `core' assertions required for the Cyc theorem prover and its underlying HL representation of the EL to conclude useful inferences.  It extends the #$LogicalTruthImplementationMt with assertions necessary for Cyc's implementation to make use of the terms defined in the #$CoreCycLMt."^^_string))) .
\"urn:uuid:a7e35574-42bf-47f0-b266-ec0a9d80da92"[silk#strict] .
istAsserted(BaseKB, comment(CoreCycLMt, ("This is a microtheory which contains only the assertions required to represent useful logical truths in CycL.  It extends the #$LogicalTruthMt with additional assertions which are so useful as to be considered `core' to the CycL language."^^_string))) .
\"urn:uuid:f56732b8-addc-438e-a99b-fee7d2e8e1ac"[silk#strict] .
istAsserted(BaseKB, comment('CurrentWorldDataCollectorMt-NonHomocentric', ("The #$Microtheory which collects together all of the instances of #$GeneralMicrotheory (including instances of #$DataMicrotheory) as #$genlMts (excepting #$HomoCentricNaturalismMt), so that any scenario or project microtheory which needs wide access to the KB but needs to accept either non-human #$Persons or supernatural things can use this as a #$genlMt and be assured that all generally defined terms are available.  If no need exists to access instances of #$TemporalThing, #$WorldLikeOursCollectorMt-NonHomocentric should be used instead.  If for the purposes of the project all persons are human and no supernatural things are being reasoned about use the #$CollectorMicrotheory #$CurrentWorldDataCollectorMt or #$WorldLikeOursCollectorMt."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName('CurrentWorldDataCollectorMt-NonHomocentric', ("CurrentWorldDataCollectorMtt-NonHomocentric"^^_string))) .
\"urn:uuid:bd404b94-1cee-4233-ab3a-035a4c8aca88"[silk#strict] .
istAsserted(BaseKB, comment(CycAdministrator, ("This constant is for use by Cyc administrators responsible for installation, setup and maintenance of Cyc images."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycArgumentDatastructure, ("CycLArgumentDatastructure"^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycDeductionDatastructure, ("CycLDeductionDatastructure"^^_string))) .
\"urn:uuid:2a6d6e58-b1c7-44bf-9b1f-712af87939f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycHLSupportDatastructure, ("A specialization of both #$CycHLDatastructure and\n#$CycSupportDatastructure (qq.v.) instances of which\nare Cyc HL datastructures that can be used as supports\nwithin a #$CycDeductionDatastructure (q.v.)."^^_string))) .
\"urn:uuid:726f6d49-16ad-4abf-8f84-073e2e0f2760"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycHLTruthValue, ("The truth/strength combinations used in the Cyc HL implementation of #$CycLAssertions and arguments."^^_string))) .
\"urn:uuid:0b3b5181-2e53-486d-b96c-bcc9d3c28c5d"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(CycHLTruthValue, TruthValue)) .
istAsserted(BookkeepingMt, oldConstantName(CycHLTruthValue, ("CyclTruthValue"^^_string))) .
\"urn:uuid:49766575-e869-424c-899d-8d66a909f3d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycInferenceAnswer, ("A specialization of #$CycInferenceDataStructure.  Each\ninstance of #$CycInferenceAnswer is a complex data structure that is a\ncomponent of one or more #$CycInferences (specifically, of certain\ninferences whose root problem is proven).  A #$CycInferenceAnswer has\ntwo components: an assigment of bindings to query variables and sets of justifications for those bindings.  For information about the components, see the predicates #$inferenceAnswerBindings and #$inferenceAnswerJustification."^^_string))) .
\"urn:uuid:fd985792-3c90-42b2-b492-ba9037eaa275"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycInferenceAnswerJustification, ("A specialization of #$CycInferenceDataStructure.  Each\ninstance of #$CycInferenceAnswerJustification is a component of one or\nmore #$CycInferenceAnswers, and, in each case, encodes a complete set\nof supports (cf., #$CycSupportDatastructure) for that answer's binding\nlist.  See also #$CycInferenceBindingsDataStructure."^^_string))) .
\"urn:uuid:58a75f90-f17d-4476-8bc3-b71c14d465e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycInferenceBindingsDataStructure, ("A specialization of #$CycInferenceDataStructure.  Each\ninstance of #$CycInferenceBindingsDataStructure is a component of one\nor more #$CycInferenceAnswers, and encodes an assignment of bindings\nto the free variables in the query which yielded that answer\n(i.e., the query which triggered the #$CycInference of which that\nanswer is a part).  If the triggering query is closed, the binding\nlist value is NIL."^^_string))) .
\"urn:uuid:0d3adae1-d038-4cfe-981a-a12969b6e5e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycInferenceFn, (1), NonNegativeInteger)) .
\"urn:uuid:7d0de997-82e8-4e48-8866-a89303a91609"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycInferenceFn, (2), CycProblemStore)) .
\"urn:uuid:7ef5b958-70ac-49fc-b66f-4befd432938d"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(CycInferenceProblemLinkStatus)) .
istAsserted(BookkeepingMt, oldConstantName(CycKBDatastructure, ("CycLKBDatastructure"^^_string))) .
\"urn:uuid:1307cb37-a0a7-4610-a2fd-daa17f37f7d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAssertedAssertion, ("A specialization of #$CycLAssertion.  An instance ASSERT of #$CycLAssertion is also an instance of #$CycLAssertedAssertion  just in case ASSERT was explicitly asserted to the Cyc Knowledge Base by one of its users (see the collection #$Cyclist), as opposed to having been deduced by Cyc's inference engine (in which case it would be an instance of #$CycLDeducedAssertion (q.v.)).  Note that since a single assertion can be both explicitly asserted to the knowledge base and also deduced by the inference engine, the collections #$CycLAssertedAssertion and #$CycLDeducedAssertion are not disjoint."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLAssertedAssertion, ("AssertedAssertion"^^_string))) .
\"urn:uuid:684648c1-e7d0-43a9-a497-5d0f2806ff5e"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(CycLAssertedAssertion)) .
\"urn:uuid:61588b99-234f-4d8a-8e8a-5c2eaf0286f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAssertion, ("The collection of semantically well-formed #$CycLSentences asserted to the Cyc Knowledge Base.  Each instance of #$CycLAssertion is either (1) an HL assertion, i.e. a CycL sentence that corresponds to a data structure actually in the Cyc KB), or (2) an EL assertion : an Epistemological Level CycL sentence that can be canonicalized into one or more already extant HL assertions.  #$CycLAssertion is used as a quoted argument type constraint for certain meta-predicates, such as #$overrides."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLAssertion, ("Assertion"^^_string))) .
\"urn:uuid:eb9aa3fd-564a-4c79-919a-b092b57c9902"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(CycLAssertion, assertionDirection)) .
\"urn:uuid:e661dcc2-e6ec-49fd-8854-a77073283e06"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAssertionDirection, ("The collection of possible inference ''directions'' that a #$CycLAssertion\ncan have.  A given CycL assertion's direction (see #$assertionDirection) \nindicates something about how and when the assertion can be used in inferences\nby the Cyc system.  More precisely: #$Backward-AssertionDirection indicates\nthat the assertion can only be used in inferences carried out when a query\nis asked; #$Forward-AssertionDirection indicates that the assertion can be used \nin inferences carried out at the time the assertion is added to the Knowledge \nBase as well as those carried out at ask-time; and #$Code-AssertionDirection\nindicates that the assertion itself cannot be used in either backward \n(ask-time) or forward (assert-time) inferences, but is instead implemented \nin the underlying code of the Cyc system.  Each CycL assertion has exactly \none of the above three directions; the default direction is Forward for \nground atomic assertions (see #$CycLClosedAtomicSentence) and Backward for \nrule assertions.  Note that a CycL sentence is given a direction at the time \nof its assertion to the system, and this fact _need_not_ be reflected in \nanother, #$assertionDirection assertion's being added to the system (as\nthat would of course lead to an infinite regress)."^^_string))) .
\"urn:uuid:8cf76359-89b1-4a91-bcc3-83b5da4d714c"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(CycLAssertionDirection)) .
\"urn:uuid:29805a9f-4aa6-4bd4-a4c2-de53cf344f34"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAtomicAssertion, ("A specialization of #$CycLAtomicSentence.  An instance ATOM of #$CycLAtomicSentence is also an instance of #$CycLAtomicAssertion just in case ATOM has been explicitly asserted to the Cyc Knowledge Base (see #$CycLAssertedAssertion), or deduced in the Knowledge Base by the Cyc inference engine (see #$CycLDeducedAssertion)."^^_string))) .
\"urn:uuid:00ab14ce-eda5-4938-863f-d908c2b147af"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAtomicSentence, ("The collection of syntactically well-formed atomic sentences in the CycL language. Each instance of #$CycLAtomicSentence consists of a CycL constant denoting a #$Predicate followed by one or more (closed or open) CycL terms, with the entire sequence enclosed in parentheses.  Thus CycL atomic sentences never contain other sentences as truth-functional components (see #$TruthFunction).  Note that ''atomic'' as used here specifically in connection with _sentences_, has a less strict meaning than it does when applied to terms generally, where it means ''not constructible from other terms via CycL syntax'' (see #$CycLAtomicTerm)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLAtomicSentence, ("CycAtomicFormula"^^_string))) .
\"urn:uuid:ba4a7eba-3c5a-4667-97c6-585df715dd09"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLAtomicTerm, CycLFormula)) .
\"urn:uuid:56619766-c1d9-4bed-b929-446a983d813d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLAtomicTerm, ("The collection of all atomic #$CycLDenotationalTerms (q.v.).  ''Atomic'' here means not constructible  from other CycL terms via the syntax of CycL.  Thus, subcollections  of #$CycLAtomicTerm include #$CycLConstant, #$CycLVariable, and #$SubLAtomicTerm.  Note that #$CycLAtomicTerm, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
\"urn:uuid:183df147-efe2-4286-82ab-1cfcdb98618f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedAtomicSentence, ("A #$CycLExpressionType and a specialization of both #$CycLAtomicSentence and #$CycLClosedSentence (qq.v.).  This is the collection of all and only the syntactically well-formed atomic sentences in the CycL language that contain no free variables.  Syntactically, each instance of #$CycLClosedAtomicSentence consists of a CycL expression denoting a #$Predicate followed by one or more (closed) CycL terms, with the entire sequence enclosed in parentheses.  Such sentences are sometimes called ''GAFs'' (an acronym for ''ground atomic formulas''); see also the specialization #$CycLFullyGroundAtomicSentence."^^_string))) .
\"urn:uuid:27828428-7477-4263-82da-7796752fd953"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedAtomicTerm, ("The collection of all closed #$CycLAtomicTerms.  ''Closed'' here means not containing any free (i.e. unbound) variables.  Since a variable itself is the only type of _atomic_ term that contains a variable (and contains it _free_, moreover, as a single occurrence of a variable can't bind itself), #$CycLClosedAtomicTerm has as instances all #$CycLAtomicTerms except #$CycLVariables.  Like all CycL atomic terms, Cycl closed atomic terms are ''denotational'' (see #$CycLDenotationalTerm).  Note that this collection, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
\"urn:uuid:2247af9d-d146-42a2-9269-c4d02a7f2052"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLClosedDenotationalTerm, Thing)) .
\"urn:uuid:41df80b6-dadc-4513-96e9-bb0b6a56087b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedDenotationalTerm, ("The collection of all closed denotational terms in the CycL language.  An expression is said to be ''closed'' if it contains no free variables (see #$CycLClosedExpression).  A CycL term is said to be ''denotational'' if it is the right sort of term to have a denotation (or value) in the universe of discourse (see #$CycLDenotationalTerm).  CycL sentences, while terms of CycL, are not considered denotational terms.  Each instance of #$CycLClosedDenotationalTerm is either a #$CycLClosedAtomicTerm (i.e. a #$CycLConstant or #$SubLAtomicTerm) or a #$CycLClosedNonAtomicTerm (i.e. a ''NAT'' with no free variables).  Examples of closed denotational terms include `#$Muffet', `(#$JuvenileFn #$Dog)', `(#$TheSetOf ?X (#$objectHasColor ?X GreenColor))', and `212'.  Note that these are also examples: `(#$BorderBetweenFn #$Canada #$Mexico)' (despite the fact that it fails actually to denote anything) and `(#$JuvenileFn #$isa #$genls #$JuvenileFn)'\n(despite the fact that it is not semantically well-formed)."^^_string))) .
\"urn:uuid:815def44-bf7c-403d-97d9-f8ebe479c4e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLClosedExpression, Thing)) .
\"urn:uuid:6e6b422b-af8c-4b20-8a12-e0a08fb53c7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedExpression, ("The collection of #$CycLExpressions that contain no free variables.  (A variable VAR occurs _free_ in an expression EXPR if and only if there is an occurrence of VAR in EXPR that is not bound by a quantifier or other #$ScopingRelation (q.v.) in EXPR.)  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing universal quantifiers are _not_ closed expressions (see #$CycLClosedSentence). Also cf. #$CycLOpenExpression."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLClosedExpression, ("CycClosedTerm"^^_string))) .
\"urn:uuid:8f63b76a-3da9-4551-8839-e50370c3f435"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedFormula, ("A specialization of both #$CycLFormula and #$CycLClosedExpression.  The collection of compound expressions of CycL that contain no free variables."^^_string))) .
\"urn:uuid:e348866a-97f6-4ffe-a372-9366a69f5854"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLClosedNonAtomicTerm, Thing)) .
\"urn:uuid:355a6797-705b-4395-a05d-59e805a88a5f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedNonAtomicTerm, ("The collection of closed, non-atomic denotational terms of the CycL language.  Each instance of #$CycLClosedNonAtomicTerm is a CycL term that contains no free variables, is constructible from other CycL terms via the syntax of CycL, and can have a denotatum (this last requirement excludes closed CycL sentences from #$CycLClosedNonAtomicTerm).  Examples: `(#$JuvenileFn #$Platypus)', `(#$JuvenileFn #$isa #$genls)', and `(#$TheSetOf ?X (#$objectHasColor ?X #$GreenColor))'.  Non-example: `(#$JuvenileFn ?X)'."^^_string))) .
\"urn:uuid:c4943abe-f4f7-4f1f-a29e-146b314ad6c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLClosedSentence, ("A specialization of both #$CycLSentence and #$CycLClosedExpression.  The collection of CycL sentences that contain no free variables.  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing universal quantifiers are <i>not</i> closed sentences (cf. #$CycLOpenSentence)."^^_string))) .
\"urn:uuid:c1bf9320-a5bc-4e73-989a-4fdb7daa04b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLClosedSentence, CycLNonAtomicTerm)) .
\"urn:uuid:a5c94cd3-50ac-482d-8d34-cda5fb3a0f4f"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLConstant, Thing)) .
\"urn:uuid:6a983671-4ae2-4a89-a70a-5dc3873959e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLConstant, ("The collection of all constants in the CycL language. #$CycLConstant has as instances all #$CycLAtomicTerms other than #$CycLVariables and #$SubLAtomicTerms (qq.v.).  Orthographically, CycL constants are those atomic terms (i.e. terms not constructable from other terms via CycL syntax) that are prefixed by '#$' in their printed (as opposed to their HTML-displayed) representations.  For example, '#$Dog' and '#$isa' are CycL constants, while other CycL terms like '?X', '42', and  '(#$GovernmentFn #$France)' are not."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLConstant, ("CycConstant"^^_string))) .
\"urn:uuid:52b46f4d-f58d-47a5-987e-a4246e155e76"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLDeducedAssertion, ("The subcollection of semantically well-formed #$CycLAssertions that are supported by at least one argument which is a deduction by Cyc's inference engine, as opposed to having been explicitly asserted to Cyc. A given assertion can have more than one argument, and can therefore be both a #$CycLAssertedAssertion and a #$CycLDeducedAssertion."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLDeducedAssertion, ("DeducedAssertion"^^_string))) .
\"urn:uuid:9e61c75e-2bda-4545-a1d4-a0935ce6204d"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(CycLDeducedAssertion)) .
\"urn:uuid:8fb31292-e910-4a95-941a-625af4e4874c"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLDenotationalTerm, Thing)) .
\"urn:uuid:e00f0ed3-3b65-405b-a88f-0bcafa21271f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLDenotationalTerm, ("The collection of all CycL terms that are not sentences (cf. #$CycLSentence), and thus are either #$CycLAtomicTerms (such as constants or variables) or #$CycLNonAtomicTerms (also known as ''NAT''s).   #$CycLDenotationalTerms are so-called, not because they all have denotations (not all of them do), but because they are in a certain sense the right kind of term for having a denotation.  That is, an instance of #$CycLDenotationalTerm -- if it is semantically well-formed and closed (i.e. contains no free variables) -- might denote something in the universe of discourse.  (Even so, it will not _necessarily_ denote something, considering (e.g.) the fact that a function need not be defined for every (sequence of) thing(s) satisfying its argument type constraints; see #$PartialFunction.)  But note that neither semantic well-formedness nor being closed is a requirement for being a CycL denotational term: `(#$JuvenileFn #$isa ?X #$genls #$JuvenileFn)', for example, is a NAT and thus a denotational term.  Other examples of denotational terms are the expressions: `#$Muffet', `?X', `(#$JuvenileFn ?X)', `(#$TheSetOf ?X (#$objectHasColor ?X #$GreenColor))', and `212'.  Note also that, like most instances of #$CycLExpressionType, #$CycLDenotationalTerm is a #$quotedCollection (q.v.)."^^_string))) .
\"urn:uuid:0e4938e9-96b4-4b09-9f3c-b0e84ad415b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'('CycLDenotationalTerm-Assertible', Thing)) .
\"urn:uuid:6fdc8a0b-7262-48cf-bfd2-6a0deeb223a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLDenotationalTerm-Assertible', ("A #$CycLExpressionType and a specialization of both #$CycLDenotationalTerm and #$CycLExpression-Assertible (qq.v.).  This is the collection of all CycL denotational terms that could appear within a sentence that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of #$CycLDenotationalTerm-Assertible is a denotational (i.e. non-logical) term that is both syntactically and semantically well-formed.  By definition, any CycL term is syntactically well-formed.  To be semantically well-formed, denotational term sentence must be either be atomic (see #$CycLAtomicTerm) or constructible via the syntax of CycL (see #$CycLNonAtomicTerm-Assertible) without violating any applicable arity or argument-type constraints (see #$arity and #$ArgTypePredicate).  A CycL term must be semantically well-formed in order to be interpretable as having a ''semantic value'', which for denotational terms means having a denotation.  Note that being ''assertible'' in the present sense does not require a sentence's actually being asserted in the KB."^^_string))) .
\"urn:uuid:7281ffdf-c446-4e39-89bf-70a8a68cdc01"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLExpression, Thing)) .
\"urn:uuid:3b432464-4d07-40e9-a640-e71e10def79d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLExpression, ("The collection of all (and only) expressions in the CycL language.  This includes all constants, variables, and formulas (i.e. non-atomic terms and sentences).  Each CycL expression is, trivially, a <i>syntactically</i> well-formed expression of CycL; but note that it might or might not be ''<i>semantically</i> well-formed'' (see #$CycLExpression-Assertible).  Also note that, since the CycL syntax allows any CycL expression to be used as a term, #$CycLExpression is coextensional with #$CycLTerm (q.v.)."^^_string))) .
\"urn:uuid:4486c09c-7cbf-46bd-9727-ab6d2fb94afc"[silk#strict] .
istAsserted(UniversalVocabularyMt, coExtensional(CycLExpression, CycLTerm)) .
\"urn:uuid:00aaf2bd-6ad0-4edb-8b5e-2e45c0f33072"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLExpression-Askable', ("The collection of #$CycLExpressions\nthat are either themselves askable as queries to the Cyc system (see \n#$CycLSentence-Askable) or could appear as non-atomic terms within \nsentences that could be so asked (see #$CycLNonAtomicTerm-Askable). \nMore precisely, each instance of #$CycLExpression-Askable is a CycL \nexpression that is constructible via the syntax of CycL without \nviolating any applicable arity constraints (see #$arity).  Note that \naskable CycL expressions do not necesarily obey other semantic \nconstraints beyond arity, such as argument-type constraints (see \n#$ArgTypePredicate); thus they are not always semantically \nwell-formed in the fullest sense (cf. #$CycLExpression-Assertible)."^^_string))) .
\"urn:uuid:fb7c506f-16cd-4179-b8b7-617d497cc0d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLExpression-Assertible', ("A #$CycLExpressionType.  The collection  of all compound CycL expressions that either could themselves be asserted to the  Cyc Knowledge Base (see #$CycLSentence-Assertible) or could appear as denotational terms within sentences that could be so asserted (see #$CycLDenotationalTerm-Assertible).  More precisely, each instance of #$CycLExpression-Assertible is a CycL expression that is both syntactically and semantically well-formed.  By definition, any compound CycL expression is  syntactically well-formed.  To be semantically well-formed, a CycL expression  must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see #$arity and #$ArgTypePredicate).  A CycL expression must be semantically well-formed in order to be interpretable as having a ''semantic value'', such as a truth-value (if the expression is a sentence) or a denotation (if it's a #$CycLDenotationalTerm).  Note that being ''assertible'' in the present sense does not require an expression's actually being asserted in (or being a component of something asserted in) the KB."^^_string))) .
\"urn:uuid:b431c0e8-91e5-4e07-8575-de9bd5115d1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLExpressionType, ("A collection of collections.  Each instance of #$CycLExpressionType is a type (i.e. a subcollection) of #$CycLExpression."^^_string))) .
\"urn:uuid:98371762-1077-418a-a440-db3ca45cf43e"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLFormula, Thing)) .
\"urn:uuid:3031dda0-323c-4f02-938c-89977e874b12"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLFormula, ("The collection of compound CycL expressions.  Each instance of #$CycLFormula consists of a CycL expression that denotes a relation (e.g. a #$Predicate, #$Function-Denotational, or #$TruthFunction) -- or at least an expression that could be interpreted as having a relation as its semantic value (see #$CycLGenericRelationFormula) -- followed by one or more CycL terms (see #$CycLTerm), with the entire sequence enclosed in parentheses.  For example, (#$isa #$Muffet #$Poodle) and (#$BirthFn #$Muffet) are both CycL formulas.  Two important specializations of #$CycLFormula are #$CycLNonAtomicTerm (whose instances are also called ''denotational formulas'') and #$CycLSentences (whose instances are also called ''logical formulas'').  Note that this notion of ''formula'' differs somewhat from that used in formal logic, where a formula is normally defined as an (atomic or non-atomic, quantificationally closed or open) sentence."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLFormula, ("RelationExpression"^^_string))) .
\"urn:uuid:2a416e3d-6b5b-4f8c-88a0-1359c56bd910"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLFormulaicSentence, ("A subcollection of syntactically well-formed sentences of the CycL language. Each instance of #$CycLFormulaicSentence consists of a CycL expression denoting an instance of #$TruthFunction (e.g., an instance of #$Predicate or #$SententialRelation) followed by one or more CycL terms (see #$CycLTerm), with the entire sequence enclosed in parentheses. For example, (#$isa #$Collection #$Thing) and (#$genls ?FOO #$SpatialThing) are both formulaic CycL sentences. The only two CycL sentences that are not formulaic are #$True and #$False. Note that #$CycLFormulaicSentences need not obey arity constraints (see #$arity) or other semantic constraints (such as argument type constraints ; see #$ArgTypePredicate). #$CycLFormulaicSentences are also called ''logical formulas'', and are to be distinguished from ''denotational formulas'' (which are also known as ''NAT''s; see #$CycLNonAtomicTerms). Note that this notion of a formulaic CycL sentence is broader than the notion of ''sentence'' standardly used in formal logic, where a sentence is defined as a _closed_ well-formed formula: formulaic CycL sentences may be _open_ (i.e., contain free variables; see #$CycLOpenSentence)."^^_string))) .
\"urn:uuid:679e2cdd-bab4-409c-8691-393bad6de6da"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLGAFAssertion, ("A #$CycLExpressionType and a specialization of both #$CycLAtomicAssertion and #$CycLClosedAtomicSentence (qq.v.).  This is the collection of all and only the closed atomic CycL sentences that have been asserted to the Knowledge Base or deduced there by the inference engine.  GAF assertions typically express particular facts (as opposed to general rules) about the world.  The acronym `GAF' stands for ''ground atomic formula''; see #$CycLClosedAtomicSentence.\n<p>\nAt the epistemological level (see #$ELExpression), a GAF assertion contains no free variables and is thus (at least) ''ground''.  At the heuristic level (see #$HLExpression), however, the #$HLAssertion(s) representing the GAF assertion -- the sentence(s) that are actually stored in the KB -- contain no variables whatsoever and are thus ''_fully_ ground'' (see #$CycLFullyGroundAtomicSentence).  For example, if the ground atomic sentence\n<p>\n(#$isa (#$TheSetOf ?X (#$objectHasColor ?X #$GreenColor)) #$Thing)\n<p>\nwere asserted it would be a GAF assertion, and it would be represented in the KB by some fully ground atomic sentence(s) containing no variables at all."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLGAFAssertion, ("GAFAssertion"^^_string))) .
\"urn:uuid:34fefd1f-c53c-4e40-b6f7-305acfee372c"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(CycLGAFAssertion)) .
\"urn:uuid:df9c98eb-dd1a-4627-9dac-2dd7474a0cb9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLGenericRelationFormula, ("A subcollection of #$CycLFormula (q.v.).  Each instance of that #$CycLGenericRelationFormula is a CycL formula that begins (immediately after the opening parenthesis) with a variable or other open expression (see #$CycLOpenExpression); i.e. it has an open expression in its ''0th'' or ''arg0'' position.  A CycL generic relation formula thus consists \nof an open expression followed by some number of terms, with the entire sequence \nenclosed in parentheses.  But note that the open expression in the formula's \narg0 position must be such that, given the syntax and intended semantics of CycL, it could conceivably have a #$Relation -- i.e. a #$Function-Denotational or a #$TruthFunction (such as a #$Predicate or #$LogicalConnective) -- as its semantic value.  Hence the arg0 open expression might be a variable, as in the generic relation formula `(?RELATION #$Muffet #$Dog)'; or it might be an appropriate open non-atomic term (or ''NAT''; see #$CycLNonAtomicTerm), as in \n`((#$Kappa (?ARG1) (#$knows ?ARG1 ?ARG2)) #$Muffet)'; or it might itself be \na generic relation formula, as in `((?REL ?ARG1 #$Dog) #$Muffet)'.  On the \nother hand, `((#$BorderBetweenFn ?ARG1 ?ARG2) #$Muffet #$Dog)' is not a \n#$CycLGenericRelationFormula, since #$BorderBetweenFn only returns instances \nof #$Border, which is disjoint with #$Relation; thus the open NAT \n`(#$BorderBetweenFn ?ARG1 ?ARG2)' couldn't possibly have a #$Relation as its \nsemantic value, no matter what values were assigned to the variables `?ARG1' \nand `?ARG2'."^^_string))) .
\"urn:uuid:e65fdd29-c392-4a04-b67c-704a21ff5866"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLGenericRelationFormula, CycLNonAtomicTerm)) .
\"urn:uuid:06cf2fd4-c77f-4ae3-8b74-7f4cc5b1997a"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLIndexedTerm, Thing)) .
\"urn:uuid:8531c36b-9e71-42a2-b46f-fa7cb76027c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLIndexedTerm, ("The collection of indexed or indexable terms in the CycL language.\nThis includes reified HL terms as well as reifiable EL NATs and assertions."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLIndexedTerm, ("CycIndexedTerm"^^_string))) .
\"urn:uuid:e76550a3-cf81-41e8-b83b-71a0f84de3fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLNonAtomicReifiedTerm, Thing)) .
\"urn:uuid:998d3762-b30c-4711-9853-101fb488f086"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLNonAtomicReifiedTerm, ("The subcollection of #$CycLReifiableNonAtomicTerms that are reified in the KB. Example: (#$JuvenileFn #$Dog).  Counterexample: (#$JuvenileFn #$Platypus), because that term is not currently reified in the KB.  These are often called NARTs, which stands for 'non-atomic reified term'."^^_string))) .
\"urn:uuid:10f26ca6-eba8-495a-94cf-395e119a89e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLNonAtomicTerm, Thing)) .
\"urn:uuid:7d5be430-a341-4836-93ce-3b1121bff48e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLNonAtomicTerm, ("A #$CycLExpressionType and a specialization of both #$CycLFormula \nand #$CycLRepresentedTerm (qq.v.).  #$CycLNonAtomicTerm is the \ncollection of non-atomic denotational terms in the CycL language.  \nA CycL term is _non-atomic_ if it is constructible from other CycL \nterms via the syntax of CycL.  A CycL term is said to be \n''denotational'' if it is the type of term that can have a \ndenotatum (or assigned value; see #$CycLDenotationalTerm).  \n#$CycLNonAtomicTerm thus includes all CycL denotational terms \nexcept constants and variables.  A CycL non-atomic term (or ''NAT'') \nconsists of a CycL expression denoting a #$Function-Denotational \nfollowed by one or more CycL terms, with the entire sequence \nenclosed in parentheses.  The NAT itself denotes the value (if any) \nof this function for the denotations of the other terms taken as \narguments.  (If there is no such value then the NAT has no denotatum;\nsee #$undefined.)  NATs are also known as ''denotational formulas'', \nin contrast to ''logical formulas'' (i.e. sentences).  Currently, \nthere are two main types of NAT: (i) #$HLNonAtomicReifiedTerms (or \n''NART''s), which are a type of #$HLReifiedDenotationalTerm and are \nimplemented with data structures that have indexing that enables all \nuses of the NAT to be retrieved, and (ii) #$ELNonAtomicTerms (or \n''NAUT''s), which have no such indexing and remain in the \nform of an EL expression in the assertions in which\nthey occur."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLNonAtomicTerm, ("NonAtomicTerm"^^_string))) .
\"urn:uuid:e9058cc1-a47c-4c08-a5c8-9ac116c81608"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLNonAtomicTerm-Askable', ("The collection of #$CycLNonAtomicTerms\nthat can appear within sentences that are askable as queries to the Cyc system\n(see #$CycLSentence-Askable).  More precisely, each instance of \n#$CycLNonAtomicTerm-Askable is a CycL non-atomic term that is constructible via \nthe syntax of CycL without violating any applicable arity constraints (see \n#$arity).  Note that askable CycL non-atomic terms do not necesarily obey other \nsemantic constraints beyond arity, such as argument-type constraints (see \n#$ArgTypePredicate); thus they are not always semantically well-formed in \nthe fullest sense (cf. #$CycLNonAtomicTerm-Assertible)."^^_string))) .
\"urn:uuid:b797be88-ef81-4d58-9df5-f8447c3fe24e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLNonAtomicTerm-Assertible', ("A #$CycLExpressionType and a specialization of both #$CycLExpression-Assertible and #$CycLNonAtomicTerm (qq.v.).  The collection of all CycL non-atomic terms that could appear within a sentence that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of #$CycLNonAtomicTerm-Assertible is a non-atomic term that is both syntactically and semantically well-formed.  By definition, any CycL non-atomic term is syntactically well-formed.  To be semantically well-formed, a non-atomic term sentence must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see #$arity and #$ArgTypePredicate).  A CycL term must be semantically well-formed in order to be interpretable as having a ''semantic value'', which for terms means having a denotation.  Note that being ''assertible'' in the present sense does not require a sentence's actually being asserted in the KB."^^_string))) .
\"urn:uuid:c0322f8c-313f-45d4-8474-cbe8fe996e95"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLNonAtomicTerm-ClosedFunctor', ("The subcollection of denotational #$CycLNonAtomicTerms which have no free variable in the arg0 position.\nExamples: (#$JuvenileFn #$Platypus), (#$JuvenileFn #$isa #$genls), (#$TheSetOf ?X (#$colorOfType ?X #$GreenColor)), (#$JuvenileFn ?X).  Counterexample: (?SOMEFN #$Gold) ((#$USDollarFn ?YEAR) 5)."^^_string))) .
\"urn:uuid:3cdb341d-7093-4e1a-87e2-6bf19544bd4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLOpenDenotationalTerm, ("The collection of all open denotational terms in the CycL language.  An expression is ''open'' if it contains one or more free variables (see #$CycLOpenExpression).  A CycL term is said to be ''denotational'' if it is the right sort of term to have a denotation (or value) in the universe of discourse (see #$CycLDenotationalTerm).  Each instance of #$CycLOpenDenotationalTerm is either a #$CycLOpenNonAtomicTerm (i.e. a ''NAT'' with a free variable) or a #$CycLVariable itself.  Examples include `?X', `(#$JuvenileFn ?X)', and `(#$JuvenileFn #$isa ?X #$genls #$JuvenileFn)' (even though the latter is semantically ill-formed)."^^_string))) .
\"urn:uuid:5dd976d0-4e12-4571-a308-3cf4f501496b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLOpenExpression, ("A specialization of #$CycLExpression.  The collection of CycL expressions that contain one or more free variables.  A #$CycLVariable VAR occurs _free_ in an expression EXPR if and only if there is an occurrence of VAR in EXPR that is not bound by another term in EXPR that denotes a #$Quantifier or other #$ScopingRelation (q.v.).  For example, the expression `(#$isa ?X #$Cat)' is open, but `(#$thereExists ?X (#$isa ?X #$Cat))' is not."^^_string))) .
\"urn:uuid:45935fd8-c1f7-40f7-bc42-4f36ddb05a83"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLOpenExpression, CycLClosedExpression)) .
istAsserted(BookkeepingMt, oldConstantName(CycLOpenExpression, ("CycOpenTerm"^^_string))) .
\"urn:uuid:eed1ef68-66a3-46cc-b9c6-f37982c9e231"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLOpenFormula, ("A specialization of both #$CycLOpenExpression and #$CycLFormula (qq.v.).  The collection of compound CycL expressions that contain one or more free variables."^^_string))) .
\"urn:uuid:4d7e4733-af48-4930-ac14-cb4b9d22cbd7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLOpenNonAtomicTerm, ("The collection of denotational #$CycLNonAtomicTerms that have free variables. Examples: `(#$JuvenileFn ?X)', `(#$JuvenileFn ?X ?Y ?Z)'.  Counterexample: `(#$TheSetOf ?X (#$objectHasColor ?X #$GreenColor))'."^^_string))) .
\"urn:uuid:1fb16d83-ec07-4613-9c22-7695c4dabd77"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLOpenSentence, CycLOpenDenotationalTerm)) .
\"urn:uuid:553756ee-9c17-47c3-a94a-26185ba98c4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLOpenSentence, ("A specialization of both #$CycLOpenExpression and #$CycLSentence. The collection of CycL sentences that contain one or more free variables.  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing initial universal quantifiers are in fact #$CycLOpenSentences."^^_string))) .
\"urn:uuid:223acd4c-865e-4be0-9a53-cabeb9024cbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLPropositionalSentence, ("The collection of CycL sentences that express propositions (see #$Proposition).  Two necessary conditions for a CycL sentence's expressing a proposition is that it be closed (see #$CycLClosedSentence) and not violate any applicable arity constraints (see #$CycLSentence-Askable)."^^_string))) .
\"urn:uuid:9b195789-3df8-4ad0-bcad-5f5226b0d44c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLReformulationRulePredicate, ("The collection of #$Predicates which may appear as the operator in a #$CycLReformulatorRule."^^_string))) .
\"urn:uuid:dbc98249-66c6-4430-987c-70e930cc84cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLReifiableDenotationalTerm, Thing)) .
\"urn:uuid:83134093-be07-491d-abbd-77da3e4f5c57"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLReifiableDenotationalTerm, ("A subcollection of both #$CycLClosedDenotationalTerm and #$CycLIndexedTerm (qq.v.).  #$CycLReifiableDenotationalTerm is the collection of all CycL terms that both may be reified and may denote something in the universe of discourse. It thus includes all instances of #$CycLConstant as well as any NAT (see #$CycLNonAtomicTerm) whose main functor denotes an instance of #$ReifiableFunction.\n<p>\nFor example, the NAT '(#$GovernmentFn #$France)' is a #$CycLReifiableDenotationalTerm, since #$GovernmentFn is a #$ReifiableFunction.  Similarly,  '(#$JuvenileFn #$Platypus)' is a CycL reifiable denotational term; although it is not currently reified in the KB, it is reifiable and denotational (see #$CycLClosedDenotationalTerm).  Finally, '(#$BorderBetweenFn #$Canada #$Mexico)' is a CycL reifiable denotational term; although it happens not to denote anything in the universe of discourse, it is nonetheless the kind of NAT that can and usually does denote.\n<p>\nNote that #$CycLVariables are not considered reifiable terms."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLReifiableDenotationalTerm, ("ReifiableTerm"^^_string))) .
\"urn:uuid:88f563c7-6b54-47af-95c7-b3cf35f0aea0"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLReifiableNonAtomicTerm, Thing)) .
\"urn:uuid:a2d30523-eef4-4447-bbaf-2a758976e9a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLReifiableNonAtomicTerm, ("A collection of Cyc terms that are NATs (#$CycLNonAtomicTerms; see\n#$Function-Denotational) whose functor is an instance of\n#$ReifiableFunction. E.g., since #$GovernmentFn is an instance of\n#$ReifiableFunction, it is true that (#$GovernmentFn #$France) is a\n#$CycLReifiableNonAtomicTerm."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLReifiableNonAtomicTerm, ("ReifiableNAT"^^_string))) .
\"urn:uuid:2f8f3404-f7a8-4a7b-9f49-44109dc1c066"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLReifiedDenotationalTerm, ("The collection of denotational terms in the CycL language which are\nreified in the KB.  Examples include #$Muffet and (#$JuvenileFn #$Dog); a\ncounterexample would be (#$JuvenileFn #$Platypus) because that term is not\ncurrently reified in the KB.  These are often called 'FORTs', which stands for\n'first-order reified terms'"^^_string))) .
\"urn:uuid:23cd7b02-e0d9-4dca-bf00-cbd221d2eba6"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLReifiedDenotationalTerm, Thing)) .
\"urn:uuid:cb8f07cb-477e-40d3-a181-38d91bcfda1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLRepresentedAtomicTerm, ("A specialization of #$CycLAtomicTerm.  An instance ATOM of #$CycLAtomicTerm is also an instance of #$CycLRepresentedAtomicTerm just in case ATOM is explicitly represented in the CycL language (as opposed to being represented in SubL, the underlying implementation language of the Cyc system).  Important specializations of #$CycLRepresentedAtomicTerm include #$CycLVariable and #$CycLConstant."^^_string))) .
\"urn:uuid:b2102a01-62b6-4324-b68b-b1c5b20ee388"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLRepresentedAtomicTerm, SubLAtomicTerm)) .
\"urn:uuid:3bc9f06c-a5af-4573-9b3f-bc320e5b25f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLRepresentedTerm, Thing)) .
\"urn:uuid:a4599025-3b69-4714-be25-e3aa4c4fde21"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLRepresentedTerm, ("The collection of all denotational terms that are represented in the CycL language, instead of being defined in SubL, the underlying implementation language used by Cyc.  That is, each instance of #$CycLRepresentedTerm is either (i) an atomic term, and thus also an instance of #$CycLRepresentedAtomicTerm (q.v.), or (ii) a non-atomic term (or ''NAT''), and has a #$CycLRepresentedTerm as its arg0 functor (the other arguments in the NAT\nneed not be CycL represented terms).  Thus #$CycLRepresentedTerm has as instances all #$CycLConstants, all #$CycLVariables, and all #$CycLNonAtomicTerms."^^_string))) .
\"urn:uuid:c20a6cbd-a55d-42f1-bc00-110e37d9a2a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLRuleAssertion, ("The subcollection of semantically well-formed #$CycLAssertions whose formulas are rules.\nMore precisely, the formulas are not\nGAFs (see #$CycLGAFAssertion), so they either have more than one literal (and therefore are\nnon-atomic) or they quantify over some free variables (and therefore are non-ground).\nAny free variables are implicitly universally quantified."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLRuleAssertion, ("RuleAssertion"^^_string))) .
\"urn:uuid:9d863785-03b3-4693-81f4-7127c06c8c6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLRuleAssertion, CycLGAFAssertion)) .
\"urn:uuid:7f497c77-9453-4183-8176-156d2b1511fa"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(CycLRuleAssertion)) .
\"urn:uuid:a54479fe-929e-4eb8-841e-9a20126b3176"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLSentence, ("The collection of syntactically well-formed sentences of the CycL language.  Each instance of #$CycLSentence consists of a CycL expression denoting an instance of #$TruthFunction (e.g. an instance of #$Predicate or #$SententialRelation) followed by one or more CycL terms (see #$CycLTerm), with the entire sequence enclosed in parentheses.  \n<p>\nFor example, (#$isa #$Collection #$Thing) and (#$genls ?FOO #$SpatialThing) are both CycL sentences.  Note that #$CycLSentences <i>need not</i> obey arity constraints (see #$arity) or other semantic constraints (such as argument type constraints; see #$ArgTypePredicate).  Thus, for example, (#$genls ?FOO #$SpatialThing #$EiffelTower) is a CycL sentence.\n<p>\n#$CycLSentences are also called ''logical formulas'', and are to be distinguished from ''denotational formulas'' (which are also known as ''NAT''s; see #$CycLNonAtomicTerms).  Note that this notion of a CycL sentence is broader than the notion of ''sentence'' standardly used in formal logic, where a sentence is defined as a <i>closed</i> well-formed formula: CycL sentences may be <i>open</i> (i.e. they may contain free variables; see the specialization #$CycLOpenSentence)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLSentence, ("CycSyntacticFormula"^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLSentence, ("ConstraintLanguageExpression"^^_string))) .
\"urn:uuid:11187e02-95a7-43a6-a70e-e017d2ed7bf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLSentence, CycLGenericRelationFormula)) .
\"urn:uuid:fc7c1f28-5926-4ca8-9f41-7af76fdda934"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLSentence, CycLNonAtomicTerm)) .
\"urn:uuid:f02218a0-12c2-4f76-bd16-8a770632ce59"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLSentence-Askable', ("The collection of #$CycLSentences that are askable as queries to the Cyc system.  More precisely, each  instance of #$CycLSentence-Askable is a CycL sentence that is  constructible via the syntax of CycL without violating any applicable  arity constraints (see #$arity).  Note that askable CycL sentences do  not necessarily obey other semantic constraints beyond arity, such as  argument-type constraints (see #$ArgTypePredicate); thus they are  not always semantically well-formed in the fullest sense (cf.  #$CycLSentence-Assertible).  The idea behind this criterion of  ''askability'' is that such a sentence, even if it isn't true or false (which it can't be unless it also obeys all argument-type  constraints), at least ''makes enough sense'' to be asked as a query  to the Cyc system."^^_string))) .
\"urn:uuid:7fda7b01-015d-4a25-9d1a-c0637fc3dad5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLSentence-Assertible', ("An instance of #$CycLExpressionType and a specialization of #$CycLExpression-Assertible and #$CycLSentence-Askable.  This is the collection of all CycL sentences that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of #$CycLSentence-Assertible is a CycL sentence that is both syntactically and semantically well-formed.  By definition, any CycL sentence is syntactically well-formed.  To be semantically well-formed, a CycL sentence must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see #$arity and #$ArgTypePredicate).  A CycL sentence must be semantically well-formed in order to be interpretable as having a ''semantic value'', which for sentences means having a truth value.  Note that being ''assertible'' in the present sense does not require a sentences's actually being asserted in the KB."^^_string))) .
\"urn:uuid:42db9d4c-2fc4-4c5d-8f1e-b09185e6c0c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('CycLSentence-ClosedPredicate', ("The subcollection of #$CycLSentences whose arg0 does not contain a free variable although free variables may occupy other argument positions."^^_string))) .
\"urn:uuid:002397e0-90ba-4e46-b31c-62de69e37699"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith('CycLSentence-ClosedPredicate', 'CycLNonAtomicTerm-ClosedFunctor')) .
\"urn:uuid:98dd9dbf-c78c-4632-a7c2-9b98b1e1b5ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(CycLTerm, Thing)) .
\"urn:uuid:f131f797-6d83-47aa-be15-414d19e5e027"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLTerm, ("The collection of all syntactically well-formed   expressions in the CycL language that can be used as terms, i.e. that can be combined with other expressions to form non-atomic terms or formulas.  Since the grammar of the CycL language allows any CycL expression to be used as a term, #$CycLTerm and #$CycLExpression are coextensional collections."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(CycLTerm, ("CycTerm"^^_string))) .
\"urn:uuid:92838b0f-0851-4bcc-9713-c661b1218154"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLTruthValueSentence, ("A collection of CycL sentences containing only the CycL sentences <code>#$True</code> and <code>#$False</code>, both of which are sentential constants."^^_string))) .
\"urn:uuid:f225da64-6a89-4e58-b024-bb50bcc7c7e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(CycLTruthValueSentence, CycLFormulaicSentence)) .
\"urn:uuid:0dcd74db-b7e5-42c0-9d75-c7d7ea21e160"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertibleCollection(CycLTruthValueSentence)) .
\"urn:uuid:0c1f3814-8534-4c94-8892-09be0c7d69e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycLVariable, ("The collection of all variables in the CycL language.\nA #$CycLVariable is a character string consisting of a question mark '?' (as its initial character) followed by one or more characters, where each of these latter characters is either an (upper- or lower-case) Roman letter, an Arabic numeral (i.e. '0' through '9'), a hyphen ('-'), an underscore ('_'), or another question mark.  (The letters occurring in a CycL variable used in an actual assertion will typically be all uppercase; but this convention is not enforced in any formal way.)  Examples: '?WHAT', '?OBJ-TYPE', and '?var0'."^^_string))) .
\"urn:uuid:1e4ba627-df23-430d-a9fb-4d12f3426ecc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProblemFn, (2), CycProblemStore)) .
\"urn:uuid:697a3fe4-8c23-4cd5-85f3-b96969abe12c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProblemFn, (1), NonNegativeInteger)) .
\"urn:uuid:37d52ef8-10c7-4c7e-af02-8f6f72f6d475"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProblemLinkFn, (2), CycProblemStore)) .
\"urn:uuid:8c386091-7d4f-4865-9291-b4b05b9f0eab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProblemLinkFn, (1), NonNegativeInteger)) .
\"urn:uuid:13fa5759-20c5-4e2b-a9a5-abf58955fa10"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProblemStoreFn, (1), NonNegativeInteger)) .
\"urn:uuid:5ff4a2a3-92de-44fa-bf6b-fa54615e472b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProofFn, (2), CycProblemStore)) .
\"urn:uuid:ec2db86a-db03-4033-855c-c2fbdad5ef61"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycProofFn, (1), NonNegativeInteger)) .
\"urn:uuid:f9afceff-8e99-4250-bf81-589b2f7d8b15"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(CycProvabilityStatus)) .
istAsserted(BookkeepingMt, oldConstantName(CycSupportDatastructure, ("CycLSupportDatastructure"^^_string))) .
\"urn:uuid:16c16ed6-2a0c-44c3-9c32-4e5b15f171e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycTacticFn, (2), CycTactic)) .
\"urn:uuid:d390e268-26aa-4a41-b5a6-85fa4adf3d31"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(CycTacticFn, (1), NonNegativeInteger)) .
\"urn:uuid:fef34f50-0764-45bb-9578-aaaf51a84bd0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(CycTransformationProof, ("The subclass of #$CycProof each of whose instances uses a #$CycLRuleAssertion to prove a query."^^_string))) .
\"urn:uuid:709769d9-6edc-4aea-92e9-d9de72255a43"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Cyclist, ("A specialization of #$IndividualAgent. Each instance of #$Cyclist is an agent (usually a person) entitled to inspect and modify the Cyc knowledge base."^^_string))) .
\"urn:uuid:17d7b6dd-fee3-4690-ad54-3905cd8d841c"[silk#strict] .
istAsserted(BaseKB, comment(CyclistDefinitionalMt, ("The microtheory in which instances of #$Cyclist are defined.  Assertions about them belong in #$CyclistsMt."^^_string))) .
\"urn:uuid:556572ba-6923-46c1-a8ec-dc1b5942e8b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DateDecodeStringFn, ("(#$DateDecodeStringFn TEMPLATE DATE-STRING) returns a #$Date which is the result of decoding DATE-STRING by the format described by the TEMPLATE string.  For example,   (#$DateDecodeStringFn 'MM/DD/YYYY' '07/20/1969') would return (#$DayFn 20 (#$MonthFn #$July (#$YearFn 1969))).   See also #$DateEncodeStringFn."^^_string))) .
\"urn:uuid:b108d093-ba89-4ad0-9271-1e02ec9e84bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(DateDecodeStringFn, (2), CharacterString)) .
\"urn:uuid:6f8d636f-5a7e-4b7c-87ac-99b4b2d74fee"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(DateDecodeStringFn, (1), CharacterString)) .
\"urn:uuid:bccbff08-7817-4da8-bf1b-993604d84a2b"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(DateDecodeStringFn, SubLSymbolFn(("CYC-DATE-DECODE-STRING"^^_string)))) .
\"urn:uuid:caf70592-c9aa-4a43-bbae-b7a2f57cedf1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DateEncodeStringFn, ("(#$DateEncodeStringFn TEMPLATE DATE) returns a string encoding of DATE (an instance of #$Date) in the format described by the TEMPLATE string.  For example,    (#$DateEncodeStringFn 'MM/DD/YYYY'      (#$DayFn 20 (#$MonthFn #$July (#$YearFn 1969))))  would return '07/20/1969'.  See also #$DateDecodeStringFn."^^_string))) .
\"urn:uuid:33460d9a-875f-4bd7-8f9e-d93242dd2ecf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(DateEncodeStringFn, (1), CharacterString)) .
\"urn:uuid:a8cc2164-2c33-4d88-8e12-ead5afaa175c"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(DateEncodeStringFn, SubLSymbolFn(("CYC-DATE-ENCODE-STRING"^^_string)))) .
\"urn:uuid:33c021b9-45ba-46ed-8d4e-19e481b0bfb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationResultQuotedIsa(DateEncodeStringFn, SubLString)) .
\"urn:uuid:16610f12-cb4e-4cfa-b458-b23e173b45f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(DayOfWeekType)) .
\"urn:uuid:d9e8d70f-1528-4460-b655-a4e203dd3e9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DayOfWeekType, ("A collection of collections and a specialization of #$WeeklyTemporalObjectType.\nEach instance of #$DayOfWeekType is a collection of #$CalendarDays, all of\nwhose instances correspond to the same particular ''day of the week'' in \nthe respective weeks in which they occur.  For example, #$Monday -- the \ncollection of all mondays -- is an instance of #$DayOfWeekType."^^_string))) .
\"urn:uuid:ea3cc659-d976-4826-9621-719685881f3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(December, ("A specialization of #$CalendarMonth.  Each instance of #$December is the twelth and final month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(December, MetaVariableFn(("DECEMBER"^^_string)))) .
\"urn:uuid:ad7a9a9b-f9da-4815-b8f5-0bac855b612d"[silk#strict] .
istAsserted(BaseKB, comment(DefaultFalse, ("An instance of #$CycHLTruthValue.  #$DefaultFalse is the attribute of being assumed false unless otherwise known to be true."^^_string))) .
\"urn:uuid:aec9c23f-6457-4532-88d8-9ef11d7d08a4"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(DefaultFalse, False)) .
\"urn:uuid:b633f4b3-02a6-46c5-8b07-beb4ebf1c75d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DefaultMonotonicPredicate, ("A collection of predicates.  Each instance of #$DefaultMonotonicPredicate is a predicate whose use as the predicate of a locally asserted ground formula causes that formula to be entered, by default, as :MONOTONIC.  Examples: #$isa, #$genls, #$disjointWith, #$equals, #$arity, #$arg1Isa."^^_string))) .
\"urn:uuid:be29232f-b522-40e4-a086-25a91654d41c"[silk#strict] .
istAsserted(BaseKB, comment(DefaultTrue, ("An instance of #$CycHLTruthValue.  #$DefaultTrue is the attribute of being assumed true unless otherwise known to be false."^^_string))) .
\"urn:uuid:e1a854af-ca1b-41b2-a52f-92b46aecaa31"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DifferenceFn, ("A binary #$MathematicalFunctionOnScalars and an extension of the arithmetic subtraction operation to #$ScalarIntervals (q.v.) generally.  When applied to two arithmetically-comparable scalars, <code>MINUEND</code> and <code>SUBTRAHEND</code>, #$DifferenceFn yields the scalar that is the result of subtracting <code>SUBTRAHEND</code> from <code>MINUEND</code>.  For example, (#$DifferenceFn 88 11) is 77 and (#$DifferenceFn (#$Kilogram 4.2) (#$Kilogram 3)) is (#$Kilogram 1.2).\n<p>\nNote that when <code>MINUEND</code> and <code>SUBTRAHEND</code> are not arithmetically-comparable, <code>(#$DifferenceFn MINUEND SUBTRAHEND)</code> is undefined.  For example, (#$DifferenceFn (#$MinutesDuration 1) (#$Meter 3)) is undefined, since (#$MinutesDuration 1) is a #$Time-Quantity and (#$Meter 3) is a #$Distance, and time-quantities are not comparable with distances.\n<p>\nFor addition, see #$PlusFn."^^_string))) .
\"urn:uuid:351eb175-f830-420f-b195-e23c59d6faed"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(DifferenceFn, (2), ScalarInterval)) .
\"urn:uuid:000e39a1-09d9-439e-bfe1-c0e0a7d5a5d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(DifferenceFn, (1), ScalarInterval)) .
istAsserted(BookkeepingMt, oldConstantName(DifferenceFn, ("Difference"^^_string))) .
\"urn:uuid:076914f9-6f18-45ae-9ac3-fdf9d091c3a2"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(DifferenceFn, SubLSymbolFn(("CYC-DIFFERENCE"^^_string)))) .
\"urn:uuid:c32c4d35-faf4-4a7a-ae6a-38256b704951"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DirectedMultigraph, ("A specialization of both #$DirectedPathSystem and #$Multigraph.  Each instance of #$DirectedMultigraph is a multigraph in which every link has one direction.  Note that there can be loops and multiple links between a pair of nodes in a given instance of #$DirectedMultigraph."^^_string))) .
\"urn:uuid:bd5a581c-73ce-4e0c-86e3-907353656fee"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DisjointCollectionType, ("A collection of collections of collections and a specialization of #$SiblingDisjointCollectionType (q.v.).  A disjoint collection type is such that its instances are collections that are all disjoint from one another.  That is, each instance <code>DISCOLTYPE</code> of #$DisjointCollectionType is a collection whose instances are mutually disjoint collections: no two instances of <code>DISCOLTYPE</code> have any instances in common.  Instances of #$DisjointCollectionType include #$BiologicalSpecies and #$SportsTeamTypeBySport."^^_string))) .
\"urn:uuid:b960183c-ddbb-436f-ae47-62c32bf1ab3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DistributingMetaKnowledgePredicate, ("A subcollection of #$MetaKnowledgePredicate (q.v.).  Each instance of #$DistributingMetaKnowledgePredicate is a meta-knowledge predicate that can be used to make meta-assertions (i.e it can take a #$CycLAssertion as an argument) and is such that, when applied to an EL-level assertion that polycanonicalizes (i.e. gets transformed by the Cyc canonicalizer into multiple HL-level assertions), it is automatically ''distributed'' over each of the multiple assertions resulting from the polycanonicalization.\n<p>\nLet METAPRED be an instance of #$DistributingMetaKnowledgePredicate. Suppose that one asserts <code>(METAPRED ASSERTION FOO)</code> and that <code>ASSERTION</code> polycanonicalizes into <code>ASSERTION1</code> and <code>ASSERTION2</code>.  Then <code>(METAPRED ASSERTION1 FOO)</code> and <code>(METAPRED ASSERTION2 FOO)</code> will both be asserted to the Knowledge Base automatically.\n<p>\nFor example, if I assert this at the EL-level:\n<pre>\n  (#$comment\n    (#$and (#$isa #$Muffet #$Dog) (#$likesAsFriend #$Muffet #$Patches-Cat))\n    ''Muffet digs Patches.''),\n</pre>\n<p>\nboth of these will automatically be asserted a the HL-level:\n<p>\n\t<code>(#$comment (#$isa #$Muffet #$Dog) ''Muffet digs Patches.'')</code>\n<p>\n\t<code>(#$comment (#$likesAsFriend #$Muffet #$Patches-Cat) ''Muffet digs Patches.'')</code> .\n<p>\nSee also the shared note #$MetaAssertionsForPolycanonicalizingAssertions."^^_string))) .
\"urn:uuid:a32d1ea1-e000-4834-b04f-99dc81596b91"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DocumentationConstant, ("A collection of CycL constants whose purpose is to facilitate users in their understanding of the system, tracking knowledge representation work being done, noting cleanup work to be done, etc. Documentation constants are usually not involved in inference.  Instances may be excluded from versions of the knowledge base in which available memory is a premium without affecting the performance of applications."^^_string))) .
\"urn:uuid:dc298521-b4e9-42a9-aa4f-aa7968d3e646"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(DocumentationPredicate, ("A #$PredicateType whose instances are #$Predicates specifically designed for in-KB documentation purposes, such as  facilitating #$Cyclists in their understanding of the Cyc system, tracking knowledge representation work being done in the Cyc Knowledge Base, or noting cleanup work to be done.  \n<p>\nNote that documentation predicates are usually not involved in inference.  They may be excluded from knowledge bases in which available memory is a premium without affecting the performance of applications. #$DocumentationPredicate is used in code to determine which documentation to show to the user when they request to see documentation for a first-order reified term (or ''FORT'')."^^_string))) .
\"urn:uuid:3ab419cd-7621-4ff6-9992-c58dc7f7953a"[silk#strict] .
istAsserted(CoreCycLMt, 'genls-SpecDenotesGenlInstances'(DocumentationPredicate, Predicate)) .
\"urn:uuid:6364bb0b-3735-46e1-b6fa-13beac5de355"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(DontReOrderCommutativeTerms, ("A CanonicalizerDirective (q.v.) that directs the CycCanonicalizer not to re-order commutative terms that appear in the CycL assertions."^^_string))) .
\"urn:uuid:bba2b772-ce41-4498-bec1-28d5c509738d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ELRelation, ("A specialization of #$MacroRelation (q.v.) instances of which appear only at the ''epistemological level'' (or EL) of the Cyc system.  Each instance of #$ELRelation is associated, via the #$expansion or #$expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  Some assertions using instances of #$ELRelation are irretrievable after being input to the Cyc System (#$ELRelation-OneWay), and others' EL forms are reconstructed dynamically by the system (#$ELRelation-Reversible)."^^_string))) .
\"urn:uuid:8a38dd0e-1edc-49fa-859a-77066b3182d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertibleCollection(ELRelation)) .
\"urn:uuid:a801f8c9-f1ba-450e-9763-8719fcf1b84b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('ELRelation-OneWay', ("A specialization of #$ELRelation (q.v.) instances of which appear only when input at the ''epistemological level'' (or EL) of the Cyc system, and whose original EL form is thereafter irretrievable.  Each instance of #$ELRelation-OneWay is associated, via the #$expansion or #$expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  More precisely: A GAF (see #$CycLClosedAtomicSentence) whose main  functor (or ''0th argument'') is a term that denotes a one-way EL relation can  occur only at the EL, and not at the underlying HL (''heuristic level'') of the system.  Thus, although one can use a one-way-EL-relation-based GAF to make an assertion to the system, the GAF that actually gets stored as an assertion in the Cyc Knowledge Base is a different (though logically  equivalent) one that is related to the first via the #$expansion assertion  on the EL relation.  Upon assertion, the first GAF is ''transformed into'' the second GAF by the #$CycCanonicalizer.  For example, #$lessThan is a one-way EL relation whose #$expansion correlate is the template (#$greaterThan :ARG2 :ARG1).  So if one makes an assertion using the sentence `(#$lessThan 1 2)', the assertion that actually shows up in the KB is `(#$greaterThan 2 1)'.  Note that terms for one-way EL relations _do_ appear in stored assertions in which  they occur in argument places other than the 0th; e.g. the sentence `(#$isa #$lessThan #$OrderingPredicate)' is in the KB.  One-way EL relations afford cyclists the convenience of having alternative forms of expression, while their expansions serve to minimize redundancy in the types of GAFs that the system has to store and reason with."^^_string))) .
\"urn:uuid:02e611c7-3820-4838-81d5-ab5bc083a0b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('ELRelation-Reversible', ("A specialization of #$ELRelation (q.v.) instances of which appear only at the ''epistemological level'' (or EL) of the Cyc system, but whose original forms, or logically equivalent variants thereof, are retrievable via the #$CycUncanonicalizer.  Each instance of #$ELRelation-Reversible is associated, via the #$expansion (q.v.) or #$expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  Furthermore, each instance of #$ELRelation-Reversible is also associated with a piece of code which can perform the inverse transformation.  Since each instance of #$ELRelation-Reversible requires special code support, this is a #$notAssertibleCollection.  More precisely:  A GAF (see #$CycLClosedAtomicSentence) whose main functor (or ''0th argument'') is a term that denotes a reversible EL relation can occur only at the EL, and not at the underlying HL (''heuristic level'') of the system.  Thus, although one can use an EL-relation-based GAF to make an assertion to the system, the GAF that actually gets stored as an assertion in the Cyc Knowledge Base is a different (though logically equivalent) one that is related to the first via the #$expansion or #$expansionDefn assertion on the EL relation.  Upon assertion, the first GAF is transformed into the second GAF by the #$CycCanonicalizer.  Upon presentation to the user, the second GAF is transformed back into the first GAF, or a GAF which is logically equivalent, by the #$CycUncanonicalizer.  For example, #$willAlwaysBe is a reversible EL relation whose #$expansionDefn and associated piece of uncanonicalization code perform the following transformation:\n<p>\n(#$ist (#$MtSpace (#$MtTimeDimFn TIME) OTHER-DIMS) (#$willAlwaysBe P)\n<->\n(#$ist (#$MtSpace (#$MtTimeDimFn (#$IntervalStartedByFn TIME)) OTHER-DIMS) P)\n<p>\nSo if one makes an assertion into an MT with time index T using the sentence `(#$willAlwaysBe P)', the assertion that actually shows up in the KB is `P' in an MT with time index (#$IntervalStartedByFn T)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName('ELRelation-Reversible', ("ELRelation-SemiReversible"^^_string))) .
\"urn:uuid:69a61150-ef84-44d8-9553-ad4027364370"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith('ELRelation-Reversible', 'ELRelation-OneWay')) .
istAsserted(EnglishParaphraseMt, genKeyword(EnglishParaphraseMt, MetaVariableFn(("ENGLISH-PARAPHRASE-MT"^^_string)))) .
\"urn:uuid:5f5d99d0-1c7a-4b59-bfc7-40b24bdb5fc2"[silk#strict] .
istAsserted(BaseKB, comment(EnglishParaphraseMt, ("An instance of both #$ParaphraseDataMicrotheory and #$GeneralMicrotheory.  #$EnglishParaphraseMt is the default context used for generating English paraphrases for CycL expressions.  Many of the assertions required for English paraphrase generation, including those with the predicates #$genFormat and #$genPhrase (qq.v.), can be found in this context."^^_string))) .
\"urn:uuid:29de7626-8ee1-40c6-a8dd-e916e5ab7225"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(EscapeQuote, (1), Thing)) .
\"urn:uuid:59262c98-42a2-4a2e-b655-28f2f2bfd987"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(EscapeQuote, (1))) .
\"urn:uuid:62f9ffb5-3a7d-4472-8ad1-0b442b96fdd4"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(EscapeQuote, (1), CycLTerm)) .
\"urn:uuid:8af10ae4-fa06-40cd-9491-8086f28f04b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(EscapeQuote, (1), CycLTerm)) .
\"urn:uuid:0ac8c1a8-8a94-4957-81f5-0aff54ae9b8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(EscapeQuote, ("A quotation-related device for making general statements about CycL expressions.  #$EscapeQuote is used to allow certain free variables occurring inside an expression that is quoted to ''escape'' (i.e. remain free with respect to) the quotation.  It is thus similar in function to, though more flexible than, #$QuasiQuote (q.v.).\n<p>\nTo be more precise: the syncategorematic symbol <code>#$EscapeQuote</code> is used in conjunction with the special quotation symbol <code>#$Quote</code> (q.v.) as a device for allowing genuinely free variables to occur inside quoted expressions, in order that one may meaningfully ''quantify into'' such expressions and thereby generalize over them.  Thus, <code>#$EscapeQuote</code> is used to indicate that the free variables occurring within its scope (which is itself inside the wider scope of an occurrence of <code>#$Quote</code>) are <i>not</i> themselves to be interpreted as being quoted.\n<p>\nThe syntax of <code>#$EscapeQuote</code> is such that it can only be used in conjunction with <code>#$Quote</code>.  For any CycL expression <code>EXPR</code>, <code>(#$EscapeQuote EXPR)</code> is not by itself a syntactically well-formed CycL expression; but the latter can appear as <i>part of</i> a well-formed expression, subject to the following restrictions.  (i) Any occurrence of <code>#$EscapeQuote</code> in a CycL expression must itself be inside the scope of an occurrence of <code>#$Quote</code>.  (ii) One occurrence of <code>#$EscapeQuote</code> can be inside the scope of another only if there is an intermediate occurrence of <code>#$Quote</code> (i.e. one whose scope subsumes that of the former and is subsumed by that of the latter).\n<p>\nThe semantics of <code>#$EscapeQuote</code> is such that a formula <code>(#$Quote ... (#$EscapeQuote EXPR) ...)</code> that contains only one occurrence of <code>#$EscapeQuote</code> means just what the corresponding formula <code>(#$Quote ... EXPR ...)</code> means, except that any free occurrence of a variable in <code>EXPR</code> is to be interpreted as still being genuinely free with respect to <code>(#$Quote ... (#$EscapeQuote EXPR) ...)</code>.  In <code>(#$Quote ... EXPR ...)</code>, by contrast, any such variables are taken to be regular quoted constituents of a quoted compound expression; thus they do not function there as variables, but as <i>quoted-names of</i> variables -- i.e. as terms that denote variables.  \n<p>\nFor example, while the term <code>(#$Quote (#$isa ?X #$Cat))</code> simply denotes the open sentence <code>(#$isa ?X #$Cat)</code>, the expression\n<pre>\n  (#$Quote (#$EscapeQuote (#$isa ?X #$Cat)))\n</pre>\nis itself an open term in which <code>?X</code> occurs free; it thus does not denote in its own right, though many <i>instantiations</i> of it do denote.  E.g. the instantiation <code>(#$Quote (#$EscapeQuote (#$isa #$Patches-Cat #$Cat)))</code> denotes the sentence <code>(#$isa #$Patches-Cat #$Cat)</code>).\n<p>\nThe foregoing explanation generalizes to cases where multiple occurrences of <code>#$EscapeQuote</code> are within the scope of the same <code>#$Quote</code>.  For example, in the expression\n<pre>\n  (#$Quote (#$loves (#$EscapeQuote ?X) (#$EscapeQuote ?Y)))\n</pre>\n-- which is equivalent to <code>(#$Quote (#$EscapeQuote (#$loves ?X ?Y)))</code> -- both <code>?X</code> and <code>?Y</code> occur free.\n<p>\nAs mentioned above, the purpose of the <code>#$EscapeQuote</code> device is to enable ''quantifying into'' quoted contexts: to provide a coherent interpretation of formulas in which an occurrence of a #$Quantifier (or other #$ScopingRelation) that is outside the scope of a given occurrence of <code>#$Quote</code> can be viewed as binding occurrences of variables that are <i>inside</i> the scope of that <code>#$Quote</code>.  For example, the sentence\n<pre>\n  (#$thereExists ?X\n    (#$and\n      (#$isa ?X #$Cat)\n      (#$isa (#$Quote (#$EscapeQuote ?X)) #$CycLAtomicTerm)))\n</pre>\nsays that there is at least one cat that is denoted by a CycL atomic term.  Without the <code>#$EscapeQuote</code> wrapper, the second conjunct of the above would be a <i>closed</i> sentence, and the entire quantified sentence would express the far less interesting claim that there exists at least one cat and the expression <code>?X</code> is an atomic term of CycL.\n<p>\nNote that the above (interesting) existential claim could be expressed more tersely using #$QuasiQuote.  #$EscapeQuote is indispensible only in cases where one wants to allow <i>some but not all</i> of the free variables in a given expression to escape quotation.  For example, in the (implicitly quantified) rule\n<pre>\n  (#$isa\n    (#$Quote (#$loves ?X (#$EscapeQuote ?Y))) \n    #$CycLOpenSentence)\n</pre>\nonly the variable <code>?Y</code> occurs free; the <code>?X</code> is part of what gets quoted (and thus functions like a closed term that <i>denotes</i> the CycL variable <code>?X</code>).  What the rule says, in effect, is that any well-formed expression built with the predicate-expression <code>#$loves</code> followed by the variable <code>?X</code> followed by a CycL term is an open sentence of CycL.\n<p>\nFor more on the use of #$EscapeQuote and #$Quote for quantifying into quoted contexts, see the shared #$NoteAboutQuotingInCycL. See also #$denotes, #$quotedIsa, #$quotedArgument, and #$NoteAboutSyncategorematicSymbols."^^_string))) .
\"urn:uuid:10bf5335-fdc9-4861-a45a-63b0c4bc927b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(EvaluatableFunction, ("A specialization of both #$EvaluatableRelation and #$Function-Denotational (qq.v.).  Each instance of #$EvaluatableFunction is a function that is associated (via #$evaluationDefn) with a piece of HL (''heuristic level'') code that computes the result of applying the function to arguments for which that function is defined.  An evaluation of this sort is carried out, for example, when the system is queried using an #$evaluate (q.v.) sentence.  As one might expect, most evaluatable functions are mathematical or syntactic in nature; for, unlike with functions generally, operations on numbers, sets, lists, and strings can in many cases be calculated algorithmically.  Examples include #$PlusFn and #$JoinListsFn.  The practical result of evaluating a term built from (a constant that denotes) an evaluatable function is another _term_ -- one that has the same denotatum as the former term, but that is syntactically simpler and constitutes a more straightforward way of referring to that denotatum.  For example, the term '(#$PlusFn 2 3 4)', when evaluated, results in the term '9'.  So if a query using the open sentence '(#$evaluate ?X (#$PlusFn 2 3 4))' is asked, the answer (or ''binding'' for the free variable '?X') returned will be the term `9'.  By way of contrast, consider the non-evaluatable function #$BorderBetweenFn and the following arbitrarily-chosen non-atomic term built with its CycL name: '(#$BorderBetweenFn #$France #$Germany)'.  As there is no general algorithm for finding simpler or ''standard'' terms for given geographical borders, it is not possible for the Cyc system to ''evaluate'' non-atomic terms like this one."^^_string))) .
\"urn:uuid:45e1a8d4-b922-4faf-befb-d69560e58292"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(EvaluatablePredicate, ("A specialization of both #$EvaluatableRelation and #$Predicate (qq.v.).   Each instance of #$EvaluatablePredicate is a  predicate associated (via #$evaluationDefn) with a piece of HL (''heuristic level'') code that computes the resulting truth-value when the predicate is applied to legal \narguments. These truth-values can, of course, be computed only when all of the predicate's argument positions are bound: thus Cyc inference will not generate viable inference tactics for non-fully-bound literals with evaluatable predicates in the arg 0 position.  As one might expect, most evaluatable predicates are mathematical or syntactic in nature; for numbers, sets, lists, and strings are the sorts of things that are related in various ways that can be calculated \nalgorithmically.  Examples include #$greaterThan and #$substring. Thus the sentence `(#$greaterThan 3 1)' evaluates to (and so if used to ask a query will return the answer) `#$True'."^^_string))) .
\"urn:uuid:6fc2beb3-0011-4251-a6df-94d86d5c4a49"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(EvaluatableRelation, ("A specialization of #$Relation.  Each instance of #$EvaluatableRelation is\na function or predicate for which there is some piece of system code that \ncan be invoked to evaluate (i.e. to determine the denotation or truth-value\nof) a closed expression built from that function or predicate (i.e. a closed \nexpression that has the constant that denotes that function or predicate in \nits initial or ''0th'' argument-place).  An evaluation of this sort is carried \nout, for example, when the system is queried using an #$evaluate (q.v.) \nsentence.  As one might expect, most evaluatable relations are mathematical \nor syntactic in nature; for numbers, sets, lists, and strings are the sorts \nof things that are related in various ways that can be calculated \nalgorithmically.  Examples include #$PlusFn, #$greaterThan, #$JoinListsFn, \nand #$substring.  In the case of a function that is evaluatable (see \n#$EvaluatableFunction), the practical result of evaluating the relevant \nexpression is another _term_ -- one that has the same denotatum as the \noriginal expression, but that is syntactically simpler and constitutes a \nmore straightforward way of referring to that denotatum.  For example, \nthe term `(#$PlusFn (#$Inch 3) (#$Inch 1))', when evaluated, results in \nthe term `(#$Inch 4)'.  So if a query using the open sentence\n`(#$evaluate ?X (#$PlusFn (#$Inch 3) (#$Inch 1)))' is asked, the answer \n(or ''binding'' for the variable `?X') returned will be the term `(#$Inch 4)'.  \nEvaluating a sentence built from (a constant that denotes) an \n#$EvaluatablePredicate, on the other hand, yields a _truth-value_.  For \nexample, the sentence `(#$greaterThan (#$Inch 3) (#$Inch 1))' evaluates \nto (and so if used to ask a query will return the answer) `#$True'.  The \npredicate #$evaluationDefn (q.v.) is used to specify the name of the piece \nof system code used to evaluate expressions formed with a given \nevaluatable relation."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(EvaluatableRelation, ("EvaluatableRelationship"^^_string))) .
\"urn:uuid:e975146c-14b5-431c-bde6-a0cb5d9f809e"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(EvaluatableRelation, evaluationDefn)) .
\"urn:uuid:3399a8a2-c528-44dd-acf1-e480a4870409"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(EvaluateSubLFn, (1))) .
\"urn:uuid:1490e56d-173e-4b53-a165-ee38818ccf0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(EvaluateSubLFn, ("<code>(#$EvaluateSubLFn SUBL)</code> denotes the SubL term resulting from the invocation of the SubL EVAL facility on the expression <code>SUBL</code>.  For example, <code>(#$EvaluateSubLFn (#$ExpandSubLFn () (+ 1 2)))</code> evaluates to 3.  See #$ExpandSubLFn for a way to denote SubL within CycL.  See also #$trueSubL."^^_string))) .
\"urn:uuid:069df4d3-d587-4556-ae93-3dcd1a747403"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(EvaluateSubLFn, SubLSymbolFn(("CYC-EVALUATE-SUBL"^^_string)))) .
\"urn:uuid:fb858a17-0827-4731-8fa1-2080feeeda4d"[silk#strict] .
istAsserted(BaseKB, comment(EverythingPSC, ("A problem solving context in which all assertions in the entire KB are visible.  This context is only appropriate for use in queries which do not care about the consequences of possible contradictions due to conflicting information from mutually inconsistent microtheories.  See also #$InferencePSC."^^_string))) .
\"urn:uuid:98577c42-4253-4f93-bc39-f7cd4c340703"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ExceptionPredicate, ("A collection of mathematical objects, which are the #$LogicalConnectives used to express exceptions to rules.  Elements include #$exceptWhen and #$exceptFor."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(ExceptionPredicate, ("ExceptionRelation"^^_string))) .
\"urn:uuid:e36e8d33-24e6-4a30-986d-93c1005b7986"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ExceptionPredicate)) .
\"urn:uuid:90a63ba5-1b61-4cb8-b673-768844534d9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ExistentialQuantifier, ("A specialization of #$Quantifier (q.v.).  Each instance of #$ExistentialQuantifier can be used to make a certain kind of assertion regarding the existence of some thing(s) meeting a specified criterion.  For example, `(#$thereExistAtLeast 9 ?X (#$isa ?X #$Cat))' means that there exist at least nine cats.  Other instances of this collection are #$thereExists and #$thereExistExactly.  Cf. #$forAll."^^_string))) .
\"urn:uuid:54d660c2-96a0-4ca7-a4b2-330a8071125f"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection('ExistentialQuantifier-Bounded')) .
\"urn:uuid:2b7b4773-ea07-4a4e-b797-db3bb9bd2418"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('ExistentialQuantifier-Bounded', ("A specialization of #$ExistentialQuantifier (q.v.).  Each instance of #$ExistentialQuantifier-Bounded is a ternary relation that can be used to make a certain kind of statement about the existence of a given bounded quantity of things meeting a given criterion.  For example, '(#$thereExistAtLeast 9 ?X (#$isa ?X #$Cat))' means that there exist at least nine cats.  What distinguishes _bounded_ existential quantifiers from existential quantifiers generally is that the former require one to specify explicitly (at least a boundary for) how many things exist that meet the specified criterion."^^_string))) .
\"urn:uuid:64a3d0b3-3254-4725-873a-629a096daf12"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ExpFn, ("A unary #$EvaluatableFunction that is the #$CycL version of the exponential operator. It takes instances of #$ComplexNumber and returns instances of #$ComplexNumber. (#$ExpFn NUM) is e^NUM, i.e. e raised to the power of NUM (where e is #$E-LogarithmBase).  When NUM is a #$RealNumber, (#$ExpFn NUM) is necessarily a #$PositiveNumber. In particular, (#$ExpFn 1) is e.  The inverse of this function (cf. #$inverseQuantFunctions-Nonsymmetric\n) is #$LogFn. Note that although the arg constraint for #$ExpFn is #$ComplexNumber, its #$evaluationDefn only evaluates to a value when NUM is a #$RealNumber. See also #$ExponentFn, a binary function which returns the result of raising a specified number to a specified exponent."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(ExpFn, ("Exp"^^_string))) .
\"urn:uuid:d9a130ab-b645-40be-abfe-e028e3aa61b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ExpandSubLFn, (2))) .
\"urn:uuid:1855f896-061a-43dd-b07c-fc4e59dbafc7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ExpandSubLFn, (1))) .
\"urn:uuid:f55df0a2-3a96-4b4b-a5fd-5ce7a6f5d991"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(ExpandSubLFn, (2), SubLSExpression)) .
\"urn:uuid:35296609-ac58-43e1-a1dc-b97f7471c51f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ExpandSubLFn, ("<code>(#$ExpandSubLFn PARAMETERS SUBL-TEMPLATE)</code> denotes the SubL expression resulting from expanding the SubL template <code>SUBL-TEMPLATE</code> once all <code>PARAMETERS</code> are known.  For example, <code>(#$ExpandSubLFn (?X) (+ 1 ?X))</code> will denote the SubL expression <code>(+ 1 2)</code> when the parameter <code>?X</code> is bound to 2.  See also #$EvaluateSubLFn, #$trueSubL and #$performSubL."^^_string))) .
\"urn:uuid:d1dab6fb-4c52-48b0-8b66-a7cf3c5226df"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('FOL-FunctionFn', (2), NonNegativeInteger)) .
\"urn:uuid:a714ee7a-4ff4-4adb-b0d6-68006a278ff9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('FOL-FunctionFn', (1), 'Function-Denotational')) .
\"urn:uuid:85cc1ea6-bd69-4a07-a62e-ce92d7fcd4a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('FOL-FunctionFn', ("(#$FOL-FunctionFn FUNC ARITY) denotes a function that has\narity ARITY in the first-order projection of CycL based on the CycL\nfunction FUNC.  For example, (#$FOL-FunctionFn #$YearFn 1) denotes the\nunary first-order function associated with #$YearFn, and\n(#$FOL-FunctionFn #$PlusFn 2) denotes the first-order binary function\nassociated with #$PlusFn"^^_string))) .
\"urn:uuid:b5ce6897-fa6d-4a7c-b480-d6823c66bfa1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('FOL-PredicateFn', ("(#$FOL-PredicateFn TERM ARITY) denotes a predicate that has\narity ARITY in the first-order projection of CycL based on the CycL\nterm TERM, which must be either a predicate or a collection.  For\nexample, (#$FOL-PredicateFn #$eventOccursAt 2) denotes the binary\nfirst-order predicate associated with #$eventOccursAt,\n(#$FOL-PredicateFn #$different 2) denotes the first-order binary\nversion of the predicate #$different, and (#$FOL-PredicateFn #$Date 1)\ndenotes the unary first-order predicate associated with #$Date"^^_string))) .
\"urn:uuid:75a0d79c-c656-42f3-af8d-c6fa9d914e71"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('FOL-PredicateFn', (2), NonNegativeInteger)) .
\"urn:uuid:0c7da6ac-f693-4aaf-aedb-d3377530fbf5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('FOL-TermFn', (1), Thing)) .
\"urn:uuid:0714fac9-81d7-4ab6-86fb-da546ffa3c16"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('FOL-TermFn', ("(#$FOL-TermFn TERM) denotes a first-order constant symbol\nbased on the CycL term TERM.  For example, (#$FOL-TermFn #$Dog)\ndenotes a first-order term based on the collection #$Dog,\n(#$FOL-TermFn 212) denotes a first-order term based on the integer\n212, and (#$FOL-TermFn #$isa) denotes a first-order term based on the\npredicate #$isa.  See also (#$FOL-PredicateFn #$isa 2) for the\nfirst-order binary predicate based on #$isa."^^_string))) .
\"urn:uuid:29a81f13-7e91-478a-b2c8-97839cbef6d8"[silk#strict] .
istAsserted(BaseKB, comment(False, ("An instance of #$TruthValue (q.v.).  #$False is the logical notion of falsehood.  That is, the term '#$False' is used as a sentential constant of CycL that is false under every model theoretic interpretation.  For example, (#$booleanResult T/F #$False) means that the result obtained from the true-or-false test T/F is False.  Cf. #$True."^^_string))) .
\"urn:uuid:21b35463-f787-4f87-8d6d-603e8c64cc16"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(February, ("The collection of all Februaries,  the second month of the year in the #$GregorianCalendar."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(February, MetaVariableFn(("FEBRUARY"^^_string)))) .
\"urn:uuid:eb4437ab-bc3c-49d9-bb12-b6d1db17968c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FixedArityRelation, ("A specialization of #$Relation.  A #$Relation is an instance  of #$FixedArityRelation just in case it takes a fixed number  of arguments.  Most relations reified in the Cyc ontology are  of fixed arity.  For example, #$likesAsFriend always takes two  arguments and #$pointOfContact three.  This collection is  disjoint with #$VariableArityRelation."^^_string))) .
\"urn:uuid:eb14411b-80d3-4501-ae1a-0d1ff34c106f"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(FixedArityRelation, arg1Isa)) .
\"urn:uuid:bcd745bd-b70b-4970-b1e1-a8299b47f7ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(FixedArityRelation, arity)) .
\"urn:uuid:0e635d60-6252-48f0-a577-162d3c38ff45"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(FixedArityRelation, argIsa)) .
\"urn:uuid:7249a6ae-9645-4ee0-ab48-2f1a45ee0f25"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FixedAritySkolemFuncN, ("The collection of #$SkolemFuncNs (q.v.) whose arity is fixed."^^_string))) .
\"urn:uuid:03a85283-1218-4daf-94b3-fc15637a70c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FixedAritySkolemFunction, ("The subcollection of #$SkolemFunctions whose arity is fixed. This is the most common type of skolem function, since variable- arity skolem functions are only created when a sequence variable is in the scope of the skolem."^^_string))) .
\"urn:uuid:a1040db1-a164-439a-b24a-e5d9474615c7"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, disjointWith(FixedAritySkolemFunction, VariableAritySkolemFunction)) .
istAsserted(EnglishParaphraseMt, genKeyword(FixedAritySkolemFunction, MetaVariableFn(("SKOLEM-FUNCTION"^^_string)))) .
\"urn:uuid:6c44fd3a-a514-4e62-97da-36ceff53f45f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Format, ("A collection of argument entry-formats that can be  specified for #$Predicates with respect to particular argument-places (see #$argFormat).  An argument entry-format is a kind of restriction on  a predicate regarding how many things, or the range of things, that the  predicate holds of with respect to a given one of its argument-places.  More  precisely: given any particular way of fixing the arguments in the rest of  the predicate's argument-places, the entry-format tells us something about  the number of different things, or the range of things, that can occupy the  given argument-place such that the relation holds of those arguments.  That is, supposing the given argument-place is the Nth, the entry-format tells us  something about the number or range of different sequences of arguments  of which the predicate holds and that differ from each other only in their Nth items.  For example, the format #$SingleEntry (q.v.) is used to state  that in every case there is at most only one such sequence, the format  #$SetTheFormat (q.v.) to state that there is no particular (upper or lower)  limit to the number of such sequences that applies to every case, and the  format #$IntervalEntry (q.v.) to state that the Nth items of any two such  sequences must be #$ScalarIntervals that ''intersect'' (see #$quantityIntersects). Thus, the first argument-place of #$biologicalMother has the format (see  #$arg1Format) #$SetTheFormat, since a given female animal might have any  number (including zero) of offspring; but the second argument-place of  this predicate has (see #$arg2Format) #$SingleEntry format, since any  given animal has at most (in fact, exactly) one biological mother.  And  the format of the second argument-place of #$bodyTemperature is #$IntervalEntry because, while a given creature (at a given moment in time) has a single  exact (see #$ScalarPointValue) body temperature, we want the predicate #$bodyTemperature to be flexible enough to allow us to specify this  temperature with varying degrees of precision (e.g. as ''98.6 degrees Fahrenheit'' or as ''between 98 and 99 degrees'' or as ''less than 100 degrees'').  See the various instances of #$Format for further details.  See also #$ArgFormatPredicate.  Note that, in contrast with what #$ArgTypePredicates  are used for, specifying an argument entry-format for a predicate does  _not_ impose any sort of necessary condition for semantic well-formedness.   A violation of a legitimate entry-format constraint necessarily involves  two or more statements, and at least one them must be _untrue_;  but there is no implication that any of them is malformed."^^_string))) .
\"urn:uuid:73d687f2-8ccb-408d-a3f8-1991819f7b30"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FormulaArgFn, ("A binary function that returns an instance of #$CycLTerm when given an instance of #$NonNegativeInteger and an instance of #$CycLFormula as arguments.  (#$FormulaArgFn N RELATION-EXPRESSION) denotes the term appearing as the Nth argument within RELATION-EXPRESSION. (Note that RELATION-EXPRESSION may be a sentence or a NAT). For example:\n<p>\n(#$FormulaArgFn 2 (#$loves #$Gilbert #$Muffet)) and\n(#$FormulaArgFn 1 (#$BirthFn #$Muffet))\n<p>\nboth denote #$Muffet."^^_string))) .
\"urn:uuid:24ff45a6-e2d6-4402-9f49-6fea9bc55ad6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FormulaArgFn, (2), Thing)) .
\"urn:uuid:629b6db7-57fa-41b9-b48b-55d3c5045ed0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FormulaArgFn, (1), NonNegativeInteger)) .
istAsserted(BookkeepingMt, oldConstantName(FormulaArgFn, ("RelationArgFn"^^_string))) .
\"urn:uuid:6482b1f9-1492-4a28-b43b-f790dafec723"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(FormulaArgFn, SubLSymbolFn(("CYC-RELATION-ARG"^^_string)))) .
\"urn:uuid:9591f864-c441-4b37-87b0-a28d9c546317"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationResultQuotedIsa(FormulaArgFn, CycLTerm)) .
\"urn:uuid:ddebd954-b2f1-46f4-8f3e-69fca76b9d47"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(FormulaArgFn, (2), CycLFormula)) .
\"urn:uuid:580823f5-28da-43ee-ba0f-d3bf7f06e245"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(FormulaArgFn, (2))) .
\"urn:uuid:e538d27a-352c-48c5-bbd5-a84bc2ebc4f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FormulaArgListFn, ("(#$FormulaArgListFn RELATION-EXPRESSION) denotes a list of the arguments in RELATION-EXPRESSION.  For example, (#$FormulaArgListFn (#$genls #$Dog #$Animal)) denotes (#$TheList #$Dog #$Animal).  See also #$FormulaArgFn and #$FormulaArityFn."^^_string))) .
\"urn:uuid:b3f31cbd-5aaa-4e52-af64-3958f054269c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FormulaArgListFn, (1), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(FormulaArgListFn, ("RelationArgsListFn"^^_string))) .
\"urn:uuid:63cf1f29-7817-4952-ab8c-f35b1a33a590"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(FormulaArgListFn, SubLSymbolFn(("CYC-RELATION-ARGS-LIST"^^_string)))) .
\"urn:uuid:23b05360-c4bc-4626-bed3-864f453a85ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(FormulaArgListFn, (1), CycLFormula)) .
\"urn:uuid:e8cec9fc-81e9-425c-a1e4-bd59129bc82b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(FormulaArgListFn, (1))) .
\"urn:uuid:dd5546f6-0705-4445-8fed-5f5565e77cba"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FormulaArgSetFn, ("(#$FormulaArgSetFn RELATION-EXPRESSION) denotes\na set of the arguments of the given #$CycLFormula RELATION-EXPRESSION.  For example, (#$FormulaArgSetFn (#$genls #$Dog #$Animal)) denotes (#$TheSet #$Dog #$Animal).  See also #$FormulaArgFn and #$FormulaArityFn."^^_string))) .
\"urn:uuid:32811d18-d73b-4ad5-a45a-fc9ad94593cf"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(FormulaArgSetFn, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:f435a097-d827-4d80-9475-4470410d7857"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FormulaArgSetFn, (1), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(FormulaArgSetFn, ("RelationArgSetFn"^^_string))) .
\"urn:uuid:55ca242f-7038-4dab-b0e5-080f9996d57a"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(FormulaArgSetFn, SubLSymbolFn(("CYC-RELATION-ARG-SET"^^_string)))) .
\"urn:uuid:3cc66f7e-4b07-4d3b-a73d-9fb83bd05650"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(FormulaArgSetFn, (1), CycLFormula)) .
\"urn:uuid:7d80bdf1-5e51-48ef-a24e-e8110dce6f0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(FormulaArgSetFn, (1))) .
\"urn:uuid:39a22e8b-b058-4b6c-85cd-0f7d8ad9f0a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FormulaArityFn, ("An instance of #$EvaluatableFunction.  When applied to a #$CycLFormula FORM, #$FormulaArityFn returns the number of arguments given to the relation (an instance of #$Relation (q.v.)) appearing in the initial (''arg0'') argument place of FORM."^^_string))) .
\"urn:uuid:f0c93ed3-1b98-4479-abde-e551fecd4b9b"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(FormulaArityFn, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:bd454f29-0e0c-4f12-b2e0-269596ee18bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FormulaArityFn, (1), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(FormulaArityFn, ("RelationExpressionArityFn"^^_string))) .
\"urn:uuid:ba33e6b0-ed83-4590-936f-a58344d39280"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(FormulaArityFn, SubLSymbolFn(("CYC-RELATION-EXPRESSION-ARITY"^^_string)))) .
\"urn:uuid:828f9da8-1932-4418-a341-1b2b1ecb92a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(FormulaArityFn, (1), CycLFormula)) .
\"urn:uuid:ea2433e9-e45b-4a4e-98f0-c967aac8c392"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(FormulaArityFn, (1))) .
\"urn:uuid:788bf7c4-074e-4479-a715-a57e5baac7c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('Forward-AssertionDirection', ("An instance of #$CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the #$Forward-AssertionDirection can be used in inferences carried \nout at the time the assertion is added to the Knowlege Base as well as \nthose carried out at when a query is asked.  This is the default direction \nfor ground atomic assertions (see #$CycLClosedAtomicSentence).  Contrast \nwith #$Backward-AssertionDirection and #$Code-AssertionDirection.  Also \nsee #$assertionDirection."^^_string))) .
\"urn:uuid:147bff4a-df77-43c1-8687-0b59e7380c33"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Friday, ("A collection of #$CalendarDays and an \ninstance of #$DayOfWeekType.  #$Friday is the collection of all \n(and only) fridays."^^_string))) .
\"urn:uuid:af1bec6f-36fd-4d7d-8273-9d9b985ff588"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('Function-Denotational', ("A specialization of #$Relation (q.v.) and the collection of all functions.  Each instance of #$Function-Denotational is a many-one relation that represents, with respect to any given context, a mapping from one set of things (the function's #$relationDomain) to another set of things (its #$relationRange).  As a many-one relation, a function maps each thing in its domain to exactly one thing in its range.  A function might be unary, binary, ternary, etc. (see #$arity; but cf. #$relationalArity), depending on whether the members of its domain are singletons, ordered pairs, ordered triples, etc.  In general, the domain of an N-ary function with respect to a given context is a set of ordered N-tuples (construed in CycL as #$Lists of length N).  The function is said to take the items from any of these N-tuples as its N <i>arguments</i> and to return a member of its range as its corresponding <i>value</i> (see #$valueOfFunctionForArgs).  There are also functions that are not of any particular fixed arity; see #$VariableArityFunction.\n<p>\nFor example, #$GovernmentFn is the unary function that takes each #$GeopoliticalEntity to its #$RegionalGovernment, and #$PlusFn is the variable-arity function that takes any sequence of two or more #$ScalarIntervals\n(q.v.) to their arithmetic sum.\n<p>\nNote that the domain and range (i.e. the extension) of a given function might vary from context to context.  For example, as the government of a country can change over time, #$GovernmentFn will in such cases map the same country to different governments with respect to different times.  Thus, an instance of #$Function-Denotational is closer to what is sometimes called a ''function-in-intension'' than to the purely set-theoretical notion of a ''function-in-extension''.\n<p>\nCycL terms that denote functions can be used to form non-atomic terms (or ''NATs''; see #$CycLClosedNonAtomicTerm).  Specifically, when such a function-denoting expression is appropriately combined with other expressions (i.e. the former is in the 0th argument position and the latter are of the correct number and type) the resulting expression is a new CycL term (a NAT) that may then freely appear as a component in other CycL expressions.  The NAT will itself denote the value (if any) of the function denoted by the former expression for the sequence of arguments denoted, respectively, by the latter expressions.  For example, #$GovernmentFn is a unary function, and so the CycL constant '#$GovernmentFn' requires one syntactic argument (such as the constant '#$France') to form a NAT (in this case, the expression '(#$GovernmentFn #$France)').  This NAT, which denotes the government of France, can in turn serve as a syntactic argument in any CycL expression in which a term for an instance of #$RegionalGovernment can legally occur.\n<p>\nImportant subcollections of #$Function-Denotational include #$IndividualDenotingFunction (whose instances always return instances of #$Individual), #$CollectionDenotingFunction, #$SetDenotingFunction, and #$FunctionDenotingFunction (which is itself a subcollection of the first).  NATs formed using terms that denote instances of #$FunctionDenotingFunction denote instances of #$Function-Denotational themselves.  Thus, like most other things, functions can be denoted in CycL either by constants  (e.g. '#$GovernmentFn') or -- although this is less common -- by NATs (e.g.  '(#$FunctionToArg 2 #$biologicalMother)').\n<p>\nAn important partition of #$Function-Denotational is into #$TotalFunction and #$PartialFunction (qq.v.).\n<p>\nNote that #$Function-Denotational does not include any of the so-called #$TruthFunctions (q.v.): #$Predicates, #$Quantifiers, or #$LogicalConnectives. For these relations (as construed in CycL) are not really functions at all, even though it can be heuristically useful to think of them as if they were functions from sequences of arguments to truth values."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword('Function-Denotational', MetaVariableFn(("NON-PREDICATE-FUNCTION"^^_string)))) .
\"urn:uuid:b3b32132-2d93-4ae6-b0c3-332c7a657cd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred('Function-Denotational', resultIsa)) .
\"urn:uuid:6c2bd6db-e676-49a3-b99e-6eab8563c5b8"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith('Function-Denotational', TruthFunction)) .
\"urn:uuid:40e561a8-cede-4f3d-9b5d-59e7151a4a60"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(FunctionToArg, ("A binary #$FunctionDenotingFunction (q.v.) that takes as argument a #$FunctionalPredicate (and an integer indicating an argument-place in which that predicate is functional) and returns the corresponding function (whose value is always equal to the predicate's corresponding argument in the indicated place).\n<p>\nMore precisely: if <code>PRED</code> is an <code>N</code>-ary functional predicate that is functional in its <code>M</code>th argument (see #$functionalInArgs), then <code>(#$FunctionToArg M PRED)</code> is the (<code>N</code>-1)-ary function <code>FUNC-TO-ARGM</code> such that <code>(PRED ARG(1) ... ARG(N))</code> holds if and only if <code>(FUNC-TO-ARGM ARG(1) ... ARG(M-1) ARG(M+1) ... ARG(N)) = ARG(M)</code>.  If <code>PRED</code> is not functional in its <code>M</code>th argument, then <code>(#$FunctionToArg PRED M)</code> is #$undefined.\n<p>\nFor example, (#$FunctionToArg 2 #$age) is the function that returns the age of a given person.  Thus ((#$FunctionToArg 2 #$age) #$GeorgeWBush) = (#$YearsDuration 50) just in case (#$age #$GeorgeWBush (#$YearsDuration 50)) is true.\n<p>\nSee also #$Lambda and #$Kappa."^^_string))) .
\"urn:uuid:939c58ce-50e9-4e79-b255-2fdacbf0f5f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(FunctionToArg, (1), PositiveInteger)) .
istAsserted(EnglishParaphraseMt, genKeyword(FunctionToArg, MetaVariableFn(("FUNCTION-TO-ARG"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(FunctionToArg, ("'~a'"^^_string), [(2), MetaVariableFn(("SINGULAR"^^_string)), MetaVariableFn(("MASS-NUMBER"^^_string))])) .
\"urn:uuid:3a20081d-3328-40fa-a6e1-1337ba1cb0ca"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(FunctionToArg, (2), TernaryPredicate, BinaryFunction)) .
\"urn:uuid:551af90c-f0e2-44eb-8c2a-da746a54a2d9"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(FunctionToArg, (2), BinaryPredicate, UnaryFunction)) .
\"urn:uuid:44c33bf1-acdf-40ed-ae80-63cd82d084f1"[silk#strict] .
istAsserted(BaseKB, comment(Guest, ("An instance of #$HumanCyclist.  A Cyc user logged in                            \nas `#$Guest' will be able to browse the Cyc knowledge base to some extent, but will not have full rights to inspect and modify it."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(HLAssertedArgumentKeywordDatastructure, ("HLAssertedArgumentKeyword"^^_string))) .
\"urn:uuid:5cc7567e-a411-41cd-9f4e-22c048a15bcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(HLExternalIDString, ("#$HLExternalIDString is the collection of all #$SubLStrings\nwhich represent valid external ID strings for #$CycLExpressions.\nMembership in this collection is determined for given strings by\nevaluation of the underlying SubL code which implements the object to\nID mapping."^^_string))) .
\"urn:uuid:0a7932e3-b91f-4f0d-84bd-22d3d8145a23"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(HLPrototypicalTerm, Thing)) .
\"urn:uuid:8572efb2-cda1-4c8f-b1cd-80851a82df55"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(HLPrototypicalTerm, ("The collection of all #$CycLTerms that are the #$hlPrototypicalInstance of some collection.  All #$HLPrototypicalTerms are #$IndeterminateTerms."^^_string))) .
\"urn:uuid:8ddc3367-2d82-4745-bbca-41d4cd42eb43"[silk#strict] .
istAsserted(BaseKB, completelyDecidableCollection(HLPrototypicalTerm)) .
\"urn:uuid:9f88a3ac-8ad6-436f-b6c2-526603f14ad2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(HumanCyclist, ("A specialization of #$Cyclist and #$Person.  Each instance of  #$HumanCyclist is a person who is entitled to inspect and modify the Cyc knowledge base."^^_string))) .
\"urn:uuid:96d4916f-bb5d-4042-b214-ccdefbafc185"[silk#strict] .
istAsserted(BaseKB, definingMt(HumanCyclist, BaseKB)) .
\"urn:uuid:d6d14491-7763-40fe-b640-6a620c559b51"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(HumanCyclist)) .
\"urn:uuid:96c0fb1c-4314-4bdd-a7f8-a5128b25f684"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(HypotheticalContext, ("A #$MicrotheoryType.  Each instance of  #$HypotheticalContext consists of assertions that are posited strictly for the purpose of exploring their consequences, without alleging their actual truth.   A hypothetical context can be used to analyze hypothetical outcomes of actions or to examine the hypothetical consequences of assuming some theory to be true.  Also, various alternative choices might be asserted, each in its own hypothetical context, so their ramifications can be generated and compared."^^_string))) .
\"urn:uuid:df8fb6c6-8ac7-48ed-a830-c4ba918969ec"[silk#strict] .
istAsserted(BaseKB, comment(IndeterminateTerm, ("A specialization of #$CycLClosedDenotationalTerm.  Each instance of #$IndeterminateTerm is a CycL symbol for which, in oreder to establish its denotation, it is not sufficient to establish every aspect of the context of its use.\n<p>\nIn other words, instances of this collection are terms used to denote something which is known or assumed to exist, but whose precise identity -- i.e. which particular thing or things it is -- is unknown (unless, of course, the term is known to satisfy #$equals with another term whose precise identity is known).\n<p>\nFor instance, if Cyc knows (#$relationAllExists #$physicalExtent #$University #$SchoolCampus), and (#$isa #$MelbourneUniversity #$University), then Cyc knows that there is at least one instance of #$SchoolCampus, <i>IndeterminateCampus</i>, for which (#$physicalExtent #$MelbourneUniversity <i>IndeterminateCampus</i>) is true. This campus (or these campuses, if there happens to be more than one) would be denoted in CycL using the #$IndeterminateTerm:\n<p>\n(#$RelationAllExistsFn #$MelbourneUniversity #$physicalExtent #$University #$SchoolCampus).\n<p>\nAnalogously, instances of #$SkolemTerm are also instances of #$IndeterminateTerm, as are terms built from #$SomeFn, #$GenericInstanceFn, #$ArbitraryInstanceFn, et al (see the specialization #$NonSkolemIndeterminateTerm)."^^_string))) .
\"urn:uuid:8d8b5295-455e-4a61-bd1f-63d2b4737d8e"[silk#strict] .
istAsserted(BaseKB, completelyDecidableCollection(IndeterminateTerm)) .
\"urn:uuid:afba1d81-95c0-4da8-983f-687737291f8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(IndeterminateTermDenotingFunction, ("#$IndeterminateTermDenotingFunction is the collection of all functions that denote indeterminate terms.  See also #$IndeterminateTerm, #$SkolemTerm, and #$SkolemFunction."^^_string))) .
\"urn:uuid:cf5db3b4-f753-45bb-ab3e-11505dceb29a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Individual, ("#$Individual is the collection of all individuals:  things that are <i>not</i> sets or collections.  Individuals might be concrete or abstract, and include (among other things) physical objects, events, numbers,  relations, and groups.  An instance of #$Individual might have parts or  structure (including discontinuous parts); but <i>no</i> individual has elements  or subsets (see #$elementOf and #$subsetOf). Thus, an individual that has parts (e.g. #$physicalParts or #$groupMembers) is <i>not</i> the same thing as either the set or the collection containing those same parts.  For example, your car is an individual, but the collection of all the parts of your car is not an individual but an instance of #$Collection.  This collection (unlike the car itself) is abstract: it doesn't have a location, mass, or a top speed; but it does have instances, subcollections, and supercollections.  In partial contrast, the #$Group (q.v.) of parts of your car (while also not the same thing as the car itself) <i>is</i> an individual that has location and mass.  Another example: A given company, the group consisting of all the company's employees, the collection of those employees, and the set of those employees are four distinct things, and only the first two are individuals."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(Individual, MetaVariableFn(("INDIVIDUAL"^^_string)))) .
\"urn:uuid:c450dcd5-e31b-4783-8167-bc905ab51024"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(Individual, SetOrCollection)) .
istAsserted(BookkeepingMt, oldConstantName(InferencePSC, ("ForwardInferencePSC"^^_string))) .
\"urn:uuid:9a93820e-9a82-4525-ae86-ae053429f8ab"[silk#strict] .
istAsserted(BaseKB, comment(InferencePSC, ("A problem solving context in which all assertions in the entire KB are initially visible.  However, down each inference path, the chain of microtheories used is required to have some common descendent microtheory which is capable of inheriting all of the microtheories in the chain.  Thus, queries made in #$InferencePSC in effect compute locations in the space of microtheories in which the query is satisfiable.  This context is used internally by the inference engine for certain recursive calls to itself, including forward inference.  See also #$EverythingPSC."^^_string))) .
\"urn:uuid:b9476d4d-e65b-436b-858d-2dcd5bdb19db"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InferenceRelatedBookkeepingPredicate, ("A collection of predicates.  Each instance of #$InferenceRelatedBookkeepingPredicate is a predicate involved in assertions used by the Cyc application to direct inferencing.  Examples: #$defnIff, #$defnSufficient, #$termOfUnit, #$afterAdding."^^_string))) .
\"urn:uuid:be454a0f-f931-4606-8f27-b56744c03b61"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:946f3986-955e-4ba2-b7a4-f8063feeaa60"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InferenceSupportedCollection, ("The collection of all CycL terms that denote collections, where these terms are supported in some way by the #$CycInferenceEngine.  If a term T denoting the collection COL is an #$InferenceSupportedCollection, this means that the inference engine treats instances of COL specially."^^_string))) .
\"urn:uuid:1673910c-4927-457f-a995-da960f7a44c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InferenceSupportedFunction, ("The collection of all #$Function-Denotationals that are supported in some way by the #$CycInferenceEngine.  This support may be provided by, for example, an #$evaluationDefn."^^_string))) .
\"urn:uuid:21aa7ee9-4d66-4ea3-af81-6d2cdbdaf3ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InferenceSupportedPredicate, ("The collection of all #$Predicates that are supported in some way by the #$CycInferenceEngine.  This support may be provided by, for example, a #$CycHLModule or an #$evaluationDefn."^^_string))) .
\"urn:uuid:450d4590-45bd-42e0-b44c-15c807448268"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InferenceSupportedTerm, ("The collection of all #$CycLTerms that are supported in some way by the #$CycInferenceEngine.  This support may be provided by, for example, a #$CycHLModule or an #$evaluationDefn."^^_string))) .
\"urn:uuid:4ae0383b-eced-450f-8da0-a8fd874bbf20"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Integer, ("A specialization of #$RationalNumber.  Each instance of #$Integer is a whole number with no fractional remainder.  An integer may be positive (e.g. 42), zero, or negative (e.g. -42).\n<p>\nNote that, in the KB browser, a fixed- or floating-point number representation such as `42.00' should not be assumed to refer to the integer 42. For it might only appear to correspond to that integer within the tolerance of its representation, and might in fact be an approximation to a non-integer number such as 42.0003.\n<p>\nAlso note that, unlike #$Integer, #$SubLInteger (q.v.) is a collection of integer-denoting expressions in the SubL programming language rather than a collection of integers themselves. Still, (#$genls #$SubLInteger #$Integer) holds, but only under a special interpretation of #$genls forced by the fact that #$SubLInteger is a #$quotedCollection (q.v).)"^^_string))) .
\"urn:uuid:78921eeb-15da-4ec4-9067-249067141318"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InterArgFormatPredicate, ("The subcollection of both #$InterArgConstraintPredicate and #$ArgFormatPredicate (qq.v.) whose instances are used to specify, for a given predicate PRED, a certain #$Format requirement on one of PRED's arguments (the ''dependent'' one), contingent upon one (usually, but not always, a different one) of PRED's arguments (the ''independent'' one) being an instance of (#$isa) a certain collection.  Currently, each instance of #$InterArgFormatPredicate is ternary, where its first argument (or ''arg1'') is the predicate PRED upon which the constraint is being placed, its arg2 the collection serving as the #$isa condition on PRED's independent argument, and its arg3 the #$Format that PRED's dependent argument is (conditionally) constrained to have.  The (numerically-specified) identities of the arguments of PRED's that are to serve as the independent and dependent arguments are fixed for each instance of \n#$InterArgFormatPredicate."^^_string))) .
\"urn:uuid:dd7f77e1-827d-42bf-83e4-72d764209260"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(InterArgIsaPredicate, ("The subcollection of both #$InterArgTypePredicate and #$ArgIsaPredicate (qq.v.) whose instances are used to put conditional #$isa based argument-type constraints on polyadic relations in regards to two of their argument-places.  Each instance of #$InterArgIsaPredicate specifies, with respect to a given #$Relation, that one of its arguments (the ''dependent'' one) must be an instance of (#$isa) a certain collection, contingent upon another of its argument's (the ''independent'' one's) being an instance of a certain (possibly different) collection.  An inter-argument-isa predicate PRED has argument-places for designating the relation and the two collections serving as argument-types; the (numerically-specified) identities of the relation's corresponding dependent and independent arguments is in most cases fixed (as in #$interArgIsa1-2), but is in some cases variable and specified via two additional argument-places of PRED's (as in #$interArgIsa).  In cases of the former sort, where the relation's argument-places are fixed, PRED is a #$TernaryPredicate that takes as it first argument (or ''arg1'') a relation, as its arg2 the type specified for the relation's independent argument, and as its arg3 the type specified (contingently) for the dependent argument."^^_string))) .
\"urn:uuid:0c2fddf2-ffcd-4ee8-9a5c-5dd5c6dace13"[silk#strict] .
istAsserted(BaseKB, comment(IntervalEntry, ("An instance of #$Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see #$argFormat), where the argument-place in question is one constrained (via #$argIsa) to instances of #$ScalarInterval.   (#$argFormat PRED N #$IntervalEntry) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there may be more than one instance of #$ScalarInterval such that, if taken as the Nth argument, PRED holds of those arguments.  However, if there is more than one instance of #$ScalarInterval taken as the Nth argument in such a situation, it must be the case that each of the instances of #$ScalarInterval intersect one another (see #$quantityIntersects).  That is, if the sequences <... ARGN-1 ...>, <... ARGN-2 ...>, ..., <... ARGN-M ...> differ at most in their Nth items and each of (PRED ... ARGN-1 ...), (PRED ... ARGN-2 ...), ..., (PRED ... ARGN-M ...) holds, then for any distinct ARGN-K and ARGN-L, where K and L are greater than or equal to 1, and less than or equal to M, (#$quantityIntersects ARGN-K ARGN-L). For example, the format of #$volumeOfObject's second argument-place is #$IntervalEntry."^^_string))) .
\"urn:uuid:cdd10f0d-a493-4c6e-bc14-5b640c12decc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(IntervalMaxFn, ("<code>(#$IntervalMaxFn SCALAR)</code> returns an interval of the same type as <code>SCALAR</code> whose maximum value is the maximum value of <code>SCALAR</code> and whose minimum value is minus infinity.  For example, (#$IntervalMaxFn (#$Mile 3)) is the same as `the interval from negative infinity miles to three miles'. [Technical Note: if that expression were to denote a strictly absolute, as opposed to a relative-or-absolute, distance, then it would mean `the interval from 0 miles to 3 miles'.]   (#$IntervalMaxFn (#$Unity 1)) is the same as `the interval from negative infinity to 1', in other words, `no greater than one'."^^_string))) .
\"urn:uuid:86c90427-f130-4f69-b90f-43fc45120013"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArgIsa(IntervalMaxFn, (1))) .
istAsserted(BookkeepingMt, oldConstantName(IntervalMaxFn, ("IntervalMax"^^_string))) .
\"urn:uuid:a178fdbd-7143-4d51-9001-b845d0a53036"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(IntervalMinFn, ("<code>(#$IntervalMinFn SCALAR)</code> returns an interval of the same type as <code>SCALAR</code> whose minimum value is the minimum value of <code>SCALAR</code> and whose maximum value is #$PlusInfinity.  For example, (#$IntervalMinFn (#$Mile 3)) is the same as `the interval from three miles to an infinite number of miles', in other words, `at least three miles'."^^_string))) .
\"urn:uuid:81d21e30-a8c2-4638-80fc-56968e046cf9"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArgIsa(IntervalMinFn, (1))) .
istAsserted(BookkeepingMt, oldConstantName(IntervalMinFn, ("IntervalMin"^^_string))) .
\"urn:uuid:66d09488-50d3-48d4-8235-603114fbb4dd"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(IntervalMinFn, (1), NonNegativeScalarInterval, NonNegativeScalarInterval)) .
\"urn:uuid:54101966-9680-43f1-94f5-f3f123fbc5e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(IrreflexiveBinaryPredicate, ("The collection of #$BinaryPredicates that are irreflexive.  A binary predicate <code>PRED</code> is an instance of #$IrreflexiveBinaryPredicate only if, for every <code>THING</code> that satisfies the single-argument type-constraints (i.e. #$argIsa and #$argGenls; see #$admittedArgument) on both of <code>PRED</code>'s argument-places, <code>(#$not (PRED THING THING))</code> holds.\n<p>\nTo rule out ''vacuous'' cases, there is an additional necessary condition for irreflexivity:  the constraints on <code>PRED</code>'s two argument-places must be co-satisfiable (see #$cosatisfiableInArgs).  Without this requirement, any binary predicate whose arguments were constrained in mutually-disjoint ways would trivially (and counterintuitively) count as irreflexive.  See #$NoteOnArgumentCosatisfiabilityRequirement\n<p>\nExamples of irreflexive binary predicates include #$spouse, #$causes-ThingProp, #$northOf, and #$temporallyDisjoint."^^_string))) .
\"urn:uuid:30ef9bf7-80dd-46c6-a46d-03bfc6de3898"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(IrreflexiveBinaryPredicate, interArgDifferent)) .
\"urn:uuid:6ead0360-c273-4ad4-b990-c188dd9fe1bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(January, ("A specialization of #$CalendarMonth.  Each instance of #$January is the first month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(January, MetaVariableFn(("JANUARY"^^_string)))) .
\"urn:uuid:ede613a2-ff84-45a7-bb05-53af9af7b274"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(July, ("The collection of all Julys,\n the seventh month of the year in the #$GregorianCalendar."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(July, MetaVariableFn(("JULY"^^_string)))) .
\"urn:uuid:a9db9767-fceb-42b3-a544-e6b1bac80ca6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(June, ("A specialization of #$CalendarMonth.  Each instance of #$June is the sixth month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(June, MetaVariableFn(("JUNE"^^_string)))) .
\"urn:uuid:68e3c3d2-fda7-4899-aca6-e942ac4af4b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Kappa, ("A binary #$PredicateDenotingFunction and a #$ScopingRelation (qq.v.), #$Kappa is used to define a predicate on the basis of a sentence (see #$CycLSentence-Assertible) and a list of variables (see #$CycLVariableList) some or all of which typically occur free in the sentence.  The resulting predicate holds of just those sequences that would make the sentence true.\n<p>\nMore precisely, if <code>VAR1,...,VAR<sub>N</sub></code> include all of the #$CycLVariables that occur free in <code>SENT</code>, then the term\n<pre>\n  (#$Kappa (VAR1 ... VAR<sub>N</sub>) SENT)\n</pre>\ndenotes the <code>N</code>-ary relation (i.e. the #$Predicate) that holds of any admitted sequence of arguments <code>ARG1...ARG<sub>N</sub></code> if and only if <code>SENT[ARG<sub>I</sub>/VAR<sub>I</sub>]</code> is true, where <code>SENT[ARG<sub>I</sub>/VAR<sub>I</sub>]</code> is the result of simultaneously replacing each free occurrence of <code>VAR<sub>I</sub></code> in <code>SENT</code> with a CycL name of the corresponding <code>ARG<sub>I</sub></code> (for 1 <= <code>I</code> <= <code>N</code>). \n<p>\n(With respect to the above, <code>ARG1...ARG<sub>N</sub></code> is an <i>admitted sequence of arguments</i> to <code>(#$Kappa (VAR1 ... VAR<sub>N</sub>) SENT)</code> just in case (i) each <code>ARG<sub>I</sub></code> satisfies any argument-type constraints applicable to the position(s) occupied by <code>VAR<sub>I</sub></code> in <code>SENT</code> and (ii) if any two variables <code>VAR<sub>I</sub></code> and <code>VAR<sub>J</sub></code> are the same then the corresponding sequence-members <code>ARG<sub>I</sub></code> and <code>ARG<sub>J</sub></code> are identical.)\n<p>\nA few examples.  (#$Kappa (<code>?X</code>) (#$greaterThan <code>?X</code> 1)) is a unary predicate that holds of all numbers greater than 1. (#$Kappa (<code>?X ?Y</code>) (#$greaterThan <code>?X</code> 1)) is a binary predicate that holds of any ordered pair of argument values whose first member is a number greater than 1. (#$Kappa (<code>?X</code>) (#$greaterThan 2 1)) is a unary predicate that holds of any thing.  (#$Kappa (<code>?X</code>) (#$greaterThan 1 2)) is a unary predicate that holds of no thing.  (#$Kappa (<code>?X ?X</code>) (#$greaterThan <code>?X 1</code>)) is a binary predicate that holds of any ordered pair of numbers whose first and second members are the same number <b>K</b>, where <b>K</b> is greater than 1.\n<p>\nMost of the above examples are uses of #$Kappa that have little utility.  The first example, however, is an example of a common and important use of #$Kappa, which is to reduce the arity of a predicate by fixing the value for one or more of its arguments. For example, (#$Kappa (<code>?COUNTRY ?RATE</code>) (#$exportRate <code>?COUNTRY</code> #$Oil <code>?RATE</code>)) defines a binary predicate that relates a country to its export rate of oil, whereas (#$Kappa (<code>?COUNTRY</code>) (#$exportRate <code>?COUNTRY</code> #$Oil (#$MillionBarrelsPerDay 2)))</code> defines a unary predicate that holds of any country that exports oil at the rate of two million barrels per day.\n<p>\nThe sentence that is an argument to #$Kappa may be arbitrarily complex.  For example, it may be an existentially quantified conjunction.  Thus,\n<pre>\n   (#$Kappa (?PERSON ?NAME)\n    (#$thereExists ?FATHER\n      (#$and\n        (#$isa ?PERSON #$Person)\n        (#$father ?PERSON ?FATHER)\n        (#$lastName ?FATHER ?NAME))\n</pre>\n<p>\nreturns a predicate that holds of any ordered pair <b><PERSON, NAME></b>, such that <b>PERSON</b> is a person whose father's last name is <b>NAME</b>.\n<p>\nSometimes it is useful to construct an expression of the form <code>(#$Kappa LIST SENT)</code> where some variables that occur free in <code>SENT</code> do <i>not</i> occur in <code>LIST</code>.  For example, <code>(#$Kappa (?X) (#$greaterThan ?X ?Y))</code> might be used in a context where the <code>?Y</code> appears within the scope of a quantifier that occurs outside of the #$Kappa expression.\n<p>\n#$Kappa is a cousin of the function #$Lambda (q.v.), which is used to define a <i>function</i> on the basis of a list of variables and a non-logical term."^^_string))) .
\"urn:uuid:512966a1-911e-4908-8893-630c81d75933"[silk#strict] .
istAsserted(BaseKB, scopingArg(Kappa, (1))) .
istAsserted(EnglishParaphraseMt, genKeyword(Kappa, MetaVariableFn(("KAPPA"^^_string)))) .
\"urn:uuid:af168ae9-d8fa-40ec-bd03-107ae757821e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(Kappa, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:8883cdc6-76da-4331-a4c6-0fdf9ca24cd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(Kappa, (2))) .
\"urn:uuid:5880b14e-9fc2-429e-bd69-92f27987d563"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(Kappa, (1))) .
\"urn:uuid:8805c915-5406-49f7-aff7-99fe2c5f1157"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(KnowledgeBase, ("A specialization of #$Database-AbstractContent. Each instance of #$KnowledgeBase is a database (considered as an abstract repository of information rather than a physical storage device) containing knowledge about at least part of the world.  A notable specialization of #$KnowledgeBase is #$CycKB, the collection of all Cyc knowledge bases."^^_string))) .
\"urn:uuid:d3f320b3-ddf2-46b8-9ef6-397b929ea50e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Lambda, ("A binary #$FunctionDenotingFunction and #$ScopingRelation (qq.v.) that is used to define a function on the basis of a non-logical term (specifically a #$CycLDenotationalTerm-Assertible) and a list of variables, some or all of which will typically occur free in the term.  The resulting ''lambda-function'', roughly speaking, takes any sequence of appropriate values of these variables to the thing denoted by the corresponding instantiation of the non-logical term.\n<p>\nMore precisely, the function that is returned when #$Lambda is applied to a given pair of arguments is determined by the following Principle of Lambda-Abstraction: If the #$CycLVariables VAR1, ..., VARn include all of the variables that occur free in TERM, then (#$Lambda (VAR1 ... VARn) TERM) is the n-ary function whose value, for any admitted sequence of arguments <ARG1, ..., ARGn>, is the thing (if any) denoted by a closed term TERM(ARGi/VARi) that is the result of simultaneously replacing each free occurrence of VARi in TERM with a CycL name of the corresponding ARGi (for 1 <= i <= n).  <ARG1, ..., ARGn> is an ''admitted sequence of arguments'' to this function just in case (i) each ARGi satisfies any argument-type constraints applicable to the position(s) occupied by VARi in TERM and (ii) if any two variables VARi and VARj are the same then the corresponding sequence-members ARGi and ARGj are identical.\n<p>\nA few examples. (#$Lambda (?X) (#$PlusFn ?X 1)) is the unary function that adds 1 to any number.  (#$Lambda (?X) (#$PlusFn 1 1)) is the unary function that maps any thing to the number 2.  (#$Lambda (?X ?Y) (#$PlusFn ?X ?Y)) is the binary addition function.  (#$Lambda (?X ?Y ?Z) (#$PlusFn ?X ?Y)) is the ternary function that maps any ordered triple whose first two items are numbers to the sum of those two numbers.  (#$Lambda (?X ?X) (#$PlusFn ?X 1)) is a binary function that takes every ordered pair whose first and second members are the same number K to K+1; e.g. it takes <2, 2> to 3.\n<p>\n(From a practical standpoint, of course, the last two examples above are rather degenerate.  When the variable-list includes items not occurring free in TERM, or contains multiple appearances of the same item, the arity of the resulting lambda-function is increased pointlessly.)\n<p>\nAn important use of #$Lambda is to yield reduced-arity version of a given function, either by fixing one (or more) of the latter's arguments or by forcing two (or more) of its arguments to be the same.  For example, (#$Lambda (?NUM) (#$LogarithmFn ?NUM 10)) is a unary function that returns the base 10 logarithm of a given number, and (#$Lambda (?NUM) (#$PlusFn ?NUM ?NUM)) is a unary function that doubles a given number.\n<p>\nAnother use of #$Lambda, shown indirectly in some of the above examples, is to yield a fixed-arity version of a given variable-arity function.  For example, (#$Lambda (?X ?Y) (#$PlusFn ?X ?Y)) is the binary addition function.\n<p>\nStill another use of #$Lambda is to yield the composition of two (or more) functions by nesting one functor inside another.  For example, (#$Lambda (?NUM1 ?NUM2) (#$MinusFn (#$TimesFn ?NUM1 ?NUM2))) is a function that returns the additive inverse of the product of two given numbers, and (#$Lambda (?ANIMAL) (#$MotherFn (#$FatherFn ?ANIMAL))) is a function that returns the paternal grandmother of a given animal.  (See also #$FunctionCompositionFn.)\n<p>\nNote that in each of the examples used thus far the variable-list included (at least) all of the variables that occurred free in the given term; hence those variables all became bound in the resulting lambda-expression, which was therefore _closed_ and capable of denoting a function.  In contrast, if TERM does contain free variables not among (VAR1 ... VARn), the former variables will remain free in the lambda-expression (#$Lambda (VAR1 ... VARn) TERM), which is therefore _open_ and incapable of denoting a function. (But of course those free variables might become bound in the context of a sentence that contains the lambda-expression and states a generalization of some sort about a certain class of lambda functions.)\n<p>\n#$Lambda is a cousin of the function #$Kappa, which is used to define a #$Predicate on the basis of an open sentence and a list of variables.  See also #$FunctionToArg."^^_string))) .
\"urn:uuid:3edf46b9-83be-460c-98ba-799d133c89a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, scopingArg(Lambda, (1))) .
\"urn:uuid:175c58ad-a97d-4c00-b3c8-b5d5c04fc494"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Lambda, (2), Thing)) .
\"urn:uuid:f97cdb73-0746-4892-96db-2d33ec2fb5d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(Lambda, (2), 'CycLDenotationalTerm-Assertible')) .
\"urn:uuid:6412608d-88d5-4425-b87f-7ed7c06a9a18"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(Lambda, (2))) .
\"urn:uuid:0b114d25-dce9-4aae-b60b-c474426602b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(Lambda, (1))) .
\"urn:uuid:d5304de5-0104-4003-8021-54f2974ee46e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(LeaveSomeTermsAtEL, ("A #$CanonicalizerDirective (q.v.) that combines the following three commands:\n<p>\n(1) Do not canonicalize #$ELVariables into #$HLVariables.\n(2) Do not expand #$CycLFormulas whose operators are instances of #$ELRelation.\n(3) Do not reify #$CycLReifiableNonAtomicTerms.\n<p>\nA consequence of (1) is that any #$CycLAssertion that contains no HL variables, regardless of its form, will be treated by the canonicalizer as if it were a GAF (see #$CycLClosedAtomicSentence) as opposed to a rule."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(LeaveSomeTermsAtELAndAllowKeywordVariables, ("CanonicalizeForNL"^^_string))) .
\"urn:uuid:ab2898ec-2849-43a3-85c9-6738f74de896"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(LeaveSomeTermsAtELAndAllowKeywordVariables, ("A  #$CanonicalizerDirective (q.v.) that is a specialization (see  #$genlCanonicalizerDirectives) of both #$LeaveSomeTermsAtEL and  #$AllowKeywordVariables (qq.v.), and thus combines the commands of both of those directives."^^_string))) .
\"urn:uuid:98299922-ba28-4c8d-8c0c-63319774fd8d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(LeaveSomeTermsAtELAndAllowKeywordVariables, ("A #$CanonicalizerDirective which combines the directives #$LeaveSomeTermsAtEL and #$AllowKeywordVariables."^^_string))) .
\"urn:uuid:d084311d-446e-4975-b93e-78fb3146ca63"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(LeaveVariablesAtEL, ("A #$CanonicalizerDirective (q.v.) that directs the canonicalizer to refrain from canonicalizing #$ELVariables into #$HLVariables.\nA consequence of this is that any #$CycLAssertion that contains no HL variables, regardless of its form, will be treated by the canonicalizer as if it were a GAF (see #$CycLClosedAtomicSentence) as opposed to a rule.  Note that this will inhibit nat reification if there are variables within the scope of the reifiable function."^^_string))) .
\"urn:uuid:c9b4e168-7ec1-43af-a1c8-f8b048d75b9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(List, ("A specialization of #$Tuple.  Each instance of #$List is a  finite sequence of things with a first and last member-position, with each member-position other than the last having a successor member-position.   As with tuples generally, lists allow for repetition of their members, so that the same item can appear at multiple member-positions in the same list.  A list can be represented formally as a function from a finite index set of counting numbers, beginning with one, into the domain of all #$Things (but note that #$Lists are _not_ explicitly represented as functions in the Cyc ontology).  Unlike an instance of #$Series (q.v.), a list is purely abstract (i.e. both aspatial and atemporal), and the only implied relation between an item and its successor in a list is the successor relation of the list itself.  Technically, #$List is more specific than #$Tuple only in that the index set (see #$tupleIndexSet) for a given list must be the counting numbers in their usual order (or some initial segment thereof), whereas the index set for a tuple, generally speaking, might be any set whatsoever."^^_string))) .
\"urn:uuid:06f6e83d-15f0-4d71-b8b1-681b9bf428e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, coExtensional(List, List)) .
istAsserted(BookkeepingMt, oldConstantName(List, ("List"^^_string))) .
\"urn:uuid:ec7ecdd0-6b97-4a48-8314-ba787cf339f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(LogFn, ("A unary #$EvaluatableFunction that returns the natural logarithm of the number taken as its argument.  (#$LogFn NUM) is the exponent to which e is raised to get NUM (where e is #$E-LogarithmBase). Its inverse (cf. #$inverseQuantFunctions-Nonsymmetric) is #$ExpFn."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(LogFn, ("Log"^^_string))) .
\"urn:uuid:ae763ca1-4f41-4f2b-ab94-66a96631500e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(LogicalConnective, ("A collection of mathematical objects, including the basic logical connectives.  Each instance of #$LogicalConnective is a #$Relation which takes one or more truth-valued expressions (sentences) as arguments and returns a truth-valued sentence.  The instances of #$LogicalConnective include #$and, #$or, #$not, and #$implies."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(LogicalConnective, MetaVariableFn(("LOGICAL-CONNECTIVE"^^_string)))) .
\"urn:uuid:a9825fa1-6847-4134-90fd-e6962fc16ec8"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(LogicalConnective, Quantifier)) .
\"urn:uuid:6ed7ec9e-7c24-4376-954e-7cdfb1e5f5c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(LogicalConnective)) .
istAsserted(BookkeepingMt, oldConstantName(LogicalTruthImplementationMt, ("CycInferenceMt"^^_string))) .
\"urn:uuid:3cd2fadb-3fa1-4981-b205-8ade246ff781"[silk#strict] .
istAsserted(BaseKB, comment(LogicalTruthImplementationMt, ("This is a microtheory which contains only the assertions required for the Cyc theorem prover and its underlying HL representation of the EL to function properly.  In other words, these are the assertions in CycL which are required by Cyc in order to perform any logical inferences using CycL formulas."^^_string))) .
\"urn:uuid:bf8ab489-10f5-41cd-b214-a942bea98149"[silk#strict] .
istAsserted(BaseKB, comment(LogicalTruthMt, ("This is a microtheory which contains only the assertions required to represent the logical system used in the Cyc knowledge base.  In other words, these are the assertions in CycL which must be present in order to use CycL to represent logical truths."^^_string))) .
\"urn:uuid:8fd8b847-8e87-4792-98d7-6d9bb1558fc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(March, ("A specialization of #$CalendarMonth. Each instance of #$March is the third month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(March, MetaVariableFn(("MARCH"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(MaxRangeFn, ("the maximum range subsuming ~a and ~a"^^_string), TheEmptyList)) .
\"urn:uuid:ea96ceae-3e76-4789-8754-b382d03e86eb"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(MaxRangeFn, SubLSymbolFn(("CYC-MAX-RANGE"^^_string)))) .
\"urn:uuid:4660654c-2be2-494d-b331-c5ead11086c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MaxRangeFn, ("<code>(#$MaxRangeFn QUANTITY<sub>1</sub> ... QUANTITY<sub>N</sub>)</code> denotes a quantity which subsumes each of <code>QUANTITY<sub>1</sub></code> through <code>QUANTITY<sub>N</sub></code>.  For example, <code>(#$MaxRangeFn (#$Meter 1 3) (#$Meter 2 4))</code> denotes (#$Meter 1 4).  See also #$MinRangeFn."^^_string))) .
\"urn:uuid:e53b5fa8-5f5f-4ab0-a9bb-234d2e43d176"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Maximum, ("A #$NumericQuantifier.  Used to denote the maximum quantity which results from applying the function specified in the second argument to all of the elements of the set expression which appears in the first argument.--Rode 3/15/98"^^_string))) .
\"urn:uuid:b20ff15b-da78-44d9-b962-ed18191b843d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Maximum, (2), UnaryFunction)) .
\"urn:uuid:bfbe0130-d368-45fe-a04b-c722ea91bfcc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Maximum, (1), SetOrCollection)) .
\"urn:uuid:84ae2c18-1b61-40df-b889-1a389414b187"[silk#strict] .
istAsserted(BaseKB, argIsa(Maximum, (1), SetOrCollection)) .
\"urn:uuid:cb16dd85-9233-473a-a19d-f8c803cc5715"[silk#strict] .
istAsserted(BaseKB, argIsa(Maximum, (2), UnaryFunction)) .
\"urn:uuid:dec7f43a-5b90-46c3-8e38-5a1e10cd5fbd"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(Maximum, SubLSymbolFn(("CYC-MAXIMUM"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(Maximum, ("the maximum ~a over ~a"^^_string), [(2), [(1), MetaVariableFn(("PLURAL"^^_string))]])) .
\"urn:uuid:34da8ea3-ce85-4d6e-95a4-417826a403f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(May, ("A specialization of #$CalendarMonth. Each instance of #$May is the fifth month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(May, MetaVariableFn(("MAY"^^_string)))) .
\"urn:uuid:cade9391-c48c-4f9d-adbb-a36d3f28a57b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MeaningInSystemFn, ("A reifiable #$BinaryFunction that returns the meaningful entities indexed by a particular character string in a Cyc-external information source. More precisely, (#$MeaningInSystemFn INFOSOURCE STRING), applied to the #$CharacterString STRING and the #$IndexedInformationSource INFOSOURCE, returns whatever is indexed by STRING in that system.  For example, (#$MeaningInSystemFn #$WordNet-1997Version ''N03585958'') returns the WordNet `synset' (`synonym set') represented by (rampart|bulwark|wall), meaning ''an embankment built around a space for defensive purposes''.\n<p>\nSTRING can have any format chosen by the person who builds the representation of the external system.  In addition, STRING may contain arbitrary further characters or information, depending on how the external information is selected and processed.  This function makes it possible to relate a concept in an external system to an arbitrarily complicated expression composed of Cyc concepts.  If the external concept has a direct, exact mapping to a single Cyc constant, then use the predicate #$synonymousExternalConcept rather than this function.  If there is correspondence only to one Cyc constant, but it is only approximate, use #$overlappingExternalConcept."^^_string))) .
\"urn:uuid:e3aec6f3-bb2d-4bf3-9d11-0f7bbebbc614"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(MeaningInSystemFn, (2), CharacterString)) .
istAsserted(EnglishParaphraseMt, genKeyword(MeaningInSystemFn, MetaVariableFn(("MEANING-IN-SYSTEM-FN"^^_string)))) .
\"urn:uuid:17c88ea8-1046-4c99-bcc2-a311862a0c79"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Microtheory, ("A specialization of #$AspatialInformationStore and #$AbstractIndividual (qq.v.).  Each instance of #$Microtheory is an atemporal, aspatial, informational thing that represents a context in Cyc.  Each microtheory (or 'mt') serves to group a set of assertions together that share some common assumptions; the assertions in an mt constitute the content of that mt.  Note that each assertion in the Cyc knowledge base must be explicitly stated to be true in at least one microtheory.  Assertions stated to be true in one mt will also be true  (by inference) in more specialized mts that depend on the content of that mt.  For example, if something is true in the #$HumanSocialLifeMt (q.v.), then it should by default be true in the more specialized #$UnitedStatesSocialLifeMt (q.v.).  Specialized microtheories are related to the more general microtheories on which they depend by the predicate #$genlMt (q.v.).  Note that every query is made in some mt, and the answer one gets to a query depends on the mt in which it is asked, since the only assertions which can be used to answer a query in an mt are those  explicitly stated to be true in that mt, or in some more general mt.  See also the predicate #$ist, which is used to relate an assertion to the microtheories in which it is true."^^_string))) .
\"urn:uuid:c6a8b5ee-9ec7-40f7-ab6b-6a2d0c96381c"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyDecidableCollection(Microtheory)) .
\"urn:uuid:c7f5dc30-f07d-4c9b-8573-2081471c5aee"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(Microtheory, TruthValue)) .
\"urn:uuid:34434d8f-6350-4ae5-bba3-6b2aa1e6b529"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MicrotheoryDesignatingRelation, ("The collection of #$Relations which specify that a #$ELSentence-Assertible is to be interpreted in a given #$Microtheory.  It will be canonicalized and checked for well-formedness with respect to that microtheory. Each microtheory-designating relation has an argument which denotes a microtheory, and another argument which denotes a #$ELSentence-Assertible.  It may have other arguments as well. Use #$microtheoryDesignationArgnum and #$sentenceDesignationArgnum to specify these argument positions for each microtheory-designating relation."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(MinRangeFn, ("the minimum range subsumed by ~a and ~a"^^_string), TheEmptyList)) .
\"urn:uuid:6d5d39f1-3905-4170-81cd-5c2147232bc7"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(MinRangeFn, SubLSymbolFn(("CYC-MIN-RANGE"^^_string)))) .
\"urn:uuid:feeef019-69af-4389-aecf-cf38012f096a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MinRangeFn, ("An instance of both #$VariableArityRelation and #$EvaluatableFunction.  When applied to instances <code>QUANTITY1</code>, ..., <code>QUANTITYN</code>  of #$ScalarInterval, #$MinRangeFn yields an instance of #$ScalarInterval that is the largest interval subsumed by each of <code>QUANTITY1</code> through <code>QUANTITYN</code>.  \n<p>\nFor example, (#$MinRangeFn  (#$Meter 1 3) (#$Meter 2 4)) is (#$Meter 2 3). \n<p>\nNote that if one of the instances <code>QUANTITY1</code>, ..., <code>QUANTITYN</code> fails to intersect with at least one of the other instances, then the result of applying #$MinRangeFn to <code>QUANTITY1</code>, ..., <code>QUANTITYN</code> is undefined (for example, both (#$MinRangeFn (#$Meter 1 1.5) (#$Meter 2 4) (#$Meter 0 5)) and (#$MinRangeFn (#$SecondsDuration 3 5) (#$Meter 1 4)) are undefined).  See also #$MaxRangeFn."^^_string))) .
\"urn:uuid:4f4c989b-287b-4096-8d24-c4ed6b54d5c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Minimum, ("Computes the minimum of a unary function's values over all elements in a given set or collection.  That is, (#$Minimum SETORCOL FUNC) denotes the value of FUNC for the element ELEM of SETORCOL taken as argument (if any) such that (FUNC ELEM) is less than or equal to (FUNC OTHER) for any element OTHER of SETORCOL other than ELEM.  Note that (#$Minimum SETORCOL #$IdentityFn) denotes the minimum element of SETORCOL itself."^^_string))) .
\"urn:uuid:3870c69a-4056-48a2-ad8b-2d5e85172f8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Minimum, (2), UnaryFunction)) .
\"urn:uuid:e1c0b7b5-cbe1-4e09-a32f-fe41a93d3c7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Minimum, (1), SetOrCollection)) .
\"urn:uuid:6736a79b-b596-446d-9384-11fa916ea944"[silk#strict] .
istAsserted(BaseKB, argIsa(Minimum, (1), SetOrCollection)) .
\"urn:uuid:a8290133-8cd9-4d53-a8b2-81a836f35d23"[silk#strict] .
istAsserted(BaseKB, argIsa(Minimum, (2), UnaryFunction)) .
istAsserted(EnglishParaphraseMt, genFormat(Minimum, ("the minimum ~a over ~a"^^_string), [(2), [(1), MetaVariableFn(("PLURAL"^^_string))]])) .
\"urn:uuid:d3de3f77-8d85-4cec-b6cb-13e34f102422"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(Minimum, SubLSymbolFn(("CYC-MINIMUM"^^_string)))) .
\"urn:uuid:e8a1d521-bad4-449b-a7ea-8687d2f17f71"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ModuloFn, ("A binary function that takes a scalar and a comparable (non-null) point-value scalar to another comparable scalar, #$ModuloFn is a generalization of a basic notion of modular arithmetic, broadened to apply to #$ScalarIntervals of all sorts.\n<p>\n(#$ModuloFn <code>SCALAR BASE</code>) is the value of <code>SCALAR</code> modulo <code>BASE</code>, determined as follows.  (i) If <code>SCALAR</code> and <code>BASE</code> are both positive or both negative values, <code>SCALAR-MOD-BASE</code> is the remainder left when <code>BASE</code> is successively subtracted from <code>SCALAR</code> (zero or more times) until the result is a value that is closer to the comparable null-value (see #$ScalarNullValue) than <code>BASE</code> is.  (ii) If <code>SCALAR</code> and <code>BASE</code> differ in their numeric signs, <code>SCALAR-MOD-BASE</code> is the remainder left when <code>BASE</code> is successively <i>added</i> to <code>SCALAR</code> (zero or more times) until the result is a value <i>whose numeric sign agrees with that of</i> <code>BASE</code> or is null, and which is closer to the comparable null-value than <code>BASE</code> is.  (iii) If <code>SCALAR</code> is already a null-value, <code>SCALAR-MOD-BASE</code> is just <code>SCALAR</code> itself.  \n<p>\nFor example, (#$ModuloFn 8 3) = 2, (#$ModuloFn (#$Meter 9) (#$Meter -4)) = (#$Meter -3), and (#$ModuloFn (#$Inch -12) (#$Inch -4)) = (#$Inch 0).\n<p>\nNote that in case (i) above, if the absolute value of <code>SCALAR</code> is any value #$lessThan the absolute value of <code>BASE</code>, <code>SCALAR-MOD-BASE</code> is equal to <code>SCALAR</code>.  In all cases, if <code>SCALAR</code> #$numericallyEquals <code>BASE</code>, <code>SCALAR-MOD-BASE</code> is the comparable null-value.  In all cases, the numeric sign of the returned value <code>SCALAR-MOD-BASE</code> agrees with that of <code>BASE</code> (unless the returned value is null).  Also note that <code>(#$ModuloFn SCALAR BASE)</code> is #$undefined if <code>SCALAR</code> and <code>BASE</code> are not #$numericallyComparable (q.v.), or if <code>BASE</code> is null. \n<p>\nIn practice, <code>BASE</code> will usually be a positive integral value, and both <code>SCALAR</code> and the returned value will often be integral as well (see #$ScalarIntegralValue).  Note that if <code>SCALAR</code> and <code>BASE</code> are given in <i>different</i> (but comparable) #$UnitOfMeasures (e.g. #$Meter and (#$Centi #$Meter)), the result returned by Cyc will be given in the same units as <code>BASE</code>."^^_string))) .
\"urn:uuid:336c8aee-950c-4f58-8923-54c464cec7d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ModuloFn, (2), ScalarPointValue)) .
\"urn:uuid:3f63e8a5-116a-48a0-936d-35812cd679fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ModuloFn, (1), ScalarInterval)) .
\"urn:uuid:755ab115-7a39-4d48-bff7-a2b080f62729"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationDefn(ModuloFn, SubLSymbolFn(("CYC-MODULO"^^_string)))) .
\"urn:uuid:282174ab-b8c1-4f01-9f3b-3b615a0a406c"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(ModuloFn, (1), Integer, NonNegativeInteger)) .
\"urn:uuid:50e08dc1-a474-4a5a-98ee-ea2229205afe"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Monday, ("A collection of #$CalendarDays and an \ninstance of #$DayOfWeekType.  #$Monday is the collection of all \n(and only) mondays."^^_string))) .
\"urn:uuid:f2ae9b3e-d3f5-470d-9308-abe5ab6fe305"[silk#strict] .
istAsserted(BaseKB, comment(MonotonicallyFalse, ("An instance of #$CycHLTruthValue.  #$MonotonicallyFalse is the attribute of being indefeasibly false."^^_string))) .
\"urn:uuid:6dbfa93d-df9d-4419-be28-2fd01fad3152"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(MonotonicallyFalse, False)) .
\"urn:uuid:ae808182-a877-4e80-bba2-9068081ff406"[silk#strict] .
istAsserted(BaseKB, comment(MonotonicallyTrue, ("An instance of #$CycHLTruthValue.  #$MonotonicallyTrue is the attribute of being indefeasibly true."^^_string))) .
\"urn:uuid:23c1b4a6-78f4-418b-88f2-c158457de0c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MonthOfYearType, ("A collection of #$Collections.\nInstances of #$MonthOfYearType are the canonical subcollections of #$CalendarMonth.  There are twelve of these in the #$JulianCalendar; for example, #$September is the collection of all Septembers."^^_string))) .
\"urn:uuid:e1de2fa7-bc73-4300-a819-53fa8845bc06"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MtSpace, ("(#$MtSpace MT-1 ... MT-N) denotes the microtheory whose set of domain assumptions is the union of the assertions true in each of MT-1 ... MT-N. Consequently, (#$MtSpace MT-1 ... MT-N) has each of MT-1 ... MT-N as one of its #$genlMts. Typically, but not always, there will be assertions true in (#$MtSpace MT-1 ... MT-N) that are not true in any of its #$genlMts. For example,\n<p>\n(#$MtSpace #$WorldHistoryMt (#$MtDim #$mtTimeIndex (#$YearFn 1790)))\n<p>\ndenotes the microtheory whose domain assumption are precisely those of the #$WorldHistoryMt (whose basic assumption is that we are in the context of actual world history) and those of the microtheory (#$MtDim #$mtTimeIndex (#$YearFn 1790)) (whose basic assumption is that 1790 is the present year -- see #$MtDim). The conjunction of these domain assumptions implies everything that is true in real world history in the year 1790. For example, these domain assumptions imply that (#$president #$UnitedStatesOfAmerica #$GeorgeWashington) is true. Consequently, this assertion is true in (#$MtSpace #$WorldHistoryMt (#$MtDim #$mtTimeIndex (#$YearFn 1790)))."^^_string))) .
\"urn:uuid:bf3fd2de-e9a6-40cd-859e-73e73676dab5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MtTimeDimFn, ("An unreifiable #$UnaryFunction that takes a #$TimeInterval and returns a #$TemporalMicrotheory.  <code>(#$ist (#$MtTimeDimFn INTERVAL) ASSERTION)</code> holds just in case <code>ASSERTION</code> holds at <code>INTERVAL</code> to granularity #$Null-TimeParameter.  See also #$MtTimeWithGranularityDimFn."^^_string))) .
\"urn:uuid:0742fdf0-727c-4a56-a23c-047c2a940776"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MtTimeWithGranularityDimFn, ("An unreifiable #$BinaryFunction that takes a #$TimeInterval and a #$TimeParameter and returns a #$TemporalMicrotheory.  <code>(#$ist (#$MtTimeWithGranularityDimFn INTERVAL PAR) ASSERTION)</code> holds just in case <code>ASSERTION</code> holds at <code>INTERVAL</code> to granularity <code>PAR</code>.  See also #$MtTimeDimFn."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(MtTimeWithGranularityDimFn, ("MtTimeDimWithGranularityFn"^^_string))) .
\"urn:uuid:c6670bb3-9f25-4635-832c-6ec7e8f5f1aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(MtUnionFn, ("(#$MtUnionFn . MTS) denotes the #$ProblemSolvingCntxt where each of MTS and all of their #$genlMts are relevant.  This microtheory effectively contains all of the assertions from all of MTS, regardless of any contradictions."^^_string))) .
\"urn:uuid:b92a6538-aa86-4823-8303-e2ce6354771e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Multigraph, ("An instance of #$PathSystemType-Structural and a subcollection of #$PathSystem.  Each instance of #$Multigraph is an instance of #$PathSystem in which the only points are nodes in the system and all paths are made of links (i.e., no intermediate points along links). Sometime such a system is called a graph or multi-graph in graph theory.  A #$Multigraph consists of nodes interconnected by links, with loops on single nodes allowed, and with multiple links between the same two nodes also allowed.  (For a graph with no parallel links and no loops, see #$SimpleGraph-GraphTheoretic."^^_string))) .
\"urn:uuid:3adf6034-08c8-49c6-b52e-e318400c6c9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(NonNegativeInteger, ("#$NonNegativeInteger is the sub-collection of #$Integer that excludes the negative integers.  Each instance of #$NonNegativeInteger is a whole number greater than or equal to zero -- for example, 0, 1, 2, 3, ...."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(NonNegativeInteger, MetaVariableFn(("NON-NEGATIVE-INTEGER"^^_string)))) .
\"urn:uuid:190d8840-e844-461b-9f35-76d8b72baded"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(NonNegativeScalarInterval, ("A specialization of #$ScalarInterval.  An instance INTERVAL of #$ScalarInterval is also an instance of #$NonNegativeScalarInterval just in case INTERVAL is a non-negative number or quantity.  Instances of #$NonNegativeScalarInterval include all instances of #$NonNegativeNumber (q.v.), as well as non-negative quantities such as (#$Meter 212), (#$Kilogram 5), and (#$SecondsDuration 0)."^^_string))) .
\"urn:uuid:c36d6c35-ead1-4b8d-b58c-1c6633ee6d83"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(November, ("A specialization of #$CalendarMonth. Each instance of #$November is the eleventh month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(November, MetaVariableFn(("NOVEMBER"^^_string)))) .
\"urn:uuid:6a8f4781-a96f-433b-ad45-871b79a9beb4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(October, ("A specialization of #$CalendarMonth.  Each instance of #$October is the tenth month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(October, MetaVariableFn(("OCTOBER"^^_string)))) .
\"urn:uuid:5efbb213-a813-4a5f-98fc-18f08ce5aa08"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PartiallyCommutativeRelation, ("An instance of #$RelationTypeByLogicalFeature (q.v.) and a specialization of #$AtLeastPartiallyCommutativeRelation.  Each instance  of #$PartiallyCommutativeRelation <code>PARTCOMRELN</code> is a predicate or function that is commutative in some, but not all, of its argument-places (see  #$commutativeInArgs).  More precisely, suppose for example that <code>PARTCOMRELN</code> is a predicate (function) that is commutative only in its odd-numbered  argument-places, and that <code>PARTCOMRELN</code> holds among (has the value <code>VAL</code> for) a given sequence of arguments <code>SEQ</code>.  It follows that <code>PARTCOMRELN</code> also holds among (has the same value <code>VAL</code> for) any other sequence <code>SEQ-PRIME</code> obtainable from <code>SEQ</code> by permuting some or all of the odd-numbered members of <code>SEQ</code> while keeping all of its even-numbered members fixed.\n<p>\nNote that <code>PARTCOMRELN</code> must  have an arity (see #$arity) of at least three and <i>cannot</i> be an instance of #$CommutativeRelation (as any instance of the latter is commutative in <i>all</i> of its argument-places).\n<p>\nInstances of #$PartiallyCommutativeRelation include #$pathsJoinAt, #$formsBorderBetween, and #$BlockOfStreetBetweenFn."^^_string))) .
\"urn:uuid:140d65e6-ed79-44eb-b963-0223ca7b819f"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(PartiallyCommutativeRelation, UnaryRelation)) .
\"urn:uuid:ee2691ab-8d14-4ffa-8fba-d2665a14d806"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PerFn, ("A binary #$UnitOfMeasureDenotingFunction (q.v.) that takes two #$UnitOfMeasure (q.v.) functions and returns a #$UnitOfRatio (q.v.) composed of them.  <code>(#$PerFn UNIT1 UNIT2)</code> is a unit <code>RATIO-FN</code> for measuring the ratio of <code>UNIT1</code> units to <code>UNIT2</code> units.   That is, for any number or other #$NumericInterval <code>NUM</code>, <code>(RATIO-FN NUM)</code> = <code>(#$QuotientFn (UNIT1 NUM) (UNIT2 1))</code>.\n<p>\nFor example, (#$PerFn #$Meter #$SecondsDuration) is a #$UnitOfSpeed function that measures meters-per-second.  When applied to (e.g.) the integer 20, this unit-of-speed returns the particular #$Speed equal to\n<pre>\n  (#$QuotientFn (#$Meter 20) (#$SecondsDuration 1))\n</pre>\nor 20 meters-per-second.\n<p>\nNote that <code>UNIT1</code> and <code>UNIT2</code> must <i>not</i> be #$interconvertibleUnits (q.v.), or <code>(#$PerFn UNIT1 UNIT2)</code> is #$undefined.  Otherwise, <code>UNIT1</code> and <code>UNIT2</code> would effectively ''cancel each other out'', and the value returned by #$PerFn for those arguments would not be a #$UnitOfRatio.\n<p>\nSee also #$UnitProductFn."^^_string))) .
\"urn:uuid:815d630c-5177-444c-9fae-fb24365ad73b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(PerFn, (2), UnitOfMeasure)) .
\"urn:uuid:0ba9cae9-d21f-4c6f-a360-8b2a5d5ebf9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(PerFn, (1), UnitOfMeasure)) .
istAsserted(EnglishParaphraseMt, genKeyword(PerFn, MetaVariableFn(("PER-FN"^^_string)))) .
\"urn:uuid:3de52b51-184b-4341-9a9a-d5d8379109e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Percent, ("A variable-arity #$MathematicalFunctionOnScalars (q.v.).  When applied to a number or other #$NumericInterval (pair of numeric-intervals), #$Percent returns the instance of #$IntervalOnNumberLine that is its argument (the interval between its two arguments) divided by 100.  For example (#$Percent 110) is 1.1, and (#$Percent 10 20) is (#$Unity 0.1 0.2): the interval between 0.1 and 0.2 inclusive."^^_string))) .
\"urn:uuid:e3c79d74-a181-49e2-8baf-42e72f4840b0"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(Percent, SubLSymbolFn(("CYC-PERCENT"^^_string)))) .
\"urn:uuid:afccccab-3b88-40e6-b696-cbc5ca612c9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, unitMultiplicationFactor(Percent, Unity, (100))) .
\"urn:uuid:7a70c4b1-137b-4415-b7ae-fe4a3f02966f"[silk#strict] .
istAsserted(UniversalVocabularyMt, expansion(Percent, QuotientFn(MetaVariableFn(("ARG1"^^_string)), (100)))) .
\"urn:uuid:92e67eb9-da6b-4713-9109-d2052a06f0fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PlusAll, ("A #$NumericQuantifier function that takes a #$SetOrCollection and a #$UnaryFunction as its arguments. (#$PlusAll <b>SETORCOL FUNC</b>) is the result of adding up the results of successively applying <b>FUNC</b> to each element of <b>SETORCOL</b>.  For example:\n<pre>\n    (#$PlusAll (#$TheSet 4 9) #$SquareRootFn)\n  = (#$PlusFn (#$SquareRootFn 4) (#$SquareRootFn 9))\n  = (#$PlusFn 2 3)\n  = 5."^^_string))) .
\"urn:uuid:55ae2114-84b9-443e-b18b-8bc73cfad13b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(PlusAll, (1), SetOrCollection)) .
\"urn:uuid:a9af124f-bd9a-44aa-a20c-09a9aa1cff12"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(PlusAll, (2), UnaryFunction)) .
\"urn:uuid:87a2b48c-0028-4521-8731-b3839d5bfa4d"[silk#strict] .
istAsserted(BaseKB, argIsa(PlusAll, (1), SetOrCollection)) .
\"urn:uuid:4ff7a4f2-d5ea-4393-8ff3-a0b54d391b1a"[silk#strict] .
istAsserted(BaseKB, argIsa(PlusAll, (2), UnaryFunction)) .
istAsserted(EnglishParaphraseMt, genFormat(PlusAll, ("the sum of ~a over ~a"^^_string), [(2), [(1), MetaVariableFn(("PLURAL"^^_string))]])) .
\"urn:uuid:18a96bd3-56d0-4ca8-8d27-89b872eeb4a5"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(PlusAll, SubLSymbolFn(("CYC-PLUS-ALL"^^_string)))) .
\"urn:uuid:9d9f18dd-d4be-4c6b-98b3-da7c7e9f56dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PlusFn, ("A variable-arity #$MathematicalFunctionOnScalars that is an extension of the arithmetical operation of addition to measurable #$ScalarIntervals (q.v.) generally.  Where  <code>ADDEND1</code>, ..., and <code>ADDENDn</code> are pairwise #$numericallyComparable (q.v.), <code>(#$PlusFn ADDEND1 ... ADDENDn)</code> is the arithmetic sum of <code>ADDEND1</code>, ..., and <code>ADDENDn</code>.  For example, (#$PlusFn 2 3 4) is 9, and (#$PlusFn (#$Meter 1.5) (#$Meter 0.7)) is (#$Meter 2.2).\n<p>\nNote that the term <code>(#$PlusFn ADDEND1 ... ADDENDn)</code> is #$undefined if there are <code>ADDENDi</code> and <code>ADDENDj</code> (1 <code><= i,j <= n)</code> that are not comparable.  For example, <code>(#$PlusFn (#$MinutesDuration 1) (#$Meter 3))</code> is undefined, since (#$MinutesDuration 1) is a #$Time-Quantity and (#$Meter 3) is a #$Distance, and time-quantities are not comparable with distances.\n<p>\nFor subtraction, see #$DifferenceFn."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(PlusFn, ("the sum of ~a"^^_string), [[(1), MetaVariableFn(("AND"^^_string))]])) .
istAsserted(BookkeepingMt, oldConstantName(PlusFn, ("Plus"^^_string))) .
\"urn:uuid:6221cbb3-c413-459f-b6e4-77b8a2ee9b85"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(PlusFn, SubLSymbolFn(("CYC-PLUS"^^_string)))) .
\"urn:uuid:abf93b76-db4f-4abb-9ea8-520a1a8a5bce"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PositiveInteger, ("A specialization of #$Integer.  An instance INT of #$Integer is an instance of #$PositiveInteger just in case INT is an integer greater than 0."^^_string))) .
\"urn:uuid:9365557d-3ffc-4175-8672-c71c65eb3f21"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Predicate, ("A specialization of #$TruthFunction (q.v.).  Each instance of #$Predicate is either a property of things (see #$UnaryPredicate) or a relationship holding between two or more things.  Like other truth-functions, predicates, or rather the expressions that represent or denote them, are used to form sentences.  More precisely, any CycL expression that denotes an instance of #$Predicate (and only such an expression) can appear in the ''0th'' (or ''arg0'') position (i.e. as the term following the opening parenthesis) of a #$CycLAtomicSentence (q.v.).  Important specializations of #$Predicate include #$UnaryPredicate, #$BinaryPredicate, #$TernaryPredicate, #$QuaternaryPredicate, and #$QuintaryPredicate.  Note that, despite its name, #$Predicate is a collection of <i>relations</i>, and not a collection of expressions that represent or denote such relations."^^_string))) .
\"urn:uuid:081e1c8b-754e-49c8-a866-31485f697c18"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg2Pred(Predicate, genlPreds)) .
\"urn:uuid:ef2d57ca-225a-45b3-b551-ae4e49461fb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(Predicate, genlPreds)) .
\"urn:uuid:902948fc-e574-43d7-90d6-af1dd6cf369b"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(Predicate, arity)) .
\"urn:uuid:d3fdb2c5-5d7e-4d1f-8f0e-d0c94a8bc7e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(Predicate, argIsa)) .
\"urn:uuid:a483d34a-d320-4592-a007-71155b69b3b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(PredicateTypeByArity, ("A collection of collections.  Each instance of #$PredicateTypeByArity is a collection of #$Predicates having the same #$arity.  Instances include #$UnaryPredicate, #$BinaryPredicate, and #$TernaryPredicate."^^_string))) .
\"urn:uuid:7dd982e6-c10c-4cd8-9da7-bcdd4a95fa7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ProblemSolvingCntxt, ("A specialization of #$Microtheory.\n#$ProblemSolvingCntxts are microtheories that are used to reason about \nparticular situations.  Queries posed in #$ProblemSolvingCntxts are\nexpected to draw -- via the #$genlMt relation -- on a large number\nof other microtheories.  A #$ProblemSolvingCntxt is usually created \nfor temporary use with a problem at hand, and is discarded after the \nproblem is dealt with.  In contrast, a #$GeneralMicrotheory (q.v.), e.g., \nis created for lasting use.  Specializations of #$ProblemSolvingCntxt \ninclude #$ParsingContext and #$ScenarioTestingMicrotheory."^^_string))) .
\"urn:uuid:ca4086cb-cb25-4c37-8978-564ffb60c2c3"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(ProblemSolvingCntxt)) .
\"urn:uuid:5c967fc6-36be-4ed2-b92f-f0f8f019d9d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Quantifier, ("A specialization of #$SententialRelation and #$ScopingRelation (qq.v.).  Each instance of #$Quantifier takes as its arguments (at least) a variable (see #$CycLVariable) and a sentence (see #$CycLSentence-Assertible), and is used to make a certain kind of generic quantitative statement regarding the things that satisfy the sentence.  Typically, the variable VAR will occur free in the sentence SENT, and in the quantified sentence (QUANT VAR SENT ...) these occurrences of VAR are bound by that occurrence of QUANT.  (If VAR does not occur free in SENT, then the quantified sentence is a ''vacuous quantification'' that is equivalent to SENT by itself.  For the definitions of 'free' and 'bound' occurrences of variables, see #$ScopingRelation.)  For example, '(#$thereExists ?X (#$isa ?X #$Dog))' means that there exists at least one dog.  Other instances of #$Quantifier are #$forAll, #$thereExistExactly, #$thereExistAtLeast, and #$thereExistAtMost."^^_string))) .
\"urn:uuid:c3145fce-4494-4d72-bb30-528efd270839"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(Quantifier)) .
istAsserted(EnglishParaphraseMt, genKeyword(Quantifier, MetaVariableFn(("QUANTIFIER"^^_string)))) .
\"urn:uuid:6813b87a-74ac-422f-88ed-665b9af1a0cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuantityConversionFn, ("(#$QuantityConversionFn UNIT QUANTITY) converts QUANTITY into an equivalent quantity expressed using UNIT as the unit of measure.  For example, (#$QuantityConversionFn #$Inch (#$Foot-UnitOfMeasure 2)) denotes (#$Inch 24)."^^_string))) .
\"urn:uuid:42cce76a-438b-4827-9eeb-5639631a3ba6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(QuantityConversionFn, (1), UnitOfMeasure)) .
\"urn:uuid:3639714c-12f1-45d7-878e-f60804d3bf40"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(QuantityConversionFn, SubLSymbolFn(("CYC-QUANTITY-CONVERSION"^^_string)))) .
\"urn:uuid:c3547cf9-e9c8-4855-9e28-e0d223e83356"[silk#strict] .
istAsserted(BaseKB, resultQuotedIsa(QuantityConversionFn, IndeterminateTerm)) .
\"urn:uuid:460b36dd-cec4-4b76-9dbf-926f526c8f27"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuasiQuote, ("A quotation device for making general statements about CycL expressions.  #$QuasiQuote allows for any free variables occurring inside an expression to which it is applied to ''escape'' (i.e. remain free with respect to) the quotation.  It is thus similar in function to, though less flexible than, the combination of #$Quote and #$EscapeQuote (qq.v.).\n<p>\nTo be more precise: the syncategorematic symbol <code>#$QuasiQuote</code> is a device for allowing genuinely free variables to occur inside quoted expressions, in order that one may meaningfully ''quantify into'' such expressions and thereby <i>generalize</i> over them.  It can thus be instructively compared to the symbol <code>#$Quote</code> (q.v.), which is used to make statements about <i>particular</i> CycL expressions.  Let <code>EXPR</code> be a well-formed CycL expression.  The expression <code>(#$Quote EXPR)</code> -- consisting of the symbols <code>#$Quote</code>, <code>EXPR</code>, and a surrounding pair of parentheses -- is a term that denotes <code>EXPR</code>.  The expression <code>(#$QuasiQuote EXPR)</code> is a term whose meaning is similar to <code>(#$Quote EXPR)</code>, except that any free occurrence of a variable in <code>EXPR</code> remains free with respect to <code>(#$QuasiQuote EXPR)</code> as a whole.  If <code>EXPR</code> contains no free variables, then <code>(#$QuasiQuote EXPR)</code> is a closed term (see #$CycLClosedDenotationalTerm) that denotes <code>EXPR</code>, and is equivalent to <code>(#$Quote EXPR)</code>.  If <code>EXPR</code> contains any free occurrences of variables, then <code>(#$QuasiQuote EXPR)</code> is an open term (see #$CycLOpenDenotationalTerm) in which exactly the same variables occur free; and any closed instantiation of <code>(#$QuasiQuote EXPR)</code> denotes the corresponding instantiation of <code>EXPR</code>.  (A <i>closed instantiation</i> of <code>EXPR</code> is any closed expression that results from replacing each free occurrence of a variable in <code>EXPR</code> with some closed term, and replacing any two occurrences of the same variable by the same closed term.)\n<p>\nFor an example, the variable <code>?X</code> occurs free in the term\n<pre>\n  (#$QuasiQuote (#$MotherFn ?X)) ;\n</pre>\nand one instantiation of this is the closed term\n<pre>\n  (#$QuasiQuote (#$MotherFn #$Plato)) ,\n</pre>\nwhich denotes the non-atomic term <code>(#$MotherFn #$Plato)</code>.  And the (implicitly quantified) rule\n<pre>\n  (#$isa (#$QuasiQuote (#$MotherFn ?X)) #$CycLNonAtomicTerm)\n</pre>\nmeans, in effect, that any closed instantiation of the open term <code>(#$MotherFn ?X)</code> -- e.g. <code>(#$MotherFn #$Plato)</code> -- is a non-atomic term of CycL.\n<p>\nSee also #$denotes, #$quotedIsa, #$quotedArgument, #$NoteAboutQuotingInCycL, and #$NoteAboutSyncategorematicSymbols."^^_string))) .
\"urn:uuid:4baf5990-f373-40ba-bf5d-48ce7ce092f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(QuasiQuote, (1), Thing)) .
\"urn:uuid:4a82543d-52e5-4787-bd45-f4bba22d0fe5"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(QuasiQuote, (1), CycLTerm)) .
\"urn:uuid:05cb8ef9-ec82-4a27-9f48-980e119ce815"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(QuasiQuote, (1), CycLTerm)) .
\"urn:uuid:d12e26e0-124c-4fdd-8cca-be2fb5c5c129"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuaternaryFunction, ("A specialization of both #$FixedArityFunction and #$QuaternaryRelation (qq.v.).  Each instance of #$QuaternaryFunction is a function that always takes four arguments at a time, i.e. has the arity (see #$arity) 4."^^_string))) .
\"urn:uuid:573538f1-8286-471e-8bcc-f7e1d8c67f81"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuaternaryPredicate, ("A specialization of both #$QuaternaryRelation and #$Predicate.   #$QuaternaryPredicate is the collection of all predicates whose arity (see #$arity) is 4."^^_string))) .
\"urn:uuid:ee6c5e2e-a87c-4bac-8bd0-847b94b40ab0"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuaternaryPredicate, UnaryPredicate)) .
\"urn:uuid:ad0dcfe9-3511-4800-9f95-849278548435"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuaternaryPredicate, BinaryPredicate)) .
\"urn:uuid:926e467f-7ca8-4f1f-8338-5f60c3dab478"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuaternaryPredicate, TernaryPredicate)) .
\"urn:uuid:d5ae1bb4-45e7-42a3-9cd9-5d0c79582532"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuaternaryRelation, ("The collection of all fixed-arity relations of arity 4 (see #$arity).  The most notable specializations of #$QuaternaryRelation are #$QuaternaryPredicate and #$QuaternaryFunction (qq.v.)."^^_string))) .
\"urn:uuid:5763db37-5437-4012-b991-de47a4ae66a9"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuaternaryRelation, arg4Isa)) .
\"urn:uuid:e999c1e7-203e-4340-b62f-7152d4567385"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuaternaryRelation, arg3Isa)) .
\"urn:uuid:ef398a90-cacd-4bea-b9a8-bed7b5fb93b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuaternaryRelation, arg2Isa)) .
\"urn:uuid:a686f8bd-8221-4906-a982-d6b9bd0de794"[silk#strict] .
istAsserted(BaseKB, comment(QueryMt, ("The instance of #$IndexicalConcept used specifically for referring to 'the microtheory in which this particular query is being run'.  This allows for a certain amount of reflection in queries, since it allows one to pose a query about the #$Microtheory of the very same Ask.  It is useful for cases where one wants to obtain certain facts about the context of an Ask without specifying anything more about that context."^^_string))) .
\"urn:uuid:e5df588e-da69-4fca-8f38-575f4d745c3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuintaryFunction, ("A specialization of both #$QuintaryRelation and #$Function-Denotational. An instance of #$Function-Denotational FUNC is an instance of #$QuintaryFunction if and only if FUNC has an #$arity of 5."^^_string))) .
\"urn:uuid:bac5a28b-0852-4eea-9934-fe75c03952d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuintaryPredicate, ("A specialization of #$Predicate and #$QuintaryRelation.  #$QuintaryPredicate is the collection of all predicates whose arity (see #$arity) is 5."^^_string))) .
\"urn:uuid:64926277-b6f8-40ff-ac6b-9d4a033ba0b3"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuintaryPredicate, UnaryPredicate)) .
\"urn:uuid:4b078ebc-6a30-4cf3-aca2-81623ef3a4ce"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuintaryPredicate, BinaryPredicate)) .
\"urn:uuid:b0a4ec9c-95cc-48a1-8d6c-a9d71973ec82"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuintaryPredicate, TernaryPredicate)) .
\"urn:uuid:09ee197d-aefa-4415-8870-6317e0e054ba"[silk#strict] .
istAsserted(BaseKB, disjointWith(QuintaryPredicate, QuaternaryPredicate)) .
\"urn:uuid:d1b2dc26-e05a-4639-aead-ea708d35b458"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuintaryRelation, ("The collection of all fixed-arity relations of arity 5 (see #$arity).  The most notable specializations of #$QuintaryRelation are #$QuintaryPredicate and #$QuintaryFunction (qq.v.)."^^_string))) .
\"urn:uuid:41c19233-09fa-48c5-80d1-d851d9009819"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuintaryRelation, arg5Isa)) .
\"urn:uuid:7dc948aa-9cc6-4298-bf42-9df213a0ec0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuintaryRelation, arg4Isa)) .
\"urn:uuid:b3c16a1b-e561-47cd-b914-66f80c66a2d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuintaryRelation, arg3Isa)) .
\"urn:uuid:dd861c08-a450-4165-8513-2f0c25e849e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(QuintaryRelation, arg2Isa)) .
\"urn:uuid:d00cfb69-4234-4e04-9605-912aa68743e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Quote, ("The symbol '#$Quote' is used in CycL as a device for referring to particular CycL expressions, in much the same way that quotation marks are often used in English in order to ''mention'' (rather than simply ''use'') an English word or phrase.  (And in much the same way that single-quotes are used in the preceding sentence in order to refer to a particular CycL symbol.)  If <code>EXPR</code> is a CycL expression, the term <code>(#$Quote EXPR)</code> -- formed by writing '#$Quote' followed by <code>EXPR</code> and enclosing the result in parentheses -- is interpreted as denoting <code>EXPR</code> itself, as opposed to whatever it is (if anything) that <code>EXPR</code> ordinarily denotes (i.e. what it denotes when not inside the scope of <code>#$Quote</code> or in a #$quotedArgument position).  For example, while the CycL constant <code>#$Plato</code> denotes a certain Greek philosopher, the compound expression <code>(#$Quote #$Plato)</code> denotes the term <code>#$Plato</code> itself.  Similarly, the expression <code>(#$Quote <b>?X</b>)</code> denotes the variable <code><b>?X</b></code>, and the expression <code>(#$Quote (#$isa #$Plato #$Philosopher))</code> denotes the sentence <code>(#$isa #$Plato #$Philosopher)</code>.\n<p>\n<code>#$Quote</code> is also used in conjunction with the symbol <code>#$EscapeQuote</code> (q.v.), as a device for making <i>general</i> statements about CycL expressions.  Let <code>EXPR = (E<sub>1</sub>...E<sub>n</sub>)</code> be a well-formed CycL expression whose <b>n</b> immediate constituents are the CycL expressions <code>E<sub>1</sub></code>, ..., and <code>E<sub>n</sub></code> (where <b>n</b> >= 1).  The expression \n<pre>\n  (#$Quote EXPR) = (#$Quote (E<sub>1</sub>...E<sub>n</sub>))\n</pre> \n-- consisting of the symbols <code>#$Quote</code>, <code>EXPR</code>, and a surrounding pair of parentheses -- is a term that denotes <code>EXPR</code>.  The expression (call it <i><b>EQ</b></i>) \n<pre>\n  (#$Quote (E<sub>1</sub>...(#$EscapeQuote E<sub>i</sub>) ...E<sub>n</sub>)\n</pre> \n(where 1 <= <b>i <= n</b>) is a term whose meaning is similar to <code>(#$Quote EXPR)</code>, except that any free occurrence of a variable in <code>E<sub>i</sub></code> remains free with respect to <b>EQ</b> as a whole.  If <code>E<sub>i</sub></code> contains no free variables, then <b>EQ</b> is a closed term (see #$CycLClosedDenotationalTerm) that denotes <code>EXPR</code>, and is equivalent to <code>(#$Quote EXPR)</code>.  If <code>E<sub>i</sub></code> does contain free variables, then <b>EQ</b> is an open term (see #$CycLOpenDenotationalTerm) in which exactly the same variables occur free; and any closed instantiation of <b>EQ</b> denotes the corresponding instantiation of <code>EXPR</code>.  (A <i>closed instantiation</i> of an open expression is any <i>closed</i> expression that results from simultaneously replacing each free occurrence of a variable in the open expression with some closed term, replacing any two occurrences of the same variable by the same closed term.)\n<p>\nFor a simple example, the variable <code><b>?X</b></code> occurs free in the term\n<pre>\n  (#$Quote (#$EscapeQuote (#$MotherFn <b>?X</b>)) ;\n</pre>\nand one instantiation of this is the closed term\n<pre>\n  (#$Quote (#$EscapeQuote (#$MotherFn #$Plato)) ,\n</pre>\nwhich denotes the non-atomic term <code>(#$MotherFn #$Plato)</code>.  \n<p>\nFor a more interesting example, consider a case where <i>some but not all</i> of the free variables in a term are quoted.  In the expression\n<pre>\n  (#$Quote (#$loves (#$EscapeQuote <b>?X</b>) <b>?Y</b>))\n</pre>\nonly <code><b>?X</b></code> occurs free -- the <code><b>?Y</b></code> is quoted. Thus this instantiation of the above:\n<pre>\n  (#$Quote #$loves (#$EscapeQuote #$Plato) <b>?Y</b>)\n</pre>\nis a closed term that denotes the <i>open</i> formula <code>(#$loves #$Plato <b>?Y</b>)</code>.  \n<p>\nNote that the sort of quotation done in the first example above can also be done -- and done more elegantly -- using just #$QuasiQuote instead of #$Quote and #$EscapeQuote.  But the sort of quotation done in the second example cannot be accomplished with #$QuasiQuote.\n<p>\nSee also #$QuasiQuote, #$EscapeQuote, #$denotes, #$quotedIsa, #$quotedArgument, #$NoteAboutQuotingInCycL, and #$NoteAboutSyncategorematicSymbols."^^_string))) .
\"urn:uuid:c928fb70-2e0e-40d3-b525-43dac0bc995a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(Quote, (1), Thing)) .
\"urn:uuid:c1a7900b-51bb-4914-8acd-7fd30dadade5"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(Quote, (1), CycLTerm)) .
\"urn:uuid:bc1ed37a-86fc-42e9-843c-771def5d05f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(Quote, (1), CycLTerm)) .
\"urn:uuid:da498acf-26cf-4a02-a7b3-c1eb23cda12a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(QuotientFn, ("An instance of both #$BinaryFunction and #$EvaluatableFunction.  When applied to an instance DIVIDEND of #$ScalarInterval and an instance DIVISOR of #$ScalarInterval, #$QuotientFn returns an instance of #$ScalarInterval that is the result of dividing DIVIDEND by DIVISOR.  For example, (#$QuotientFn 24 6) is 4, (#$QuotientFn (#$Meter 3) (#$SecondsDuration 2)) is (#$MetersPerSecond 1.5) (i.e., 1.5 meters per second), and (#$QuotientFn (#$SecondsDuration 2) (#$Meter 3)) is ((#$PerFn #$SecondsDuration #$Meter) 0.6666666666666666) (i.e., 0.6666666666666666 seconds per meter).  Note that (#$QuotientFn DIVIDEND 0) is undefined for any instance DIVIDEND of #$ScalarInterval."^^_string))) .
\"urn:uuid:a28363c1-8266-4d52-bd58-f9d7d1e1c05a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(QuotientFn, (1), ScalarInterval)) .
\"urn:uuid:1f24156b-b1cb-473c-9bb3-c70f3d5973ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(QuotientFn, (2), ScalarInterval)) .
istAsserted(BookkeepingMt, oldConstantName(QuotientFn, ("Quotient"^^_string))) .
\"urn:uuid:cb34a99d-926f-4d70-80c5-aed05f763e00"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(QuotientFn, SubLSymbolFn(("CYC-QUOTIENT"^^_string)))) .
\"urn:uuid:f8b0eeea-3292-4caf-b740-f73c79e35790"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RealNumber, ("The collection of real numbers; a specialization of both  #$IntervalOnNumberLine and #$ScalarPointValue (qq.v.).  Each  instance of #$RealNumber is a single point on the real number  line, which has no upper or lower bounds.  Specializations  of this collection include #$Integer, #$RationalNumber, and  #$NegativeNumber.  Note that #$RealNumber is also a specialization  of #$ComplexNumber (q.v.), and any instance of the former  constitutes a degenerate case of the latter, in that the value  along the real's ''imaginary axis'' is zero (cf. #$ImaginaryNumber)."^^_string))) .
\"urn:uuid:fdffd399-1c8c-4cb7-a350-5c26684c4f3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReflexiveBinaryPredicate, ("The specialization of #$BinaryPredicate whose instances are reflexive relations.  A reflexive binary predicate relates anything that meets the predicate's argument constraints to that thing itself.  Typically, a reflexive predicate has precisely the same constraints on both of its argument-places.\n<p>\nMore precisely: a binary predicate <code>PRED</code> is an instance of #$ReflexiveBinaryPredicate if and only if both (i) for every <code>X</code> that satisfies the constraints on (i.e is an #$admittedArgument for) <i>both</i> argument-places of <code>PRED</code>, <code>(PRED X X)</code> holds and (ii) <code>PRED</code>'s two argument-places are ''co-satisfiable'' with respect to their (single-argument) type constraints (see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nInstances of #$ReflexiveBinaryPredicate include #$physicalParts, #$inRegion, #$genls, and #$equals."^^_string))) .
\"urn:uuid:daca5121-cda1-4b6f-b526-71c555fc349a"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(ReflexiveBinaryPredicate, IrreflexiveBinaryPredicate)) .
\"urn:uuid:cd7ee3f4-7cb1-4bbf-9e48-8717bc60ee32"[silk#strict] .
istAsserted(UniversalVocabularyMt, collectionExpansion(ReflexiveBinaryPredicate, MetaVariableFn(("ARG1"^^_string))(?X, ?X))) .
\"urn:uuid:f56e8b75-18a4-4c58-b507-647ff2c3b0b5"[silk#strict] .
istAsserted(BaseKB, comment(ReformulationBackwardDirection, ("A meta-property of a #$CycLReformulatorDirective, meaning\nthat there exist two arguments in the directive such that the\nhigher-numbered arg (e.g. arg2 for a binary predicate) is the 'from'\narg, the input to the reformulator, and that the lower-numbered arg\n(e.g. arg1 for a binary predicate) is the 'to' arg, the output of the\nreformulator.  Its semantics are more fully determined by context.\nSee #$reformulationDirectionInMode for how this\ndirection can be used."^^_string))) .
\"urn:uuid:8c66ef12-d00c-4815-acee-7e5eb4fa6ea8"[silk#strict] .
istAsserted(BaseKB, comment(ReformulationForwardDirection, ("A meta-property of a #$CycLReformulatorDirective, meaning\nthat there exist two arguments in the directive such that the\nlower-numbered arg (e.g. arg1 for a binary predicate) is the 'from'\narg, the input to the reformulator, and that the higher-numbered arg\n(e.g. arg2 for a binary predicate) is the 'to' arg, the output of the\nreformulator.  Its semantics are more fully determined by context.\nThis is the default #$preferificationDirection for\n#$reformulatorRules.  See #$reformulationDirectionInMode for how this\ndirection can be used."^^_string))) .
\"urn:uuid:005454e6-0540-4ace-b841-8d0baa5829bd"[silk#strict] .
istAsserted(BaseKB, comment(ReformulationNeitherDirection, ("A meta-property of a #$CycLReformulatorDirective,\nmeaning that no arg is to be interpreted as either the 'from' or 'to' arg.\nSee #$reformulationDirectionInMode for how this\ndirection can be used."^^_string))) .
\"urn:uuid:a459368f-5c0d-478f-be53-0262ba02aa42"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReformulatorDirectivePredicate, ("The collection of #$Predicates which can affect the\nbehaviour of the #$CycLReformulator or its submodules.  When\nreformulator directive GAFs are asserted, they are only relevant to\nthe reformulator when it is reformulating expressions in the\nmicrotheory in which the directive is asserted, or a specMt thereof."^^_string))) .
\"urn:uuid:72526bf2-6dc1-4d44-8e8f-fbbd84523596"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReformulatorHighlyRelevantFORT, ("The collection of Cyc FORTs that are highly relevant to the reformulator."^^_string))) .
\"urn:uuid:544f1af3-7966-4695-97ec-49446dd4f006"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReformulatorHighlyRelevantFORT, ("The collection of Cyc FORTs that are highly relevant to the reformulator.           An example of such a FORT would be one that is referenced in a large           number of reformulator rules in the KB (see intances of            #$CycLReformulationRulePredicate)."^^_string))) .
\"urn:uuid:50ecac9b-db44-44fd-9f54-5dad7ae6e45b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReformulatorIrrelevantFORT, ("The collection of Cyc FORTs that are not relevant to the reformulator."^^_string))) .
\"urn:uuid:601b4bed-c1b2-4435-a8aa-b5245ebafcfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ReifiableFunction, ("A specialization of #$Function-Denotational.   Each instance of #$ReifiableFunction is denoted by a CycL constant that can stand in the 0th (or ''arg0'') position in a #$CycLReifiableNonAtomicTerm  (q.v.).  For example, #$GovernmentFn is a reifiable function, so the term  `(#$GovernmentFn #$France)' is a reifiable non-atomic term (or ''NAT'').   And since this particular term actually _is_ reified in the Cyc Knowledge  Base, it is, more specifically, a #$CycLNonAtomicReifiedTerm (or ''NART'').   The NART `(#$GovernmentFn #$France)' is treated more or less the same as if  it were a CycL constant (named, say, `GovernmentOfFrance').  Similary, the constant for #$GovernmentFn can be applied to the constant (or other  reified or reifiable term) for _any_ instance of #$GeopoliticalEntity to form a reifiable NAT that denotes that region's government; and should this NAT appear in a sentence that is asserted to the KB, it will thereby become a NART. Note, however, that not all NATs are such that it is desireable that  they should become reified (i.e. become NARTs) if they appear in  assertions; for more on this see #$UnreifiableFunction."^^_string))) .
\"urn:uuid:c0026efb-3e23-4888-86ab-5deb27ec561e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, disjointWith(ReifiableFunction, UnreifiableFunction)) .
\"urn:uuid:59de9346-e7ce-444b-9da3-9c5988d59f5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Relation, ("A specialization of #$MathematicalObject and the collection of all relations.  Each instance of #$Relation is a relation that can hold among one or more things, depending on whether the relation is unary, binary, ternary, or whatever (see #$arity and #$relationalArity).  A unary relation (such as #$unknownSentence) is a sort of degenerate case that holds of  certain individual things (in this case, all sentences that are unknown to Cyc).  A binary relation (such as #$likesAsFriend) relates one thing to another (in this case, it relates one sentient animal to another just in case the first likes the second).  A ternary relation relates certain triples of things.  And so on.  There are also relations of no particular fixed arity; see #$VariableArityRelation.\n<p>\nNames of relations can be used to construct sentences and other formulas.  More precisely, CycL terms that denote #$Relations can appear in the ''0th'' argument (or ''arg0'') position of a #$CycLFormula (q.v.), i.e. as the term immediately following the formula's opening parenthesis.\n<p>\nAn important subcollection of #$Relation is #$TruthFunction (q.v.), whose instances are intimately related to truth-values, as reflected in the fact that the CycL expressions that denote truth-functions can appear in the arg0 position of a #$CycLSentence; and a sentence (if quantificationally closed; see #$CycLClosedSentence), will generally be either true or false (with respect to a given context or interpretation).  The major subcollections of #$TruthFunction are #$Predicate, #$LogicalConnective, and #$Quantifier (qq.v.).\n<p>\nAnother important subcollection of #$Relation is #$Function-Denotational (q.v.), the collection of all functions.  A CycL term that denotes a function can appear in the arg0 position of a #$CycLNonAtomicTerm (q.v.).\n<p>\nSee also #$relationExtension and #$relationHoldsAmong."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(Relation, MetaVariableFn(("RELATIONSHIP"^^_string)))) .
istAsserted(BookkeepingMt, oldConstantName(Relation, ("Relationship"^^_string))) .
\"urn:uuid:49b2929b-43a0-4e5a-9f4b-dc0954ce9355"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(Relation, NonNegativeInteger)) .
\"urn:uuid:18479e44-4e0c-48ac-be0b-efabcf0fcf14"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(Relation, TruthValue)) .
\"urn:uuid:c0329065-be8e-44b5-863e-4c3479b54b2a"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(Relation, Microtheory)) .
istAsserted(EnglishParaphraseMt, requiredArg1Pred(Relation, genFormat)) .
\"urn:uuid:d4c66286-22b7-4d95-b2d9-161cd076eae6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RelationAllExistsFn, ("An #$IndeterminateTermDenotingFunction (q.v.) that is closely related to #$relationAllExists.  If both (#$relationAllExists PRED INDEP-COL DEP-COL) and (#$isa INDEP-INS INDEP-COL) hold,  then (PRED INDEP-INS (#$RelationAllExistsFn INDEP-INS PRED INDEP-COL DEP-COL) also holds.  Thus the term '(#$RelationAllExistsFn INDEP-INS PRED INDEP-COL DEP-COL)' ''indeterminately denotes'' some instance of DEP-COL that is related to INDEP-INS by PRED.  For instance, since (#$relationAllExists #$citizens #$Country #$Person) and (#$isa #$Malaysia #$Country) both hold, so does (#$citizens #$Malaysia (#$RelationAllExistsFn #$Malaysia #$citizens #$Country #$Person))."^^_string))) .
\"urn:uuid:608d32e0-18f0-476f-ba61-8dcf4488dd2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationAllExistsFn, (3), Thing)) .
\"urn:uuid:87aba797-b58d-4ac6-a99c-1885387df39f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationAllExistsFn, (4), Thing)) .
\"urn:uuid:7183e8f4-738c-493a-b9f1-3dd241e385c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationAllExistsFn, (4), Collection)) .
\"urn:uuid:dce8d06a-d71e-4d02-8e2e-dc86d44e5514"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationAllExistsFn, (2), BinaryPredicate)) .
\"urn:uuid:3b18d651-a4cf-4070-8b5d-a51116e40c99"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationAllExistsFn, (1), Thing)) .
\"urn:uuid:9f2cac40-3694-4a7b-8ab9-503463ad2a55"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationAllExistsFn, (3), Collection)) .
\"urn:uuid:f5e51758-9d76-42f6-a93f-3c82e25ca1fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArg(RelationAllExistsFn, (4))) .
\"urn:uuid:9e7c5750-4a11-4871-9790-19c803fdb99c"[silk#strict] .
istAsserted(BaseKB, resultQuotedIsa(RelationAllExistsFn, IndeterminateTerm)) .
\"urn:uuid:791f58dc-3e6d-4cb1-90a3-7a96a72262b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RelationExistsAllFn, ("The predicate #$relationExistsAll states that for every instance of a collection, some other term exists in a certain relationship.  An arbitrary such term is a function of the instance, the predicate, the collection, and the type of the other term.  (#$RelationExistsAllFn TERM PRED DEP-COL INDEP-COL) allows one to denote this `arbitrary such term that so exists' in a named fashion."^^_string))) .
\"urn:uuid:83ae5eae-e9cb-4cbf-a718-fc51c1617724"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationExistsAllFn, (4), Thing)) .
\"urn:uuid:96c915a7-29cc-4d93-952d-423c2fc67fe4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationExistsAllFn, (3), Thing)) .
\"urn:uuid:592a1300-2433-46a8-a90a-a7558dcbcea2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsAllFn, (1), Thing)) .
\"urn:uuid:16e48b02-ff25-480b-ad99-e7cb78f43150"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsAllFn, (2), BinaryPredicate)) .
\"urn:uuid:ca202eea-2111-425b-9c97-54fd53bddafb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsAllFn, (3), Collection)) .
\"urn:uuid:045f0b32-85e8-4489-b1b6-cce5bcdaf795"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsAllFn, (4), Collection)) .
\"urn:uuid:1dcb4b5b-2e68-484e-aa20-96ea1df0de54"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArg(RelationExistsAllFn, (3))) .
\"urn:uuid:c14ba13e-4437-4cff-9a0c-1d4916b33751"[silk#strict] .
istAsserted(BaseKB, resultQuotedIsa(RelationExistsAllFn, IndeterminateTerm)) .
\"urn:uuid:99bd513a-ec6c-4cd9-8749-599192169783"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RelationExistsInstanceFn, ("(#$relationExistsInstance PRED COLL THING) says that some (not necessarily known) instance INS of the #$Collection COLL stands in the relation PRED to THING. (#$RelationExistsInstanceFn PRED COLL THING) denotes INS."^^_string))) .
\"urn:uuid:7f86470d-ac05-4682-9275-6669dc4e6c79"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationExistsInstanceFn, (2), Thing)) .
\"urn:uuid:ab7d04df-da8f-4560-baf4-f72d986785b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsInstanceFn, (3), Thing)) .
\"urn:uuid:85956808-bb73-441f-b999-de8cccb7ea39"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsInstanceFn, (2), Collection)) .
\"urn:uuid:f788a2f4-5123-4c17-b2da-02b96eaa3991"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationExistsInstanceFn, (1), BinaryPredicate)) .
\"urn:uuid:474bd7db-fd79-42b2-8483-c1239ed95241"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArg(RelationExistsInstanceFn, (2))) .
\"urn:uuid:a315e438-02a0-4a0e-a7a8-207123a5409e"[silk#strict] .
istAsserted(BaseKB, resultQuotedIsa(RelationExistsInstanceFn, IndeterminateTerm)) .
\"urn:uuid:1356e9e4-4967-4b6b-8a63-7b86b813f1d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RelationInstanceExistsFn, ("(#$relationInstanceExists PRED THING COLL) says that THING stands in the relation PRED to some (not necessarily known) instance of the #$Collection COLL. (#$RelationInstanceExistsFn PRED THING COLL) denotes this instance of COLL."^^_string))) .
\"urn:uuid:387fa241-101d-4994-9d7e-1562da8ccd54"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(RelationInstanceExistsFn, (3), Thing)) .
\"urn:uuid:eca4089e-a3c2-4156-8c4e-58c13372d53b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationInstanceExistsFn, (3), Collection)) .
\"urn:uuid:712e65e4-ca21-4c53-9b13-0c6b028fe782"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationInstanceExistsFn, (2), Thing)) .
\"urn:uuid:3423446e-86da-419e-a161-7294934dc24f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RelationInstanceExistsFn, (1), BinaryPredicate)) .
\"urn:uuid:19126c57-50f5-4427-9f38-877a97ff45e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, resultIsaArg(RelationInstanceExistsFn, (3))) .
\"urn:uuid:be7a2a97-59b6-4394-a4ec-9a5635036714"[silk#strict] .
istAsserted(BaseKB, resultQuotedIsa(RelationInstanceExistsFn, IndeterminateTerm)) .
\"urn:uuid:87e6ce22-4bb5-4653-abb7-9a042ff399cc"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(RelaxArgTypeConstraintsForVariables, ("A #$CanonicalizerDirective  (q.v.) that directs the #$CycCanonicalizer (specifically, the  #$CycWellFormednessChecker) to relax the argument-type constraints it usually imposes on variables.  For example, this canonicalizer directive  would allow the sentence `(#$and (#$isa ?X #$Collection) (#$isa ?X #$Individual))'  to be admitted, though it would otherwise be rejected as ill-formed due to  the mutually disjoint argument-type constraints (see #$ArgTypePredicate) on the positions occupied by the two occurrences of the variable `?X'."^^_string))) .
\"urn:uuid:1e066b27-b461-4848-b45f-1ea79627ee6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('RemovalModuleSupportedCollection-Generic', ("The collection of all #$Collections which are supported by some #$CycRemovalModule-Generic.  An assertion of the form (#$isa INS COL), where COL is an instance of #$RemovalModuleSupportedCollection-Generic, may affect the provability of sentences that do not mention COL explicitly.  In particular, it may affect the provability of sentences mentioning INS."^^_string))) .
\"urn:uuid:6f6d30ee-0556-446e-84e2-bb7348ad7324"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('RemovalModuleSupportedPredicate-Generic', ("The collection of all #$Predicates which are supported by some #$CycRemovalModule-Generic.  An assertion of the form (PRED . ARGS), where PRED is an instance of #$RemovalModuleSupportedPredicate-Generic, may affect the provability of sentences other than just sentences whose predicate is PRED.  This is what is meant by 'generic' in this sense."^^_string))) .
\"urn:uuid:dff58d52-6d41-4c83-aa97-369949240d2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('RemovalModuleSupportedPredicate-Specific', ("The collection of all #$Predicates which are supported by some #$CycRemovalModule-Specific.  Sentences of the form (PRED . ARGS), where PRED is an instance of #$RemovalModuleSupportedPredicate-Specific, have special inference support."^^_string))) .
\"urn:uuid:6a2c4931-7433-4a45-9601-d0c5cf4aa085"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RoundClosestFn, ("(#$RoundClosestFn QUANTITY) converts QUANTITY into one where the maximum and minimum ranges have been rounded to the closest integer values.  For example,  (#$RoundClosestFn (#$Meter 2.41)) denotes (#$Meter 2),  (#$RoundClosestFn (#$Meter 2.7)) denotes (#$Meter 3), and (#$RoundClosestFn (#$Meter 1.6 4.2)) denotes  (#$Meter 2 4). If QUANTITY is exactly between two integers (that is, in the form integer+0.5), then it is rounded to the one that is even. So, (#$RoundClosestFn (#$Meter 2.5)) denotes (#$Meter 2), and (#$RoundClosestFn (#$Meter 7.5)) denotes (#$Meter 8). See also #$RoundUpFn, #$RoundDownFn."^^_string))) .
\"urn:uuid:8b1cc462-51aa-41b0-9405-c04cc6b9b37b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RoundClosestFn, (1), ScalarInterval)) .
\"urn:uuid:035699cc-dfd1-458b-a53c-520a94bf20f5"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(RoundClosestFn, SubLSymbolFn(("CYC-ROUND-CLOSEST"^^_string)))) .
\"urn:uuid:25f5e1aa-fb28-4479-874a-abe4c497bdb0"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundClosestFn, (1), ScalarPointValue, ScalarPointValue)) .
\"urn:uuid:06896864-ee52-42a2-a5ed-572941ded5dc"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundClosestFn, (1), RealNumber, Integer)) .
\"urn:uuid:86b4d5f6-268c-4b7b-af53-d2ac8de0ac1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RoundDownFn, ("(#$RoundDownFn QUANTITY) converts QUANTITY into one where the maximum and minimum ranges have been rounded downwards to integer values.  For example, (#$RoundDownFn (#$Meter 2.5)) denotes (#$Meter 2)."^^_string))) .
\"urn:uuid:43fe6ab7-38f8-4086-b61a-a4853a6f60f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RoundDownFn, (1), ScalarInterval)) .
istAsserted(EnglishParaphraseMt, genFormat(RoundDownFn, ("~a, rounded down"^^_string), TheEmptyList)) .
\"urn:uuid:806d07ba-8f3b-4402-889d-407adeea1161"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(RoundDownFn, SubLSymbolFn(("CYC-ROUND-DOWN"^^_string)))) .
\"urn:uuid:fb20043a-4020-46e2-a350-718e66c9efe0"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundDownFn, (1), ScalarPointValue, ScalarPointValue)) .
\"urn:uuid:dbcb3cc0-6370-4a2b-a6bf-235fb2c9415a"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundDownFn, (1), RealNumber, Integer)) .
\"urn:uuid:632af4ab-6a88-4256-b241-a79f7921a1c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RoundUpFn, ("An instance of #$EvaluatableFunction.  When applied to an instance INTERVAL of #$ScalarInterval, #$RoundUpFn returns an instance ROUNDED-INTERVAL of #$ScalarInterval in which the minimum and maximum ranges of INTERVAL have been rounded upwards to integer values.  For example, (#$RoundUpFn (#$Meter 2.5 5.2)) is (#$Meter 3 6)."^^_string))) .
\"urn:uuid:62d57567-72ae-4cc7-b701-ff97215e5ed4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(RoundUpFn, (1), ScalarInterval)) .
istAsserted(EnglishParaphraseMt, genFormat(RoundUpFn, ("~a, truncated"^^_string), TheEmptyList)) .
istAsserted(EnglishParaphraseMt, genFormat(RoundUpFn, ("~a, rounded up"^^_string), TheEmptyList)) .
\"urn:uuid:9538afe1-eaff-4e54-b3d1-1763be97a9cb"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(RoundUpFn, SubLSymbolFn(("CYC-ROUND-UP"^^_string)))) .
\"urn:uuid:9f433303-35ed-4711-8474-a120d804c2ef"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundUpFn, (1), ScalarPointValue, ScalarPointValue)) .
\"urn:uuid:a80d0360-c788-4d62-afcc-13bd4cf30a87"[silk#strict] .
istAsserted(BaseKB, interArgResultIsa(RoundUpFn, (1), RealNumber, Integer)) .
\"urn:uuid:1c865958-53a1-44a2-aa9e-60ba7efa6a77"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(RuleTemplate, ("Terms denoting formulas (typically without support for efficient inference) that can be (partially) instantiated as Cyc assertions (typically with support for efficient inference); see #$trueRule and #$ruleTemplateAssertion."^^_string))) .
\"urn:uuid:f6f51603-0c11-4330-9cb2-45f34d477945"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Saturday, ("A collection of #$CalendarDays and an \ninstance of #$DayOfWeekType.  #$Saturday is the collection of all \n(and only) saturdays."^^_string))) .
\"urn:uuid:31ec9fc6-4719-45bd-b8cd-4ca83e87e869"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ScalarIntegralValue, ("A specialization of #$ScalarPointValue (q.v.).  Each instance of #$ScalarIntegralValue is either an #$Integer or a #$MeasurableQuantity  (q.v.) that is the value returned when some #$UnitOfMeasure (q.v.) function is applied to an #$Integer.  In the latter case, the quantity is said to be ''integral with respect to'' that unit-of-measure (see #$integralWRTUnit).\n<p>\nFor example, both 6 and (#$Inch 6) are scalar integral values.  The latter is integral with respect to #$Inch.\n<p>\n#$ScalarIntegralValues are the admitted arguments for, and the values returned by, #$GreatestCommonDivisorFn and #$LeastCommonMultipleFn (qq.v.).\n<p>\nNote that, despite appearances to the contrary, (#$Foot-UnitOfMeasure 0.5) is a scalar integral value that is integral with respect to #$Inch, as it is equal to the scalar integral (#$Inch 6).  It might even be argued that, in principle, <i>every</i> #$MeasurableQuantity is integral with respect to some (reified or not) unit-of-measure or other.  But that is a contentious issue on which we need not take sides."^^_string))) .
\"urn:uuid:60fd803f-d5ec-4085-8083-f06c1a5daa61"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ScalarInterval, ("A specialization of #$TupleOfIntervals (q.v.).  Roughly put, this is the collection of all things that can be ranked according to some one-dimensional scale.  Instances of #$ScalarInterval are numbers or quantities possessing only sign and magnitude.  They are construed as <i>one-tuples</i> (see #$Tuple) of intervals.  They are to be contrasted with #$VectorIntervals (q.v.), which possess a direction as well as a magnitude, and are construed as two-membered tuples of intervals.\n<p>\n#$ScalarInterval is partitioned into the two collections #$NumericInterval (which is the collection of numbers and number-ranges of all kinds) and #$Quantity (qq.v).  A #$Quantity is usually specified with a numeric-interval, as with (#$Meter 3)), but it might also be given in a generically-ranked way, as with (#$HighAmountFn #$Happiness); see the specializations #$MeasurableQuantity and #$NonNumericScalarQuantity.  The magnitude of a scalar might be given by a specific number (see #$ScalarPointValue) or by a proper range of numbers (see #$ScalarProperInterval).\n<p>\nNote that the instances of #$MathematicalFunctionOnScalars (q.v.), which include artithmetic functions such as addition (see #$PlusFn) and division (see #$QuotientFn), are defined broadly so as to apply not only to numbers, but to (numerically-measured) scalar intervals generally.  Thus (#$PlusFn (#$Meter 3) (#$Meter 5)) is equal to (#$Meter 8)."^^_string))) .
\"urn:uuid:76db2075-0c60-498a-80ab-688c6f314626"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ScalarPointValue, ("A specialization of #$ScalarInterval (q.v.).  Each instance of #$ScalarPointValue is a specific number or quantity, as opposed to a range of numbers or quantities (cf. #$ScalarProperInterval).  Instances of #$ScalarPointValue include all reals numbers and other #$Number-Generals (q.v.), as well as specific instances of #$Quantity such as (#$Meter 3) and (#$SecondsDuration 10)."^^_string))) .
\"urn:uuid:0e44e017-15dc-4af1-8a84-d0b85412c09a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ScopingRelation, ("A specialization of #$Relation whose instances are used to determine a ''scope'' with respect to one or more variables and to bind any free occurrences of those variables that are inside that scope.  Each instance of #$ScopingRelation takes as its arguments (at least) a variable or list of variables (see #$CycLVariable and #$CycLVariableList) and a formula (see #$CycLExpression-Assertible).  The former argument is the scoping relation's ''scoping'' argument (see #$scopingArg), and the latter its ''scoped formula'' argument (see #$scopedFormulaArg).\n<p>\nSyntactically, the formula (SCOPINGRELN VAR SENT) might either be a sentence or a non-atomic term (see #$CycLNonAtomicTerm), depending on which #$ScopingRelation it is built from.  Suppose for simplicity that the sentence SENT itself contains no #$ScopingRelation expressions, so that any variables occurring in SENT are not bound (i.e. they are _free_).  Then, in the formula (SCOPINGRELN VAR SENT), the _scope_ of the occurrence of the term SCOPINGRELN is SENT, and any free occurrence of the variable VAR in SENT is said to be _bound_ by that occurrence of SCOPINGRELN, and thus is bound (and hence not free) with respect to the entire formula.  (The occurrence of VAR immediately to the right of SCOPINGRELN is also considered bound with respect to the entire formula.)\n<p>\nSemantically, if the formula (SCOPINGRELN VAR SENT) is _closed_ (i.e. if it contains no free occurrence of any variable), then it will in some sense be ''about'' the value(s) of VAR that satisfy SENT.  That is, if (SCOPINGRELN VAR SENT) is a closed sentence it will state something about those values, while if (SCOPINGRELN VAR SENT) is a closed NAT it will (purport to) denote something related to those values.  For an example of the former case see #$thereExists; for the latter case see #$TheSetOf.  (If there are no free occurrences of VAR inside SENT, then (SCOPINGRELN VAR SENT) is a ''vacuous'' application of SCOPINGRELN that means exactly what SENT means.)\n<p>\nInstances of #$ScopingRelation include all of the #$Quantifiers and #$Lambda."^^_string))) .
\"urn:uuid:27a4a4f3-278d-4ddd-91ba-2084f9aa246d"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(ScopingRelation, scopingArg)) .
\"urn:uuid:7ab0721b-3043-4198-bbdc-87e4121a16ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SententialRelation, ("A collection of mathematical objects.  Each instance of #$SententialRelation is by definition either a #$LogicalConnective or a #$Quantifier."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SententialRelation, ("NonPredicateTruthFunction"^^_string))) .
\"urn:uuid:8a613486-aa75-4aa4-ac8c-ca1a769af2ea"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(SententialRelation, Predicate)) .
\"urn:uuid:9dbc9df4-5fac-4af1-bab4-ae43fee0fdf0"[silk#strict] .
istAsserted(UniversalVocabularyMt, completelyEnumerableCollection(SententialRelation)) .
\"urn:uuid:412956bf-5755-4101-8a9b-cd281b008e56"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(September, ("A specialization of #$CalendarMonth.  Each instance of #$September is the ninth month of a particular year in the #$GregorianCalendar (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(September, MetaVariableFn(("SEPTEMBER"^^_string)))) .
\"urn:uuid:ce6b76d0-78b2-435a-b43d-6722f9c1b63f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('Set-Mathematical', ("A specialization of #$SetOrCollection (q.v.); the collection of mathematical sets.  An instance of #$Set-Mathematical can be any arbitrary set of #$Things.  A good way to explain this notion with respect to the Cyc ontology is to contrast #$Set-Mathematical with #$Collection (q.v.).  First, while the instances of a given collection all have some more-or-less significant (often ''natural'') property or properties in common, the elements (see #$elementOf) in a given set might have nothing in common (besides membership in that set).  Second, while it is in principle possible for two distinct collections to have exactly the same elements (with respect to a given context), this cannot happen in the case of sets, which are individuated strictly in terms of their extensions (see #$extent).  Third (and specifically regarding their expression in the CycL language), unlike with collections, rarely will it be desirable to create a new constant to denote a particular set.  Instead, a set will often be either (a) intensionally specified by a defining property via #$TheSetOf (q.v.), as in `(#$TheSetOf ?X (#$and (#$isa ?X #$Integer) (#$greaterThan ?X 42)))', or (b) extensionally specified by enumerating its elements via #$TheSet (q.v.), as in `(#$TheSet 3 4 5)'; see also #$ThePartition and #$TheCovering."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword('Set-Mathematical', MetaVariableFn(("SET-MATHEMATICAL"^^_string)))) .
\"urn:uuid:985316a6-38f7-46b2-ba00-f8a4f39fc25e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SetOrCollection, ("A specialization of #$MathematicalThing.  Something is an instance of #$SetOrCollection just in case it is a collection (i.e. an instance of #$Collection) or a mathematical set (i.e. an instance of #$Set-Mathematical).  Instances of #$Set-Mathematical and instances of #$Collection (and thus instances of #$SetOrCollection) share some basic common features.  All instances of #$Collection and all instances of #$Set-Mathematical (and thus all instances of #$SetOrCollection) are abstract entities, lacking spatial and temporal properties.  Nearly all instances of #$Collection (except ''empty'' collections) and nearly all instances of #$Set-Mathematical (except the empty set; see #$TheEmptySet) have ''elements'' (i.e. instances or members; see #$elementOf); hence set-or-collections may stand to one another in generalized set-theoretic relations such as #$subsetOf and #$disjointWith (qq.v.).  (It is this shared feature of having elements that provides the basic rationale for reifying the collection #$SetOrCollection.)  Nevertheless, sets and collections differ in two important ways.  First, each collection is intrinsically associated with an intensional criterion for membership -- a more or less natural property (or group of properties) possessed by all of (and only) its elements.  Collections are thus akin to kinds.  In contrast, the elements of a set are not required to be homogeneous in any respect: any things whatsoever may together constitute the elements of a set.  The second major difference between sets and collections is that no two distinct sets can be coextensional (i.e. have exactly the same elements; see #$coExtensional).  Sets can thus be identified purely on the basis of their extensions (see #$extent).  Collections, on the other hand, are individuated by their intensional criteria for membership.  So collections that have exactly the same elements might nevertheless be distinct, differing in their respective membership criteria.  (Note that the general relationship between collections and their ''intensional criteria for membership'' in the above sense is not something that is currently represented explicitly in the Knowledge Base (though this seems a worthwhile area for future work); still the #$comment and other ''definitional'' assertions on a given collection should ideally convey a reasonably clear and precise idea of its associated membership criterion.)"^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(SetOrCollection, MetaVariableFn(("SET-OR-COLLECTION"^^_string)))) .
\"urn:uuid:71f82588-f417-4f67-8ea6-23f96c9a53b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(SetOrCollection, subsetOf)) .
\"urn:uuid:1dd4ce7c-649b-45fe-a46d-1bd9575b611e"[silk#strict] .
istAsserted(BaseKB, comment(SetTheFormat, ("An instance of #$Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see #$argFormat).  (#$argFormat PRED N #$SetTheFormat) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there might be any number (including zero) of things such that, if taken as the Nth argument, PRED holds of those arguments.  For example, the format of #$biologicalMother's first argument-place is #$SetTheFormat, since a female animal might have any number of offspring.  Unlike the other reified instances of #$Format, #$SetTheFormat actually places no restriction at all on what PRED might or might not hold of with respect to the relevant argument-place.  But one should not infer from this that entry-format assertions using #$SetTheFormat are pointless; for they forestall duplication of effort by serving notice that the entry-format of a given argument-place has previously been considered and #$SetTheFormat was deemed the appropriate format.  #$SetTheFormat is the most commonly-encountered format in the Cyc Knowledge Base.  Contrast with #$SingleEntry."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SiblingDisjointAttributeType, ("MutuallyDisjointAttributeType"^^_string))) .
\"urn:uuid:bf1b20ec-23d2-40bd-9e87-20a2a7a884bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SiblingDisjointAttributeType, ("A collection of collections.  Each instance of #$SiblingDisjointAttributeType is a collection of quantities.  If COL is such a collection, then nothing can have two instances of COL as quantities unless those two instances are related in a #$quantitySubsumes relationship to each other.  See also #$SiblingDisjointCollectionType."^^_string))) .
\"urn:uuid:559cab4f-1b34-4a15-89a5-d721e4c7ab5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SiblingDisjointCollectionType, ("A #$KBDependentCollection of collections of  collections (and thus an instance of #$CollectionTypeType and a specialization of #$CollectionType).  A sibling-disjoint collection type is such that its known  (i.e. KB-represented) instances are collections that -- save for any that are related to each other by  #$genls and any that are explicitly asserted to be exceptions (see  #$siblingDisjointExceptions) -- are disjoint from each other. \n<p>\nMore precisely, each instance <code>SIB</code> of #$SiblingDisjointCollectionType is a collection of collections that has the following KB-dependent property: \n<p>\nFor any two known instances <code>COL1</code> and <code>COL2</code> of   <code>SIB</code>, at least one of the following is known to hold: \n<pre>\n  (a) (#$genls COL1 COL2)\n  (b) (#$genls COL2 COL1)\n  (c) (#$siblingDisjointExceptions COL1 COL2)\n  (d) (#$disjointWith COL1 COL2)\n</pre>  \nMoreover, note that if <code>MT</code> is a context (see #$Microtheory) in which (i) both <code>(#$isa COL1 SIB)</code> and <code>(#$isa COL2 SIB)</code> hold and (ii)  neither <code>(#$genls COL1 COL2)</code> nor <code>(#$genls COL2 COL1)</code> nor <code>(#$siblingDisjointExceptions COL1 COL2)</code> is known to hold (see #$knownSentence), then \n<code>(#$disjointWith COL1 COL2)</code> holds by default in <code>MT</code>.   \n<p>\nFor example, in #$BiologyMt both #$Person and #$Dog are instances of the  sibling-disjoint collection type #$BiologicalSpecies, while neither  (#$genls #$Person #$Dog) nor (#$genls #$Dog #$Person) nor  (#$siblingDisjointExceptions #$Person #$Dog) is known to hold in that  context; consequently, (#$disjointWith #$Person #$Dog) holds by default  in #$BiologyMt.  Instances of #$SiblingDisjointCollectionType include  #$BiologicalTaxon (and its specializations), #$OrganismPartType, and #$RelationshipTypeByArity.\n<p>\nSee the generalization #$SiblingDisjointSetOrCollectionType.  Also cf. the stronger notion of #$DisjointCollectionType."^^_string))) .
\"urn:uuid:a22a4bf8-f662-449f-a80d-ec373623061d"[silk#strict] .
istAsserted(BaseKB, comment(SingleEntry, ("An instance of #$Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see #$argFormat).  (#$argFormat PRED N #$SingleEntry) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there is at most one thing such that, if taken as the Nth argument, PRED holds of those arguments.  That is, if the sequences <... ARGN ...> and <... ARGN-PRIME ...> differ at most in their Nth items and both (PRED ... ARGN ...) and (PRED ... ARGN-PRIME ...) hold, then ARGN = ARGN-PRIME (see #$equals).  For example, the format of #$biologicalMother's second argument-place is single-entry, since an animal can only have one biological mother.  A predicate with a single-entry format argument-place is thus a #$StrictlyFunctionalPredicate (q.v.) that is strictly functional with respect to that argument-place (see #$strictlyFunctionalInArgs).  Contrast with #$SetTheFormat."^^_string))) .
\"urn:uuid:4fb8f93c-d5ca-4236-9e2e-3fd910b30035"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SkolemFuncN, ("#$SkolemFuncN is a collection of Cyc system-generated functions that partially implement existential quantifications in Cyc.  Whenever someone asserts to Cyc an expression that contains a '#$thereExistAtLeast', a '#$thereExistAtMost', or a '#$thereExistExactly' quantifier, Cyc automatically creates a new instance of #$SkolemFuncN and rewrites the assertion using this skolem function instead of that existential quantifier.  See also #$termOfUnit. At this time (3/98), skolem functions are automatically named by the Cyc system using the prefix 'SKF-' followed by a number."^^_string))) .
\"urn:uuid:8a7bb234-41b3-41f5-9ed6-7cb1e6757a10"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(SkolemFuncNFn, (4), NonNegativeScalarInterval)) .
\"urn:uuid:0279273f-89c1-41b1-be48-39d59f40e8cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SkolemFuncNFn, ("#$SkolemFuncNFn is used by the #$CycCanonicalizer and should rarely\n(if ever) need to be seen by users or referenced in assertions entered\nat the EL level.  It is used by the canonicalizer to denote a skolem\nfunction before it is reified, when the skolem is derived from a formula\nasserted at the EL level that uses #$thereExistAtLeast,\n#$thereExistAtMost, or #$thereExistExactly.  Its arity is 4: the first\nargument is a list of the term variable arguments of the denoted skolem function,\n(term variables which are in the scope of the bounded existential).\nThe second argument is a variable which uniquely identifies the\nexistentially quantified variable by which the denoted skolem will\nbe represented in the canonical version of the formula.\nThe third is a sequence variable if there is a sequence variable\nargument of the denoted skolem function (which there will be iff there\nis a sequence variable in the scope of the bounded existential), and NIL otherwise.\nThe fourth is an interval specifying the number of things which may satisfy the formula."^^_string))) .
\"urn:uuid:dff9ead5-3eb1-4ab1-8515-f91245dae3f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFuncNFn, (2), CycLVariable)) .
\"urn:uuid:e3de1ad0-6c89-4466-8e42-932b40f77f1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFuncNFn, (1), SubLList)) .
\"urn:uuid:d0715e67-8b42-4aa4-a100-c8bede191973"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFuncNFn, (3), SubLSymbol)) .
\"urn:uuid:0fdaf8ef-dc34-466c-8004-40281bd5d4c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFuncNFn, (1))) .
\"urn:uuid:7c383c66-ab8d-4795-b01c-b56e894041a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFuncNFn, (2))) .
\"urn:uuid:2a3f0b73-36bf-4534-976b-4741c3ba495c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFuncNFn, (3))) .
\"urn:uuid:986fdea0-c8a3-4053-8b81-0621e4bce6b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SkolemFunction, ("A specialization of #$IndeterminateTermDenotingFunction and #$ReifiableFunction (qq.v.).  #$SkolemFunction is a collection of system-generated functions that implement existential quantification in Cyc.  Whenever someone asserts to the Knowledge Base a sentence that contains '#$thereExists' (in an arg0 position), Cyc automatically creates a new instance of #$SkolemFunction and rewrites the assertion using that Skolem function.\n<p>\nFor example, suppose we want Cyc to know that every animal has a birth date.   So we assert the following sentence:\n<p>\n<pre>\n  (#$implies\n    (#$isa ?X #$Animal)\n    (#$thereExists ?Y\n      (#$birthDate ?X ?Y))) .\n</pre>\n<p>\nIn response, Cyc automatically reifies a new unary instance of #$SkolemFunction (call it 'BirthDateFn') that takes any given animal to its date of birth, and then rewrites our rule using BirthDateFn instead of #$thereExists, as\n<p>\n<pre>\n  (#$implies\n    (#$and\n      (#$isa ?X #$Animal)\n      (#$termOfUnit ?Y (BirthDateFn ?X)))\n    (#$birthDate ?X ?Y)) .\n</pre>\n<p>\nNote that actual Cyc-generated Skolem function names currently (02/04) consist of the prefix 'SKF-' follow by a numeral."^^_string))) .
\"urn:uuid:5b345869-c198-44b1-b736-99d610796945"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(SkolemFunction)) .
\"urn:uuid:0fd98d3b-909b-4447-aedf-0ada05933df7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SkolemFunctionFn, ("#$SkolemFunctionFn is used by the #$CycCanonicalizer and should rarely (if ever) need to be seen by users or referenced in assertions entered at the EL level.  It is used by the canonicalizer to denote a skolem function before it is reified, when the skolem is derived from a formula asserted at the EL level that uses #$thereExists. Its arity is 3: the first argument is a list of the term variable arguments of the denoted skolem function, (term variables which are in the scope of the existential), the second argument is a variable which uniquely identifies the existentially quantified variable by which the denoted skolem will be represented in the canonical version of the formula, and the third is  a sequence variable if there is a sequence variable argument of the denoted skolem function (which there will be iff there is a sequence variable in the scope of the existential), and NIL otherwise."^^_string))) .
\"urn:uuid:15dfb7b3-4746-4ba7-8327-047af6d94198"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFunctionFn, (2), CycLVariable)) .
\"urn:uuid:e6596fb5-e889-4f1b-afe4-52a350250c76"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFunctionFn, (1), SubLList)) .
\"urn:uuid:55aeb9f9-79b9-413f-b60f-b0c98937e86a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SkolemFunctionFn, (3), SubLSymbol)) .
\"urn:uuid:1c274017-a3ab-4d98-9be1-a00de815bf9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFunctionFn, (2))) .
\"urn:uuid:61cf54ee-806a-4b48-bcc1-66c82e03a21d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFunctionFn, (3))) .
\"urn:uuid:144583e5-0a3f-48ef-a332-2206b52d1a09"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SkolemFunctionFn, (1))) .
\"urn:uuid:5cf3e76e-dc52-48be-9913-990e2115a3bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationDefn(SortFn, SubLSymbolFn(("CYC-SORT"^^_string)))) .
\"urn:uuid:59cb7999-908b-48a5-8aad-a87518879342"[silk#strict] .
istAsserted(BaseKB, comment(SortFn, ("#$SortFn is a ternary list denoting function that takes a set in arg1, any binary comparison relation in arg2, and a unary function F in arg3 and returns the list that is the result of pairwise comparing F(element) for each element in arg1 and sorting the list according to the results of the comparison.  For example, (#$SortFn (#$TheSet 'one' 'four' 'eight') #$greaterThan #$LengthOfStringFn) returns (#$TheList 'eight' 'four' 'one')."^^_string))) .
\"urn:uuid:aec8d0a9-e309-48ad-9f69-1eb1760f7d61"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(SortFn, (2), BinaryPredicate)) .
\"urn:uuid:74bf70d7-b0e5-4be8-a9b3-fecf36bf4bd7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(SortFn, (3), UnaryFunction)) .
\"urn:uuid:45ace371-eb30-4e4e-bffe-f66a9ac10561"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(SortFn, (1), SetOrCollection)) .
\"urn:uuid:a3b820d3-3eed-408f-953c-33a6c444b428"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLAtom, ("A collection of #$SubLSExpressions that are atomic: they cannot be decomposed into other SubL expressions. Save for certain variables (see #$SubLVariable), instances of #$SubLAtom are rarely used in CycL assertions (other than assertions built with certain #$CycInferenceDescriptorPredicates like #$defnIff). Many SubL atoms are not even #$CycLExpressions.  Do not confuse this collection with #$SubLAtomicTerm, which is a #$CycLExpressionType (though its instances are neither CycL constants nor CycL variables).  Note that #$SubLAtom is a ''quoted-collection'' (see #$quotedCollection)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLAtom, ("CycSystemAtom"^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLAtom, ("LispAtom"^^_string))) .
\"urn:uuid:ad24bdab-de2a-49b4-9a96-9720fab36dcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLAtomicTerm, ("The collection of all atomic denotational terms in the CycL language that are not explicitly represented in CycL (i.e. they are neither #$CycLConstants nor #$CycLVariables) but are represented in SubL, the underlying implementation language of the Cyc system.  ''Atomic'' here means not constructable from other terms via the SubL syntax.  Examples include the terms '212', ':NOUN', '#x', and 'VARIABLE-P'. Do not confuse this collection with #$SubLAtom, most of whose instances, while they are expressions of SubL, are <i>not</i> part of CycL.  Note that this collection, like most instances of #$CycLExpressionType, is ''quoted''."^^_string))) .
\"urn:uuid:eb5f2569-4deb-49ef-b541-5f74bb580b62"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLCharacter, ("The collection of all character-denoting terms in the CycL language that are #$SubLAtomicTerms (q.v.). (SubL, which subsumes CycL, is the underlying implementation language of the Cyc system.)  A given #$SubLCharacter CHAR-TERM is itself a string consisting of the hash-symbol (`#'), followed by the backslash (`\\'), followed (in most cases) by the character CHAR that CHAR-TERM denotes.  For example, the SubLCharacter `#\\A'\ndenotes the character `A'.  (An exception to the above is when CHAR is a non-printing or control character, in which case a specially-designated string\nappears after the `#\\'.)"^^_string))) .
\"urn:uuid:1940ff0d-56d3-416a-8573-a352310b3005"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLExpressionType, ("A collection of collections.  Each instance of #$SubLExpressionType is a type (i.e. a subcollection) of SubLSExpression."^^_string))) .
\"urn:uuid:53a4e15a-1ad3-484f-b950-77b9769d3f62"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLInteger, ("The collection of all integer-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  #$SubLIntegers  are numeric strings of the Arabic decimal system (including the negative-value symbol `-', but _not_ the decimal point or scientific notation) that denote integers.  Examples include the expressions `0', `12', and `-4' (which denote the integers 0, 12, and -4, respectively).  Non-examples include `4.012', `(#$Meter 6)', `(#$Unity 3.3)', `:34', and `#$PlusInfinity'.  Note that #$SubLInteger is a ''quoted-collection'' (see #$quotedCollection). Thus the sentence `(#$isa 12 #$SubLInteger)' means that the expression `12' (and not the number 12) is an instance of #$SubLInteger.  Similarly, the assertion `(#$genls #$SubLInteger #$Integer)' means (not that each SubL integer is an integer, but) that each  instance of #$SubLInteger _denotes_ an instance of #$Integer (see the shared #$NoteAboutUseVersusMention)."^^_string))) .
\"urn:uuid:4bbde667-c213-4809-805d-5c01bd083da3"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLInteger, Integer)) .
istAsserted(BookkeepingMt, oldConstantName(SubLInteger, ("CycSystemInteger"^^_string))) .
\"urn:uuid:dc408995-40d0-4e5e-bccd-0d735b8afd04"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLKeyword, ("The subcollection of #$SubLSymbol consisting of all SubL keywords.  Instances include the symbols `:KEYWORD', `:OBJECT', and `:PLURAL'.  Every instance of #$SubLKeyword satisfies (in the sense relevant to #$defnIff) `KEYWORDP'.  Note that #$SubLKeyword, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLKeyword, ("CycSystemKeyword"^^_string))) .
\"urn:uuid:02eecd7c-0f58-4138-9df2-cd2e9308cd0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLList, ("A collection of list-denoting expressions that are not represented in CycL (i.e. they are not #$CycLConstants or #$CycLNonAtomicTerms) but are represented in SubL, the underlying implementation language of the Cyc system.  Each instance of #$SubLList is a sequence of #$SubLListOrAtoms (q.v.) enclosed in parentheses.  SubL lists are those things that pass the #$defnIff LISTP. Note that this collection is ''quoted'' (see #$quotedCollection)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLList, ("CycSystemList"^^_string))) .
\"urn:uuid:bb0b4d3e-6cae-425d-ba24-4395615d461b"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLNonNegativeInteger, Integer)) .
\"urn:uuid:b9e3eac9-7393-4b32-bd76-ef84c93e32aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLNonNegativeInteger, NonNegativeInteger)) .
\"urn:uuid:227ba588-2385-4d3d-b667-eb3b9515f569"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLNonNegativeInteger, ("The collection of all non-negative-integer-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  #$SubLNonNegativeIntegers \nare numeric strings of the Arabic decimal system (not including the decimal point or scientific notation).  Examples include the expressions `0', `12', and `4'.  Non-examples include `4.012', `(#$Meter 6)', `(#$Unity 3.3)', `:34', and `#$PlusInfinity'.  Note that #$SubLNonNegativeInteger is a ''quoted-collection'' (see #$quotedCollection); thus the sentence `(#$isa 12 #$SubLNonNegativeInteger)' means that the expression `12' (and not \nthe number 12) is an instance of #$SubLNonNegativeInteger."^^_string))) .
\"urn:uuid:3eb04eda-066b-449a-8089-685374a211cf"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, disjointWith(SubLNonNegativeInteger, SubLSymbol)) .
\"urn:uuid:6fabc12f-0a41-44de-a998-5014147e1a78"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(SubLNonVariableNonKeywordSymbol, SubLKeyword)) .
\"urn:uuid:28434956-0afe-42f3-a607-b7ff83e4dec9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLNonVariableNonKeywordSymbol, ("The collection of all #$SubLSymbols except #$SubLVariables (q.v.) and #$SubLKeywords (q.v.); a subcollection of #$CycLClosedAtomicTerm.  Note that `symbol' has a very specific, technical meaning in SubL; #$SubLNonVariableNonKeywordSymbols are rarely used in CycL assertions, except within those built with certain #$CycInferenceDescriptorPredicates like #$defnIff. Examples of SubL non-variable non-keyword symbols include the symbols `GENLS' and `CYC-SYSTEM-NON-VARIABLE-NON-KEYWORD-SYMBOL-P'.  Note that this collection, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
\"urn:uuid:797b5ad2-5a55-4bca-98c1-448ffad75309"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLNonVariableSymbol, ("The collection of all #$SubLSymbols except #$SubLVariables (qq.v.); a subcollection of #$CycLClosedAtomicTerm.  Note that `symbol' has a very specific, technical meaning in SubL; #$SubLNonVariableSymbols are rarely used in CycL assertions, except within those built with certain #$CycInferenceDescriptorPredicates like #$defnIff and those whose arguments are #$KeywordVariableTemplates (qq.v.). Examples of SubL non-variable symbols include the symbols `GENLS', `:ARG1', and `CYC-SYSTEM-NON-VARIABLE-SYMBOL-P'.  Note that this collection, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
\"urn:uuid:5c2657f8-8daa-4868-b888-419accc5eb79"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLPositiveInteger, NonNegativeInteger)) .
\"urn:uuid:fef567a9-aa07-435e-b5f0-a81a7abfa435"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLPositiveInteger, PositiveInteger)) .
\"urn:uuid:1a066625-69e8-4117-a98c-9240703ab05e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLPositiveInteger, ("The collection of all positive-integer-denoting expressions in the CycL language that are <i>not</i> CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  #$SubLPositiveIntegers  are numeric strings of the Arabic decimal system (not including the decimal point or scientific notation).  Examples include the expressions '2', '12', and '4'.  Non-examples include '0', '4.012', '(#$Meter 6)', '(#$Unity 3.3)', ':34', and '#$PlusInfinity'.  Note that #$SubLPositiveInteger is a ''quoted-collection'' (see #$quotedCollection); thus the sentence '(#$isa 12 #$SubLPositiveInteger)' means that the expression '12' (not the number 12) is an instance of #$SubLPositiveInteger."^^_string))) .
\"urn:uuid:9426444c-4dc2-4a40-8990-9ab5805373c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, omitArgIsa(SubLQuoteFn, (1))) .
\"urn:uuid:cd5f2b56-d764-4ec2-b0f2-f4a299396176"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(SubLQuoteFn, (1))) .
\"urn:uuid:6313a0d2-436e-4b3c-a34d-abb23bdc1911"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(SubLQuoteFn, (1), SubLSExpression)) .
\"urn:uuid:62e55dde-8696-4d89-8559-2075b208ed93"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLQuoteFn, ("<code>(#$SubLQuoteFn SUBL-EXPRESSION)</code> is one of exactly two escapes to SubL from CycL, the other being #$ExpandSubLFn.  These are the only two ways to represent arbitrary SubL in CycL.  #$SubLQuoteFn encapsulates <code>SUBL-EXPRESSION</code> such that it will not be rejected by the CycL wff-checker as ill-formed CycL.  For example, <code>(#$SubLQuoteFn (+ 1 2))</code>, which <i>is</i> a #$CycLExpression, denotes the #$SubLSExpression (+ 1 2), which itself is <i>not</i> a #$CycLExpression."^^_string))) .
\"urn:uuid:7316534c-1b56-48c6-9748-db6ec5292f1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(SubLQuoteFn, ExpandSubLFn)) .
\"urn:uuid:b4dd8e51-a9f9-49e5-9941-3b694bb37a7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(SubLQuoteFn, performSubL)) .
\"urn:uuid:e249a763-d653-4528-a8c6-755764ee5a0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(SubLQuoteFn, trueSubL)) .
\"urn:uuid:896afcb9-1d97-4e0e-b0bf-b2fe17d0e05a"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(SubLQuoteFn, EvaluateSubLFn)) .
\"urn:uuid:ce8c1ced-0eab-4db1-9918-eb335e629349"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLRealNumber, ("The collection of all number-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system. #$SubLRealNumbers are numeric strings of the Arabic decimal system, including the decimal point and scientific notation.  Examples include the terms `212' and `3.14159d0'.  Non-examples include the expressions `#$One', `(#$Meter 6)', `(#$Unity 3)', `:34', `#$PlusInfinity', and `Avogadro's number'.  Note that this collection, like most instances of #$CycLExpressionType, is ''quoted'' (see #$quotedCollection)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLRealNumber, ("CycSystemRealNumber"^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLRealNumber, ("LispRealNumber"^^_string))) .
\"urn:uuid:990b0156-a8fb-4d67-8eb9-4a96ff54f149"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLSExpression, ("The collection of all expressions of the #$SubL language.  #$SubL is the implementation language of the Cyc system, and it subsumes the #$CycL language.  The #$CycL grammar is more strict than the #$SubL grammar. Thus, while every #$CycLExpression is a #$SubLSExpression, the converse is not true. Examples of #$SubLSExpressions that are not #$CycLExpressions include Arabic decimal numeric expressions such as '123', expressions like '(1 2 3)' that denote lists of numbers, and ''dotted pair'' expressions like '(#$Cat . #$Dog)'."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLSExpression, ("SubLExpression"^^_string))) .
\"urn:uuid:2302adc8-a65e-4592-824d-3c96c0194f3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLString, ("A subcollection of #$SubLAtomicTerm (q.v.) whose instances can be used to denote character-strings.  In the SubL language (as in English), one can refer to a particular character-string by simply putting a pair of quotation marks around it.  Semantically, what this amounts to is using a certain character-string to denote itself.  \n<p>\nMore precisely: a given #$SubLString STRING is a character-string such that, when it appears inside a pair of double-quotation marks, STRING is interpreted as denoting itself (i.e. STRING).  The surrounding quotation-marks are <i>not</i> considered to be parts of STRING; rather, they are syncategorematic symbols whose role is merely to indicate that a string is being referred to.  Thus, in the context of the sentence '(#$firstName #$Lenat ''Doug'')', the four-character string 'Doug' denotes itself: the string `Doug'.  \n<p>\nNote that <i>not</i> every #$CharacterString is a #$SubLString: there are some restrictions on what characters a SubL-string can contain. Note also that #$SubLStrings are <i>atomic</i> terms (see #$SubLAtomicTerm and #$CycLAtomicTerm), as they cannot be constructed out of other SubL (or CycL) terms via the syntax (grammar) of SubL (or CycL).  Thus although the string 'hotdog' can indeed be obtained from 'hot' and 'dog' via concatenation (see #$ConcatenateStringsFn), the <i>syntax</i> of SubL (or CycL) itself contains no rule that licenses such a construction (see e.g. the comments on #$SubLSExpression, #$CycLExpression, #$CycLTerm, #$CycLFormula, and various subcollections thereof).  Note finally that #$SubLString is a ''quoted-collection'' (see #$quotedCollection).  Thus the sentence '(#$isa ''hotdog'' #$SubLString)' means, just as one would expect, that the six-character string 'hotdog' (not the eight-character quote-inclusive '''hotdog'''; see above) is an instance of #$SubLString."^^_string))) .
\"urn:uuid:c2da494b-e7a6-4f34-ae25-9d98bf6a4def"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(SubLString, CharacterString)) .
istAsserted(BookkeepingMt, oldConstantName(SubLString, ("CycSystemString"^^_string))) .
\"urn:uuid:37abdb5d-4c92-4c54-944d-db024d9fa09b"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(SubLString, TruthValue)) .
\"urn:uuid:853f5250-a508-4a8e-9c78-9729ce3af7a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SubLSymbol, ("The collection of all #$SubLAtoms that are also ''symbols'' in the SubL language.  That is, each instance of #$SubLSymbol satisfies the #$defnIff SYMBOLP.  Note that `symbol' has a very specific, technical meaning in SubL.  Save for those that are variables (see #$SubLVariable), #$SubLSymbols are rarely used in CycL assertions, except within those built with certain #$CycInferenceDescriptorPredicates like #$defnIff. Examples of SubL symbols include the symbols 'GENLS' and 'CYC-SYSTEM-NON-VARIABLE-SYMBOL-P'. Note also that #$SubLSymbol is a ''quoted-collection'' (see #$quotedCollection)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLSymbol, ("CycSystemSymbol"^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(SubLSymbol, ("LispSymbol"^^_string))) .
\"urn:uuid:d94fe341-d913-4d60-a21c-ca794a73e735"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Sunday, ("A collection of #$CalendarDays and an  instance of #$DayOfWeekType.  #$Sunday is the collection of all  (and only) sundays."^^_string))) .
\"urn:uuid:780a0d7f-36d5-4f6f-aa96-815c42c06ef2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(SymmetricBinaryPredicate, ("A specialization of both #$BinaryPredicate and #$CommutativeRelation (qq.v.).  A binary predicate <code>PRED</code> is an instance of #$SymmetricBinaryPredicate if and only if (i) for any things <code>X</code> and <code>Y</code>, if <code>(PRED X Y)</code> then <code>(PRED Y X)</code> and (ii) the single-argument argument type constraints (see #$argIsa and #$argGenls) on <code>PRED</code>'s two argument-places are co-satisfiable (see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement).  Note that if <code>PRED</code> satisfies condition (i), then it also satisfies condition (ii) as long as <code>(PRED A B)</code> holds for some <code>A</code> and <code>B</code>.\n<p>\nInstances of #$SymmetricBinaryPredicate include #$siblings, #$teammates, #$connectedTo, and #$bordersOn."^^_string))) .
\"urn:uuid:825cf590-0706-434b-9143-506e216c239b"[silk#strict] .
istAsserted(BaseKB, expansionDefn(TLAssertionFn, SubLSymbolFn(("TL-ASSERTION-TERM-TO-EL"^^_string)))) .
\"urn:uuid:013e9178-1b05-4048-87d2-259da8701401"[silk#strict] .
istAsserted(BaseKB, microtheoryDesignationArgnum(TLAssertionFn, (1))) .
\"urn:uuid:c1b4ff95-4983-4d75-ad40-f6af54dcaaf0"[silk#strict] .
istAsserted(BaseKB, sentenceDesignationArgnum(TLAssertionFn, (2))) .
\"urn:uuid:501b306f-68b0-4f71-bd7f-8e6e315c4ccf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(TLAssertionFn, (1), Microtheory)) .
\"urn:uuid:055ae0d4-839e-4257-a732-4a161e5a4932"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TLAssertionFn, ("Denotes HL assertion terms at the TL (e.g., assertions appearing as terms within meta-assertions): arg1 is the mt of the assertion; arg2 is the formula of the assertion."^^_string))) .
\"urn:uuid:d1b59ed5-51d1-4918-b9ef-7a63600bd5a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TLAssertionFn, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:6723608a-f9f5-4e87-8500-62dd57c21a82"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TLAssertionFn, (2))) .
\"urn:uuid:f8f7f60a-9a74-45af-9d47-da1b92a42148"[silk#strict] .
istAsserted(BaseKB, expansionDefn(TLReifiedNatFn, SubLSymbolFn(("TL-FUNCTION-TERM-TO-EL"^^_string)))) .
\"urn:uuid:24ed807f-f070-43f4-95e5-904d37a97fc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(TLReifiedNatFn, (1), Thing)) .
\"urn:uuid:83c3ab66-5548-476d-870c-34ddd04d8c5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TLReifiedNatFn, ("Denotes a reified nat term at the TL: arg1 is the formula of the nat."^^_string))) .
\"urn:uuid:f75b69ec-5a40-41e9-a80e-00781b29a258"[silk#strict] .
istAsserted(BaseKB, expansionDefn(TLVariableFn, SubLSymbolFn(("TL-VAR-TO-EL"^^_string)))) .
\"urn:uuid:76b5d800-29b9-4cf3-98d6-7765079024a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TLVariableFn, ("Denotes HL variables at the TL: arg1 is the HL index of the variable; arg2 is the EL string name of the variable."^^_string))) .
\"urn:uuid:775b211e-ae8e-4d28-82e3-a7cc80841f92"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TLVariableFn, (2), SubLString)) .
\"urn:uuid:447d59be-3e80-4f77-bfc6-5a7e7cccb137"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TLVariableFn, (2))) .
\"urn:uuid:40885efd-a9d2-4312-8e1a-c20fa534491a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(TLVariableFn, (2), CharacterString)) .
\"urn:uuid:fc89ecc1-b655-4b9d-ad9b-dc1a9c704235"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(TLVariableFn, (1), NonNegativeInteger)) .
istAsserted(TemporaryEnglishParaphraseMt, genKeyword(TemporaryEnglishParaphraseMt, MetaVariableFn(("TEMPORARY-ENGLISH-PARAPHRASE-MT"^^_string)))) .
\"urn:uuid:ab5fe821-3e07-43d5-a68b-b313a452c09c"[silk#strict] .
istAsserted(BaseKB, comment(TemporaryEnglishParaphraseMt, ("This is a temporary MT for holding paraphrase assertions prior to review, after which time they will be moved to #$EnglishParaphraseMt"^^_string))) .
\"urn:uuid:5554b809-e0f1-4e01-94a4-a73e775e0c3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TernaryFunction, ("A specialization of #$FixedArityFunction and #$TernaryRelation.  An instance FUNC of #$FixedArityFunction is an instance of #$TernaryFunction if and only if FUNC has an #$arity of three."^^_string))) .
\"urn:uuid:0f0b0d31-e55f-4835-ac6e-5e0776a85399"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TernaryPredicate, ("A specialization of both #$TernaryRelation and #$Predicate.  #$TernaryPredicate is the collection of all predicates whose arity (see #$arity) is 3."^^_string))) .
\"urn:uuid:0e737b88-4599-4879-8b9e-4c05353fb634"[silk#strict] .
istAsserted(BaseKB, disjointWith(TernaryPredicate, UnaryPredicate)) .
\"urn:uuid:32472278-1e74-49b7-903a-74fb0709b9b2"[silk#strict] .
istAsserted(BaseKB, disjointWith(TernaryPredicate, BinaryPredicate)) .
\"urn:uuid:ec46d619-b4e8-49a1-a63c-22432ee2c8bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TernaryRelation, ("The collection of all fixed-arity relations of arity 3 (see #$arity).  The most notable specializations of #$TernaryRelation are #$TernaryPredicate and #$TernaryFunction (qq.v.)."^^_string))) .
\"urn:uuid:1c7777bc-021d-4687-b9ee-116f1114cd3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(TernaryRelation, arg3Isa)) .
\"urn:uuid:62801f91-8992-4b24-8da3-9caab7dfed75"[silk#strict] .
istAsserted(UniversalVocabularyMt, requiredArg1Pred(TernaryRelation, arg2Isa)) .
\"urn:uuid:a670e4f3-85ec-4d07-a848-78bca9e8d633"[silk#strict] .
istAsserted(BaseKB, comment(TheCollectionOf, ("A collection denoting function that takes a CycL variable and an open formula with exactly one free variable to the collecion of things satisfying that formula."^^_string))) .
\"urn:uuid:c541e98e-af69-4a8c-a041-85c55af92754"[silk#strict] .
istAsserted(BaseKB, scopingArg(TheCollectionOf, (1))) .
\"urn:uuid:65e43987-1c98-4f54-adef-f62e9cc8c7d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TheCollectionOf, (2), 'CycLSentence-Askable')) .
\"urn:uuid:51e8e90c-5479-4894-be64-4275eb0b902e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TheCollectionOf, (1), CycLVariable)) .
\"urn:uuid:cb9aaf21-1f18-4cb0-80ee-0017e177ab26"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TheCollectionOf, (2))) .
\"urn:uuid:b5ffa1d0-0968-4356-99ef-ac264cb3d4bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TheCollectionOf, (1))) .
\"urn:uuid:ffff3c16-6d34-4e1b-abdc-e99dfced1001"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheEmptyList, ("An instance of #$ListWithoutRepetition. #$TheEmptyList is a list that has no members (see #$listMembers).  Note that any list that has no members is identical with #$TheEmptyList; thus #$TheEmptyList is the only list whose length is 0.  Note also that #$TheEmptyList is a sublist (see #$subLists) of every list.  Note finally that #$TheEmptyList is not the same as #$TheEmptySet (q.v.)."^^_string))) .
\"urn:uuid:9f0c32a9-996c-418d-a8e2-b1c2b55d3a87"[silk#strict] .
istAsserted(BaseKB, equals(TheEmptyList, [])) .
\"urn:uuid:053583b8-8535-42db-9fd2-d740c7050a35"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheEmptySet, ("#$TheEmptySet is the empty (or ''null'') set: the unique set that has no elements.  Note that #$TheEmptySet is an instance of #$Set-Mathematical and thus _not_ an instance of #$Collection."^^_string))) .
\"urn:uuid:32fd192c-f072-4f26-8ecc-0658c19619d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, rewriteOf(TheEmptySet, SetOfListMembersFn([]))) .
\"urn:uuid:65060ce0-b932-43be-84ef-3407ae825bfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheList, ("#$TheList is a function that combines its arguments into a list.  For any ITEM(1), ..., ITEM(n), each of which is an instance of #$Thing, (#$TheList ITEM(1) ... ITEM(n)) gives the instance of #$List-Extensional whose first member is ITEM (1), ..., and whose last member is ITEM(n). Note that in general ITEM(1), ..., ITEM(n) do not have to be distinct, though they do if (#$TheList ITEM(1) ... ITEM(n)) is an instance of #$ListWithoutRepetition."^^_string))) .
\"urn:uuid:eda918e3-d83d-435d-bff1-6b75cecea913"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheSet, ("A variable-arity #$SetDenotingFunction that is used to specify a set by enumerating its elements.  For any finite sequence <code>THING1,...,THING<sub>N</sub></code> (<code>N</code> >= 1), (#$TheSet <code>THING1...THING<sub>N</sub>)</code> is the #$Set-Mathematical whose elements (see #$elementOf) are precisely <code>THING1,...,THING<sub>N</sub></code>.  For example, (#$TheSet #$SonnyBono #$Cher) is the set whose only elements are Sonny and Cher.  \n<p>\nNote that in the degenerate case where <code>N</code> is zero, (#$TheSet) is #$TheEmptySet.  \n<p>\nSee also the related function #$TheSetOf, which is used to specify a set by giving a necessary and sufficient membership condition.  And see #$TheList and #$TheCollection."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(TheSet, ("the set containing ~a"^^_string), [[(1), MetaVariableFn(("AND"^^_string))]])) .
\"urn:uuid:c4580540-a1cd-4f45-a22c-788d4a67dda5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheSetOf, ("A binary #$SetDenotingFunction and #$ScopingRelation that takes a variable and an open sentence to a set, where the open sentence specifies a necessary and sufficient membership condition for the set.  If <code>SENT</code> is an open #$CycLSentence-Assertible in which <code>VAR</code> is the only variable occuring free, (#$TheSetOf <code>VAR SENT</code>) is the #$Set-Mathematical of exactly those things that satisfy <code>SENT</code>.  For example, (#$TheSetOf ?X (#$and (#$isa ?X #$Dog) (#$mainColorOfObject ?X #$BlackColor))) is the set of black dogs.\n<p>\nNote that if <code>VAR</code> does not occur free in <code>SENT</code>, or is not the only variable occuring free in <code>SENT</code>, the term <code>(#$TheSetOf VAR SENT)</code> will be itself be open (see #$CycLOpenNonAtomicTerm) and thus will not denote anything.  Given that a true sentence is satisfied by <i>everything</i>, we stipulate that <code>(#$TheSetOf VAR SENT)</code> is #$undefined whenever <code>SENT</code> is closed in order to avoid commitment to a ''universal set''. \n<p>\nSee also #$TheSet, which is used to specify a set by enumerating its elements.  And see #$TheCollectionOf."^^_string))) .
\"urn:uuid:582c799b-6823-48b9-accf-57ae39985e89"[silk#strict] .
istAsserted(BaseKB, scopingArg(TheSetOf, (1))) .
\"urn:uuid:262d7f85-f5cd-4c4d-9845-d97b398cbc97"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TheSetOf, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:bbd6cbd9-a66e-491b-8cba-77fadb68aa1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(TheSetOf, (1), CycLVariable)) .
\"urn:uuid:69da0b3b-0fd7-4883-9f73-f45c089999aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TheSetOf, (1))) .
\"urn:uuid:a60430dc-15d3-4428-828a-f16c7f04feb7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(TheSetOf, (2))) .
\"urn:uuid:2de41755-7bfc-424f-9464-61f66f53b51c"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'genls-SpecDenotesGenlInstances'(TheTerm, Thing)) .
\"urn:uuid:ee5ca3f1-2113-4de1-9221-0ba222c1383e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TheTerm, ("A special kind of term that allows back-reference to any individual thing that satisfies the constraints on the #$TheTerm.  E.g., 'Suppose a cat walks into a fish store.  The cat is likely to get into a lot of trouble.'  'The cat' in the second sentence refers back to 'a cat' in the first; i.e., any cat that walks into a fish store.  In Cyc, the constraints for a #$TheTerm in a given context are given by use of the predicate #$theTermConstraints on the unit representing that context.  In lifting assertions out of that context, the constraints are added as antecedents."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(TheTerm, MetaVariableFn(("THE-TERM"^^_string)))) .
\"urn:uuid:40acec84-2297-47df-bf40-c42b20fdb7c4"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(TheTerm)) .
\"urn:uuid:b8570ea4-1e96-4501-8ab1-7142c44f6c28"[silk#strict] .
istAsserted(BaseKB, comment(TheUser, ("#$TheUser denotes the `current user' of an individual, running Cyc image.  Note that at any moment there may actually be many current users of an image, communicating with it through various sorts of API: HTML-based browser, telnet API connection, etc. #$TheUser serves as a placeholder allowing Cyc to keep track of relevant characteristics (including authorization, sophistication level) of each distinct user."^^_string))) .
\"urn:uuid:c3794d68-87bf-450a-8623-35f33bcfc135"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Thing, ("#$Thing is the ''universal collection'': the collection which, by definition, contains everything there is.  Every thing in the Cyc ontology -- every #$Individual (of any kind), every #$Set-Mathematical, and every #$Collection -- is an instance of (see #$isa) #$Thing.  Similarly, every collection is a subcollection of (see #$genls) #$Thing.  Trivially, #$Thing is both an instance of and a subcollection of itself, and is not a subcollection of any other collection.  (Note that the above reference to ''every thing in the Cyc ontology'' is <i>not</i> meant to be limited to things actually <i>reified</i> in the Cyc system, but includes (e.g.) every instance -- reified or not, known or not -- of every collection recognized by Cyc.)"^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(Thing, MetaVariableFn(("THING"^^_string)))) .
\"urn:uuid:89700e8e-6d30-4c1b-b464-3d0a0365ce80"[silk#strict] .
istAsserted(BaseKB, comment(ThisInference, ("The instance of #$IndexicalConcept used specifically for referring to 'the inference object for this very query itself'.  It's most usefully used via a top-level disjunction to get ahold of a term for an inference as well as the answers for that inference."^^_string))) .
\"urn:uuid:a173dd35-def0-4c55-95a0-ad9dc0b9ddf4"[silk#strict] .
istAsserted(BaseKB, comment(ThisProblemStore, ("The instance of #$IndexicalConcept used specifically for referring to 'the problem store used by this very inference'.  It's most usefully used via a top-level disjunction to get a hold of a term for a problem store used with an inference."^^_string))) .
\"urn:uuid:0b4f50bf-010d-4756-8b12-bf6b84b76e51"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Thursday, ("A collection of #$CalendarDays and an  instance of #$DayOfWeekType.  #$Thursday is the collection of all  (and only) thursdays."^^_string))) .
\"urn:uuid:79544cff-4a1f-4427-a6b9-cfb8ebbd12a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TimesFn, ("A #$VariableArityRelation that represents multiplication in #$CycL. (#$TimesFn MULT1 MULT2 ...) yields a quantity which is the result of multiplying MULT1 MULT2 (...) together. All arguments to #$TimesFn must be instances of #$ScalarInterval, as is its result. Thus (#$TimesFn 2 3 4) returns 24; (#$TimesFn #$Pi-Number #$E-LogarithmBase) returns pi times e. For division see #$QuotientFn."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(TimesFn, ("Times"^^_string))) .
\"urn:uuid:03e5c8d0-dd21-42b0-9f1e-117a5177d908"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(TimesFn, SubLSymbolFn(("CYC-TIMES"^^_string)))) .
\"urn:uuid:1c30e985-5b3c-4b50-8c1d-7588b2a2764c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TransformationModuleSupportedCollection, ("The collection of all #$Collections which are supported by some #$CycTransformationModule."^^_string))) .
\"urn:uuid:dfd6c69d-a0b1-4b40-9d29-74bbc9148cb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TransformationModuleSupportedPredicate, ("The collection of all #$Predicates which are supported by some #$CycTransformationModule."^^_string))) .
\"urn:uuid:b49afde5-530a-4bf0-a4ff-530bd37252d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TransitiveBinaryPredicate, ("A #$BinaryPredicateTypeByLogicalFeature and thus a specialization of #$BinaryPredicate.  A binary predicate <code>PRED</code> is an instance of #$TransitiveBinaryPredicate only if it has the following property: For any <code>THING1</code>, <code>THING2</code>, and <code>THING3</code>, if both of these hold:\n<pre>\n  (PRED THING1 THING2)\n  (PRED THING2 THING3)\n</pre>\nThen so does this:\n<pre>\n  (PRED THING1 THING3) .\n</pre>\nNote that a necessary condition on <code>PRED</code>'s being transitive is that its two argument-places must be co-satisfiable; see #$cosatisfiableInArgs and #$NoteOnArgumentCosatisfiabilityRequirement.\n<p>\nInstances of #$TransitiveBinaryPredicate include #$greaterThan,\n#$geographicalSubRegions, and #$cotemporal.  \n<p>\nCf. #$QuasiTransitiveBinaryPredicate and #$AntiTransitiveBinaryPredicate."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(TransitiveBinaryPredicate, ("TransitiveSlot"^^_string))) .
\"urn:uuid:5c37df34-3b05-4952-b954-8fe10f41cb0f"[silk#strict] .
istAsserted(BaseKB, comment(True, ("An instance of #$TruthValue (q.v.).  #$True is the logical notion of truth.  That is, the term '#$True' is used as a sentential constant of CycL that is true under every model theoretic interpretation.  For example, (#$booleanResult T/F #$True) means that the result obtained from the true-or-false test T/F is True.  Cf. #$False."^^_string))) .
\"urn:uuid:5db6e68e-03ca-4d71-b603-5590045e4ca9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TruthFunction, ("A major subcollection of #$Relation that subsumes the collections #$Predicate, #$LogicalConnective, and #$Quantifier (qq.v.). Truth-functions, or rather the expressions that represent or denote them, are used to form sentences.  More precisely, any CycL expression that denotes an instance of #$TruthFunction (and only such an expression) can appear in the ''0th'' argument-position (i.e. as the term immediately following the opening parenthesis) of a #$CycLSentence.  \n<p>\nThe name 'TruthFunction' derives in part from the fact that the sentences thus formed (if semantically well-formed and quantificationally closed; see #$CycLSentence-Assertible and #$CycLClosedSentence) are the kind of expression that can be true or false (with respect to a given context and interpretation). Though not really functions (cf. #$Function-Denotational), many #$TruthFunctions are ''truth-functional'' in the sense that the truth-value of a (closed, semantically well-formed) sentence <code>(RELN ARG1..ARGN)</code> built using a truth-function <code>RELN</code> is uniquely determined (with respect to a given context) by <code>RELN</code> together with the argument(s) <code>ARG1..ARGN</code> to which it is applied.  For example, the sentence <code>(#$mother #$ChelseaClinton #$HillaryClinton)</code> is made true (in the actual world) by the fact that Chelsea Clinton's mother is Hillary Clinton."^^_string))) .
\"urn:uuid:5e1d34f4-0529-4fcf-9b8f-14af371c9b1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(TruthValue, ("#$TruthValue is a collection of mathematical objects; it contains the abstract, logical objects #$True and #$False."^^_string))) .
\"urn:uuid:d4322e3b-3b63-417d-a0bb-f18f361305a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, disjointWith(TruthValue, List)) .
\"urn:uuid:d37d1079-1c77-4def-86f0-ad7db528752d"[silk#strict] .
istAsserted(BaseKB, completelyEnumerableCollection(TruthValue)) .
\"urn:uuid:d524c1b2-49bf-469a-b121-c64f50ee5559"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Tuesday, ("A collection of #$CalendarDays and an \ninstance of #$DayOfWeekType.  #$Tuesday is the collection of all \n(and only) tuesdays."^^_string))) .
\"urn:uuid:5897996c-5e29-4164-8e1e-69391923054a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnaryFunction, ("A specialization of both #$FixedArityFunction and #$UnaryRelation (qq.v.).  Each instance of #$UnaryFunction is a function that always takes a single argument, i.e. has an arity (see #$arity) of 1."^^_string))) .
\"urn:uuid:2c85e9e0-5850-45b0-8d31-c776977c5075"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnaryPredicate, ("A specialization of both #$UnaryRelation and #$Predicate.  #$UnaryPredicate is the collection of all predicates whose arity (see #$arity) is 1."^^_string))) .
\"urn:uuid:becaa0fb-2606-4c2d-9a78-48946611fdd3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnaryRelation, ("The collection of all fixed-arity relations of arity 1 (see #$arity).  The most notable specializations of #$UnaryRelation are #$UnaryPredicate and #$UnaryFunction (qq.v.)."^^_string))) .
\"urn:uuid:fa81fda8-3fa6-4d6a-b7cf-850fdb71cb27"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UncanonicalizerAssertionFn, ("#$UncanonicalizerAssertionFn is used by the #$CycUncanonicalizer and should rarely (if ever) need to be seen by users or referenced in assertions entered at the EL level.  It is used by the uncanonicalizer to denote an #$CycLAssertion after it is transformed to its canonical EL formula."^^_string))) .
\"urn:uuid:aa17cc5e-3844-493c-839c-4f42b62755b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(UncanonicalizerAssertionFn, (1))) .
\"urn:uuid:037596df-2cb3-4d27-92d4-51b079e96ab0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnitOfMeasure, ("A specialization of #$ScalarDenotingFunction (q.v.).  Each instance of #$UnitOfMeasure is a function that takes one or two numbers or other #$NumericIntervals as arguments, and returns as value a #$MeasurableQuantity (q.v.), such as a #$Distance or a #$Speed or a #$Volume.  If a unit of measure is applied to one number (see #$Number-General) the result is a precise quantity that is a #$ScalarPointValue; if applied to two (different) numbers -- or to one (or two) #$ProperIntervalOnNumberLine(s) -- the result is a closed-interval quantity that is a #$ScalarProperInterval.  For example, (#$Meter 5) is the distance five meters and (#$Meter 5 10) is the distance ''five to ten meters (inclusive)''.\n<p>\n(A partial exception to the above is the unit-of-measure #$Unity (q.v.), which always returns a #$NumericInterval rather than a #$MeasurableQuantity.)\n<p>\nSpecializations of #$UnitOfMeasure grouped by what they measure include #$UnitOfTime, #$UnitOfSpeed, and #$UnitOfVolume.  Other specializations are #$OneDimensionalUnitOfMeasure, #$MultiDimensionalUnitOfMeasure, #$UnitOfMeasureWithPrefix and #$UnitOfMeasureNoPrefix."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(UnitOfMeasure, MetaVariableFn(("UNIT-OF-MEASURE"^^_string)))) .
\"urn:uuid:6465e586-0988-4c6d-8450-720103d1fea3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnitProductFn, ("A binary #$UnitOfMeasureDenotingFunction that takes two #$UnitOfMeasure (q.v.) functions and returns the unit-of-measure function whose value for any given argument is the multiplicative ''product'' of the respective values yielded by the first two units, when one unit is applied to that same argument and the other unit is applied to 1.  That is, <code>(#$UnitProductFn UNIT1 UNIT2)</code> is the function <code>PRODUCT-FN</code> such that, for any number or other #$NumericInterval <code>NUM</code>, <code>(PRODUCT-FN NUM)</code> = <code>(#$TimesFn (UNIT1 NUM) (UNIT2 1))</code>.\n<p>\nFor example, (#$UnitProductFn #$Meter #$Meter) is #$SquareMeter; and (e.g.) (#$SquareMeter 5) is equal to (#$TimesFn (#$Meter 5) (#$Meter 1)). Also, (#$UnitProductFn  #$Kilowatt #$HoursDuration) is #$KilowattHour.\n<p>\nSee also #$PerFn."^^_string))) .
\"urn:uuid:0249fe56-a539-4f31-be80-db98ccc3cbb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(UnitProductFn, (2), UnitOfMeasure)) .
\"urn:uuid:f30b6872-c4ea-4692-aaf8-2e35905791c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(UnitProductFn, (1), UnitOfMeasure)) .
\"urn:uuid:b51155f9-3d67-4559-b0e6-446680484a8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Unity, ("An instance of #$ZeroDimensionalUnitOfMeasure (q.v.) that takes one or two numbers or other #$NumericIntervals (q.v.) as argument(s) and returns the continuous numeric-interval that spans between and includes those arguments.  Given one argument, #$Unity behaves like an identity function.\n<p>\nMore precisely: for any numeric-interval <code>NUM</code>, <code>(#$Unity NUM)</code> = <code>NUM</code>; and for any two numeric-intervals <code>LO</code> and <code>HI</code> such that <code>(#$greaterThanOrEqualTo HI LO)</code>, <code>(#$Unity LO HI)</code> is the numeric-interval that ranges from the least point-value (see #$Number-General) subsumed by (see #$quantitySubsumes) <code>LO</code> to the greatest point-value subsumed by <code>HI</code>.\n<p>\nIn practice, <code>LO</code> and <code>HI</code> will typically be two distinct #$RealNumbers, and <code>(#$Unity LO HI)</code> will be the continuous #$ProperIntervalOnNumberLine that ranges from <code>LO</code> to <code>HI</code>.  For example, (#$Unity 1 10) is the interval from 1 to 10 inclusive.  But note that <code>LO</code> and/or <code>HI</code> might themselves be proper intervals: (#$Unity (#$Unity 7 9) 11) is thus the interval from 7 to 11 inclusive.\n<p>\n#$Unity is classified as a #$UnitOfMeasure mainly in order to simplify the application of quasi-mathematical operations (e.g. #$PerFn, #$UnitProductFn) to units-of-measure generally.  For example, #$TimesPerDay is defined as the result of ''dividing'' (via #$PerFn) #$Unity by #$DaysDuration."^^_string))) .
\"urn:uuid:8a1130b8-f3f9-456a-90e2-15c281a71af1"[silk#strict] .
istAsserted(BaseKB, comment(UniversalVocabularyImplementationMt, ("This is the microtheory which contains the assertions about CycL terms which are necessary for Cyc's inference engine to reason about those terms."^^_string))) .
\"urn:uuid:4ebddd42-cade-40dc-bad4-680b691622ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UniversalVocabularyMt, ("This is the microtheory which contains the 'definitional' assertions about everything in Cyc's universe of discourse.  Definitional assertions about a concept are those which are intrinsic to the concept's nature and cannot be violated in any context."^^_string))) .
\"urn:uuid:acb11ca7-937c-4894-a922-7f3368da1cb1"[silk#strict] .
istAsserted(BaseKB, comment('Unknown-HLTruthValue', ("An instance of #$CycHLTruthValue. #$Unknown-HLTruthValue is the attribute of being neither known to be true nor known to be false."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName('Unknown-HLTruthValue', ("Unknown-TruthValue"^^_string))) .
\"urn:uuid:ae8d6936-dd86-4280-94a4-b30786446ca3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnknownScalarInterval, ("A specialization of #$ScalarInterval.  If a quantity is an instance of #$UnknownScalarInterval, Cyc may know what kind of quantity it is (it may also be a #$Distance or a #$NegativeNumber, e.g.), but its size is explicitly not known.  This is a signal to the inference engine that when this quantity appears as an argument to mathematical functions, full evaluation of the functional term is not required, and the functional term itself (possibly with some simplification) can be returned as an answer.  Hypothetical queries that propose an unspecified value will lead to that value being hypothesized as an instance of #$UnknownScalarInterval.  For example, the English query ''Suppose Fred has N pairs of shoes.  How many individual shoes does he have?'' would be represented in CycL this way: \n<pre>\n<code>\n(#$implies (#$relationInstanceExistsCount #$possesses #$Fred (#$PairFn #$Shoe) ?N)\n           (#$relationInstanceExistsCount #$possesses #$Fred #$Shoe ?HOWMANY))\n</code>\n</pre>\nThe variable ?N will be instantiated as an #$IndeterminateTerm and instance of #$PositiveInteger - say, #$HYP-PositiveInteger-1 - and Cyc will conclude that it is an instance of #$UnknownScalarInterval.  Thus (#$TimesFn 2 #$HYP-PositiveInteger-1) will be allowed as a binding for ?HOWMANY."^^_string))) .
\"urn:uuid:720d5b6f-72f7-4c23-8856-73f0a79f066c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(UnreifiableFunction, ("A specialization of #$Function-Denotational instances of which are such  that their values are not reified in the Cyc system.  More precisely, an instance of #$UnreifiableFunction is such that closed ''NATs'' (see  #$CycLNonAtomicTerm) built from its standard CycL name are _not_ instances of  #$HLReifiedDenotationalTerm.   Constrast with #$ReifiableFunction.  Usually it is more efficient to make functions reifiable; but it is not desirable  to reify every non-atomic term, such as those built from (names of)  instances of #$MathematicalFunctionOnScalars.  For example, it would be cumbersome to reify every term of the form (#$Inch N) that happened to appear in a CycL assertion."^^_string))) .
\"urn:uuid:fbc08123-0e04-4244-936c-18db0c8e6aa7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(VariableArityRelation, ("A specialization of #$Relation.  Each instance of #$VariableArityRelation is a relation that can take a variable number of arguments. The degree of variability for a given such relation can be constrained using the predicates #$arityMin and #$arityMax. Examples of #$VariableArityRelations include the predicate #$different and the function #$PlusFn.  Thus the terms '(#$PlusFn 1 2)' and '(#$PlusFn 1 2 3)' are both well-formed. Cf. #$FixedArityRelation."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(VariableArityRelation, MetaVariableFn(("VARIABLE-ARITY-RELATION"^^_string)))) .
\"urn:uuid:8b36e86e-8422-4bd0-83a9-133e4e701cfe"[silk#strict] .
istAsserted(LogicalTruthMt, disjointWith(VariableArityRelation, FixedArityRelation)) .
\"urn:uuid:33a03998-4d2c-429f-8c95-61d72b3377b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(VariableAritySkolemFuncN, ("The subcollection of #$SkolemFuncNs with variable arity. These are only created when a sequence variable is in the scope of  a bounded existential."^^_string))) .
\"urn:uuid:d767b112-3b74-444a-bc0d-47d809ac4d49"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(VariableAritySkolemFunction, ("The subcollection of #$SkolemFunctions with variable arity. These are only created when a sequence variable is in the scope of the skolem."^^_string))) .
\"urn:uuid:6288627f-8947-449b-a712-20eb89496ab0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(WFFConstraintPredicate, ("The collection of all #$Predicates which can impose well-formedness constraints.  More specifically, only assertions of the form (PRED . ARGS), where PRED is an instance of #$WFFConstraintPredicate, can directly impose a well-formedness constraint, i.e. cause a previously well-formed sentence to become ill-formed, given the same WFF standards.  Any assertion could _indirectly_ impose a well-formedness constraint, for instance by triggering a forward rule or an #$afterAdding."^^_string))) .
\"urn:uuid:25b3705a-6afb-4f38-aef8-1c547cb800e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(WFFConstraintSatisfactionPredicate, ("The collection of all #$Predicates which can satisfy well-formedness constraints.  More specifically, only assertions of the form (PRED . ARGS), where PRED is an instance of #$WFFConstraintPredicate, can directly satisfy a well-formedness constraint, i.e. cause any previously ill-formed sentence to become well-formed, given the same WFF standards.  Any assertion could _indirectly_ satisfy a well-formedness constraint, for instance by triggering a forward rule or an #$afterAdding.  A common case of this is the #$afterAddings on spec-preds of #$isa and #$genls."^^_string))) .
\"urn:uuid:6e493378-f728-4c47-9367-1fbd55f9ae4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(WFFDirectivePredicate, ("The collection of all #$Predicates which can affect what WFF standards to impose on a given sentence."^^_string))) .
\"urn:uuid:4349c3d9-c2ac-4c5e-aff0-98a1354e3820"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(WFFSupportedPredicate, ("The collection of all #$Predicates that are supported in some way by the #$CycWellFormednessChecker, either to satisfy, impose, or relax well-formedness constraints."^^_string))) .
\"urn:uuid:f45dd0ca-3d54-410e-9e4b-f7083f9bf410"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(WFFSupportedTerm, ("The collection of all #$CycLTerms that have some kind of special support in the #$CycWellFormednessChecker."^^_string))) .
\"urn:uuid:e54989c7-4ba7-4312-9613-a96df99806c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(Wednesday, ("A collection of #$CalendarDays and an \ninstance of #$DayOfWeekType.  #$Wednesday is the collection of all \n(and only) wednesdays."^^_string))) .
\"urn:uuid:182d8211-6903-4537-98db-46dc4e4a26ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(abnormal, ("A binary #$MetaKnowledgePredicate that is used to state exceptions to a given general #$CycLAssertion.  Typically, an #$abnormal assertion will be the result of the #$CycCanonicalizer having ''transformed'' a sentence asserted at the EL level that was built from an #$ExceptionPredicate (i.e. #$exceptWhen or #$exceptFor).  While perhaps less common-sensically intuitive than #$exceptWhen or #$exceptFor, #$abnormal facilitates an efficient and uniform handling of exceptions.\n<p>\nHere, in more detail, is how #$abnormal is used.  Every default rule in our system, schematically:\n<p>\nP[X1 ... Xn] -> Q[X1 ... Xn]\n<p>\n(with X1, ..., Xn free in both P and Q) is implicitly treated as\n<p>\n(not (''abnormal-for-this-rule'' X1 ... Xn)) & (P[X1 ... Xn] -> Q[X1 ... Xn]) .\n<p>\nThus rules without exceptions need never incur the overhead of default reasoning.  Since a different ''abnormality'' relation would otherwise be needed for every default rule in the system, we use instead a single predicate -- #$abnormal -- which takes the rule in question as an argument.  And the other argument to #$abnormal is a #$List of variables (or of a single closed term) over which abnormality is computed; this allows #$abnormal to be binary rather than variable-arity.  Hence a sentence of the form\n<p>\n(#$exceptWhen EXCEPTION RULE) ,\n<p>\nin which each of the variables X1, ..., Xn occurs free in both EXCEPTION and RULE, gets canonicalized to an #$implies rule that concludes to an #$abnormal sentence:\n<p>\n<pre>\n(#$implies\n  EXCEPTION\n  (#$abnormal (#$TheList X1 .... Xn) RULE)) .\n</pre>\n<p>\nAnd a sentence of the form\n<p>\n(#$exceptFor TERM RULE) ,\n<p>\nin which exactly one variable X occurs free in RULE, gets canonicalized to a sentence of the form\n<p>\n(#$abnormal (#$TheList TERM) RULE) .\n<p>\nSee also #$pragmaticallyNormal."^^_string))) .
\"urn:uuid:d7ae5bfc-f0c7-48db-b97d-4b61d00968a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(abnormal, (1), List)) .
\"urn:uuid:47426d4c-d169-461a-90e6-dd27ca203ffe"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(abnormal, (2), CycLAssertion)) .
\"urn:uuid:af6c2f99-2a2b-4e7f-986f-3eaf64d05004"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(abnormal, (2))) .
\"urn:uuid:db73ff66-028e-4dc8-8567-c2068444831e"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(abnormal, meetsPragmaticRequirement)) .
\"urn:uuid:b7316a13-3b2a-4fb5-8272-1813f6753cef"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(abnormal, pragmaticallyNormal)) .
\"urn:uuid:7773883d-3e8c-4913-a0b3-27fecced2e7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(admittedAllArgument, ("A ternary #$MetaRelation predicate that relates a #$Collection to an integer (representing an argument-place) to a #$Relation such that every instance of the collection is an #$admittedArgument (q.v.) to the specified argument-place of the relation.  <code>(#$admittedAllArgument COL ARGNUM RELN)</code> means that every instance of <code>COL</code> satisfies all of the (single-argument) argument-type constraints (see #$ArgIsaPredicate and #$ArgGenlPredicate) for the <code>ARGNUM</code>th argument position of <code>RELN</code>.  Note that <code>COL</code> is required <i>not</i> to be an  #$EmptyCollection.\n<p>\nFor example, <code>(#$admittedAllArgument #$FemaleHuman 1 #$spouse)</code> and <code>(#$admittedAllArgument #$PersonTypeByActivity 1 #$JuvenileFn)</code> both hold."^^_string))) .
\"urn:uuid:d656c1e0-b667-4279-bc52-91ddfa9db584"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(admittedAllArgument, (1))) .
\"urn:uuid:610c31e5-43b4-4fdd-b27f-14ddf22235e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(admittedAllArgument, (2))) .
\"urn:uuid:5052de98-9b46-413a-9596-6b269d50b4dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(admittedAllArgument, (3))) .
\"urn:uuid:7104e079-182c-493c-ad70-fd8d0c4b6646"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(admittedAllArgument, (1), Thing)) .
\"urn:uuid:d7bb8485-50d1-4300-bb07-eff1ee7371cf"[silk#strict] .
istAsserted(BaseKB, notAssertible(admittedAllArgument)) .
\"urn:uuid:07e20dc2-36a1-424a-9171-e72241d6d939"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedAllArgument, (2), PositiveInteger)) .
\"urn:uuid:87e1ed90-0d54-43f5-8a5e-a00e783c8e74"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedAllArgument, (1), Collection)) .
\"urn:uuid:54d6732c-066d-4ee8-a516-b5090837cc68"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedAllArgument, (3), Relation)) .
\"urn:uuid:2c4328af-d61f-4871-8413-3053db24377f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(admittedAllArgument, openEntryFormatInArgs)) .
\"urn:uuid:b72ee350-4891-4e52-aa63-59d9ce61af7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(admittedAllArgument, openEntryFormatInArgs)) .
\"urn:uuid:f575dcb6-498b-4c41-bf44-57094ea363a2"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(admittedAllArgument)) .
\"urn:uuid:c3352f36-a134-4035-a80b-1b5c8d1ea524"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(admittedAllArgument, openEntryFormatInArgs)) .
\"urn:uuid:a21b41fd-5c5a-48cb-816e-d82d1542f55d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(admittedAllArgument, genls, (1))) .
\"urn:uuid:a7939688-73cf-4899-b5e0-893b472e5719"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(admittedAllArgument, genlPreds, (2))) .
\"urn:uuid:8c62ae24-72f0-4645-945d-e78f244786d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(admittedArgument, ("A ternary #$MetaRelation predicate that is used to state that a given thing meets the argument-type constraints on a given argument-place of a given relation. <code>(#$admittedArgument THING ARGNUM RELN)</code> means that <code>THING</code> satisfies all of the (single-argument) argument-type constraints (see #$ArgIsaPredicate and #$ArgGenlPredicate) for the <b><code>ARGNUM</b>-th</code> argument position of <code>RELN</code>.  \n<p>\nFor example, both of the following sentences hold:\n<pre>  (#$admittedArgument #$AbrahamLincoln 1 #$wife)\n\n  (#$admittedArgument #$Cougar 1 #$JuvenileFn) .</pre>\nSee also #$admittedAllArgument and #$admittedSentence."^^_string))) .
\"urn:uuid:fc6df708-2356-4652-8c01-98e97e79da28"[silk#strict] .
istAsserted(BaseKB, notAssertible(admittedArgument)) .
\"urn:uuid:9ac2fce8-c806-4944-b157-b733fc069c55"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedArgument, (2), PositiveInteger)) .
\"urn:uuid:485efe32-e145-450d-9243-62c8b68b7d70"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedArgument, (3), Relation)) .
\"urn:uuid:ac6ecae5-1052-4164-be27-c3e037bc684b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedArgument, (1), Thing)) .
\"urn:uuid:4554da8d-e920-41c3-8296-819a052bcf99"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(admittedArgument, openEntryFormatInArgs)) .
\"urn:uuid:2e872f57-7b2d-4aae-bffb-215f1426d648"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(admittedArgument, openEntryFormatInArgs)) .
\"urn:uuid:6387a47c-d483-43c3-984b-c54c1db3ded8"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(admittedArgument)) .
\"urn:uuid:cd9b34b5-f027-4596-a60a-bc7b24a67fef"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(admittedArgument)) .
\"urn:uuid:c663045a-77bc-4cc0-b73e-c34507448e3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(admittedArgument, openEntryFormatInArgs)) .
\"urn:uuid:d3c36075-3c53-4a62-95cf-2a12db69edf6"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(admittedArgument)) .
\"urn:uuid:cdf3f820-e170-47ab-90e2-c838615031f7"[silk#strict] .
istAsserted(BaseKB, notAssertible(admittedNAT)) .
\"urn:uuid:6b068f1e-4691-46b7-9bb0-d18f99d315ca"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(admittedNAT)) .
\"urn:uuid:63b26122-daea-40c3-b300-abff3f89738b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(admittedNAT, ("(#$admittedNAT NAT) states that NAT is a #$CycLNonAtomicTerm which is both syntactically and semantically well-formed wrt arg constraints.  For example, (#$admittedNAT (#$MotherFn #$Muffet)) is true precisely in those mts in which #$Muffet satisfies all the applicable arg1 constraints imposed by #$MotherFn.  See also #$admittedSentence."^^_string))) .
\"urn:uuid:c2122dc7-0d09-4cbb-bf96-0d704b8d9b62"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(admittedNAT, (1), CycLNonAtomicTerm)) .
\"urn:uuid:c0c44263-7e91-43dc-8ae2-bced04eb8bfa"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(admittedNAT, (1))) .
\"urn:uuid:c62ae7c7-24ea-44ba-a4e7-d0b403b440f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(admittedNAT, (1), Thing)) .
\"urn:uuid:84528573-b322-4684-8133-fa6e28ae8d73"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(admittedSentence, ("(#$admittedSentence SENTENCE) states that SENTENCE is a #$CycLSentence which is both syntactically and semantically well-formed with respect to argument constraints only.  For example, (#$admittedSentence (#$bordersOn #$Canada #$France)) is true in #$WorldGeographyDualistMt, but not in #$WorldGeographyMt, since #$Canada and #$France are known to be instances of #$GeographicalRegion in the former microtheory, but not in the latter microtheory.  See also #$admittedArgument."^^_string))) .
\"urn:uuid:03691e46-a10e-4d2c-b5d4-2b514e6262bb"[silk#strict] .
istAsserted(BaseKB, notAssertible(admittedSentence)) .
istAsserted(BookkeepingMt, oldConstantName(admittedSentence, ("admittedFormula"^^_string))) .
\"urn:uuid:6fea6e89-9938-4a56-a904-d4ac14e9ae03"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(admittedSentence)) .
\"urn:uuid:c55c1c2f-250f-4a5b-9a61-0eb56372a4f0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(admittedSentence)) .
\"urn:uuid:cfadfed3-f08e-4503-980e-16c4fc11b348"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(admittedSentence)) .
\"urn:uuid:58e6c1af-6d31-42e0-ac73-5a49b7a5cadc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(admittedSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:91134d63-0cda-4518-ad90-9cc3e2d8acbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(admittedSentence, (1))) .
\"urn:uuid:8eb94c8c-7c7b-46ea-8f6c-b6d33eb3a724"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(afterAdding, ("Whenever a gaf is asserted, #$afterAddings are called on the gaf dependent on the predicate of the gaf.  (#$afterAdding PRED HOOK) means that HOOK will be called on gaf whose predicate is PRED.  If the gaf predicate has multiple #$afterAddings, the order of execution is not guaranteed.  Also, #$afterAddings are retriggered on the addition of new arguments to an existing gaf."^^_string))) .
\"urn:uuid:89de9af2-af90-4043-bac6-7eb4226843d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(afterAdding, (1), Predicate)) .
\"urn:uuid:ed191cab-b069-42ff-b437-7dec772f0edf"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argIsa(afterAdding, (1), Predicate)) .
\"urn:uuid:e7a4fb56-31f8-4387-986d-623c798778d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(afterAdding, SetTheFormat)) .
\"urn:uuid:f6c166e4-d205-4285-9bf0-d52a9953d48e"[silk#strict] .
istAsserted(BaseKB, definingMt(afterAdding, BaseKB)) .
\"urn:uuid:ca26236a-846b-45c4-af3a-64530e9236d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(afterAdding, (2))) .
\"urn:uuid:4d874327-0ad0-45ec-bb99-4434d372a2e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(afterRemoving, ("When a gaf is unasserted, #$afterRemovings are called on the gaf dependent on the predicate of the gaf.  (#$afterRemoving PRED HOOK) means that HOOK will be called on gaf whose predicate is PRED.  If the gaf predicate has multiple #$afterRemovings, the order of execution is not guaranteed.  Also, #$afterRemovings are retriggered on the removal of each of the arguments to a gaf."^^_string))) .
\"urn:uuid:893b30c9-b640-4c9c-a13b-f099f9bb957f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(afterRemoving, (1), Predicate)) .
\"urn:uuid:8670996c-f434-48c2-94c7-3482f881ae1e"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argIsa(afterRemoving, (1), Predicate)) .
\"urn:uuid:fa176cce-5d08-426e-bd50-0e977393971b"[silk#strict] .
istAsserted(BaseKB, definingMt(afterRemoving, BaseKB)) .
\"urn:uuid:a994d281-8250-41c9-bbd7-8e0cbfcd2a0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(afterRemoving, (2))) .
\"urn:uuid:43d19b2b-702c-4b03-81b2-4f9ea592d76f"[silk#strict] .
istAsserted(BaseKB, distributesOutOfArg(cyc#and, holdsIn, (2))) .
\"urn:uuid:7657fd96-45f6-40fd-829e-c1f89fc9c7f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(cyc#and, ("A #$LogicalConnective that represents conjunction in #$CycL. It is a #$VariableArityRelation, taking an arbitrary number of #$ELSentence-Assertibles as arguments.  <code>(#$and P Q ... Z)</code> is true if and only if all of the sentences <code>P</code>, <code>Q</code>, ..., and <code>Z</code> are true."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(cyc#and, MetaVariableFn(("AND"^^_string)))) .
\"urn:uuid:ed81d1ea-14e8-4040-8923-37dcb0431cbf"[silk#strict] .
istAsserted(LogicalTruthMt, argAndRestQuotedIsa(cyc#and, (1), 'CycLSentence-Assertible')) .
istAsserted(BookkeepingMt, oldConstantName(cyc#and, ("LogAnd"^^_string))) .
\"urn:uuid:2879aa56-6e42-462e-8bb4-1586dbc2f9b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cyc#and, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:13d62bd6-98c3-45c7-afd1-41a3bc8b0417"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cyc#and, (1))) .
\"urn:uuid:1c97e33f-2aaa-43eb-8118-03264bdfcfd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg1Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the first (or ''arg1'') argument-place of a given predicate.  (#$arg1Format PRED FORMAT) means that PRED's arg1 is constrained to FORMAT.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:8d8339a7-517a-4377-afa8-ab5b4aa2c46d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1Format, (1), Predicate)) .
\"urn:uuid:73e6859e-b419-42b5-bf2d-89b95d66cde3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg1Format, openEntryFormatInArgs)) .
\"urn:uuid:55c668d5-8427-4217-9b2f-3cbfa359a8ce"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg1Format, (1))) .
\"urn:uuid:f5adb158-7297-48d6-a0c9-475bcddc2447"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg1Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg1Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the first argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1</code> ...) is semantically well-formed only if <code>(#$genls ARG1 COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argGenl for a similar but more flexible  ternary predicate."^^_string))) .
\"urn:uuid:2b77c16f-06a1-495e-95f6-b08787b7a8e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg1Genl, (2), Thing)) .
\"urn:uuid:91657c47-77fa-4ea0-9f4e-abd574d018f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1Genl, (1), Relation)) .
\"urn:uuid:4853e471-6247-49f1-82db-a5a64f044ab2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1Genl, (2), Collection)) .
\"urn:uuid:7c6e989e-0d62-45a3-bc0b-a11833d700b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg1Genl, SetTheFormat)) .
\"urn:uuid:5bbba176-c404-408e-9e54-af59b42b78db"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg1Genl, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(arg1Genl, ("argumentOneGenls"^^_string))) .
\"urn:uuid:0b1285b9-d0f3-49df-b99d-549f6f6e61bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg1Genl, genls, (2))) .
\"urn:uuid:e93e3063-ce35-4ebf-a3ee-14946466381b"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg1Genl, genls, (2))) .
\"urn:uuid:88e8f45b-1f03-4a04-aafa-731346b1f4f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, constrainsArg(arg1Genl, (1))) .
\"urn:uuid:2ab8c09c-41f8-491e-9bc0-b3394632f154"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg1Genl, (1))) .
\"urn:uuid:ba10623d-631a-430a-96d5-b4a16b93c08b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg1Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg1Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the first argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is, <code>(RELN ARG<sub>1</sub> ...)</code> is semantically well-formed only if <code>(#$isa ARG<sub>1</sub> COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argIsa for a similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:66151c2e-474c-4302-9f69-3de1d233a735"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg1Isa, (2), Thing)) .
\"urn:uuid:5d831c22-a4a6-4418-ad52-f963c70b8cb1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1Isa, (1), Relation)) .
\"urn:uuid:2b126f8d-61dd-4062-8ac7-614bb92f0556"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1Isa, (2), Collection)) .
\"urn:uuid:6a259b01-e599-4760-a0ef-6791246a5b12"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg1Isa, SetTheFormat)) .
\"urn:uuid:b7c85a6b-c181-4f5e-ab68-487e7372ddae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg1Isa, SetTheFormat)) .
\"urn:uuid:7e4ac081-9f35-4e9e-875b-efb316c1b23f"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg1Isa)) .
\"urn:uuid:3025be22-27b9-44bf-b9da-ca06033a92e4"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg1Isa, ArgTypeTernaryPredicate, Relation)) .
\"urn:uuid:1955bf69-5942-4249-9ad4-c8e277f56667"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg1Isa, ArgTypeBinaryPredicate, Relation)) .
istAsserted(BookkeepingMt, oldConstantName(arg1Isa, ("argumentOneType"^^_string))) .
\"urn:uuid:d6a8e332-994c-4d36-a8c7-9bfaa4721587"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg1Isa)) .
\"urn:uuid:86534f58-55e8-41dd-ac70-525ed967afea"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg1Isa, genls, (2))) .
\"urn:uuid:6e82a649-2b70-4586-a442-d4506541bf31"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg1Isa, genls, (2))) .
\"urn:uuid:dca6e1bd-3bc0-4ca8-b8df-771dc0f7ae7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, constrainsArg(arg1Isa, (1))) .
\"urn:uuid:4f183782-99e2-4ec5-80bd-c6373daef296"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg1Isa, (1))) .
\"urn:uuid:802ac5d6-78c0-4dc2-9aae-be046ff87a84"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg1QuotedIsa, ("A binary #$Predicate (#$arg1QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the first argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ...) is semantically well-formed only if (#$quotedIsa ARG1 COL) holds."^^_string))) .
\"urn:uuid:59e61955-d942-47eb-bcfc-be4b0805474c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg1QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:16193ed6-271a-4538-941a-05d4e7910070"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:8197e0da-afee-4b83-8801-d7abbacc0866"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1QuotedIsa, (1), Relation)) .
\"urn:uuid:025b67f1-9c4c-4d05-93c5-4d06a00141aa"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg1QuotedIsa, (1))) .
\"urn:uuid:9c417362-bb32-40fc-a5a8-d0d901df246f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg1SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg1SometimesIsa RELATION\nCOLLECTION)</code> means that semantic well-formedness requires that anything\ngiven as the first argument to <code>RELATION</code> must be an instance of\n<code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg1SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ARG1 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG1 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:259db183-ffc0-48ed-b287-a9a168c5e6e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg1SometimesIsa, (2), Thing)) .
\"urn:uuid:21333ebd-00bc-466e-a629-716df15d3c6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1SometimesIsa, (2), Collection)) .
\"urn:uuid:f9ed1c19-7ab7-4e57-aeae-06a496180dfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg1SometimesIsa, (1), Relation)) .
\"urn:uuid:f70d0948-77ae-4e38-8a98-3d4259726920"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg1SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:3c495a87-0608-41e0-9448-c9eba2bfd039"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg1SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:74ccca37-83be-4eb4-88db-2cd6a2a9ced8"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg1SometimesIsa, genls, (2))) .
\"urn:uuid:48e3febf-4845-43fe-9ab8-3d3b0e547e68"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg1SometimesIsa, (1))) .
\"urn:uuid:f35899b2-38a8-4843-9a33-464e6445bf3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg2Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the second (or ''arg2'') argument-place of a given predicate.  <code>(#$arg2Format PRED FORMAT)</code> means that <code>PRED</code>'s arg2 is constrained to <code>FORMAT</code>.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:8af67a58-46fc-4d23-a4a1-c78afcfd3468"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2Format, (1), Predicate)) .
\"urn:uuid:ec01920b-c00d-44a8-88bb-1fdea585a703"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg2Format, openEntryFormatInArgs)) .
\"urn:uuid:90906c7f-32d6-40f4-81ac-73e4483752ea"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg2Format, (2))) .
\"urn:uuid:3cf07186-5934-4ae6-8693-0d20af63ee06"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg2Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg2Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the second argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2</code> ...) is semantically well-formed only if <code>(#$genls ARG2 COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argGenl for a similar but more flexible ternary  predicate."^^_string))) .
\"urn:uuid:791c9eab-7697-4d5d-80b0-4b9373300b74"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg2Genl, (2), Thing)) .
\"urn:uuid:333f12f1-69e0-4f35-9a86-4d36d2b2d66f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2Genl, (2), Collection)) .
\"urn:uuid:c79bef72-ba52-4855-b8f8-900d2ac5f1f3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2Genl, (1), Relation)) .
\"urn:uuid:643f45f3-ff09-45df-a365-20f4229378fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg2Genl, SetTheFormat)) .
\"urn:uuid:195872aa-4dc2-4f6d-b260-253b8e379d1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg2Genl, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(arg2Genl, ("argumentTwoGenls"^^_string))) .
\"urn:uuid:9720695c-cc9a-4b7a-a195-0eea337c8033"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg2Genl, genls, (2))) .
\"urn:uuid:70a96bfa-8f5a-40b9-b53d-f2262851e0d7"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg2Genl, genls, (2))) .
\"urn:uuid:89905733-9d66-4dd4-b2b3-4b5d2e9c0f60"[silk#strict] .
istAsserted(UniversalVocabularyMt, constrainsArg(arg2Genl, (2))) .
\"urn:uuid:571a08b7-93b8-41d5-8ce4-374202bb95be"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg2Genl, (2))) .
\"urn:uuid:70301680-163f-4fc8-a339-d262997da1b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg2Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg2Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the second argument to RELN must be an instance of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2</code> ...) is semantically well-formed only if <code>(#$isa ARG2 COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argIsa for a similar but more flexible ternary  predicate."^^_string))) .
\"urn:uuid:abcd7ad7-5028-4187-a389-5b21aee4de53"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg2Isa, (2), Thing)) .
\"urn:uuid:e9efadc5-a166-4577-a553-ca10fef50e57"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2Isa, (1), Relation)) .
\"urn:uuid:48725dde-0569-4bef-927f-20c484fc051e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2Isa, (2), Collection)) .
\"urn:uuid:c171972f-1182-46ed-818a-c925e787b340"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg2Isa, SetTheFormat)) .
\"urn:uuid:be0d6b5e-0bfa-491d-b8d1-2b88a9dab937"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg2Isa, SetTheFormat)) .
\"urn:uuid:e501945c-30f8-4f72-879a-3ecb3d77803e"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg2Isa)) .
\"urn:uuid:04238189-fee6-4e50-b391-e94fab4a79d8"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg2Isa, ArgTypeTernaryPredicate, NonNegativeInteger)) .
\"urn:uuid:f543a57b-9a35-4ee1-945f-68546c1b93ee"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg2Isa, ArgGenlBinaryPredicate, Collection)) .
\"urn:uuid:8c7ba861-a6e5-463f-beae-a6e5374a45b3"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg2Isa, ArgIsaBinaryPredicate, Collection)) .
istAsserted(BookkeepingMt, oldConstantName(arg2Isa, ("argumentTwoType"^^_string))) .
\"urn:uuid:c0f50a64-c851-49ca-b0a0-add5121fe02d"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg2Isa)) .
\"urn:uuid:dc912ba9-26de-4d01-b86a-a7e1bed4d69e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg2Isa, genls, (2))) .
\"urn:uuid:5e2a02a4-ac9b-49bf-9239-d25ab230c061"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg2Isa, genls, (2))) .
\"urn:uuid:2159a041-651b-4bcb-a1cd-3a7948dc74f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, constrainsArg(arg2Isa, (2))) .
\"urn:uuid:abbdc081-2f69-4517-8b32-932ed3d7b400"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg2Isa, (2))) .
\"urn:uuid:feb302b2-548c-4891-9a77-10b3145999db"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg2QuotedIsa, ("A binary #$Predicate (#$arg2QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the second argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ARG2 ...) is semantically well-formed only if (#$quotedIsa ARG2 COL) holds."^^_string))) .
\"urn:uuid:51997b35-a465-41bc-b4d3-68a09bd695e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg2QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:b2e7d7ef-3771-4858-be83-d2028f6a5c72"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:aa00774f-69a0-48a3-a15e-eaa2594ccb4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2QuotedIsa, (1), Relation)) .
\"urn:uuid:09934da3-1405-4837-a9d2-566912370afe"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg2QuotedIsa, (2))) .
\"urn:uuid:0aefce45-764f-4804-917f-012dc3160751"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg2SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg2SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the second argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg2SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG2 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG2 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:2c2b87b2-8b5d-4028-b090-0550d6f8964d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg2SometimesIsa, (2), Thing)) .
\"urn:uuid:c59515e0-b57f-4b45-8024-668fdc9de121"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2SometimesIsa, (2), Collection)) .
\"urn:uuid:3d744000-75b8-45cd-8f38-c7a6e7897205"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg2SometimesIsa, (1), Relation)) .
\"urn:uuid:9127a3db-aca0-4b79-b31f-3af344c991d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg2SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:8ccdca66-7200-4552-9ca8-da4256e7898a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg2SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:ed6e193e-9514-49cd-aae7-b59152cb8435"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg2SometimesIsa, genls, (2))) .
\"urn:uuid:f1e69a74-a091-437e-a120-915ce546eff9"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg2SometimesIsa, (2))) .
\"urn:uuid:7e3b95e4-14c8-4fb8-a536-37c0b136cb83"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg3Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the third (or ''arg3'') argument-place of a given predicate.  (#$arg3Format PRED FORMAT) means that PRED's arg3 is constrained to FORMAT.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:81b13b0a-e679-4cf1-8489-eac4908bdd96"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3Format, (1), Predicate)) .
\"urn:uuid:eb04f386-c98e-45f9-b582-84dc54ca4302"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg3Format, openEntryFormatInArgs)) .
\"urn:uuid:4fcc1e95-702b-4148-be3d-d82b34b8865b"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg3Format, (3))) .
\"urn:uuid:f61702fe-b838-480e-a181-eaa01281bb9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg3Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg3Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the third argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2 ARG3 ...)</code> is semantically well-formed only if <code>(#$genls ARG3 COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argGenl for a similar but more flexible ternary  predicate."^^_string))) .
\"urn:uuid:26283edc-59cf-4765-96d8-9982725b81ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg3Genl, (2), Thing)) .
\"urn:uuid:f0c04bda-df3c-452d-956f-2acd3b62ba0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3Genl, (1), Relation)) .
\"urn:uuid:95f4bd30-7542-40ad-ad77-be8a2b4a193d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3Genl, (2), Collection)) .
\"urn:uuid:ecaa364b-8265-4d68-b520-776e21c2e424"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg3Genl, SetTheFormat)) .
\"urn:uuid:644c0346-9f40-4322-ba3d-c63ee3ef76f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg3Genl, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(arg3Genl, ("argumentThreeGenls"^^_string))) .
\"urn:uuid:10fb0d81-e342-4be3-8ff2-3851647a5bcd"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg3Genl, genls, (2))) .
\"urn:uuid:a2aaf951-43c7-4031-a4dd-9519082c89c6"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg3Genl, genls, (2))) .
\"urn:uuid:925afdcd-ecd5-4728-824c-fd3ca1394d2a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg3Genl, (3))) .
\"urn:uuid:d80fcd88-6761-4cb5-86bb-024f4a289c8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg3Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg3Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the third argument to <code>RELN</code> must be an instance of COL.  That is, <code>(RELN ARG1 ARG2 ARG3</code> ...) is semantically well-formed only if <code>(#$isa ARG3 COL)</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  See #$argIsa for a similar but more flexible ternary  predicate."^^_string))) .
\"urn:uuid:52055815-ca7d-46ff-84f8-fa2d0e5cc7ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg3Isa, (2), Thing)) .
\"urn:uuid:5b3f205d-cbe5-4148-9c10-16203501792e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3Isa, (1), Relation)) .
\"urn:uuid:dff5300e-6554-44ea-ad17-2a3405395aae"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3Isa, (2), Collection)) .
\"urn:uuid:a9e3804a-70d2-494b-94c6-54e046679df3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg3Isa, SetTheFormat)) .
\"urn:uuid:387624b0-0090-4226-ac6d-1f210fb4f12a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg3Isa, SetTheFormat)) .
\"urn:uuid:0c7b5442-a5ce-460f-a64a-06ecd74d04cc"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg3Isa)) .
\"urn:uuid:5002fb48-1722-47cf-99e1-b245663531e9"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg3Isa, ArgGenlTernaryPredicate, Collection)) .
\"urn:uuid:63f9bcf7-ec5c-406e-9cf7-c7d438684550"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arg3Isa, ArgIsaTernaryPredicate, Collection)) .
istAsserted(BookkeepingMt, oldConstantName(arg3Isa, ("argumentThreeType"^^_string))) .
\"urn:uuid:4fa51ebc-e957-4d80-9cd9-29b771e18d5e"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg3Isa)) .
\"urn:uuid:0e4eaa0a-0e79-483e-a3b0-6540396af1ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg3Isa, genls, (2))) .
\"urn:uuid:85ab36e1-5dff-414f-9d6d-2d171c2e6151"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg3Isa, genls, (2))) .
\"urn:uuid:70e40301-b0b2-483d-881a-9b029f36f6e8"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg3Isa, (3))) .
\"urn:uuid:0e201e38-dfe1-43a6-9d3a-e101518d129a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg3QuotedIsa, ("A binary #$Predicate (#$arg3QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the third argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ...) is semantically well-formed only if (#$quotedIsa ARG3 COL) holds."^^_string))) .
\"urn:uuid:1a292844-0e86-41a0-b174-1998ad896955"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg3QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:8aca724e-5ccf-440e-8c0a-ecceda36af4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:ea04c88e-aac9-4bf5-9f66-4676be6fe14c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3QuotedIsa, (1), Relation)) .
\"urn:uuid:e9c0c1c3-bbf8-4424-84bc-ebc5c8dfce70"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg3QuotedIsa, (3))) .
\"urn:uuid:38f4b9ba-0665-490a-b0d9-0437a3218aa1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg3SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg3SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the third argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG3 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG3 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:64b01cdc-819d-42cc-bc69-dfd328e0d7be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg3SometimesIsa, (2), Thing)) .
\"urn:uuid:daa31998-4be7-4397-adc8-d355050c348d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3SometimesIsa, (2), Collection)) .
\"urn:uuid:62960a3e-5815-48dd-9054-9116c0836956"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg3SometimesIsa, (1), Relation)) .
\"urn:uuid:d20ebe85-c8a2-4987-9fc3-0301a0e97639"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg3SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:8e482938-10cd-4892-88b4-7658bbb3de70"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg3SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:693fb10b-e496-4441-9ebf-546d4fa4b497"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg3SometimesIsa, genls, (2))) .
\"urn:uuid:acf58cf7-3628-4b4b-b073-0b43c22d6f01"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg3SometimesIsa, (3))) .
\"urn:uuid:b0947069-7e41-4b8f-be1c-e72b90851c1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg4Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the fourth (or ''arg4'') argument-place of a given predicate.  (#$arg4Format PRED FORMAT) means that PRED's arg4 is constrained to FORMAT.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:5c0459b7-3694-4406-a0f9-80a3983a1e77"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4Format, (1), Predicate)) .
\"urn:uuid:34d67890-40d9-470e-8666-4ea7ac4d744c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg4Format, openEntryFormatInArgs)) .
\"urn:uuid:c3d5c9a5-b06e-4c44-921c-2777ac61d17a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg4Format, (4))) .
\"urn:uuid:e9f1ff68-92f0-4b8f-8f06-98c6368f0704"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg4Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg4Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the fourth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ...)</code> is semantically well-formed only if  <code>(#$genls ARG4 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argGenl for a  similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:67749ae1-4849-4303-9b9e-78a011777a1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg4Genl, (2), Thing)) .
\"urn:uuid:8b0ec420-c96c-4278-b8ce-a62c30f9e5ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4Genl, (1), Relation)) .
\"urn:uuid:cb34c744-6e0d-4eaa-a38d-135971fd7372"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4Genl, (2), Collection)) .
\"urn:uuid:457bbccd-1701-4420-9a6e-17c78150b20b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg4Genl, SetTheFormat)) .
\"urn:uuid:ecf7e0db-f78f-4409-89f7-8c6fd17087d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg4Genl, SetTheFormat)) .
\"urn:uuid:87eaade4-9ae6-4f18-bfe8-9b925a101695"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg4Genl, genls, (2))) .
\"urn:uuid:362b177f-0054-4273-98ae-0fb200bfbbe8"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg4Genl, genls, (2))) .
\"urn:uuid:7810bda1-f521-4ef8-baed-445f4a0f2396"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg4Genl, (4))) .
\"urn:uuid:9cb240ee-2b77-4100-bf63-ea08618f011b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg4Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg4Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the fourth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4</code> ...) is semantically well-formed only if  <code>(#$isa ARG4 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argIsa for a  similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:4cc5edce-8ff1-4e54-a7c9-a74c0c2cbf79"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg4Isa, (2), Thing)) .
\"urn:uuid:e15bcfe1-c20a-4cfb-8df5-6c46d3efcf02"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4Isa, (2), Collection)) .
\"urn:uuid:51f7d17a-16c3-4874-9a04-adcf71ad54c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4Isa, (1), Relation)) .
\"urn:uuid:823a6881-aa1f-4ec0-8925-4455e0caf94c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg4Isa, SetTheFormat)) .
\"urn:uuid:c13d4cd2-2a47-416c-80ed-a36605e1e591"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg4Isa, SetTheFormat)) .
\"urn:uuid:f2a37a42-9ca8-4b97-9505-b2057be056b4"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg4Isa)) .
istAsserted(BookkeepingMt, oldConstantName(arg4Isa, ("argumentFourType"^^_string))) .
\"urn:uuid:4b2f0136-15ef-4ed6-ab8e-44d811a3536c"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg4Isa)) .
\"urn:uuid:0f0f3597-f47d-4bd1-ace1-dc6584bda17d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg4Isa, genls, (2))) .
\"urn:uuid:34359a15-719f-49ec-86cf-713fa8be48e6"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg4Isa, genls, (2))) .
\"urn:uuid:6fee8820-a925-42ee-b119-57731d685a4d"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg4Isa, (4))) .
\"urn:uuid:35228402-8019-495b-a71c-adf9bb3f94ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg4QuotedIsa, ("A binary #$Predicate (#$arg4QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the fourth argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ...) is semantically well-formed only if (#$quotedIsa ARG4 COL) holds."^^_string))) .
\"urn:uuid:cae08d01-e228-4ef9-8dcf-59c20a4054f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg4QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:9a5b5613-219a-4fe6-b6ef-044275b5e6c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:4bdb2018-8ba3-404f-bc35-cb539cb731a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4QuotedIsa, (1), Relation)) .
\"urn:uuid:d6387e6c-e978-4202-82b1-7c2acc10c501"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg4QuotedIsa, (4))) .
\"urn:uuid:7ac065c5-e096-4430-a419-57019f52e9ae"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg4SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg4SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the fourth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG4 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG4 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:b58ea2b6-2993-4bfe-b2a6-d8cc4ef22785"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg4SometimesIsa, (2), Thing)) .
\"urn:uuid:b0f785f7-b7c8-4a16-89db-3c29851cd837"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4SometimesIsa, (2), Collection)) .
\"urn:uuid:78042ae6-0519-4cff-adc2-02d11f451b54"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg4SometimesIsa, (1), Relation)) .
\"urn:uuid:ea0522f3-8959-49ca-8ea1-b1b56d4957d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg4SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:bb158019-cb86-4d5d-8982-2581704404df"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg4SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:f10cc526-f83e-4ce7-a387-d55cb9c78c4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg4SometimesIsa, genls, (2))) .
\"urn:uuid:3fe5afd6-0f6e-49bf-9e8b-7eff7b3cb95a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg4SometimesIsa, (4))) .
\"urn:uuid:da26bf31-70f3-48f5-b75f-6de8345dbe26"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg5Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the fifth (or ''arg5'') argument-place of a given predicate.  (#$arg5Format PRED FORMAT) means that PRED's arg5 is constrained to FORMAT.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:878d27c2-6571-443e-bc77-a359e28a2a8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5Format, (1), Predicate)) .
\"urn:uuid:3cec8254-0065-4496-bd03-a1cd97e2eba9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg5Format, openEntryFormatInArgs)) .
\"urn:uuid:100afb68-87fd-4a9c-8c65-e4e7aed526c5"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg5Format, (5))) .
\"urn:uuid:2e51ff03-498a-4458-aea4-feeb28eeb256"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg5Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg5Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the fifth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ...)</code> is semantically well-formed only if <code>(#$genls ARG5 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argGenl for a  similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:0007eb68-f139-4861-b23f-9b7f58839d68"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg5Genl, (2), Thing)) .
\"urn:uuid:1445226d-cd04-4040-a7ae-0bc018b87535"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5Genl, (2), Collection)) .
\"urn:uuid:ddbc4588-1033-4de5-ada3-781dbf44c579"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5Genl, (1), Relation)) .
\"urn:uuid:bdd3536c-47c4-4a3c-b98f-3e568da1c4f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg5Genl, SetTheFormat)) .
\"urn:uuid:83ce909b-75dd-4715-9c34-b921fc21afbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg5Genl, SetTheFormat)) .
\"urn:uuid:a209ec39-c187-4a38-a08d-201b46de8276"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg5Genl, genls, (2))) .
\"urn:uuid:0a3c5849-716c-44f1-aee6-3ab3dff2783f"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg5Genl, genls, (2))) .
\"urn:uuid:6ecd7a48-00f3-4e79-81e1-9ebb24e3ba5a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg5Genl, (5))) .
\"urn:uuid:8f1dd7e4-b26a-490e-a740-92d4e1dc1b72"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg5Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg5Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the fifth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5</code> ...) is semantically well-formed only if  <code>(#$isa ARG5 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argIsa for a  similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:93c06794-c987-413f-8c6c-1338ab8414e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg5Isa, (2), Thing)) .
\"urn:uuid:c338e578-5c1f-482d-8cad-f28d874ff500"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5Isa, (1), Relation)) .
\"urn:uuid:41c61785-e012-46cc-bb19-660664e810d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5Isa, (2), Collection)) .
\"urn:uuid:c514e0a1-6afe-4e7d-aa1e-83519072e349"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg5Isa, SetTheFormat)) .
\"urn:uuid:60891cf2-ae02-4962-b176-72c25232fe7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg5Isa, SetTheFormat)) .
\"urn:uuid:69b0f8b6-832e-4bc4-a4e5-558747a3f2d8"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg5Isa)) .
istAsserted(BookkeepingMt, oldConstantName(arg5Isa, ("argumentFiveType"^^_string))) .
\"urn:uuid:e323476f-9a53-45e2-8b96-10f6cd279b91"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg5Isa)) .
\"urn:uuid:9c4c3454-79b1-45c9-8b7f-91e71f4cdd75"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg5Isa, genls, (2))) .
\"urn:uuid:7e3d8d7e-d68a-41ae-9c51-5c21de967850"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg5Isa, genls, (2))) .
\"urn:uuid:096391a9-722b-4271-b77b-f8929458fe82"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg5Isa, (5))) .
\"urn:uuid:a094bfe6-29fb-4675-baea-62ae4015fbf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg5QuotedIsa, ("A binary #$Predicate (#$arg5QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the fifth argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ARG5 ...) is semantically well-formed only if (#$quotedIsa ARG5 COL) holds."^^_string))) .
\"urn:uuid:956dd557-b90b-4e9e-844d-8923e87c7441"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg5QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:2c91281e-3d1e-4201-aa38-396c4f758fbd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:c77046ca-e2db-4bf1-bd13-e5db44930f4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5QuotedIsa, (1), Relation)) .
\"urn:uuid:5cb57b82-4ae5-4650-999d-0e9f4e935364"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg5QuotedIsa, (5))) .
\"urn:uuid:d7caaa5a-ee3a-4182-8c13-ffbc5088fd78"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg5SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg5SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the fifth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG5 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG5 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:5c6ef83b-9ef4-4c21-afbb-798b72e9f11d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg5SometimesIsa, (2), Thing)) .
\"urn:uuid:8fbcf906-a891-4a7b-a2e9-63ae0e6153bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5SometimesIsa, (2), Collection)) .
\"urn:uuid:8d4f509f-2163-40d9-b2ab-34ea7ee4824c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg5SometimesIsa, (1), Relation)) .
\"urn:uuid:62f31234-11ea-429c-b759-5ee3bd1d7837"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg5SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:9dc398d6-09b4-4807-8219-da773b2b64eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg5SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:33be3ab6-6260-42a5-a86b-1be23a388ea9"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg5SometimesIsa, genls, (2))) .
\"urn:uuid:523c80c8-7a46-4df7-a320-144f8924df9b"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg5SometimesIsa, (5))) .
\"urn:uuid:a8ecfbd9-5a11-475b-9d4a-373b57c38dc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg6Format, openEntryFormatInArgs)) .
\"urn:uuid:db306d04-8514-446d-bb49-e53ecd49590a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg6Format, ("An instance of #$ArgFormatPredicate (q.v.) used to place a particular #$Format (q.v.) constraint on the sixth (or ''arg6'') argument-place of a given predicate.  (#$arg6Format PRED FORMAT) means that PRED's arg6 is constrained to FORMAT.  See the reified instances #$Format for\nfurther details."^^_string))) .
\"urn:uuid:a1535716-3df9-4b8d-8250-6e55f2bd9489"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6Format, (1), Predicate)) .
\"urn:uuid:c7b456ab-c9e1-4936-8a25-285a321975e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg6Genl, ("A binary #$ArgGenlPredicate (q.v.).  <code>(#$arg6Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the sixth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...)</code> is semantically well-formed only if <code>(#$genls ARG6 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argGenl for a  similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:9b28b9ce-22c6-4606-b7a1-255afb90c29b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg6Genl, (2), Thing)) .
\"urn:uuid:c5caa746-6b4d-49da-a134-11bfafeb2c5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6Genl, (1), Relation)) .
\"urn:uuid:99484803-f3c9-49dc-be12-fb1be5875b37"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6Genl, (2), Collection)) .
\"urn:uuid:caa50a85-9b36-4ea3-ae56-39145cf5d12c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg6Genl, SetTheFormat)) .
\"urn:uuid:468883ff-5a08-44c7-a2b7-1af09830106f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg6Genl, SetTheFormat)) .
\"urn:uuid:1db7360c-e3ef-4d29-9b4b-144c5889268b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg6Genl, genls, (2))) .
\"urn:uuid:377ddf4c-8ca4-4caf-8015-0fc777a7352f"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg6Genl, genls, (2))) .
\"urn:uuid:c9762db1-fb46-4679-a055-b20405dc3a08"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg6Genl, (6))) .
\"urn:uuid:35251eb3-024c-436e-b5fb-f5b7e6dcb2cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg6Isa, ("A binary #$ArgIsaPredicate (q.v.).  <code>(#$arg6Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the sixth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...)</code> is semantically well-formed only if  <code>(#$isa ARG6 COL)</code> holds.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its specializations.  See #$argIsa for a similar but more flexible ternary predicate."^^_string))) .
\"urn:uuid:ba798aa5-bfb7-4e98-b4cb-164bf902dbce"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg6Isa, (2), Thing)) .
\"urn:uuid:ed9dd9bd-c87a-424e-aa18-da79be3ef1d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6Isa, (1), Relation)) .
\"urn:uuid:3f3dd101-5bcd-4f2b-b7e9-cb829e899a0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6Isa, (2), Collection)) .
\"urn:uuid:453c32e3-0b43-430b-8ee7-dbe9d6b73240"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg6Isa, SetTheFormat)) .
\"urn:uuid:e7470029-c4a3-4496-b00b-07bef1b0da96"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(arg6Isa)) .
\"urn:uuid:9f169e2d-758e-446f-a50e-5f1bbddb0964"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg6Isa, SetTheFormat)) .
\"urn:uuid:a14712b9-0435-46c7-a382-6933c54ea64c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg6Isa, genls, (2))) .
\"urn:uuid:c2b05240-ae66-49e9-bd2d-9231a790d216"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(arg6Isa, genls, (2))) .
\"urn:uuid:518ab212-066a-41fe-afaa-76bbddb693ed"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(arg6Isa)) .
\"urn:uuid:4f093fb6-b524-453c-9478-794993e74af3"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg6Isa, (6))) .
\"urn:uuid:6ea3f388-232b-4896-b857-1e59d62c5935"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg6QuotedIsa, ("A binary #$Predicate (#$arg6QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the sixth argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...) is semantically well-formed only if (#$quotedIsa ARG6 COL) holds."^^_string))) .
\"urn:uuid:8bea0abf-d59f-456f-a3ef-1a08b25c1fef"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg6QuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:021969ec-11c8-4a24-8e23-fc9363e4b484"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6QuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:bfa0fe49-0ddc-490b-a73f-854e516fa5e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6QuotedIsa, (1), Relation)) .
\"urn:uuid:28609806-48f9-4f40-9711-1404df7971fb"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg6QuotedIsa, (6))) .
\"urn:uuid:6801f01c-add1-4959-a3eb-688b136551c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arg6SometimesIsa, ("An #$ArgSometimesIsaPredicate and #$ArgTypeBinaryPredicate, <code>(#$arg6SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the sixth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg6SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG6 ...)</code>, it must only be the case that there\nexists some time interval (including #$Always-TimeInterval) in which\n<code>(#$isa ARG6 COLLECTION)</code> holds."^^_string))) .
\"urn:uuid:3f061671-4410-48a9-bf4f-7cefb64f9ea0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(arg6SometimesIsa, (2), Thing)) .
\"urn:uuid:dc709bef-6917-475c-87c8-205c1dda35f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6SometimesIsa, (2), Collection)) .
\"urn:uuid:da0b511c-4b81-4c9a-9cf4-0d52ffedd5f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arg6SometimesIsa, (1), Relation)) .
\"urn:uuid:d69fce20-76e6-4a05-99af-87fe820ca4c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arg6SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:8df486fb-d655-4ec9-8e0b-b2ca859984fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arg6SometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:6ea8d1e0-b67c-48a9-ac3a-e299b60aa3fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(arg6SometimesIsa, genls, (2))) .
\"urn:uuid:29bf15d6-2c6f-4cb5-931a-0b2d2c11300a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(arg6SometimesIsa, (6))) .
\"urn:uuid:ce48cbfe-59c0-40a9-8f4c-97c6dfb5124c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argAndRestGenl, ("A ternary #$ArgGenlPredicate (q.v.) used to \nplace a specified #$genls based argument-type constraint on a given \n#$VariableArityRelation (q.v.) with respect to any of its argument-places \nwhose ordinal position is greater than or equal to a specified number.\n(#$argAndRestGenl RELN N COL) means that, as a necessary condition for \nsemantic well-formedness, anything given as the Nth or greater argument \nto RELN must be an specialization of COL.  Thus a closed formula \n(RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is an instance of COL.  See also #$argsGenl and #$argAndRestIsa."^^_string))) .
\"urn:uuid:4c6fa009-4bc1-4aaa-9886-ee0cfcc66d3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argAndRestGenl, (3), Thing)) .
\"urn:uuid:8e29474b-ed45-4603-8089-4639812573c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestGenl, (3), Collection)) .
\"urn:uuid:53b6a060-f7f2-413e-aa90-93e3830dd99d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestGenl, (1), VariableArityRelation)) .
\"urn:uuid:31f38ec1-daec-49c7-946b-97370d63adec"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestGenl, (2), PositiveInteger)) .
\"urn:uuid:148a7b77-30f8-46d2-a017-21574662c9a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argAndRestGenl, SetTheFormat)) .
\"urn:uuid:a6473a4f-7e22-4ba1-8033-00abda67063a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(argAndRestGenl, SetTheFormat)) .
\"urn:uuid:69442b82-7556-45dc-bc54-3991ac01da55"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argAndRestGenl, SetTheFormat)) .
\"urn:uuid:999eb213-5e54-4a7d-bce4-5e1f41ae2ea4"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argAndRestGenl, genls, (3))) .
\"urn:uuid:6f80c2b5-1e21-4470-8f04-b96ae9d47c1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argAndRestIsa, ("A ternary #$ArgIsaPredicate (q.v.) used to \nplace a specified #$isa based argument-type constraint on a given \n#$VariableArityRelation (q.v.) with respect to any of its argument-places \nwhose ordinal position is greater than or equal to a specified number.\n(#$argAndRestIsa RELN N COL) means that, as a necessary condition for \nsemantic well-formedness, anything given as the Nth or greater argument \nto RELN must be an instance of COL.  Thus a closed formula\n(RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is an instance of COL.  See also #$argsIsa and #$argAndRestGenl."^^_string))) .
\"urn:uuid:6e41182b-a265-4c81-b3c6-110e62fd06f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argAndRestIsa, (3), Thing)) .
\"urn:uuid:983353e7-ae3d-458a-8f2e-f84bc5f7417e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestIsa, (2), NonNegativeInteger)) .
\"urn:uuid:29045196-a9c5-4da9-95d1-6b2cfc149704"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestIsa, (3), Collection)) .
\"urn:uuid:643d9098-ad98-4953-be08-4053f1ae26d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestIsa, (2), PositiveInteger)) .
\"urn:uuid:061d1628-9861-4cd6-9b32-33ed76f3286c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestIsa, (1), Relation)) .
\"urn:uuid:d80e3442-60da-4ab2-b6ee-4e7363e249b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestIsa, (1), VariableArityRelation)) .
\"urn:uuid:ec5779f4-5727-4884-9ccb-6b01182e436b"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argAndRestIsa, (2), PositiveInteger)) .
\"urn:uuid:97da2b50-c17c-4e39-bb22-5fee3029b9d7"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argAndRestIsa, (1), Relation)) .
\"urn:uuid:60b492f6-217b-4171-9fbf-931fe8d33fa4"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argAndRestIsa, (3), Collection)) .
\"urn:uuid:5cf27284-9eb2-451c-a21a-039d7e2be05f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argAndRestIsa, SetTheFormat)) .
\"urn:uuid:80e6f2f4-4af7-4690-8b43-44001efe6327"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(argAndRestIsa, SetTheFormat)) .
\"urn:uuid:2e54600c-1d67-477d-bd7d-4ec960fa9fe6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argAndRestIsa, SetTheFormat)) .
\"urn:uuid:b29ea266-0b82-41ad-880c-a41dc120896d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(argAndRestIsa, (2), SubLPositiveInteger)) .
\"urn:uuid:65879e1f-48fd-4bfd-953c-c621391e5077"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(argAndRestIsa, (2), SubLPositiveInteger)) .
\"urn:uuid:f83fd459-6da5-49b7-a1a9-187a7201129e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(argAndRestIsa, (2))) .
\"urn:uuid:a11cff71-5ad6-42b4-92e8-8a38d2b348a1"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argAndRestIsa, genls, (3))) .
\"urn:uuid:3e020a31-7395-4602-81b4-59d57e35f2e2"[silk#strict] .
istAsserted(BookkeepingMt, comment(argAndRestQuotedIsa, ("A ternary #$ArgQuotedIsaPredicate (q.v.) used to place a specified quoted isa based argument-type constraint on a given #$VariableArityRelation (q.v.) with respect to any of its argument-places whose ordinal position is greater than or equal to a specified number. (#$argAndRestQuotedIsa RELN N COL) means that, as a necessary condition for semantic well-formedness, anything given as the Nth or greater argument to RELN must be a quoted instance of COL. Thus a closed formula (RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is a quoted instance of COL. See also argsQuotedIsa."^^_string))) .
\"urn:uuid:417cc359-8025-4f76-8b39-80ac57246270"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argAndRestQuotedIsa, (3), Thing)) .
\"urn:uuid:06d3bb8c-068e-4a16-ba19-6020671b60ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argAndRestQuotedIsa, (3), SubLSExpression)) .
\"urn:uuid:12ec6a56-01c9-4972-ba94-04b4c40c7f7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestQuotedIsa, (3), SubLExpressionType)) .
\"urn:uuid:b9d159ea-b8f7-4fec-be60-739de65cb0b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestQuotedIsa, (2), PositiveInteger)) .
\"urn:uuid:e04497e7-2ace-4b5a-acc6-5ca66d938f31"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argAndRestQuotedIsa, (1), VariableArityRelation)) .
\"urn:uuid:ad97224f-6e15-439a-a814-f423e4260889"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argGenl, ("A ternary #$ArgGenlPredicate (q.v.).  <code>(#$argGenl RELN N COL)</code> means that semantic well-formedness requires that anything given as the <code>N</code>th argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ... ARGN ...)</code> is semantically well-formed only if <code>(#$genls ARGN COL)</code> holds.  For example, <code>(#$argGenl #$AtomFn 1 #$ElementStuff)</code> and <code>(#$argGenl #$argGenl 3 #$Thing)</code> both hold. In the special case where N is 0, #$argGenl is used to state that a certain #$genls constraint applies to <i>each</i> of <code>RELN</code>'s argument-places. Thus, <code>(#$argGenl RELN 0 COL)</code> means that <i>any</i> semantically appropriate argument to <code>RELN</code>, regardless of argument-place, must be a specialization of <code>COL</code>. For example, <code>(#$argGenl #$AtomicCompositionFn 0 (#$GroupFn #$Atom))</code> holds.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  For similar but less flexible binary predicates, see #$arg1Genls et al. See also #$argIsa."^^_string))) .
\"urn:uuid:d370a228-c77c-4b52-8933-57dd9f120bac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argGenl, (3), Thing)) .
\"urn:uuid:55f95e92-c042-4501-a52d-eec9b09814cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argGenl, (1), Relation)) .
\"urn:uuid:eb4cb079-70d3-4c87-8a54-2273cb3b9a12"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argGenl, (3), Collection)) .
\"urn:uuid:e556d2e0-c710-44e8-b196-1d9b3879af5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argGenl, (2), NonNegativeInteger)) .
\"urn:uuid:ee3caf41-9a90-4945-ae74-f44f7bfa0d9a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argGenl, SetTheFormat)) .
\"urn:uuid:5de9fe07-2062-4127-a7d2-ebfe1f70c7e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(argGenl, SetTheFormat)) .
\"urn:uuid:66b412d2-7b7b-4311-a945-0714c180d3dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argGenl, SetTheFormat)) .
\"urn:uuid:b0fa33e4-a0ea-4c28-bd50-533c1a50b482"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argGenl, genls, (3))) .
\"urn:uuid:c1ba4b59-df3e-4fbc-8935-63f2c5202b28"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argIsa, ("A ternary #$ArgIsaPredicate (q.v.).  <code>(#$argIsa RELN N COL)</code> means that semantic well-formedness requires that anything given as the <code>N</code>th argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is, <code>(RELN ... ARG<sub>N</sub> ...)</code> is semantically well-formed only if <code>(#$isa ARG<sub>N</sub> COL)</code> holds.  For example, <code>(#$argIsa #$mother 1 #$Animal)</code> and <code>(#$argIsa #$argIsa 3 #$Collection)</code> both hold.  For an  explanation of semantic well-formedness, see #$CycLExpression-Assertible and its specializations.  For similar but less flexible binary predicates, see #$arg1Isa et al. See also #$argGenl."^^_string))) .
\"urn:uuid:9fc602d2-6e01-4f28-bbd7-8ea60d4e83cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argIsa, (3), Thing)) .
\"urn:uuid:99da2775-7813-40b9-b0ee-882ee9a7121a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argIsa, (2), NonNegativeInteger)) .
\"urn:uuid:f735aacc-fafb-498c-9cf6-3fc9241f9a88"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argIsa, (1), Relation)) .
\"urn:uuid:ad9f9ed7-b02c-4e09-be1a-88d8257db30b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argIsa, (3), Collection)) .
\"urn:uuid:9f083af9-a223-4b5f-a722-34f1dc38c58a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argIsa, (2), PositiveInteger)) .
\"urn:uuid:57e445d9-9176-4f45-a50f-f57af90dcffb"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argIsa, (2), PositiveInteger)) .
\"urn:uuid:2bfe8821-4773-4860-acd7-f6d7d37d62ce"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argIsa, (1), Relation)) .
\"urn:uuid:fe3d4274-3e6e-476f-8313-58500e2fa4a8"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(argIsa, (3), Collection)) .
\"urn:uuid:270e0614-5f53-4253-9f71-4e2cbff7427b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argIsa, SetTheFormat)) .
\"urn:uuid:559dfe11-ddca-4852-8f58-f144dba4e261"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(argIsa, SetTheFormat)) .
\"urn:uuid:079b27ab-418f-4249-9f75-8279869f3445"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argIsa, SetTheFormat)) .
\"urn:uuid:48dbc783-6241-4b01-ac4c-f954f4e9157b"[silk#strict] .
istAsserted(BaseKB, completeExtentEnumerable(argIsa)) .
\"urn:uuid:d84193fb-5032-4838-a428-62c4a7b96cd9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(argIsa, (2), SubLPositiveInteger)) .
\"urn:uuid:174fb360-1eb0-483d-ba24-f224eb3b0adb"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(argIsa, (2), SubLPositiveInteger)) .
\"urn:uuid:29085b47-28bd-4e87-a16e-e644deb2c9aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(argIsa, (2))) .
\"urn:uuid:4e038fc2-b7ae-4b78-bd77-7becf6793547"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(argIsa)) .
\"urn:uuid:e1a11aa9-c11d-415b-be83-595aa8ac06f3"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argIsa, genls, (3))) .
\"urn:uuid:4b6781dd-ea39-446c-b604-2409cd8c3f09"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argN, ("A predicate that relates a CycL term and an  integer (representing an argument-position) to a CycL formula in  which the term appears (in that position). <code>(#$argN TERM N FORMULA)</code> means that <code>TERM</code> occurs in the <code>N</code>th argument-position within <code>FORMULA</code>. For example, the sentence `(#$argN #$Dog 1 (#$genls #$Dog #$Mammal))' holds.  Note that #$argN's first and third argument-places are both ''quoted'' (see #$quotedArgument); thus in the context of the above  #$argN sentence the constituent term `#$Dog' denotes  <i>itself</i>  (rather than the collection of dogs), and similarly for the  constituent #$genls sentence."^^_string))) .
\"urn:uuid:3e9b4a2d-f0f2-41bc-80ea-f70eb1974807"[silk#strict] .
istAsserted(BaseKB, notAssertible(argN)) .
\"urn:uuid:41d512f0-de89-4a20-8447-4da9547a501f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argN, (1), Thing)) .
\"urn:uuid:11b60bb9-2843-4a14-87b0-9d33b788688b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argN, (3), Thing)) .
\"urn:uuid:03cd5f28-817b-46d7-b4d1-cd215b100680"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argN, (2), NonNegativeInteger)) .
\"urn:uuid:06d0d5b7-5be0-4e35-ae65-734e50557adb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argN, singleEntryFormatInArgs)) .
\"urn:uuid:2ebb6a11-43cb-43f3-adbc-d29d74b64eca"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(argN)) .
\"urn:uuid:f64eaaea-2799-428f-a26d-0ecb582c3333"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(argN, (3), CycLFormula)) .
\"urn:uuid:53d5dd56-e01d-453f-9b9a-45daa3eb558b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(argN, (1), CycLTerm)) .
\"urn:uuid:7d85c440-59e8-4daa-b011-724f3da05c29"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(argN, (3))) .
\"urn:uuid:0a5baecb-7e9e-475d-91df-9fcede10ad97"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(argN, (1))) .
\"urn:uuid:df2c8539-f0d9-4ac1-be04-c4e6ecac4ea2"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(argN, (1))) .
\"urn:uuid:115d968c-e1f0-4cc2-af08-6ece6a15479b"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(argN)) .
\"urn:uuid:9504f7dc-078f-4492-a5fa-ea46b75f75fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argQuotedIsa, ("A ternary #$Predicate (#$argQuotedIsa RELN N COL) means that semantic well-formedness requires that the term given as the Nth argument to RELN must be an instance of the #$SubLExpressionType COL. That is, (RELN ... ARGN ...) is semantically well-formed only if (#$quotedIsa ARGN COL) holds. For example, (#$argQuotedIsa #$examplePredSentences 1 #$CycLSentence) holds. "^^_string))) .
\"urn:uuid:46b7ba61-cadb-476b-9a93-4f7fa8e5a4ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argQuotedIsa, (3), SubLSExpression)) .
\"urn:uuid:9e304256-2d13-4515-8c5a-3e7c796e4f87"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argQuotedIsa, (3), SubLExpressionType)) .
\"urn:uuid:06dcf846-e0d8-4178-afa4-b4c911ecf9e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argQuotedIsa, (2), NonNegativeInteger)) .
\"urn:uuid:7a5b1f85-fea5-4b60-b4b4-30e26cb3ec6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argQuotedIsa, (1), Relation)) .
\"urn:uuid:5ffe9dc5-64fe-4dee-b05c-b4784b684035"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argSometimesIsa, ("(#$argSometimesIsa RELATION POSITIVE-INTERGER-N COLLECTION) means that semantic\nwell-formedness requires that anything given as the Nth argument to RELN must be\nan instance of COL at sometime or other.  More precisely, if (#$argSometimesIsa RELATION POSITIVE-INTERGER-N COLLECTION) then in order to assert: (RELATION ARG-N ... OTHER-ARGS)<MT TIME PAR>, it must be the case that there exists some time interval, t, such that (#$isa ARG-N COLLECTION)<MT t PAR>."^^_string))) .
\"urn:uuid:81f84d24-a96a-48e3-9c5a-028660e162b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argSometimesIsa, (3), Thing)) .
\"urn:uuid:aafe7dc0-c8c4-4633-aef2-a35fc6209742"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(argSometimesIsa, (3))) .
\"urn:uuid:304c7fe3-e112-4c10-bf75-67c2abc82ae6"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(argSometimesIsa, (2))) .
\"urn:uuid:2ad19ff7-d517-41c4-bd90-3786d0adb8ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(argSometimesIsa, (1))) .
\"urn:uuid:0785e375-15d7-4b54-ab0a-4e9947d6647c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argSometimesIsa, (2), NonNegativeInteger)) .
\"urn:uuid:155eaea8-fa8c-49d9-a13a-e7233add7b9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argSometimesIsa, (2), PositiveInteger)) .
\"urn:uuid:537e87d0-9c74-4daf-b926-a0b61eecd393"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argSometimesIsa, (3), Collection)) .
\"urn:uuid:a275231d-f2e5-4f7f-a40e-91160f7fac02"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argSometimesIsa, (1), Relation)) .
\"urn:uuid:c5a5b61d-3794-4302-a38a-3315ea438fde"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argSometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:62642f3f-75ee-4994-9c57-9b78c1af0fcc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(argSometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:6450cf32-89a9-45ad-bd1f-a50bbe98dabd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argSometimesIsa, openEntryFormatInArgs)) .
\"urn:uuid:25cb25d7-1ff9-4059-ab93-6e677775ffb4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(argSometimesIsa, (2), SubLPositiveInteger)) .
\"urn:uuid:c9f33911-5864-41c5-8a07-86f1881282ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(argSometimesIsa, (2))) .
\"urn:uuid:4da40148-9167-4d72-90ec-e7450d3c902e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argsGenl, ("A binary #$ArgGenlPredicate (q.v.) that is used to put \na specified #$genls based argument-type constraint on all of a given relation's \nargument-places at once.  (#$argsGenl RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be an subcollection of COL.  For example, `(#$argsGenl #$PerformSimultaneouslyFn #$Event)' means that the function #$PerformSimultaneouslyFn must only be applied to types of events.  #$argsGenl is particularly useful for constraining (any and all of) the arguments to a #$VariableArityRelation (the preceding example being a case in point); though #$argsGenl may be applied to fixed-arity relations as well.  For an explanation of semantic well-formedness, see #$CycLExpression-Assertible and its immediate specializations.  See also #$argsIsa."^^_string))) .
\"urn:uuid:3c349650-9237-4f37-90d7-acb51743f470"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argsGenl, (2), Thing)) .
\"urn:uuid:95801580-dff2-469e-9596-286a589a85e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsGenl, (1), Relation)) .
\"urn:uuid:1237b237-8f7f-4367-a82a-8f5ed805e757"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsGenl, (2), Collection)) .
\"urn:uuid:39e125c6-687e-41d3-bd00-7992d056dfdc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argsGenl, SetTheFormat)) .
\"urn:uuid:101aa5fe-0109-4b4d-8fe3-4026e3926d57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argsGenl, SetTheFormat)) .
\"urn:uuid:bc63d66e-0711-4e27-b509-3f3f8099dd1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(argsGenl, genls, (2))) .
\"urn:uuid:e9a63e9c-f209-4626-abe4-91dc1a00e0df"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argsGenl, genls, (2))) .
\"urn:uuid:d75865f2-1bac-4424-a9cd-6c2479011a0c"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(argsGenl, (0))) .
\"urn:uuid:cba25d35-8094-4ec8-9022-6f25f49225dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argsIsa, ("A binary #$ArgIsaPredicate (q.v.) that is used to put a specified #$isa based argument-type constraint on all of a given relation's argument-places at once.  (#$argsIsa RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be an instance of COL.  For example, '(#$argsIsa #$PlusFn #$ScalarInterval)' means that the function #$PlusFn must only be applied to scalar intervals.   #$argsIsa is particularly useful for constraining (any and all of) the arguments to a #$VariableArityRelation (the preceding example being a case in point); though #$argsIsa may be applied to fixed-arity relations as well.  For an explanation of semantic well-formedness, see #$CycLExpression-Assertible and its immediate specializations.  See also #$argsGenl."^^_string))) .
\"urn:uuid:d8144597-3819-457a-be21-fc15f586a98e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argsIsa, (2), Thing)) .
\"urn:uuid:2e1835e7-ef24-4841-aa78-9c509410341f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsIsa, (2), Collection)) .
\"urn:uuid:08440df5-0bfa-4a07-a567-ab40f585efe3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsIsa, (1), Relation)) .
\"urn:uuid:b9cdb494-6aba-42c5-9790-7799d012b26f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(argsIsa, SetTheFormat)) .
\"urn:uuid:6c07bbe2-2821-40da-b9ad-1b7f67f645b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(argsIsa, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(argsIsa, ("argumentTypes"^^_string))) .
\"urn:uuid:886e7336-212a-4483-8f29-8f8053d8e152"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(argsIsa, genls, (2))) .
\"urn:uuid:f166a9e6-8b60-4849-8b4f-696d9ebcaf08"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(argsIsa, genls, (2))) .
\"urn:uuid:c87a63da-b62c-4669-a327-c75adc5c263e"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg(argsIsa, (0))) .
\"urn:uuid:9bbaf60e-f4ba-4a9e-8dcb-286cb5769b03"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(argsQuotedIsa, ("A binary #$ArgQuotedIsaPredicate (q.v.) that is used to put a specified quoted-isa based argument-type constraint on all of a given relation's argument-places at once. (#$argsQuotedIsa RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be a quoted instance of COL. For example, '(#$argsQuotedIsa #$and #$CycLSentence-Assertible)' means that the relation #$and must only be applied to assertible CycL sentences. #$argsQuotedIsa is particularly useful for constraining (any and all of) the arguments of a VariableArityRelation (the preceding example being a case in point); though #$argQuotedIsa may be applied to fixed-arity relations as well. For an explanation of semantic well-formedness, see CycLExpression-Assertible and its immediate specializations."^^_string))) .
\"urn:uuid:700850cd-5615-4e4a-8362-2a74141f8731"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argsQuotedIsa, (2), Thing)) .
\"urn:uuid:bdb87f64-0005-4d0e-ade6-6a76d9ed0948"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(argsQuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:fbee5710-65e0-45e9-967d-44dbbcf747cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsQuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:04533354-8de9-475d-ae67-e33c14920d9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(argsQuotedIsa, (1), Relation)) .
\"urn:uuid:ef39f385-ee74-49e6-8537-31045ea96f79"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arity, ("A #$MetaRelation used for stating that a given  relation takes a specified number of arguments.  <code>(#$arity RELN N)</code>  means that that semantic well-formedness requires that <code>RELN</code> take  exactly <code>N</code> arguments at a time.  That is, a formula  <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically well-formed only if <code>M</code> = <code>N</code>.\n<p>\nFor example, the #$arity of any instance of #$BinaryPredicate is 2.\n<p>\nNote that full semantic well-formedness requires obeying argument-type constraints (see #$ArgTypePredicate) as well as arity constraints.  For a general explanation of semantic well-formedness, see #$CycLExpression-Assertible.  See also #$CycLExpression-Askable."^^_string))) .
\"urn:uuid:ed15d444-a72e-4ae3-a079-4f8475f52bea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arity, (2), Integer)) .
\"urn:uuid:4431db95-5167-4d94-a149-ffa0b4ea821d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arity, (2), NonNegativeInteger)) .
\"urn:uuid:dd2a71c4-154b-4234-aa9c-9528f48cc221"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arity, (1), FixedArityRelation)) .
\"urn:uuid:0e36f2a4-afc5-424d-82f0-02ee8bc5bb60"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(arity, (2), NonNegativeInteger)) .
\"urn:uuid:7578313a-55e4-4802-a565-25b6e0001824"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(arity, (1), FixedArityRelation)) .
\"urn:uuid:e6c472d5-ed76-49c6-b3e1-e99fcca8fb49"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arity, SingleEntry)) .
\"urn:uuid:1bfa36dc-9c68-41da-93ff-a1bd5dd948d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arity, SetTheFormat)) .
\"urn:uuid:375560fd-220c-4db4-ac51-9a15b7006e6b"[silk#strict] .
istAsserted(BaseKB, relationAllExists(arity, Predicate, NonNegativeInteger)) .
\"urn:uuid:f019f59a-2232-4059-b89d-af15b4458cc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(arity, (2), SubLNonNegativeInteger)) .
\"urn:uuid:c48969de-1d70-4ac0-899f-a11abc943d17"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(arity, (2), SubLNonNegativeInteger)) .
\"urn:uuid:6f3772c1-708b-4162-bab7-3cea85117922"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(arity, Predicate, NonNegativeInteger)) .
\"urn:uuid:a0bc1c3e-23de-4c18-9cf2-e913d6a9aedc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(arity, (2))) .
\"urn:uuid:aa72bbe0-82cf-44ab-8553-d8f88e1d94d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(arity, (1), Predicate, (2), NonNegativeInteger)) .
\"urn:uuid:b7e8203e-1176-482d-b3aa-8d6d0a371208"[silk#strict] .
istAsserted(CoreCycLMt, relationAllInstance(arity, BinaryRelation, (2))) .
\"urn:uuid:19e1e3ab-ff81-4fe3-962c-25a838afa609"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arity, BinaryRelation, (2))) .
\"urn:uuid:a88a5926-6a4e-4cb5-af3d-37948dae626d"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arity, QuintaryRelation, (5))) .
\"urn:uuid:a0714ff5-d38b-4fcd-869b-e39adc665698"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arity, QuaternaryRelation, (4))) .
\"urn:uuid:e622e337-0ec5-47af-8963-32289475c003"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arity, UnaryRelation, (1))) .
\"urn:uuid:512d945c-5e40-4263-9cfc-1b170bf1ba67"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arity, TernaryRelation, (3))) .
\"urn:uuid:6b256120-53fc-46d8-b98e-a7aadcfb47d9"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(arity, (2))) .
\"urn:uuid:77f50a78-4245-4cf4-a0f1-4e8d4fd9b1ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(arity, Thing, Thing, (1))) .
istAsserted(BookkeepingMt, oldConstantName(arity, ("expressionArity"^^_string))) .
\"urn:uuid:0a4b5e2e-741c-46d0-89c0-df293325a356"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arityMax, ("A #$MetaRelation for specifying the maximum number\nof arguments a given #$VariableArityRelation can take if the \nresulting formula is to be semantically well-formed.  <code>(#$arityMax RELN N)</code> means \nthat semantic well-formedness requires that <code>RELN</code> take at most <code>N</code> arguments at \na time.  More precisely: a formula <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically \nwell-formed only if <code>M</code> is less than or equal to <code>N</code>.  For example, the \nmaximum-arity of any instance of #$UnitOfMeasure is 2.  Note that full semantic \nwell-formedness requires obeying argument-type constraints (see \n#$ArgTypePredicate) as well as arity constraints.  For a general explanation \nof semantic well-formedness, see #$CycLExpression-Assertible.  See also \n#$arityMin and #$arity."^^_string))) .
\"urn:uuid:3b9a9e47-17a7-4786-b775-a6ed93d8e0f7"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arityMax, UnitOfMeasure, (2))) .
\"urn:uuid:61502ba8-dd64-4927-87a1-5bf7afc67682"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(arityMax, (2))) .
\"urn:uuid:687c371e-fb73-4968-ba35-73b84839d28b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arityMax, (1), VariableArityRelation)) .
\"urn:uuid:39693623-6f25-4df1-8b2a-bcdf935ceee1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arityMax, (2), NonNegativeInteger)) .
\"urn:uuid:d8c47604-cec9-4abe-81c7-0de7f0db1795"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(arityMax, Thing, Thing, (1))) .
\"urn:uuid:78a9696f-1579-46d6-9823-9518bce85224"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arityMax, SingleEntry)) .
\"urn:uuid:599f4f4e-00ee-4b28-925c-263d7c6564b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arityMax, SetTheFormat)) .
\"urn:uuid:4a00d2f0-5eff-4296-85ea-e335bdfff21f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(arityMin, ("A #$MetaRelation for specifying the minimum number\nof arguments a given #$VariableArityRelation must take if the resulting formula is to be semantically well-formed.  <code>(#$arityMin RELN N)</code> means that semantic well-formedness requires that <code>RELN</code> take at least <code>N</code> arguments at a time.  More precisely: a formula <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically well-formed only if <code>M</code> is greater than or equal to <code>N</code>.  For example, the minimum-arity of any instance of #$UnitOfMeasure is 1.  Note that full semantic well-formedness requires obeying argument-type constraints (see #$ArgTypePredicate) as well as arity constraints. For a general explanation of semantic well-formedness, see #$CycLExpression-Assertible.  See also #$arityMax and #$arity."^^_string))) .
\"urn:uuid:8dcff3c8-30bc-463a-8b75-ec98e9ac0b18"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(arityMin, UnitOfMeasure, (1))) .
\"urn:uuid:358ad86e-387a-40ff-b96a-f026007b818b"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(arityMin, (2))) .
\"urn:uuid:e91431e9-46e4-4da6-a1c9-a3e0735684f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arityMin, (1), VariableArityRelation)) .
\"urn:uuid:91ed789d-1d42-45de-a3cc-cbef197bac92"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(arityMin, (2), NonNegativeInteger)) .
\"urn:uuid:07190a67-5b59-4aea-9d1b-6bfe39becd61"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(arityMin, Thing, Thing, (1))) .
\"urn:uuid:7a2f306c-8575-4223-84a8-00cdd54c7d9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(arityMin, SingleEntry)) .
\"urn:uuid:e5d1da4c-7ca9-4e1d-9c56-ee5539460771"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(arityMin, SetTheFormat)) .
\"urn:uuid:0b6eb70c-a64e-43d4-b847-7524aa8d99d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertedMoreSpecifically, ("<code>(#$assertedMoreSpecifically GENL-SENTENCE)</code> states that there exists a <code>SPEC-SENTENCE</code> which is an asserted sentence that is more specific than <code>GENL-SENTENCE</code>, but implies <code>GENL-SENTENCE</code>.  For example, were\n<p>\n(#$isa #$and #$LogicalConnective)\n<p>\nto be asserted, we would have\n<p>\n(#$assertedMoreSpecifically (#$isa #$and #$Relation))\n<p>\nsince (#$genls #$LogicalConnective #$Relation)."^^_string))) .
\"urn:uuid:d0e2f839-eeca-4bce-a5eb-7c96239c901c"[silk#strict] .
istAsserted(BaseKB, notAssertible(assertedMoreSpecifically)) .
\"urn:uuid:000a089e-25bc-42c6-8354-c7f1236cdf78"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, backchainForbidden(assertedMoreSpecifically)) .
\"urn:uuid:f9aa6ca9-39cd-4a5b-b7f7-1db8983edf2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertedMoreSpecifically, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:e9bb0f3e-065a-4162-b3ed-ed0b0d7bc2cd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertedMoreSpecifically, (1))) .
\"urn:uuid:7cb55c46-ad7a-4ec0-8eca-fca3f98479bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertedPredicateArg, ("(#$assertedPredicateArg OBJ N PREDICATE) means that a ground atomic formula (or ''GAF''; see #$CycLClosedAtomicSentence) whose initial (or ''0th'' argument-place) term denotes PREDICATE, and whose Nth argument-place term denotes OBJ, is asserted in the Cyc Knowledge Base. Note that this predicate is itself #$notAssertible (q.v.), since it must be computed from the state of the knowledge base."^^_string))) .
\"urn:uuid:903c62e3-59ef-4ae3-8c76-5011d63ce88f"[silk#strict] .
istAsserted(BaseKB, notAssertible(assertedPredicateArg)) .
\"urn:uuid:f16a06a8-2ca1-435e-b9f7-d8b74c76360f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(assertedPredicateArg, (2), PositiveInteger)) .
\"urn:uuid:e79e32db-550c-4db6-83e5-35c550cc3a2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(assertedPredicateArg, (1), Thing)) .
\"urn:uuid:ef5ed30b-0ea8-4611-a16b-22ffbeeb3076"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(assertedPredicateArg, (3), Predicate)) .
\"urn:uuid:00fc4e09-df25-42cf-b592-1ee3c2cbf38b"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(assertedPredicateArg)) .
\"urn:uuid:36b9afaf-6834-4052-ae1c-b78efdb7803d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(assertedPredicateArg)) .
\"urn:uuid:f69d509b-2b24-4117-9efe-b84b9309c4f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(assertedPredicateArg)) .
\"urn:uuid:84f78c26-f064-4111-9fc2-047a2b5ed816"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertedSentence, ("A #$KBDependentRelation (q.v.) and specialization of #$knownSentence (q.v.) that is used to state that a given #$CycLSentence-Assertible has been asserted in the KB (in some accessible #$Microtheory). More exactly, (#$assertedSentence SENT) is true in microtheory MT precisely when SENT canonicalizes into a set of clauses of the same form as the canonicalized form of some assertion in a microtheory accessible to MT. (The predicate is thus true both of assertions entered into the KB by hand and assertions deduced by Cyc from forward rules.) For the more specific claim that SENT is asserted <b>in MT</b>, see the predicate #$ist-Asserted.\n<p>\nThis predicate enables Cyc to select a subset of information when answering queries, filtering out more generic (inferrable-but-not-asserted) information. Thus, for example, the query:\n<p>\n(#$genls #$Dog #$Thing)\n<p>\nwill return #$True (in appropriate microtheories), whereas:\n<p>\n(#$assertedSentence (#$genls #$Dog #$Thing))\n<p>\nwill not."^^_string))) .
\"urn:uuid:dab5999e-b8b2-4af9-b695-015e106b2418"[silk#strict] .
istAsserted(BaseKB, notAssertible(assertedSentence)) .
istAsserted(BookkeepingMt, oldConstantName(assertedSentence, ("assertedFormula"^^_string))) .
\"urn:uuid:30954e58-e09d-4c82-942e-8a1056eec9a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(assertedSentence)) .
\"urn:uuid:22bf00af-e9d4-43dd-8b6d-bd573c3e966f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(assertedSentence)) .
\"urn:uuid:66b273c8-d6eb-44cd-83a8-3917f346d148"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAll(assertedSentence, CycLAssertion)) .
\"urn:uuid:3447f84d-c7af-4851-85be-d2e886cc7d09"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(assertedSentence)) .
\"urn:uuid:f06eb1ee-b86b-48ce-ac5f-f9cd3302ee79"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertedSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:92b46434-d094-4bdb-af78-f9442382500d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertedSentence, (1))) .
\"urn:uuid:5f9cee5e-f5d3-439d-9549-ff27e6887f61"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertedTermSentences, ("(#$assertedTermSentences THING SENTENCE) means that SENTENCE has been asserted to the Cyc Knowledge Base (and is thus a  #$CycLAssertion) and that THING is mentioned in SENTENCE.  More precisely, and assuming the #$assertedTermSentences formula contains no free variables (and \nis thus a ''ground atomic formula'' or ''GAF''): the CycL term immediately following the constant `#$assertedTermSentences' in the formula occurs in SENTENCE.  For example, (#$assertedTermSentences #$France (#$bordersOn #$France #$Germany)) holds.  See also #$assertedSentence and #$assertedPredicateArg for related predicates about assertions; and see #$termFormulas for a more general predicate that does not entail that SENTENCE has been asserted."^^_string))) .
\"urn:uuid:41ff0727-ad50-4427-877e-f1dc444bcb18"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(assertedTermSentences, (1), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(assertedTermSentences, ("assertedTermFormulas"^^_string))) .
\"urn:uuid:f834dc87-3d08-4ed0-a42a-f542a3024f5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(assertedTermSentences)) .
\"urn:uuid:8acf75ff-6065-41a2-adf5-998443cc468b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(assertedTermSentences)) .
\"urn:uuid:7e5b8b6a-6b0b-4688-895a-58e9185e29e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(assertedTermSentences)) .
\"urn:uuid:5fca9695-981d-4542-a444-c3430bd255cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertedTermSentences, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:1068ca26-2320-40f2-86bf-bc83eeab64cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertedTermSentences, (1), CycLTerm)) .
\"urn:uuid:1f44f4ce-8819-4ce9-bb0c-f39f960fd33b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertedTermSentences, (2))) .
\"urn:uuid:6d094465-5222-4cf5-9e1a-8edc0b1a41dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertedTermSentences, (1))) .
\"urn:uuid:8901ea54-0495-44b3-9c14-eea303e40485"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(assertionDirection, CycLRuleAssertion, 'Backward-AssertionDirection')) .
\"urn:uuid:44ae9a94-d1dd-49fa-b83e-53eb7aa36ef8"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(assertionDirection, CycLGAFAssertion, 'Forward-AssertionDirection')) .
\"urn:uuid:0982028c-d6c7-4455-86cb-ed6c87c17b7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertionDirection, ("An #$AssertionDescriptorPredicate that \nis used to state that a given #$CycLAssertion has a certain inference \n''direction'', which indicates something about how and when the assertion \ncan be used in inferences by the Cyc system. (#$assertionDirection ASSERTION DIRECTION) means that ASSERTION has DIRECTION as its #$CycLAssertionDirection (q.v.).  DIRECTION is normally #$Backward-AssertionDirection (q.v.) when \nASSERTION is a rule and #$Forward-AssertionDirection (q.v.) when ASSERTION is \na ground atomic formula (or ''GAF''; see #$CycLClosedAtomicSentence).  Note \nthat a CycL sentence is given a direction at the time of its assertion to the \nKnowledge Base, and this fact _need_not_ in general be reflected in another, \n#$assertionDirection GAF's being asserted (as that would of course lead to an infinite regress)."^^_string))) .
\"urn:uuid:3104e247-3ed4-4e51-bcf4-349d104dbd7f"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(assertionDirection, (2))) .
\"urn:uuid:ced4a640-7db5-40fd-b069-ee6aa85181f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(assertionDirection, (2), CycLAssertionDirection)) .
\"urn:uuid:17b70ed5-2ebc-4365-a6c5-7f3467d5be76"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(assertionDirection, Thing, Thing, (1))) .
\"urn:uuid:e74c34ad-918e-4c9e-af45-da2d6d7bc826"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(assertionDirection, SingleEntry)) .
\"urn:uuid:5571ff79-6eff-45de-aca9-618ec13767ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(assertionDirection)) .
\"urn:uuid:cb4363a9-1ed6-4c42-8d90-e134c6487cb2"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(assertionDirection)) .
\"urn:uuid:8c387be3-ed9a-4975-8e46-1e3566abac02"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(assertionDirection)) .
\"urn:uuid:5d28d1d5-9f61-42ae-9a24-6a39117f8ef3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertionDirection, (1), CycLAssertion)) .
\"urn:uuid:bf1b48e0-c90a-4a2b-a10c-0a071f6663ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertionDirection, (1))) .
\"urn:uuid:448fa547-a85d-46c2-ad48-78660f3278a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertionUtility, ("A #$CycInferenceHeuristicRelevancePredicate. (#$assertionUtility ASSERTION NUM) states that the #$CycLAssertion ASSERTION should be heuristically considered of utility NUM to inferences made in the current Microtheory. NUM should be a #$RealNumber between 1 and -1, with 1 indicating maximum utility, -1 indicating minimum utility, and 0 being agnostic with respect to utility.  (#$assertionUtility ASSERTION 1) is equivalent to (#$highlyRelevantAssertion ASSERTION). (#$assertionUtility ASSERTION -1) is equivalent to (#$irrelevantAssertion ASSERTION).  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:5d23c682-7f7c-49a4-8079-a8dd5e1a64e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertionUtility, (1), CycLAssertion)) .
\"urn:uuid:4fa62cbe-485f-4fc1-900f-b60bd7009300"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertionUtility, (1))) .
\"urn:uuid:06583f69-953d-4d3f-8ea2-004e76b6cdfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('assertionUtility-1', ("A #$CycInferenceHeuristicRelevancePredicate. (#$assertionUtility ASSERTION NUM) states that the #$CycLAssertion ASSERTION should be heuristically considered of utility NUM to inferences made in the current Microtheory. NUM should be a #$RealNumber between 1 and -1, with 1 indicating maximum utility, -1 indicating minimum utility, and 0 being agnostic with respect to utility.  (#$assertionUtility ASSERTION 1) is equivalent to (#$highlyRelevantAssertion ASSERTION). (#$assertionUtility ASSERTION -1) is equivalent to (#$irrelevantAssertion ASSERTION).  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:d3800e0a-3969-4d27-9d9f-6c167735a1ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa('assertionUtility-1', (1), CycLAssertion)) .
\"urn:uuid:415e39a5-11a0-4bf5-8cd7-2b9382887f79"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument('assertionUtility-1', (1))) .
\"urn:uuid:5a196ec6-066d-47cd-adaf-ccdeb0898ba2"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationDefn(assertiveWFFEnabled, SubLSymbolFn(("WFF-ASSERTIVE?"^^_string)))) .
\"urn:uuid:8e026177-820b-47cf-b2a5-78de1bd82fe7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertiveWFFEnabled, ("(#$assertiveWFFEnabled) is true iff #$CycWellFormednessChecker is in assertive wff mode, which means that WFF will actively try to make assertions to make an incoming assertion true."^^_string))) .
\"urn:uuid:886bf099-6e0f-4f7e-884e-fac0039a6a55"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(assertiveWFFEnabled)) .
\"urn:uuid:1957cbab-c460-4dd2-ac31-6c64610ac191"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(assertiveWFFRule, (1), CycLRuleAssertion)) .
\"urn:uuid:007e0724-4cca-47b4-b871-5d9cacd25050"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(assertiveWFFRule, (1))) .
istAsserted(BookkeepingMt, oldConstantName(assertiveWFFRule, ("millerWFFRule"^^_string))) .
\"urn:uuid:ce4f974f-2367-4eb6-8f48-4f96733fe484"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(assertiveWFFRule, ("(#$assertiveWFFRule <code>RULE</code>) means that <code>RULE</code> is a #$CycLRuleAssertion to be used by the #$CycWellFormednessChecker in 'assertive' mode.  'Assertive' mode is the mode in which assertions are allowed into the KB as long as they are not provably disjoint with existing knowledge, and then forward inference (constrained to rules of which #$assertiveWFFRule holds) may conclude additional facts based on the newly asserted knowledge."^^_string))) .
\"urn:uuid:8c6e49a5-7ed5-437c-aef7-aaabc613e72e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(backchainForbidden, ("#$backchainForbidden is a predicate that allows users to cut down on the number of rules used to prove certain literals, and thus to increase the speed of inferences that involve proving those literals.  <code>(#$backchainForbidden PREDICATE)</code> means that no rules containing a positive literal with <code>PREDICATE</code> as the arg0 (in other words, no #$implies assertions in which a literal with <code>PREDICATE</code> as the arg0 appears in the consequent) will be used when attempting to prove (non-negated) literals with <code>PREDICATE</code> as the arg0.  Asserting <code>(#$backchainForbidden PREDICATE)</code> is useful when all (non-negated) literals with <code>PREDICATE</code> as the arg0 are expected to be solvable by lookup of ground atomic formulas (GAF's) already in the KB, and so rules won't be needed to prove them.  However, asserting <code>(#$backchainForbidden PREDICATE)</code> is usually counter-productive in contexts where some literals with <code>PREDICATE</code> as the arg0 are expected to be proven via backchaining on rules containing a positive literal with <code>PREDICATE</code> as the arg0.  See also the related predicates #$backchainRequired, #$backchainEncouraged, and #$backchainDiscouraged."^^_string))) .
\"urn:uuid:5464ea8e-170b-4d18-a6a1-8d8ec94f3ae1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(backchainForbidden, (1), Predicate)) .
\"urn:uuid:50f4ea16-3e97-40ed-8b39-8521e07a99df"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(backchainForbidden)) .
\"urn:uuid:5739cb68-3ae2-4119-abdd-3cca097065b4"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(backchainForbidden)) .
\"urn:uuid:6d662317-bdaa-453b-917f-4fef8a7fc9b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(backchainForbidden)) .
\"urn:uuid:d0b7d63f-97c1-4e63-92db-329c1b998144"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(backchainForbiddenWhenUnboundInArg, ("#$backchainForbiddenWhenUnboundInArg is a predicate that\nallows users to prevent the inference engine from backchaining on a\nliteral when one or more of its arguments are unbound. That is, if\nPRED is a #$Predicate, N a positive integer less than or equal to the\narity of PRED, then (#$backchainForbiddenWhenUnboundInArg PRED N) that\nno rules concluding to a positive literal with PREDICATE as the arg0\n(in other words, no #$implies assertions in which a literal with\nPREDICATE as the arg0 appears in the consequent) will be used when\nattempting to prove (non-negated) literals with PREDICATE as the arg0\n*unless* argN in the literal is fully bound. For instance, the sentence\n<pre>\n(#$backchainForbiddenWhenUnboundInArg #$interestingSentence 1)\n</pre>\nprevents the inference engine from applying any rule concluding\n#$interestingSentence, such as \n<pre>\n(#$implies\n  (#$maleficiary ?PROGRAM ?AGENT) \n  (#$interestingSentence ?AGENT (#$maleficiary ?PROGRAM ?AGENT)))\n</pre>\nunless and until <code>?AGENT</code> is bound."^^_string))) .
\"urn:uuid:ad015013-0b29-4cde-8d68-7657ee03687d"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(backchainForbiddenWhenUnboundInArg)) .
\"urn:uuid:7f5ae38f-9c8d-4551-80a3-88ae5fe6a568"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(backchainForbiddenWhenUnboundInArg)) .
\"urn:uuid:8b6419f3-bb9c-41a3-beec-2b705127693a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(backchainForbiddenWhenUnboundInArg, (2), PositiveInteger)) .
\"urn:uuid:9b8160e2-7c0c-48b0-a494-fb91a4696647"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(backchainForbiddenWhenUnboundInArg, (1), Predicate)) .
\"urn:uuid:c1592add-a3d3-4d2e-a09e-357293152cf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(backchainRequired)) .
\"urn:uuid:c411c9d7-b312-422c-bc64-8b5ac8af2ba2"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(backchainRequired)) .
\"urn:uuid:13aa18ae-ea85-45f7-855d-ffef8ae6d528"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(backchainRequired, ("(#$backchainRequired PREDICATE) means that rules that conclude PREDICATE must be used in order to prove literals involving PREDICATE.  In other words, when performing inferences, all literals involving PREDICATE must be eliminated using rules since there won't be any other way to prove them.  See also #$backchainEncouraged, #$backchainDiscouraged, and #$backchainForbidden."^^_string))) .
\"urn:uuid:a27d0bdd-61c1-4acf-9876-7da95673bac4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(backchainRequired, (1), Predicate)) .
\"urn:uuid:e40f3311-4645-41f8-8445-0db68ddf504b"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(canonicalizerDirectiveForAllArgs, ("A  #$CanonicalizerDirectivePredicate (q.v.) used (in conjunction with a  #$CanonicalizerDirective) to control the behavior of the #$CycCanonicalizer. (#$canonicalizerDirectiveForAllArgs RELN DIRECTIVE) means that the  #$CycCanonicalizer obeys DIRECTIVE when canonicalizing any argument of a  #$CycLFormula whose main (or ''0th place'') operator denotes RELN.  See the  instances of #$CanonicalizerDirective for more information on how particular  directives affect canonicalization.  Also see #$canonicalizerDirectiveForArg and #$canonicalizerDirectiveForArgAndRest."^^_string))) .
\"urn:uuid:358391c8-b3b3-41eb-bd20-87dd9e05b910"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForAllArgs, (1), Relation)) .
\"urn:uuid:e03442c3-6d4e-4bf3-8057-fa64c351a40f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForAllArgs, (2), CanonicalizerDirective)) .
\"urn:uuid:c9030814-b07c-4b57-b89d-e706d3ab7def"[silk#strict] .
istAsserted(CoreCycLImplementationMt, transitiveViaArg(canonicalizerDirectiveForAllArgs, genlCanonicalizerDirectives, (2))) .
\"urn:uuid:e45c3ef2-8482-48f0-839d-6776539c7ca2"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(canonicalizerDirectiveForArg, ("A #$CanonicalizerDirectivePredicate  (q.v.) used (in conjunction with a #$CanonicalizerDirective) to control the  behavior of the #$CycCanonicalizer.  (#$canonicalizerDirectiveForArg RELN  N DIRECTIVE) means that the #$CycCanonicalizer obeys DIRECTIVE when  canonicalizing the Nth argument of a #$CycLFormula whose main (or ''0th place'') operator denotes RELN.  See the instances of #$CanonicalizerDirective  for more information on how particular directives affect canonicalization. Also see #$canonicalizerDirectiveForArgAndRest and  #$canonicalizerDirectiveForAllArgs."^^_string))) .
\"urn:uuid:ec5ad2bc-d4b8-4ccb-bece-64343d4a8357"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArg, (3), CanonicalizerDirective)) .
\"urn:uuid:1ebbc290-2bb4-4014-8f40-77fa635d8ec8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArg, (1), Relation)) .
\"urn:uuid:e362d06c-c863-43d4-9353-dd01cc34f59e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArg, (2), PositiveInteger)) .
\"urn:uuid:38aea1ac-ab78-4912-be10-51c2afedb865"[silk#strict] .
istAsserted(CoreCycLImplementationMt, transitiveViaArg(canonicalizerDirectiveForArg, genlCanonicalizerDirectives, (3))) .
\"urn:uuid:d54993ef-e0ef-4e12-9caf-df8467675f58"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(canonicalizerDirectiveForArgAndRest, ("A  #$CanonicalizerDirectivePredicate (q.v.) used (in conjunction with a  #$CanonicalizerDirective) to control the behavior of the #$CycCanonicalizer. (#$canonicalizerDirectiveForArgAndRest RELN N DIRECTIVE) means that  the #$CycCanonicalizer obeys DIRECTIVE when canonicalizing the Nth and subsequent (i.e. (N+1)th, (N+2)th, ...) arguments of any #$CycLFormula  whose main (or ''0th place'') operator denotes RELN.  See the instances  of #$CanonicalizerDirective for more information on how particular  directives affect canonicalization.  Also see #$canonicalizerDirectiveForArg and #$canonicalizerDirectiveForAllArgs."^^_string))) .
\"urn:uuid:dc3b445c-a427-4f88-8b71-0420216146c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArgAndRest, (3), CanonicalizerDirective)) .
\"urn:uuid:d1b575a6-9871-46b0-aac0-eca44d60e67b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArgAndRest, (1), Relation)) .
\"urn:uuid:d9a30af6-2f4b-47d8-8434-eb36116f1bce"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(canonicalizerDirectiveForArgAndRest, (2), PositiveInteger)) .
\"urn:uuid:12f8efd5-f9c0-455a-b732-37c727035056"[silk#strict] .
istAsserted(CoreCycLImplementationMt, transitiveViaArg(canonicalizerDirectiveForArgAndRest, genlCanonicalizerDirectives, (3))) .
\"urn:uuid:cc60bc05-865c-40c8-8414-8ea3a33721c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(chooseTerm)) .
\"urn:uuid:5d341987-6f78-43bf-93a8-4c6660ca0355"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(chooseTerm, ("(#$chooseTerm TERM) is true for any closed Cyc TERM, and indicates that TERM has been chosen from the set of terms in the universe of discourse.  This predicate is primarily used as a pragmatic hint that a variable should become bound as soon as possible in order to maximally assist inference progress.  There should never be methods for generating bindings for non-closed #$chooseTerm literals.  See also the related #$termChosen."^^_string))) .
\"urn:uuid:9fa10233-962d-4bca-9e5a-4a5b9cb6f376"[silk#strict] .
istAsserted(BaseKB, notAssertible(chooseTerm)) .
\"urn:uuid:069a210a-f64b-430a-b034-7b54a0f9256f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(chooseTerm, (1), Thing)) .
\"urn:uuid:b84ecbc0-5989-4c2c-a807-0fdde1a926d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(chooseTerm)) .
\"urn:uuid:401bb4a1-6f18-4a81-bd76-37203f79443a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(chooseTerm)) .
\"urn:uuid:fcfb1030-abef-462d-9b8d-8559bb2d0aac"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(coExtensional, ("A #$TaxonomicSlotForCollections (q.v.) that holds between collections whose extents (see #$extent) are exactly the same. (#$coExtensional COL1 COL2) means that COL1 and COL2 have all their elements in common: every instance of (see #$isa) one is an instance of the other.  Note that since collections (see #$Collection), unlike mathematical sets (see #$Set-Mathematical), are ''intensionally defined'', two collections can be coextensional without thereby being identical (see #$equals).  See also \n#$coextensionalSetOrCollections."^^_string))) .
\"urn:uuid:a0c25a84-7c35-4c9b-95e3-abe591d9c6c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(coExtensional, (2), Thing)) .
\"urn:uuid:75083f32-73a3-4568-925c-b2c4ec27eaca"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(coExtensional, (1), Thing)) .
\"urn:uuid:1acb4770-b324-487d-866a-338c141f2547"[silk#strict] .
istAsserted(BaseKB, argIsa(coExtensional, (2), Collection)) .
\"urn:uuid:d0b8ccae-b9f3-45c1-954e-1aa1e69bc582"[silk#strict] .
istAsserted(BaseKB, argIsa(coExtensional, (1), Collection)) .
\"urn:uuid:41b33368-f6dc-40f9-944b-3cc9a8c61a22"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(coExtensional, (1), Collection)) .
\"urn:uuid:f459ef34-e4c3-47d0-a0b7-4b7f5db913ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(coExtensional, (2), Collection)) .
\"urn:uuid:394bb551-6506-4d37-bb37-98000823291a"[silk#strict] .
istAsserted(BaseKB, fanOutArg(coExtensional, (1))) .
\"urn:uuid:6a30c836-fd09-4b5d-9d1a-57cbd8a49617"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionBackchainEncouraged, ("<p>\n(#$collectionBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(#$isa <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(#$isa <anything> COLLECTION),\n<p>\nand rules that conclude\n<p>\n(#$genls <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(#$genls <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled. Note that it will not necessarily use rules of the form\n<p>\n([#$isa|#$genls] <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n([#$isa|#$genls] <anything> SPEC), where (#$genls SPEC COLLECTION).\n<p>\nSee also #$backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:2fdd553d-b44a-4355-b0fa-d6361882bdfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionBackchainEncouraged, (1), Thing)) .
\"urn:uuid:c64163de-ade2-4b34-8774-5bb8fee98a09"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionBackchainEncouraged, (1), Collection)) .
\"urn:uuid:0729f08f-96e2-46bc-94f3-4bcb4bf4bf5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(collectionBackchainEncouraged)) .
\"urn:uuid:c6626d56-d407-4405-aa1b-9a129d3575ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(collectionBackchainEncouraged)) .
\"urn:uuid:e35513f4-8429-41c7-b1d6-01e379a1b2c0"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionBackchainEncouraged, Collection)) .
\"urn:uuid:642b9abe-17b4-4c34-9c08-f52f6a933ac4"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionBackchainEncouraged, isa)) .
\"urn:uuid:fcbea41b-8943-4b00-ab1d-23a9ba53159a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionBackchainRequired, ("<code>(#$collectionBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(#$isa <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(#$isa <anything> COLLECTION)</code>\n<p>\nand rules that conclude\n<p>\n<code>(#$genls <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(#$genls <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  See also #$backchainRequired for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:cf7d5d35-9d3e-4847-9e25-8643ab779877"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionBackchainRequired, isa)) .
\"urn:uuid:3c46e17a-4b69-4b0c-ac6a-6860045f873c"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionBackchainRequired, Collection)) .
\"urn:uuid:a8da9dfb-5c1b-4ebf-998d-b51534665131"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionBackchainRequired, (1), Thing)) .
\"urn:uuid:de5db49e-b9f5-4910-a06e-9dde42dfc6b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionBackchainRequired, (1), Collection)) .
\"urn:uuid:7a2fdc3d-0091-4c7e-8922-400c190910ef"[silk#strict] .
istAsserted(CoreCycLMt, comment(collectionCompletelyEnumerableViaBackchain, ("A unary #$InferenceCompletenessPredicate.  <code>(#$collectionCompletelyEnumerableViaBackchain COL)</code> means that the #$CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code> by appeal to isa consequent rules.  For example, in certain medical domain microtheories, #$MazeProcedure-SurgicalProcedure is collectionCompletelyEnumerableViaBackchain because backchaining on its single rule is sufficient to generate all the relevant instances in those microtheories."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(collectionCompletelyEnumerableViaBackchain, ("collectionCompletelyEnumerableViaBackchains"^^_string))) .
\"urn:uuid:b069004b-c58c-43d9-8f05-34606e515642"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionCompletelyEnumerableViaBackchain, (1), Thing)) .
\"urn:uuid:4dd06503-3234-47ad-b369-e723f84feb4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionCompletelyEnumerableViaBackchain, (1), Collection)) .
\"urn:uuid:aecf612b-f7dd-4756-846e-2b6464a90049"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionConventionMt, ("(#$collectionConventionMt COL MT) means that assertions of the form (#$isa INS COL), for any INS, are by convention asserted in MT."^^_string))) .
\"urn:uuid:d76fec66-0816-4eaa-90a9-ccc4b0afd442"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllInstance(collectionConventionMt, AtemporalNecessarilyEssentialCollectionType, UniversalVocabularyMt)) .
\"urn:uuid:7d8a8a42-0063-49b1-8063-6cd1259970ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionConventionMt, (1), Thing)) .
\"urn:uuid:6c6e5b78-7df5-4fe4-831f-9bce25a4056c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionConventionMt, (1), Collection)) .
\"urn:uuid:15a3fd51-0687-4ce8-908b-5c82ee710887"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionConventionMt, (2), Microtheory)) .
\"urn:uuid:9ed9d698-2228-449f-8b88-2b4b905f8f10"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(collectionConventionMt, singleEntryFormatInArgs)) .
\"urn:uuid:f767f3ff-7117-48b0-b5d5-2ed71e1a0aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionExpansion, ("(#$collectionExpansion COL FORMULA) states that membership\nof a term in the collection COL is equivalent to FORMULA involving\nthat term being true.  The meta-variable :ARG1 is used to stand for\nthe term in FORMULA, and the meta-variable :ARG2 is used to stand for\nthe collection in FORMULA."^^_string))) .
\"urn:uuid:9138c89f-c3d1-477b-93f3-9685cc6c5fbf"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(collectionExpansion, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:0eda273f-c2e8-4ed6-84ce-ad3dd358c222"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(collectionExpansion, (2), AllowGenericArgVariables)) .
\"urn:uuid:019d92f4-1a1a-4bae-9c05-a136a54b0cf0"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(collectionExpansion, (2))) .
\"urn:uuid:b4b9e8cc-f37e-4b22-9364-4eaf5f3cb9bc"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, argIsa(collectionExpansion, (2), Thing)) .
\"urn:uuid:923d2cfa-e2d4-4723-b543-e27fb25305a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionExpansion, (1), Collection)) .
\"urn:uuid:14cf6845-9ed7-4c24-8aad-9e03a7d3e17a"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(collectionExpansion, Thing, Thing, (1))) .
\"urn:uuid:22f79b17-e437-4b5f-8f96-46b84d0f3812"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, argQuotedIsa(collectionExpansion, (2), CycLExpression)) .
\"urn:uuid:114fc8ce-3cb6-4077-b150-aa260495f9eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(collectionExpansion, (2))) .
\"urn:uuid:a370dfeb-1a6c-4b43-b676-5cf43ff8560b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionGenlsBackchainEncouraged, ("<p>\n(#$collectionGenlsBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(#$genls <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(#$genls <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  Note that it will not necessarily use rules of the form\n<p>\n(#$genls <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n(#$genls <anything> SPEC),\n<p>\nwhere (#$genls SPEC COLLECTION).\n<p>\nSee also #$backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:d3d8a719-818b-4b65-bdf3-8cb03875bf5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionGenlsBackchainEncouraged, (1), Thing)) .
\"urn:uuid:c0146a67-66ce-4e74-992b-38ee5cd2594c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionGenlsBackchainEncouraged, (1), Collection)) .
\"urn:uuid:1bf140a5-e95a-4c0f-8f65-495c311185af"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(collectionGenlsBackchainEncouraged)) .
\"urn:uuid:eec35fc6-53c6-43a6-8d24-06ec1c05fd41"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(collectionGenlsBackchainEncouraged)) .
\"urn:uuid:d8563386-9af1-454b-a045-1f9d43a858a3"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionGenlsBackchainEncouraged, isa)) .
\"urn:uuid:a53e286b-2f78-42f9-b5db-97a61cb81e8d"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionGenlsBackchainEncouraged, Collection)) .
\"urn:uuid:15af7914-3386-4f25-9839-110e86791bea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionGenlsBackchainRequired, (1), Collection)) .
\"urn:uuid:1bc8c485-2bc1-4273-adc9-d52e948fd86a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionGenlsBackchainRequired, (1), Thing)) .
\"urn:uuid:a042699f-3050-4fb5-91f4-c1ab5548ef07"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(collectionGenlsBackchainRequired)) .
\"urn:uuid:6992c683-bf9d-4544-ab7a-5cf8ec79f292"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(collectionGenlsBackchainRequired)) .
\"urn:uuid:95bb1c7f-22c2-4e02-a2f2-003ce72ca9b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionGenlsBackchainRequired, ("<code>(#$collectionGenlsBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(#$genls <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(#$genls <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled. See also #$backchainRequired for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:ed6c1532-d988-489d-bc97-f86baef8fb9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionIsaBackchainEncouraged, ("<p>\n(#$collectionIsaBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(#$isa <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(#$isa <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  Note that it will not necessarily use rules of the form\n<p>\n(#$isa <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n(#$isa <anything> SPEC),\n<p>\nwhere (#$genls SPEC COLLECTION).\n<p>\nSee also #$backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:acb6defb-ea98-433a-8143-3bdba5ad1498"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionIsaBackchainEncouraged, (1), Thing)) .
\"urn:uuid:bcd725f2-7a83-4b10-ba78-48d82790d796"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionIsaBackchainEncouraged, (1), Collection)) .
\"urn:uuid:c7f0e939-6dc6-44f4-b3fc-12e504f6ab20"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(collectionIsaBackchainEncouraged)) .
\"urn:uuid:576ede03-4b62-4a72-b5e3-acd6e559359e"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(collectionIsaBackchainEncouraged)) .
\"urn:uuid:8cd1c9b7-755b-415f-a380-6767d4102796"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionIsaBackchainEncouraged, isa)) .
\"urn:uuid:0acfb168-aecb-4303-bb55-c51e7536f666"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(collectionIsaBackchainEncouraged, Collection)) .
\"urn:uuid:0e22f0c4-22b8-4b86-82f6-0b5e4d1176e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(collectionIsaBackchainRequired, ("<code>(#$collectionIsaBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(#$isa <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(#$isa <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  See also #$backchainRequired for the analogue of this predicate applicable to predicates rather than collections."^^_string))) .
\"urn:uuid:61b85dc2-fe96-43f2-a429-6905f5e6755f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(collectionIsaBackchainRequired)) .
\"urn:uuid:3ac8e8f2-6fd2-4c4b-ad1e-d02f00863a54"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(collectionIsaBackchainRequired)) .
\"urn:uuid:743068ae-c7f0-4670-911a-3cddfce4a45e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(collectionIsaBackchainRequired, (1), Thing)) .
\"urn:uuid:7f25b9d1-52f1-4ba1-a1a9-8e70c11e6252"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(collectionIsaBackchainRequired, (1), Collection)) .
\"urn:uuid:bef78993-42a2-4053-bbf2-e0e0ba3ff095"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(comment, ("A #$DocumentationPredicate (q.v.) that is used to relate a #$CycLIndexedTerm (usually a #$CycLConstant) to a #$SubLString containing an English explanation of the term's meaning and use, as an aid to humans (whether #$Cyclists or not) browsing the Cyc Knowledge Base.  <code>(#$comment TERM STRING)</code> means that <code>STRING</code> is a piece of Cyc documentation that explains the meaning and use of <code>TERM</code>.  For example, the passage you are reading now is the comment for the CycL constant `#$comment'.  See also #$cyclistNotes."^^_string))) .
\"urn:uuid:8acf110e-4bc1-4867-87ae-676bb85f49a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(comment, (1), Thing)) .
\"urn:uuid:4a79a585-70b4-4744-bf29-917f6b5e21b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(comment, (2), CharacterString)) .
\"urn:uuid:4ca202d4-0e58-4637-a543-e31d5b96bb51"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(comment, SetTheFormat)) .
\"urn:uuid:3d53279a-7c89-4a6a-a662-83a781a6c99c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(comment, SetTheFormat)) .
\"urn:uuid:3fab4876-17bc-4ebe-bd1d-a1efb51f3319"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(comment)) .
\"urn:uuid:8a7a1258-b964-4594-8b4f-929706c8211c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(comment, (1), CycLIndexedTerm)) .
\"urn:uuid:d4ed52ff-0a45-4f59-8955-4f9fac57671e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(comment, (2), SubLString)) .
\"urn:uuid:84289b0f-f9b9-4a1e-bc4a-0d9107950b17"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(comment, (1))) .
\"urn:uuid:f4a9c403-4850-4529-82ea-190ff87632fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(comment, (2))) .
istAsserted(BookkeepingMt, oldConstantName(comment, ("english"^^_string))) .
\"urn:uuid:b922ff34-5dc3-4ef3-b627-032de0fdd1b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(comment)) .
\"urn:uuid:98832ede-5c2c-466c-8d3d-08a5706f780c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(commutativeInArgs, ("A variable-arity #$MetaRelation used for stating that a given #$PartiallyCommutativeRelation (q.v.) is ''commutative'' with respect to two or more specified argument-places.\n<p>\n<code>(#$commutativeInArgs RELN ARGNUM-1 ... ARGNUM-N)</code> means that  <code>RELN</code> is commutative in its <code>ARGNUM-1</code>th, ..., and <code>ARGNUM-N</code>th arguments.  Thus <code>RELN</code> admits unrestricted permutation among  these arguments.  More precisely: (i) if <code>RELN</code> is a #$Predicate that  holds of a given argument-sequence <code>SEQ</code>, then <code>RELN</code> also holds of any other sequence <code>SEQ-PERMUTE</code> obtainable from <code>SEQ</code> by permuting some or all of <code>SEQ</code>'s <code>ARGNUM-1</code>th, ..., and <code>ARGNUM-N</code>th items (while leaving all of <code>SEQ</code>'s other items unchanged).  (ii) if <code>RELN</code> is a #$Function-Denotational that associates a given argument-sequence <code>SEQ</code> with the value <code>VALUE</code>, then <code>RELN</code> also associates any sequence <code>SEQ-PERMUTE</code> (as described above) with <code>VALUE</code>.\n<p>\nFor example, <code>(#$commutativeInArgs #$formsBorderBetween 2 3)</code> has as a consequence that whenever a sentence of the form <code>(#$formsBorderBetween BORDER REG1 REG2)</code> holds, so does the corresponding sentence  <code>(#$formsBorderBetween BORDER REG2 REG1)</code>.\n<p>\nIf <code>RELN</code> is commutative in at least two argument-places it is an #$AtLeastPartiallyCommutativeRelation.  If <code>RELN</code> is commutative in <i>all</i> argument-places it is, more specifically, a #$CommutativeRelation.  If <code>RELN</code> is commutative in at least two, but <i> not all</i>,\nargument-places it is, instead, a #$PartiallyCommutativeRelation.\n<p>\nNote that the fact that each argument-place of a given relation commutes with some other argument-place is not sufficient for its being fully commutative.  For example, a partially-commutative quaternary relation might be such that its first and third places commute with each other and its second and fourth places commute with each other."^^_string))) .
\"urn:uuid:cc974989-7cad-4abb-b6f6-90499be4eaf3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(commutativeInArgs, (3), PositiveInteger)) .
\"urn:uuid:a12f9717-9f0d-486b-adc8-6f01e1ddb22b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(commutativeInArgs, (2), PositiveInteger)) .
\"urn:uuid:b776b810-cd56-4ac4-baac-3f3792feaaab"[silk#strict] .
istAsserted(BookkeepingMt, oldConstantName(commutativeInArgs, ("symmetricInArgs"^^_string))) .
\"urn:uuid:7fc871c1-bb94-472c-ab6a-b9269142a59c"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (4), (5))) .
\"urn:uuid:891306b5-605e-42b4-83b9-16b001e75384"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (3), (5))) .
\"urn:uuid:00d37b7e-95de-40fd-93e3-671c337edda3"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (3), (4))) .
\"urn:uuid:ccc7738f-2c07-4b65-93d8-f3eb988a4279"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (2), (5))) .
\"urn:uuid:a08fd204-775e-4009-ba31-6ab3b6917b43"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (2), (4))) .
\"urn:uuid:69c3cf09-ddd5-4ef3-b57f-b18535890387"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(commutativeInArgs, (2), (3))) .
\"urn:uuid:0108b739-433a-4445-9641-dfad7befa36a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argAndRestIsa(commutativeInArgs, (2), PositiveInteger)) .
\"urn:uuid:4d84818f-98d5-4233-a181-062b0a5f5a48"[silk#strict] .
istAsserted(BaseKB, commutativeInArgsAndRest(commutativeInArgs, (2))) .
\"urn:uuid:8d742fc1-f3f3-45b9-802f-5acbffcf41d7"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(commutativeInArgs, CommutativeRelation)) .
\"urn:uuid:f92ca092-9a2b-4f02-9962-7ffeb345d5e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(commutativeInArgsAndRest, ("A variable-arity #$MetaRelation used for \nstating that a given #$PartiallyCommutativeRelation (q.v.) is ''commutative'' \nwith respect to two or more argument-places, including all argument-places that \ncome after the ordinally highest one that is explicitly specified.  \n(#$commutativeInArgsAndRest RELN ARGNUM-1 ARGNUM-2 ... ARGNUM-N) means that \nRELN is commutative in its ARGNUM-1th, ARGNUM-2th, ..., and ARGNUM-Nth \narguments-places, along with any of its argument-places whose ordinal positions \nare greater than the greatest of the ARGNUM-i.  Thus RELN admits unrestricted \npermutation among any of these arguments.  More precisely (and assuming without \nloss of generality that ARGNUM-N is the numerically greatest of the ARGNUM-i):  \n(i) if RELN is a #$Predicate that holds of a given argument-sequence SEQ, then \nRELN also holds of any other sequence SEQ-PERMUTE obtainable from SEQ by \npermuting some or all of SEQ's ARGNUM-1th, ARGNUM-2th, ..., ARGNUM-Nth, and \nsubsequent items (while leaving all of SEQ's other items unchanged).  \n(ii) if RELN is a #$Function-Denotational that associates a given \nargument-sequence SEQ with the value VALUE, then RELN also associates any \nsequence SEQ-PERMUTE (as described above) with VALUE.  For example, \n(#$commutativeInArgsAndRest #$commutativeInArgsAndRest 2) \nhas as a consequence that whenever a sentence of the form \n(#$commutativeInArgsAndRest RELN 2 3 5) holds, so do the corresponding \nsentences (#$commutativeInArgsAndRest RELN 2 5 3), \n(#$commutativeInArgsAndRest RELN 3 2 5), and so on.  Note that since RELN \nis an instance of #$PartiallyCommutativeRelation, it must have at \nleast two argument-places that are commutative with each other and at \nleast one that is _not_ commutative with any other argument-place.  See\nalso #$commutativeInArgs."^^_string))) .
\"urn:uuid:81b32bbe-fde5-4b99-800c-fbd9ff3e5a44"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(commutativeInArgsAndRest, (1), PartiallyCommutativeRelation)) .
\"urn:uuid:0f818396-3519-4d28-a418-6931685476a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(commutativeInArgsAndRest, (2), PositiveInteger)) .
\"urn:uuid:5e82ee81-5602-4bdf-9a20-4ae941979564"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(commutativeInArgsAndRest, singleEntryFormatInArgs)) .
\"urn:uuid:f6b064ae-19ea-4eda-bfe2-aa13cc6cc297"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(commutativeInArgsAndRest, openEntryFormatInArgs)) .
\"urn:uuid:b56aeea2-5bbf-4834-8e4a-f7dced4a05f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argAndRestIsa(commutativeInArgsAndRest, (2), PositiveInteger)) .
\"urn:uuid:b8e59f7a-5a5a-45cc-b958-2b34ca52a62a"[silk#strict] .
istAsserted(BaseKB, commutativeInArgsAndRest(commutativeInArgsAndRest, (2))) .
\"urn:uuid:1dee0f7b-eb8d-4534-8c84-a23625279449"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentAsserted, ("A unary #$InferenceCompletenessPredicate and a specialization of #$completeExtentEnumerable (q.v.) that applies to predicates whose entire extents are explicitly asserted in the Cyc Knowledge Base.  <code>(#$completeExtentAsserted PRED)</code> means that, for every sequence <code><THING1,..., THING<sub>N</sub>></code> that satisfies <code>PRED</code>, <code>(PRED THING1 ... THING<sub>N</sub>)</code> is asserted in the Knowledge Base.  That is, for each such sequence, there are reified CycL terms <code>PRED-NAME</code>, <code>TERM1</code>, ..., <code>TERM<sub>N</sub></code> -- which denote <code>PRED</code>, <code>THING1</code>, ..., <code>THING<sub>N</sub></code>, respectively -- such that the sentence <code>(PRED-NAME TERM1 ... TERM<sub>N</sub>)</code> built from those terms is an assertion in the KB.\n<p>\nIf #$completeExtentAsserted is true of <code>PRED</code>, then the #$CycInferenceEngine, when asked a query of the form <code>(PRED <b>. VARS</b>)</code>, can return a complete set of bindings for the variables in <code>VARS</code> simply via a lookup of assertions in the KB.  By a ''complete set of bindings'' is meant a set of sequences of terms such that, for each sequence <code><THING1, ..., THING<sub>N</sub>></code> in the extent of <code>PRED</code>, there is a corresponding sequence of terms <code><TERM1, ..., TERM<sub>N</sub>></code> returned wherein each <code>TERM<sub>I</sub></code> denotes <code>THING<sub>I</sub></code> (for 1 <= <code>I</code> <= <code>N</code>).\n<p>\nFor example, (#$completeExtentAsserted #$hourOfDayIndex-24Hour) holds.  Thus, the sentence <code>(#$hourOfDayIndex-24Hour #$TimeOfDay-1AM 1)</code> is one of twenty-four similar ground-atomic sentences asserted in the KB.  Conversely, (#$completeExtentAsserted #$argN) does <i>not</i> hold.  Thus, while the Inference Engine could generate the set of all true <code>#$argN</code> based ground-atomic sentences (i.e. #$completeExtentEnumerable holds of #$argN), the members of this set are not all asserted in the KB.\n<p>\nSee also #$completelyAssertedCollection, which applies to collections rather than predicates."^^_string))) .
\"urn:uuid:59e44174-8bd4-4a69-8445-6ff8d8ae4211"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(completeExtentAsserted, openEntryFormatInArgs)) .
\"urn:uuid:d1fb3f72-b9b4-4c3e-bf64-8ebffb1face1"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(completeExtentAsserted, (1))) .
\"urn:uuid:bbbba260-37b6-45cc-a5f4-ba0d16f08cfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentAsserted, (1), Predicate)) .
\"urn:uuid:71c7a62e-947e-427c-b391-70bc87973f2d"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentAssertedForValueInArg, ("A ternary #$InferenceCompletenessPredicate and a specialization of #$completeExtentEnumerableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  (#$completeExtentAssertedForValueInArg PRED VALUE N) means that for every sequence of arguments that PRED holds of and whose Nth member is VALUE, there is an explicit assertion to that effect in the Cyc Knowledge Base.  Thus, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine -- simply via lookup of assertions in the KB -- can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence SEQ in PRED's extension whose Nth member is VALUE (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting VALUE.\n<p>\nFor example, (#$completeExtentAssertedForValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, as all the members of the International Monetary Fund are asserted to be such in the KB.\n<p>\nIf PRED's extent is completely asserted for VALUE in the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not (PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable ''unique name assumption'' might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of something in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  The KB contains the assertion '(#$cityInState #$CityOfDallasTX #$Texas-State)'; but it might nevertheless fail to contain the equally true sentence '(#$cityInState #$CityOfDallasTX (StateOfResidenceFn #$Pace))'.\n<p>\nSee also #$completeExtentAsserted."^^_string))) .
\"urn:uuid:593337a0-8aba-4eef-b7a3-f97e1847a13d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentAssertedForValueInArg, (3), NonNegativeInteger)) .
\"urn:uuid:13735f2f-6be7-4205-8fd2-092e6cece1b3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentAssertedForValueInArg, (2), Thing)) .
\"urn:uuid:e9de9e29-dc97-4c97-a875-9c306a1f76f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentAssertedForValueInArg, (1), Predicate)) .
\"urn:uuid:740b626f-eaeb-4a50-831e-ac5b4c47dc41"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentDecidable, ("A unary #$InferenceCompletenessPredicate (q.v.) that applies to predicates.  <code>(#$completeExtentDecidable PRED)</code> means that the #$CycInferenceEngine can determine if any given sequence of things is in the extent of <code>PRED</code> (see #$relationExtension and #$relationHoldsAmong).  More precisely: for any given n-length sequence <code>SEQ</code> among which <code>PRED</code> holds (and for nothing else), there are CycL terms <code>TERM<sub>1</sub></code>, ..., <code>TERM<sub>N</sub></code> that denote the respective items in <code>SEQ</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code>, will return the answer <code>#$True<code>.\n<p>\nFor example, <code>(#$completeExtentDecidable #$integerBetween)</code> holds, as the Inference engine can correctly determine if any given triple of integers is such that the second member is numerically between the first and third.  Conversely, the extent of #$likesAsFriend is not decidable, as many of the friendships in the world are beyond Cyc's ken.\n<p>\nIf <code>PRED</code>'s extent is completely decidable and there are CycL terms <code>TERM<sub>1</sub>, ..., TERM<sub>N</sub></code> such that the sentence <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code> is semantically well-formed but <i>not</i> provable by the Inference Engine, that fact consitutes a strong argument for the truth of its negation <code>(#$not (PRED TERM<sub>1</sub> ... TERM<sub>1</sub>))</code>.  But note that it is not a conclusive argument: the normally-reliable ''unique name assumption'' might fail here, and some <code>TERM<sub>I</sub></code> could conceivably denote something that Cyc can prove to be a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(#$integerBetween 1 2 3)</code>; but it might nevertheless fail to prove the equally true sentence\n<pre>\n  (#$integerBetween 1 2 (FavoriteNumberOfFn #$Pace)) .\n</pre>\nSee also the more specific predicates #$completeExtentEnumerable and #$completeExtentAsserted.  And see #$completelyDecidableCollection."^^_string))) .
\"urn:uuid:fd30228d-7c15-44b5-b049-7a070812985e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(completeExtentDecidable, openEntryFormatInArgs)) .
\"urn:uuid:ecaaa51b-cb31-45ea-8245-cb6ac640dea7"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(completeExtentDecidable, (1))) .
\"urn:uuid:081b7816-e2b1-475c-b62f-c868974a9767"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentDecidable, (1), Predicate)) .
\"urn:uuid:7dbd3ceb-4ac3-45a2-9b89-9ae44047d1e1"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentDecidableForValueInArg, ("(#$completeExtentDecidableForValueInArg PRED VALUE ARGNUM) means that when the            #$CycInferenceEngine                                                                                 is asked a closed query of the form (PRED ... VALUE ...) where VALUE appears in the                  ARGNUMth position, either it can prove (PRED ... VALUE ...) without transformation,                  or (#$not (PRED ... VALUE ...)) is true."^^_string))) .
\"urn:uuid:8b033fed-984e-4447-b1a4-e1e928d28965"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentDecidableForValueInArg, (1), Predicate)) .
\"urn:uuid:bb789f0f-033c-4214-aad4-f9b518b0eb9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentDecidableForValueInArg, (3), NonNegativeInteger)) .
\"urn:uuid:980e4cb2-ad48-407c-adf7-73f7444f0365"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentDecidableForValueInArg, (2), Thing)) .
\"urn:uuid:45617473-8c77-492e-8b6e-391499a17783"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentEnumerable, ("A unary #$InferenceCompletenessPredicate and a specialization of #$completeExtentDecidable and #$minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by the #$CycInferenceEngine.  <code>(#$completeExtentEnumerable PRED)</code> means that the Inference Engine can, without using transformations, generate a list of all of (and only) the sequences of things among which <code>PRED</code> holds (see #$relationExtension and #$relationHoldsAmong).\n<p>\nFor example, (#$completeExtentEnumerable #$assertedSentence) holds, as the Inference Engine could, if asked, list all of the assertions in the Knowledge Base.  Conversely, although the Inference engine could correctly determine if any given CycL sentence is in the extent of #$knownSentence (i.e #$completeExtentDecidable holds of #$knownSentence), it could not generate a list of all CycL sentences in the extent of #$knownSentence.\n<p>\nThe practical import of #$completeExtentEnumerable can be stated more precisely as follows.  Let's say that an N-length sequence of terms ''pointwise-denotes'' an N-length sequence of things just in case each term in the former denotes the corresponding item in the latter.  Suppose <code>(#$completeExtentEnumerable PRED)</code> holds.  If <code>PRED</code> is a #$FixedArityRelation of arity N and <code>VAR1...VARN</code> are N distinct #$CycLVariables, then, given a query of the form <code>(PRED VAR1 ... VARN)</code>, the Inference Engine can, without the use of Transformation Modules, return a list of N-length sequences of terms -- each sequence consisting of bindings for the respective variables <code>VAR1-VARN</code> -- such that every sequence in <code>PRED</code>'s extent (and nothing else) is pointwise-denoted by some term-sequence on the list.   If <code>PRED</code> is a #$VariableArityRelation, it is the same, except the given query should then have the form <code>(PRED . VARS)</code>, and there might be no constant length N shared by all of the term-sequences in the returned list.\n<p>\nIf <code>PRED</code>'s extent is completely enumerable and a given term-sequence <code><TERM-1, ..., TERM-N></code> is <i>not</i> in the list returned for the above query, that fact consitutes a <i>strong argument</i> for the truth of the negation <code>(#$not (PRED TERM-1 ... TERM-N))</code>, assuming that it's semantically well-formed.  But note that it is <i>not a conclusive argument</i>: the normally-reliable ''unique name assumption'' might fail here, and some term <code>TERM-I</code> could conceivably denote something that Cyc can prove to be a member of something in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace was also denoted by the (imaginary) CycL term <code>ErasmusCAnderson</code>, but Cyc did not know that #$Pace and Erasmus C. Anderson are the same person.  Cyc will return the term-sequence <<code>#$Pace, #$GeneralCycKE</code>> for the query <code>(#$cyclistPrimaryProject ?X ?Y)</code>; but it might nevertheless <i>fail</i> to return the sequence <<code>ErasmusCAnderson, #$GeneralCycKE</code>>, even though the sentence\n<pre>\n  (#$cyclistPrimaryProject ErasmusCAnderson #$GeneralCycKE)\n</pre>\nwas in fact true."^^_string))) .
\"urn:uuid:1ca77f08-9585-4caf-b318-d4b390ac9272"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(completeExtentEnumerable, (1))) .
\"urn:uuid:ed8a8573-2a37-4e33-b3bc-c5826e9bf700"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerable, (1), Predicate)) .
istAsserted(EnglishParaphraseMt, genFormat(completeExtentEnumerable, ("the complete extent of the predicate ~a is known"^^_string), [[(1), MetaVariableFn(("EQUALS"^^_string))]])) .
istAsserted(BookkeepingMt, oldConstantName(completeExtentEnumerable, ("completeExtentKnown"^^_string))) .
\"urn:uuid:6e452d48-9e3a-462f-a564-d997139fbf97"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(completeExtentEnumerable, openEntryFormatInArgs)) .
\"urn:uuid:20ab785b-a987-44d8-a469-b35fb605c0ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableForArg, (2), NonNegativeInteger)) .
\"urn:uuid:5c279569-651a-45e5-b345-73aeb20fb693"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableForArg, (1), Predicate)) .
\"urn:uuid:4ed726d9-d54d-4157-b978-9eaaf4aefdf1"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentEnumerableForArg, ("A binary #$InferenceCompletenessPredicate (q.v.) that can apply to a predicate and a specified argument-place.  (#$completeExtentEnumerableForArg PRED N) means that, for any given thing ARGN, the #$CycInferenceEngine can enumerate every sequence in the extent of PRED whose Nth item is ARGN (see #$relationExtension and #$relationHoldsAmong).  In practical terms this means that, if asked a query of the form (PRED ... ARGN ...), where all of PRED's argument-places save the Nth are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for the other (i.e. non-Nth) arguments.  That is, for every sequence SEQ in PRED's extension whose Nth member is ARGN (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting ARGN.\n<p>\nFor example, (#$completeExtentEnumerableForArg #$cityInState 1) holds: given any city, Cyc can return a list of all the states (i.e. the one state, if any) in which it is located.\n<p>\nIf PRED's extent is completely enumerable for the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not (PRED TERM1 ... TERM(N-1) ARGN TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable ''unique name assumption'' might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of a sequence in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding '#$Texas-State' for the query '(#$cityInState #$CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn #$Pace)'.\n<p>\nSee also #$completeExtentEnumerable and #$completeExtentEnumerableForValueInArg)."^^_string))) .
\"urn:uuid:4fc9ad3c-6db9-4682-8a49-70a272d2aefb"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentEnumerableForArg, ("(#$completeExtentEnumerableForArg PRED ARGNUM) means that when the #$CycInferenceEngine   is asked a query of the form (PRED ... ARG ...) where ARG is any closed term in the                  ARGNUMth position, it can completely enumerate all possible bindings for the other argument          positions.                                                                                           This means that for any arguments (PRED ... NOT-ARGi ... ARG ... NOT-ARGj) for which the             NOT-ARGs are not a member of the enumerated bindings,                                                (#$not (PRED ... NOT-ARGi ... ARG ... NOT-ARGj)) is true."^^_string))) .
\"urn:uuid:72df8cfb-7a88-4134-9092-735e07c6f0d2"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentEnumerableForValueInArg, ("A ternary #$InferenceCompletenessPredicate and a specialization of #$completeExtentDecidableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  <code>(#$completeExtentEnumerableForValueInArg PRED VALUE N)</code> means that the #$CycInferenceEngine can enumerate every sequence in the extent of <code>PRED</code> whose <code>N</code>th item is <code>VALUE</code>.  In practical terms this means that, if asked a query of the form <code>(PRED ... VALUE ...)</code>, where <code>VALUE</code> appears in the <code>N</code>th argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence <code>SEQ</code> in <code>PRED</code>'s extension whose <code>N</code>th member is <code>VALUE</code> (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of <code>SEQ</code> excepting <code>VALUE</code>.\n<p>\nFor example, (#$completeExtentEnumerableForValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, as Cyc can enumerate all the members of the International Monetary Fund.\n<p>\nIf PRED's extent is completely enumerable for <code>VALUE</code> in the <code>N</code>th argument and a given sequence of bindings <<code>TERM1</code>, ..., <code>TERM(N-1)</code>, <code>TERM(N+1)</code>, ...> (whose length matches the arity of <code>PRED</code>, if fixed) is <i>not</i> returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not <code>(PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...))</code>.  But note that it is not a conclusive argument: the normally-reliable ''unique name assumption'' might fail here, and a term <code>TERM</code>i could conceivably denote something that Cyc can prove a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding '#$Texas-State' for the query '(#$cityInState #$CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn #$Pace)'.\n<p>\nSee also the specialization #$completeExtentAssertedForValueInArg and see #$completeExtentEnumerableForArg."^^_string))) .
\"urn:uuid:9f27a3f9-f183-440b-9c64-c1868ccad627"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableForValueInArg, (3), PositiveInteger)) .
\"urn:uuid:f05afe7b-4406-43e6-86ea-c37be111bb39"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableForValueInArg, (1), Predicate)) .
\"urn:uuid:6b6b310b-21a9-4d8c-9c53-09fa600c5b59"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableForValueInArg, (2), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(completeExtentEnumerableForValueInArg, ("completeExtentKnownForArg"^^_string))) .
\"urn:uuid:781fd2ee-0a81-41dd-ad78-c32124749fda"[silk#strict] .
istAsserted(CoreCycLMt, comment(completeExtentEnumerableViaBackchain, ("A unary #$InferenceCompletenessPredicate and a specialization of  #$minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by reference to the transformation rules currently asserted on it.  For example, #$surgicalIncisionEmployed is #$completeExtentEnumerableViaBackchain in the context of certain medical domain microtheories because the pair of rules on it are sufficient to completely generate its entire extent within those microtheories."^^_string))) .
\"urn:uuid:26aa6693-cec7-4e1d-8c99-b79a3465d822"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completeExtentEnumerableViaBackchain, (1), Predicate)) .
\"urn:uuid:8ab87d71-fe0c-4522-bad1-77e6dfe2339a"[silk#strict] .
istAsserted(CoreCycLMt, comment(completelyDecidableCollection, ("A unary #$InferenceCompletenessPredicate (q.v.) that applies to collections.  <code>(#$completelyDecidableCollection COL)</code> means that the #$CycInferenceEngine can determine if any given thing is an instance of <code>COL</code>.  More precisely: for any given instance <code>INST</code> whatsoever (and for no non-instances) of <code>COL</code>, there is a CycL term <code>INST-TERM</code> that denotes <code>INST</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(#$isa INST-TERM COL)</code>, will return the answer <code>#$True</code>.\n<p>\nFor example, the collection #$Integer is completely decidable. Given any integer <code>INT</code>, the Cyc query <code>(#$isa INT #$Integer)</code> -- wherein <code>INT</code> is given its standard base-10 arabic numeral representation -- will come back <code>#$True</code>.\n<p>\nIf <code>COL</code> is completely decidable and Cyc fails to return <code>#$True</code> for some query <code>(#$isa TERM COL)</code>, that fact consitutes a strong argument for the truth of its negation <code>(#$not (#$isa TERM COL))</code>.  But note that it is not a conclusive argument: the normally-reliable ''unique name assumption'' might fail here, and the term <code>TERM</code> could conceivably denote something that Cyc can prove to be an instance of <code>COL</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(#$isa 3 #$Integer)</code>; but it might nevertheless fail to prove the equally true sentence\n<pre>\n  (#$isa (<b>FavoriteNumberOfFn</b> #$Pace) #$Integer) .\n</pre>\nSee also the more specific predicates #$completelyEnumerableCollection and #$completelyAssertedCollection.  And see #$completeExtentDecidable, which applies to #$Predicates."^^_string))) .
\"urn:uuid:0b97a384-43ec-4ac3-837a-8072ab02029e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(completelyDecidableCollection, (1), Thing)) .
\"urn:uuid:e4b55d3b-4fbb-4501-bce0-43869cc41208"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(completelyDecidableCollection, (1))) .
\"urn:uuid:b1c59478-1607-43ab-bd46-d3826eced524"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completelyDecidableCollection, (1), Collection)) .
\"urn:uuid:86eda20a-bfb9-4b72-954d-4cd032a24ff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(completelyDecidableCollection, openEntryFormatInArgs)) .
\"urn:uuid:f45a8413-0353-4ed2-8147-5b4917a139f5"[silk#strict] .
istAsserted(CoreCycLMt, comment(completelyEnumerableCollection, ("A unary #$InferenceCompletenessPredicate that is a specialization of #$completelyDecidableCollection (qq.v.).  <code>(#$completelyEnumerableCollection COL)</code> means that the #$CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code>.  More precisely: given a query of the form <code>(#$isa VAR COL)</code>, the Inference Engine can (without using transformations) return a list of terms -- bindings for the variable <code>VAR</code> -- such that every instance (and no non-instance) of the collection <code>COL</code> is denoted by some binding on the list.\n<p>\nFor example, #$SkolemFunction is a completely enumerable collection.  (But note that #$SkolemFunction does <i>not</i> satisfy the more specialized #$completelyAssertedCollection (q.v.), as most of its instances are only asserted to be instances of one of its specializations, such as #$FixedAritySkolemFunction.)\n<p>\nSee also #$completeExtentEnumerable, which applies to #$Predicates."^^_string))) .
\"urn:uuid:23be9290-a1ed-43d0-ab7a-550a7ad77188"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(completelyEnumerableCollection, (1))) .
\"urn:uuid:73cd5b4e-79f6-4f9c-a110-96029a905aa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(completelyEnumerableCollection, (1), Thing)) .
\"urn:uuid:ce7600f7-82c8-441c-8258-a2afaed9049a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(completelyEnumerableCollection, (1), Collection)) .
istAsserted(BookkeepingMt, oldConstantName(completelyEnumerableCollection, ("completeCollectionExtent"^^_string))) .
\"urn:uuid:dfccca9b-49fe-4681-97be-78d5dddb9944"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(completelyEnumerableCollection, openEntryFormatInArgs)) .
\"urn:uuid:a9f6f4ca-a849-4210-a10a-0239d69ac00a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(conceptuallyRelated, ("This predicate is used to state the fact of a conceptual link between two things, where a very complex sentence would be required in order to describe the precise nature of this link explicitly.  Examples of such conceptually-linked couples include #$PublicTransportationDevice / #$PublicTransportationScheduleDocument and #$Dog / #$DogFood.  The rationale for having such a predicate as #$conceptuallyRelated is similar to that behind many #$RuleMacroPredicates (q.v.).  Having complex relationships represented -- possibly redundantly -- in a more compact fashion makes for faster retrieval. Because things can be conceptually related in many different ways, no explicit definition for this predicate is provided.  Note that #$conceptuallyRelated is _not_ a #$SymmetricBinaryPredicate (q.v.); but see #$conceptuallyCoRelated for a specialization of this predicate that is symmetric."^^_string))) .
\"urn:uuid:982a8527-7395-4413-bf5b-a5efe62f6fd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(conceptuallyRelated, (2), Thing)) .
\"urn:uuid:b88e973e-4e6c-48bc-b481-329c9c3bde06"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(conceptuallyRelated, (1), Thing)) .
\"urn:uuid:7781b34f-5156-4a67-b15e-7bf485422e9c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(conceptuallyRelated, SetTheFormat)) .
\"urn:uuid:67e811e9-4444-4623-b89e-5baf63e2709b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(conceptuallyRelated, SetTheFormat)) .
\"urn:uuid:c2af9c09-f54b-4c6a-81ed-9b729821471c"[silk#strict] .
istAsserted(UniversalVocabularyMt, opaqueArgument(conceptuallyRelated, (2))) .
\"urn:uuid:b983a5de-401a-4134-9327-f858f3393b23"[silk#strict] .
istAsserted(UniversalVocabularyMt, opaqueArgument(conceptuallyRelated, (1))) .
\"urn:uuid:f7de81f3-0940-4579-8cb8-de9aba1a2c81"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(conceptuallyRelated)) .
\"urn:uuid:ede85ca0-99d3-45c2-910f-f2bf92e226e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForArg(conceptuallyRelated, (1))) .
istAsserted(BookkeepingMt, oldConstantName(conceptuallyRelated, ("mysteryLink"^^_string))) .
\"urn:uuid:14370ceb-5176-4293-99d2-cd63d2723bbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(conceptuallyRelated)) .
\"urn:uuid:7c5ce408-d125-41a1-9267-2a0805de5d43"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(conceptuallyRelated, isa)) .
\"urn:uuid:710dfc25-5cd8-484f-94d8-fa9124abf22b"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(conceptuallyRelated, genls)) .
\"urn:uuid:633d1659-56c2-48f3-b516-5a650c9fb8b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(conceptuallyRelated, genls)) .
\"urn:uuid:c2c5db17-4118-4f58-91a7-9c127adfba14"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(consistent)) .
\"urn:uuid:bf3cec6d-9533-4403-a0b5-cc29494d352f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(consistent, ("A predicate which asserts of sentences that they do not contradict currently known facts. (#$consistent SENTENCE) means that the #$CycLSentence-Assertible SENTENCE is consistent with assertions known in the current context.  Consequently, (#$consistent SENTENCE) holds in a #$Microtheory MT just in case, for any assertion ASSERT that holds in MT, SENTENCE does not imply the negation of ASSERT.  Note that this predicate is #$notAssertible. See also #$inconsistentWithMt."^^_string))) .
\"urn:uuid:0cf39232-b2d9-4283-b5ae-efd56bd16b25"[silk#strict] .
istAsserted(BaseKB, notAssertible(consistent)) .
\"urn:uuid:ad1c30e0-965e-4def-8783-e50f5f995559"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(consistent)) .
\"urn:uuid:93d6596e-6f02-4515-8fd0-04714dfa2672"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(consistent, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:8172f50c-72bd-4c43-b810-e9259a249750"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(consistent, (1))) .
\"urn:uuid:4bbfb5fb-673d-4152-b250-141b3cd13dbe"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(constantGUID, ("A strictly functional slot used to associate CycL constants with the GUID strings they are assigned. <code>(#$constantGUID CONSTANT GUID-STR)</code> means that the #$CycLConstant <code>CONSTANT</code> is associated with the #$GUIDString <code>GUID-STR</code>.  The arg1 position of this predicate is ''quoted'', so, for example, (#$constantGUID #$Dog  ''bd58daa0-9c29-11b1-9dad-c379636f7270'') means that the constant ''#$Dog'' itself, not the collection of dogs, is associated with the #$GUIDString ''bd58daa0-9c29-11b1-9dad-c379636f7270''."^^_string))) .
\"urn:uuid:bae4e0d9-782e-41e5-b56f-dd31a4f258ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(constantGUID)) .
\"urn:uuid:7b6db913-166a-4274-9adc-4a932d12987e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constantGUID, (1), Thing)) .
\"urn:uuid:f7723968-3f60-4056-93c0-e2fac14ddb0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(constantGUID, SingleEntry)) .
\"urn:uuid:0e2cbda4-d2ae-44ed-81db-37a3701f8b4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(constantGUID, singleEntryFormatInArgs)) .
\"urn:uuid:bf30dc23-78b8-4f95-bacc-4c417eb72e47"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(constantGUID)) .
\"urn:uuid:fefb221f-1dd2-49d7-ba45-129e56b2a246"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(constantGUID, (1), CycLConstant)) .
\"urn:uuid:2f20f322-9961-4f8a-96d8-eeba329e7ee5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(constantGUID, (1))) .
\"urn:uuid:5ac2a487-d8d7-413d-b589-06e05d27956e"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(constantGUID, (2))) .
\"urn:uuid:25d0b73a-640c-45da-ab80-5c021bc39424"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(constantGUID, (1))) .
\"urn:uuid:899d1cbc-033f-4cf1-8700-41c73bddb6b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(constantGUID, Thing, Thing, (1))) .
\"urn:uuid:0022881a-5450-4e4d-8282-9ca4e887125f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(constantGUID)) .
\"urn:uuid:9e58d7e4-5a14-46d8-ad50-94775c6e6373"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(constantGUID)) .
\"urn:uuid:d9e95ac4-9980-4230-b8c8-2dd36089fd4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(constantID, ("A predicate which relates each Cyc constant to an internal identification number for it. This number is unique within any given image, though not necessarily across images (for that, see #$constantGUID). <code>(#$constantID CONSTANT ID)</code> states that the #$NonNegativeInteger <code>ID</code> is the unique internal id for the #$CycLConstant <code>CONSTANT</code> (in the current image). For obvious reasons, this predicate is #$notAssertible."^^_string))) .
\"urn:uuid:b8f29954-a987-44db-be49-28159d58a8c8"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(constantID, (2))) .
\"urn:uuid:2a4b67e2-625b-4a1f-9ef0-cfdf00419e82"[silk#strict] .
istAsserted(BaseKB, notAssertible(constantID)) .
\"urn:uuid:e0434afe-e05c-4c46-8e9b-764e60e2aeac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constantID, (1), Thing)) .
\"urn:uuid:0fa2274b-4ca9-464f-becd-b8837089051f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constantID, (2), NonNegativeInteger)) .
\"urn:uuid:d8dfe71d-8015-4966-ab03-9d5214ac5317"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(constantID, Thing, Thing, (1))) .
\"urn:uuid:9109b1f1-deb4-4a72-9de8-a0e2cf268369"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(constantID, SingleEntry)) .
\"urn:uuid:b763d09d-bfe0-4492-8a66-159718342ba5"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(constantID)) .
\"urn:uuid:8499b91a-4472-4ff3-b1de-1b57b31de1ef"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(constantID)) .
\"urn:uuid:835ea73e-126d-4ccb-8ff8-7f87bd60651c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(constantID, SingleEntry)) .
\"urn:uuid:0abf12ca-b82a-4c88-b43b-a37f0fd4b3e7"[silk#strict] .
istAsserted(BaseKB, relationAllExists(constantID, CycLConstant, NonNegativeInteger)) .
\"urn:uuid:dae55348-7751-46e7-b620-645899bff300"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(constantID)) .
\"urn:uuid:3c4060da-3d4e-479d-9951-a9b6ec102ace"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(constantID, (1), CycLConstant)) .
\"urn:uuid:d1c65615-49e1-4305-b214-94bb2bd3cba6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(constantID, (1))) .
\"urn:uuid:ebfbb3a8-3b2a-4793-a9f6-3c0b49e8936a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(constantName, ("(#$constantName CONSTANT STRING) means that the #$SubLString STRING is the ''name'' for the #$CycLConstant CONSTANT.  That is, STRING is the string of characters that make up CONSTANT, minus the initial ''#'' and the following ''$''."^^_string))) .
\"urn:uuid:671f2622-b291-4ee0-b4ae-5c391680836b"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(constantName, (2))) .
\"urn:uuid:4e34cdb8-6978-4c9c-8ecb-1b15fbf8fe13"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(constantName, (1))) .
\"urn:uuid:d1bc35ff-2c76-47c4-bcf3-071afc7f7eb4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constantName, (1), Thing)) .
\"urn:uuid:4ec7aae4-57c6-4b12-bb8d-05ed22bc775f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constantName, (2), CharacterString)) .
\"urn:uuid:d58cc824-884a-41fc-8c53-7cbf4ea65ab5"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(constantName, Thing, Thing, (1))) .
\"urn:uuid:c673e7fa-ce8a-4880-8f9c-1598def10426"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(constantName, singleEntryFormatInArgs)) .
\"urn:uuid:26c1b905-7452-4424-af27-2923276f6858"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(constantName, SingleEntry)) .
\"urn:uuid:9f0e441e-751f-4d67-8593-44496f419a2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(constantName)) .
\"urn:uuid:8efdbe53-c199-4855-8838-6b77b523b1ac"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(constantName)) .
\"urn:uuid:bd1561c9-e7d9-4f6e-9e6e-19401632cedb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(constantName, singleEntryFormatInArgs)) .
\"urn:uuid:b015fd9c-ca81-45c0-9646-ae15ebb05558"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(constantName)) .
\"urn:uuid:37f176ab-d6ad-4ac0-badd-249a400e3f53"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(constantName, (1), CycLConstant)) .
\"urn:uuid:15247c61-20c4-4cee-9e26-b8471071b4bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(constantName, (2), SubLString)) .
\"urn:uuid:b9d6dd62-d4ee-43c2-aeb6-f419d259a626"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(constantName, (1))) .
\"urn:uuid:d656f3d4-0a36-4e86-87b2-e6c998565196"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(constantName, (2))) .
\"urn:uuid:28386e58-c394-4d09-9074-1c35c13911dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(constrainsArg, ("A #$MetaRelation predicate for stating that a given meta-relation is used to put an argument-type or format constraint (see e.g. #$ArgConstraintPredicate) on a given argument-place of a relation. (#$constrainsArg METARELN N) means that METARELN is always used to put a constraint on a relation's Nth argument-place.  For example, (#$constrainsArg #$arg2Isa 2) holds.  A slight deviation from the above occurs when N is 0: we take (#$constrainsArg METARELN 0) to mean that METARELN is used to constrain _all_ of a relation's argument-places; see e.g. #$argsIsa and #$argsGenl."^^_string))) .
\"urn:uuid:f54849f1-b074-4e10-9190-b877d4b6ac1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(constrainsArg, (2), NonNegativeInteger)) .
\"urn:uuid:6763f969-1d03-43f2-bda4-60d0a0276274"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(constrainsArg, SetTheFormat)) .
\"urn:uuid:79e25573-749f-4642-99af-4b5fd368a977"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(constrainsArg, SetTheFormat)) .
\"urn:uuid:65504d34-1368-43c2-b9ae-d649fe97696b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(constraint, ("(#$constraint RULE) labels a given RULE assertion as a constraint.  Constraints are typically used to verify that a given logical expectation is already true, rather than to deduce (and then add) a new formula which would satisfy the expectation.  In other words, if a rule (#$implies P(?X) Q(?X)) is labelled as a #$constraint, then when P(?X) is determined to be true, we verify that Q(?X) is already true rather than add a new argument for Q(?X) using the rule and P(?X) as justification."^^_string))) .
\"urn:uuid:086b0b65-a999-473b-b663-cf757ee05359"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(constraint, (1), CycLAssertion)) .
\"urn:uuid:72f4f51b-a53a-451b-84c9-d160a58882da"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(constraint, (1))) .
\"urn:uuid:22638ee1-04ee-4e13-8fcb-5870c6af034e"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycInferenceAnswerLink, (1))) .
\"urn:uuid:c5088aa3-4cda-4065-a5b0-099563c2dec5"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycInferenceAnswerLink, (2))) .
\"urn:uuid:bef45c16-a6b2-455e-9d0d-867fd567299e"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycInferenceAnswerLink, (2))) .
\"urn:uuid:749b8453-8636-47c1-8a60-3d751b233c3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycInferenceAnswerLink, (1))) .
\"urn:uuid:198d29a5-f490-4941-84a3-265a4dc774b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycInferenceAnswerLink, (1), CycInference)) .
\"urn:uuid:60e8aad0-dbff-4851-8413-63d4a594a1af"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycInferenceAnswerLink, (2), 'CycProblemLink-AnswerLink')) .
\"urn:uuid:38946992-19fe-4212-a210-aae8511d0e6b"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycInferenceAnswerLink, Thing, Thing, (1))) .
\"urn:uuid:e2b607bf-4d77-41bf-879c-b293a2c7aecb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycInferenceAnswerLink, singleEntryFormatInArgs)) .
\"urn:uuid:b23ce336-7835-4044-b3ab-a0180a90c00b"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycInferenceAnswerLink)) .
\"urn:uuid:62781a8b-a705-47ff-a081-03ef0b50af71"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(cycInferenceAnswerLink, singleEntryFormatInArgs)) .
\"urn:uuid:0ce9a4ac-9c75-4c3b-82b1-c36d0a14347b"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycInferenceRelevantProblems)) .
\"urn:uuid:78a0730a-8e31-4c5e-9870-6313e90aa5ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycInferenceRelevantProblems, SetTheFormat)) .
\"urn:uuid:8e8fc8df-bd8c-440f-a8c3-31f2822ca21f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycInferenceRelevantProblems, (2), CycProblem)) .
\"urn:uuid:2b99b420-31ee-49d9-9ed6-8e175c4349b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycInferenceRelevantProblems, (1), CycInference)) .
\"urn:uuid:662f64d0-331a-4535-9c61-8322c113d417"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemArgumentLinks)) .
\"urn:uuid:43a478a5-6f07-412a-af19-b7871de1e031"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemArgumentLinks, (1), CycProblem)) .
\"urn:uuid:eb55e646-e47a-4392-bc07-e0617d135020"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemArgumentLinks, (2), CycProblemLink)) .
\"urn:uuid:de219174-7599-4d8c-b262-0ec713ecb5e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemArgumentLinks, SetTheFormat)) .
\"urn:uuid:b3076015-e5d9-4e38-a061-08d22e5e01b7"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemDependentLinks)) .
\"urn:uuid:8e76ce9f-2e47-46b9-9de5-0c59fd43ab2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemDependentLinks, (2), CycProblemLink)) .
\"urn:uuid:63dd0430-05da-4dc4-92f6-44b8699c8dac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemDependentLinks, (1), CycProblem)) .
\"urn:uuid:a745706a-0ae8-4a8d-b1b4-af6d5a83a24d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemDependentLinks, SetTheFormat)) .
\"urn:uuid:45a9173d-97be-4003-a85d-97e8a3436b33"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemID)) .
\"urn:uuid:80e2192a-1f2f-43f4-bb5e-70f607997f60"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemID, (3))) .
\"urn:uuid:b7f116df-e48a-4d4e-bbc3-98c5d1a9fbc0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemID, (2), CycProblemStore)) .
\"urn:uuid:c729665c-9294-450d-a195-cd7c30666bc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemID, (3), NonNegativeInteger)) .
\"urn:uuid:97a6970f-4557-4e21-9a21-46d430cd8661"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemID, (1), CycProblem)) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemID, ("the inference problem ~a contained within inference problem store ~a, has ~a as its ID"^^_string), [[(1), MetaVariableFn(("SINGULAR"^^_string))], [(2), MetaVariableFn(("SINGULAR"^^_string))]])) .
\"urn:uuid:65856180-9c44-41e8-8703-20970a1e047b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(cycProblemID, singleEntryFormatInArgs)) .
\"urn:uuid:df6ff40e-3b5b-47b3-abef-001c44ce6bfd"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemLinkID)) .
\"urn:uuid:1ba192b0-9aa8-45aa-86b9-6842284fbe0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemLinkID, (3))) .
\"urn:uuid:b4916d03-f9dc-4693-83fe-b0586a948df2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemLinkID, (3), NonNegativeInteger)) .
\"urn:uuid:87c9be86-d2fc-485f-a78c-48b2035a77ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemLinkID, (1), CycProblemLink)) .
\"urn:uuid:3d659430-d8ee-47a3-bdb5-3f01857e8aaa"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemLinkID, (2), CycProblemStore)) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemLinkID, ("the inference problem link ~a contained within inference problem store ~a, has ~a as its ID"^^_string), [[(1), MetaVariableFn(("SINGULAR"^^_string))], [(2), MetaVariableFn(("SINGULAR"^^_string))]])) .
\"urn:uuid:2a5afc0d-4341-420a-9c01-d8ff1cbd346c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(cycProblemLinkID, singleEntryFormatInArgs)) .
\"urn:uuid:198176df-ef3f-4582-bbf2-30f011c68f7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(cycProblemProvabilityStatus, (2), CycProvabilityStatus)) .
\"urn:uuid:a1e71400-5b97-4a55-aded-6f3047115a08"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemProvabilityStatus, (2))) .
\"urn:uuid:4c884bc6-0e60-42f5-8a49-8b16ea88751f"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemProvabilityStatus, (2))) .
\"urn:uuid:5f95b103-d811-4c40-8ebd-c8c8c949bb7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemProvabilityStatus, (2), Collection)) .
\"urn:uuid:38fa5108-797a-403d-bbeb-786dd2c05663"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemProvabilityStatus, (1), CycProblem)) .
\"urn:uuid:b0320af0-b681-49ba-8e48-a3d709a7ecd0"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemProvabilityStatus, Thing, Thing, (1))) .
\"urn:uuid:a6284ff3-4266-4feb-9cb3-ddcde71f8094"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemProvabilityStatus, singleEntryFormatInArgs)) .
\"urn:uuid:89bc049d-6f8a-40f3-ac97-cc013dccf257"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemProvabilityStatus)) .
\"urn:uuid:c77faeaa-f2c1-44e8-9d71-198cfc23187a"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemProvabilityStatus)) .
\"urn:uuid:4306f1cd-4ca6-4962-a31e-c01d8af44fff"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemProvabilityStatus)) .
\"urn:uuid:540130b0-795f-40ed-933a-1bfbfd11cf87"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemQuerySentence, (2))) .
\"urn:uuid:653a6561-2de4-443c-9482-7182f23d30bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemQuerySentence, (2))) .
\"urn:uuid:e1d398fe-9440-4e1a-aa16-fd2c86d7ff07"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemQuerySentence, (1), CycProblem)) .
\"urn:uuid:5cac080f-72e6-4ead-9dde-a49cb8aec4e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemQuerySentence, Thing, Thing, (1))) .
\"urn:uuid:434bc56f-8633-41b2-9764-4c239ff8ebfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemQuerySentence, singleEntryFormatInArgs)) .
\"urn:uuid:1db10c25-8359-43b5-b450-aed608916b00"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemQuerySentence)) .
\"urn:uuid:c7aae0c4-83fa-43e7-bb56-0213f2c136fc"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemQuerySentence)) .
\"urn:uuid:08724946-d894-4058-8e74-6f717fa58bf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemQuerySentence)) .
\"urn:uuid:7b23ee96-0da4-4c7a-af50-71f86e9f8a58"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cycProblemQuerySentence, (2), 'CycLSentence-Askable')) .
\"urn:uuid:4c5b4852-42fb-4146-8418-3803624ce10f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cycProblemQuerySentence, (2))) .
\"urn:uuid:f74d0e53-8a35-4d58-8588-49ceef2c8b24"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemQueryTerms)) .
\"urn:uuid:d34741ae-5ff6-4ffe-b48b-bf964cdb68df"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemQueryTerms)) .
\"urn:uuid:e74fed6a-5c33-4962-924f-a3f2204d8ad7"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemQueryTerms)) .
\"urn:uuid:cc75b925-9977-426b-9622-17e0d21ecefc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemQueryTerms, SetTheFormat)) .
\"urn:uuid:eafe782d-92f5-44c2-888b-86335ef73393"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cycProblemQueryTerms, (2), CycLClosedDenotationalTerm)) .
\"urn:uuid:b520838a-d653-4f94-b37f-7cf0c30fc02c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cycProblemQueryTerms, (2))) .
\"urn:uuid:65caf9ed-d971-4660-b2e6-42ebbd235289"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemQueryTerms, (2), Thing)) .
\"urn:uuid:f643d1d2-f53b-4284-a792-91b73428448e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemQueryTerms, (1), CycProblem)) .
\"urn:uuid:38f2ad0f-dd42-45b0-9486-ce2ae953f37e"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemStoreID, (2))) .
\"urn:uuid:cc1aaf9b-e729-460e-baa9-3b88561812f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemStoreID, (2))) .
\"urn:uuid:b38d89e7-a2f7-422f-853c-f74d91ac16c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreID, (1), CycProblemStore)) .
\"urn:uuid:07ea6df7-e1a2-406f-8866-18a33244f052"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreID, (2), NonNegativeInteger)) .
\"urn:uuid:1eb26d74-e98a-424d-bf94-4a9057307f7a"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemStoreID, Thing, Thing, (1))) .
\"urn:uuid:fc7d90b3-022d-4de7-b413-76f94755a988"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreID, singleEntryFormatInArgs)) .
\"urn:uuid:a616ce28-cfee-47de-b46a-67e4fd9052a7"[silk#strict] .
istAsserted(BaseKB, fanOutArg(cycProblemStoreID, (2))) .
\"urn:uuid:0d5aa586-49c2-4eec-a316-2db8f8f54742"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreID)) .
\"urn:uuid:1a9d9986-8561-472f-a3d5-41568c5cf051"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExists(cycProblemStoreID, CycProblemStore, NonNegativeInteger)) .
\"urn:uuid:992e24ec-c1b3-4469-b86a-62087307f622"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemStoreInferenceCount, (2))) .
\"urn:uuid:c5d974c8-7027-4c77-b79a-a9d1928ebe77"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemStoreInferenceCount, (2))) .
\"urn:uuid:6065bcfa-bb25-40b0-90fd-169a49d19a2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreInferenceCount, (1), CycProblemStore)) .
\"urn:uuid:6aa4b3f6-a236-4501-a4b2-ee0042b78762"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreInferenceCount, (2), NonNegativeInteger)) .
\"urn:uuid:3c95b55d-f066-49f9-9bfd-873265ef628a"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemStoreInferenceCount, Thing, Thing, (1))) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemStoreInferenceCount, ("the inference problem store ~a has ~a inference~a"^^_string), [(1), (2), [(""^^_string), ("s"^^_string)]])) .
\"urn:uuid:8fef89dd-ca0a-430c-8982-39a70fb836d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreInferenceCount, singleEntryFormatInArgs)) .
\"urn:uuid:e8fdfb57-519d-4973-a151-0bf0da7c0f8f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreInferenceCount)) .
\"urn:uuid:a06d5335-9141-4fa5-8fd9-bc0a141d0b32"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreInferenceCount)) .
\"urn:uuid:31d6fb58-ac87-49f3-a5bc-18219c8b3b1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreInferenceCount)) .
\"urn:uuid:6917ee39-8f3e-424d-91da-4a370b6565e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreInferences, (1), CycProblemStore)) .
\"urn:uuid:ea3195d4-c409-434b-aa61-94fd28f3a89c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreInferences, (2), CycInference)) .
\"urn:uuid:8372b4f7-0a72-4bc4-aad3-8c4bfa306da5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreInferences, SetTheFormat)) .
\"urn:uuid:41ba4b6d-a046-43d6-ae21-ae7847f2e39d"[silk#strict] .
istAsserted(BaseKB, fanOutArg(cycProblemStoreInferences, (2))) .
\"urn:uuid:287fccc1-a002-415f-a39c-1593f05fa9f4"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreInferences)) .
\"urn:uuid:e4308f61-bbe2-4e2d-b59e-df9eebcd33d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExists(cycProblemStoreInferences, CycProblemStore, CycInference)) .
\"urn:uuid:7b4953d9-edf5-44ec-a928-919143211691"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemStoreLinkCount, (2))) .
\"urn:uuid:689893fc-70a7-4e68-927e-2748107410af"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemStoreLinkCount, (2))) .
\"urn:uuid:0e1a10f5-1a2c-494d-9acd-820e23af3c0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreLinkCount, (2), NonNegativeInteger)) .
\"urn:uuid:164e07d3-3466-4392-973d-402b83624720"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreLinkCount, (1), CycProblemStore)) .
\"urn:uuid:f7f8d905-3db6-4129-882b-65e864091587"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemStoreLinkCount, Thing, Thing, (1))) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemStoreLinkCount, ("the inference problem store ~a has ~a inference link~a"^^_string), [(1), (2), [(""^^_string), ("s"^^_string)]])) .
\"urn:uuid:d9d31b98-50d0-4b05-ad76-6f288510de7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreLinkCount, singleEntryFormatInArgs)) .
\"urn:uuid:69a0c388-1ab7-4107-95c1-67bb77d68c4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreLinkCount)) .
\"urn:uuid:bd08da9f-6310-494c-ab23-dae0aa599756"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreLinkCount)) .
\"urn:uuid:41a4a4a5-8940-48d5-99cb-8486572140dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreLinkCount)) .
\"urn:uuid:9384536a-e816-47de-9747-28bee4dfa4d3"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreLinks)) .
\"urn:uuid:c86f91e6-21ae-4e75-9f6e-a58c5e10216a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreLinks, (2), CycProblemLink)) .
\"urn:uuid:82e4e189-4cb7-44d7-a277-818ed0301148"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreLinks, (1), CycProblemStore)) .
\"urn:uuid:b43c1d83-4aa7-4f9c-877e-f2817cc663f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreLinks, SetTheFormat)) .
\"urn:uuid:0655f052-a08c-41cf-934b-57f6cda54159"[silk#strict] .
istAsserted(BaseKB, fanOutArg(cycProblemStoreLinks, (2))) .
\"urn:uuid:f0ccd56d-854c-444d-a1fc-2dd879ca03d6"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemStoreProblemCount, (2))) .
\"urn:uuid:6cbe7129-7107-4c4d-860e-eacdace67f04"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemStoreProblemCount, (2))) .
\"urn:uuid:00cc4f6b-9985-4878-bb45-80549528a368"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProblemCount, (1), CycProblemStore)) .
\"urn:uuid:5395dd4d-dc5b-48e9-a8c7-7ac88a1cb6a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProblemCount, (2), NonNegativeInteger)) .
\"urn:uuid:c25670bd-dd6a-47b9-82b2-baf83701cba2"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemStoreProblemCount, Thing, Thing, (1))) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemStoreProblemCount, ("the inference problem store ~a has ~a inference problem~a"^^_string), [(1), (2), [(""^^_string), ("s"^^_string)]])) .
\"urn:uuid:20fc12a2-face-4fd3-8c9e-0bfb5afee0c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreProblemCount, singleEntryFormatInArgs)) .
\"urn:uuid:f8df21de-d3b5-4ea6-b160-45b0b4431803"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreProblemCount)) .
\"urn:uuid:78ea4c28-3466-4e25-a339-c6b44e59d28c"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreProblemCount)) .
\"urn:uuid:de54b264-43a6-4939-8fc8-57d8c5cbbb34"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreProblemCount)) .
\"urn:uuid:acdfec4f-2fe6-491f-8304-e368974d7cc2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProblems, (2), CycProblem)) .
\"urn:uuid:34a8f243-9e93-4962-b352-d202dc80b86c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProblems, (1), CycProblemStore)) .
\"urn:uuid:db6cbaae-9b81-4534-b39c-226da882c118"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreProblems)) .
\"urn:uuid:39880bdd-7bb1-4363-9bf7-0ae698e0622a"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreProblems)) .
\"urn:uuid:05ac3deb-63bc-4ca7-a67e-b0324995185f"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreProblems)) .
\"urn:uuid:35cd9f33-3110-4d29-adb8-2dcff340bcc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreProblems, SetTheFormat)) .
\"urn:uuid:61ea78ad-40a2-4d52-bcc9-16a2142b4f59"[silk#strict] .
istAsserted(BaseKB, fanOutArg(cycProblemStoreProblems, (2))) .
\"urn:uuid:17dc2934-c7b6-443f-927e-e42664bccb58"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(cycProblemStoreProofCount, (2))) .
\"urn:uuid:e7d16c94-e2c2-4595-887b-8d6e57fe4bd2"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProblemStoreProofCount, (2))) .
\"urn:uuid:95948ae5-c888-426f-9e3d-abd62f7a0d72"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProofCount, (2), NonNegativeInteger)) .
\"urn:uuid:3021c6ca-36c4-445e-b22f-7d8a82cce81d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProofCount, (1), CycProblemStore)) .
\"urn:uuid:5f0cfeaf-3cbe-43ff-8a4d-5cac637442f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(cycProblemStoreProofCount, Thing, Thing, (1))) .
istAsserted(EnglishParaphraseMt, genFormat(cycProblemStoreProofCount, ("the inference problem store ~a has ~a proof~a"^^_string), [(1), (2), [(""^^_string), ("s"^^_string)]])) .
\"urn:uuid:2a3db9bd-a674-412f-bff7-cd3b95db1b02"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreProofCount, singleEntryFormatInArgs)) .
\"urn:uuid:752409c2-16a4-4a03-b512-44f952340168"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreProofCount)) .
\"urn:uuid:9e6be55c-9f46-4a1c-b174-fdb390f68b21"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreProofCount)) .
\"urn:uuid:6549d37d-5aec-4922-a1c8-67b8a146e0dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreProofCount)) .
\"urn:uuid:cc8011c3-bd45-4004-8267-931d3270cbc5"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreProofs)) .
\"urn:uuid:ce3f1ef6-5704-4d81-b129-34e485f2bf39"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProofs, (1), CycProblemStore)) .
\"urn:uuid:db553dd8-b163-4c50-98c8-e161dbc601f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreProofs, (2), CycProof)) .
\"urn:uuid:9249296a-a991-459e-b816-22033a15184a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreProofs, SetTheFormat)) .
\"urn:uuid:8db07bbf-22fe-4357-bb52-2926769d98d7"[silk#strict] .
istAsserted(BaseKB, fanOutArg(cycProblemStoreProofs, (2))) .
\"urn:uuid:39a9286f-f902-4931-bee7-71be9aa67d8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycProblemStoreTerms)) .
\"urn:uuid:690b8f8f-d413-4c45-b2cb-50963720ae14"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycProblemStoreTerms)) .
\"urn:uuid:8d829357-b0c5-4ab9-9f13-9c5b295055cf"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProblemStoreTerms)) .
\"urn:uuid:ed20ef75-f393-4de6-af5c-fc87d97f6256"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycProblemStoreTerms, SetTheFormat)) .
\"urn:uuid:1d9f131c-a62a-4955-ada8-d4f4fb9115a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cycProblemStoreTerms, (2), CycLClosedDenotationalTerm)) .
\"urn:uuid:768bbf1a-301e-4a16-8adb-a6cb8bc2a9f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cycProblemStoreTerms, (2))) .
\"urn:uuid:df153904-df96-4788-bdd4-ac03668cf9fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreTerms, (2), Thing)) .
\"urn:uuid:a97aafda-8924-4e93-bcc0-fbde4132e85c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProblemStoreTerms, (1), CycProblem)) .
\"urn:uuid:5b0d2111-914f-491f-b7f6-df2d52ddb795"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycProofID)) .
\"urn:uuid:e5a5adb8-c612-4b06-b0e5-f61ba914f6fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycProofID, (3))) .
\"urn:uuid:32408619-2d94-45e3-93fd-b914f006e9a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProofID, (3), NonNegativeInteger)) .
\"urn:uuid:cd706f15-bd35-4555-95ed-928b1a796de0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProofID, (1), CycProof)) .
\"urn:uuid:2288e051-88e4-4f0e-9331-99ffe7ce52c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycProofID, (2), CycProblemStore)) .
istAsserted(EnglishParaphraseMt, genFormat(cycProofID, ("the inference proof ~a contained within inference problem store ~a, has ~a as its ID"^^_string), [[(1), MetaVariableFn(("SINGULAR"^^_string))], [(2), MetaVariableFn(("SINGULAR"^^_string))]])) .
\"urn:uuid:6f58f080-ce95-4bf7-9148-69b2c2c1475c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(cycProofID, singleEntryFormatInArgs)) .
\"urn:uuid:0e948865-4a4c-438b-83e8-c0d694499f30"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycTacticID)) .
\"urn:uuid:7ee3fd71-972b-4fad-bfbb-ceb2da1ae653"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(cycTacticID, (3))) .
\"urn:uuid:ee85052f-0bca-401e-b956-eaa8ced8ec29"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycTacticID, (1), CycTactic)) .
\"urn:uuid:c8dbf727-20e4-4c83-ad5e-81a9e23df18b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycTacticID, (2), CycProblem)) .
\"urn:uuid:63f51a8b-be5f-486c-b80c-95a1445c7396"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycTacticID, (3), NonNegativeInteger)) .
istAsserted(EnglishParaphraseMt, genFormat(cycTacticID, ("the inference tactic ~a contained within the inference problem ~a, has ~a as its ID"^^_string), [[(1), MetaVariableFn(("SINGULAR"^^_string))], [(2), MetaVariableFn(("SINGULAR"^^_string))]])) .
\"urn:uuid:97e9fd5c-5499-46a3-b98c-454ea9836922"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(cycTacticID, singleEntryFormatInArgs)) .
\"urn:uuid:22edd06a-3550-491e-a168-11bc566071bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycTransformationProofBindings, (1), CycTransformationProof)) .
\"urn:uuid:9718d8b2-617e-4068-aa05-469ee8e0f8fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(cycTransformationProofBindings, (2))) .
\"urn:uuid:a42de134-8e9a-4bc1-8eef-1ac893d2fd19"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(cycTransformationProofBindings, ("(#$cycTransformationProofBindings TRANSFORMATION-PROOF BINDING) means that BINDING is an #$InferenceBinding (using the appropriate variable from the transformation rule for TRANSFORMATION-PROOF) proven by TRANSFORMATION-PROOF."^^_string))) .
\"urn:uuid:2396bf94-7132-412a-bf91-f6db98a238d7"[silk#strict] .
istAsserted(BaseKB, notAssertible(cycTransformationProofBindings)) .
\"urn:uuid:4f689ef7-a636-4338-950f-a1226a0a0afa"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycTransformationProofBindings)) .
\"urn:uuid:b3a3b4ac-a79d-44f7-ad44-1988d114886f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycTransformationProofBindings)) .
\"urn:uuid:3bd49ef7-c5d3-41a3-9c7b-b2b66edee661"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycTransformationProofBindings)) .
\"urn:uuid:de7f6181-f818-4bbb-a264-3d9dfe395181"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(cycTransformationProofBindings, openEntryFormatInArgs)) .
\"urn:uuid:866e8b53-a8a5-4fa0-a404-68b9cb821732"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(cycTransformationProofRule, ("(#$cycTransformationProofRule PROOF RULE) means that RULE is the rule used by PROOF to prove its proven query."^^_string))) .
\"urn:uuid:3af26d4c-03bb-484c-8a9a-89a69d39b5cf"[silk#strict] .
istAsserted(BaseKB, notAssertible(cycTransformationProofRule)) .
\"urn:uuid:edf22e31-31be-4a4d-8ea0-abe9e4e73eae"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(cycTransformationProofRule)) .
\"urn:uuid:84f93bac-7819-4579-a611-c7fa94fa5604"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(cycTransformationProofRule)) .
\"urn:uuid:2eb404c7-af6d-4158-8a07-f824bca5bc3f"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(cycTransformationProofRule)) .
\"urn:uuid:edf9c85a-9d77-4284-93ac-605c08900cc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(cycTransformationProofRule, (1), CycTransformationProof)) .
\"urn:uuid:3e541015-3467-4063-8b1c-ab07d6832702"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cycTransformationProofRule, (2), CycLRuleAssertion)) .
\"urn:uuid:a0ee5a54-16c4-4dff-84c6-4fc3d5903f27"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cycTransformationProofRule, (2))) .
\"urn:uuid:203c5631-df1d-4eb0-8641-a35c3bc7f856"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(decontextualizedCollection, ("(#$decontextualizedCollection COL) states that COL is a collection in which membership is context-independent.  In effect, any instance of COL is an instance of COL in every microtheory."^^_string))) .
\"urn:uuid:50c271b3-4c21-4268-abf4-41eae3a4f273"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(decontextualizedCollection, (1), Thing)) .
\"urn:uuid:1e69ed1d-01ff-4824-a84a-4873c73043bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(decontextualizedCollection, (1), Collection)) .
\"urn:uuid:3f5e7f8c-bc35-4bbd-99b1-2560164d0048"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAll(decontextualizedCollection, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:83f6a295-aa26-4cb5-8533-26d5c09b0709"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(decontextualizedPredicate, ("(#$decontextualizedPredicate PRED) states that PRED is a predicate which is context-independent.  In effect, any use of PRED can be lifted into any microtheory.  Predicates which are labelled with #$decontextualizedPredicate typically have an argument which either implicitly or explicitly provides the implied context.  A good example of such a predicate is #$ist."^^_string))) .
\"urn:uuid:111dde7d-a508-4428-8d35-566af334bcd0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(decontextualizedPredicate, (1), Predicate)) .
\"urn:uuid:fc0acc56-d879-4356-98ea-479aced27548"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(defaultReformulationDirectionInModeForPred, ("If the #$CycLReformulator is operating in MT in the mode MODE, and it\nencounters a reformulation rule with no #$reformulationDirectionInMode\nmeta-assertion for MODE stated in MT or a genlMt thereof, the extent of this\npredicate will be used to determine the reformulation direction of the\nrule."^^_string))) .
\"urn:uuid:8226cef6-06ab-499a-99c5-560bbff9e1b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(defaultReformulationDirectionInModeForPred, (3), ReformulatorDirectivePredicate)) .
\"urn:uuid:9015d72f-2b4b-4819-8b9b-716f2533defe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(defaultReformulationDirectionInModeForPred, SingleEntry)) .
\"urn:uuid:5b4a6586-306f-4d71-b03a-3a8265682151"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(defaultReformulatorModePrecedence, ("(#$defaultReformulatorModePrecedence PRIMARY-MODE\nSECONDARY-MODE TERTIARY-MODE ...), asserted in the microtheory MT,\nmeans that in MT or a specMt thereof (unless overridden),\nthe #$CycLReformulator will use PRIMARY-MODE as its primary mode,\nSECONDARY-MODE as its secondary mode, etc.  This helps the\nreformulator establish precedence of #$CycLReformulatorDirectives.\nDo not specify both tersify and verbosify."^^_string))) .
\"urn:uuid:9c959cbe-80e2-47e8-87e5-e0f8afa9f220"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(definingMt, ("(#$definingMt TERM MT) states that TERM only begins to have semantic meaning in microtheory MT. In microtheories in which MT is not  accessible, TERM is #$undefined. Additionally,  (#$termDependsOn TERM MT)."^^_string))) .
\"urn:uuid:fd1afb7e-5db7-4603-99c6-fb7f404c9848"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(definingMt, (1), Thing)) .
\"urn:uuid:f3046020-8c08-4fa5-94ec-9f06adaa5945"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(definingMt, (2), Microtheory)) .
\"urn:uuid:b141ce75-e293-4db7-88ff-7529072afb12"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(definingMt, SingleEntry)) .
\"urn:uuid:399a43ec-6de9-4bd7-8710-c03318074119"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(definingMt, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:17acca45-ed2a-440c-ac73-235e4818b326"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(definingMt, (1))) .
\"urn:uuid:8acc02a3-437a-4f9d-b52c-a0c22acc0306"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(definingMt, Microtheory, BaseKB)) .
\"urn:uuid:01a6aeef-c08d-417e-b7e5-48d87b4ce403"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(definingMt, (2))) .
\"urn:uuid:5bc228d6-a798-4457-9ff3-4a5391e06f0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(definingMt, Thing, Thing, (1))) .
\"urn:uuid:7e6e4947-8537-4806-ac86-631babeefcd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(defnIff, ("A #$CycInferenceDescriptorPredicate.  (#$defnIff COL TEST) means \nthat TEST is the name of a piece of code in the SubL implementation \nof Cyc that specifies, and tests for, a necessary and sufficient \ncondition for a CycL term's denoting an instance of (see #$isa) the \ncollection COL.  If and only if TEST returns `T' (for `True') when \napplied to a particular term can that term's denotatum be considered \nan instance of COL; all and only terms that denote instances of COL \nmust fulfill TEST's requirements.  See also #$defnNecessary and \n#$defnSufficient."^^_string))) .
\"urn:uuid:c9ec7eb0-4e3a-406c-ad06-190434d6b53c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(defnIff, (1), Thing)) .
\"urn:uuid:03dba5d0-0c16-4541-9090-bf795b24f1c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(defnIff, (1), Collection)) .
\"urn:uuid:0af115d9-3cb3-4b3c-bdb1-8cf870338e65"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argIsa(defnIff, (1), Collection)) .
\"urn:uuid:5385c176-0169-4a3f-8f68-241f583ff96d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(defnIff, SingleEntry)) .
\"urn:uuid:4543f477-d05e-48ca-ac72-d801bb27e5ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(defnIff, (2))) .
\"urn:uuid:7ccc53cd-4a60-426a-a0c3-2a18eebbf107"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(defnIff, (2))) .
\"urn:uuid:f1bd978e-4925-40fe-9e20-6727d7790a3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(defnIff, Thing, Thing, (1))) .
istAsserted(BookkeepingMt, oldConstantName(defnIff, ("necessaryDefn"^^_string))) .
\"urn:uuid:54b3dcbb-1d4c-492f-b5d3-dbb945b8105d"[silk#strict] .
istAsserted(BaseKB, definingMt(defnIff, BaseKB)) .
\"urn:uuid:a2a5ca34-8be7-4e40-9607-aa7d61368675"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(defnNecessary, ("A #$CycInferenceDescriptorPredicate.  \n(#$defnNecessary COL TEST) means that TEST is the name of a piece \nof code in the SubL implementation of Cyc that specifies, and tests \nfor, a necessary condition for a CycL term's denoting an instance of \n(see #$isa) the collection COL.  Only if TEST returns `T' (for \n`True') when applied to a particular term can that term's \ndenotatum be considered an instance of COL; all terms that denote \ninstances of COL must fulfill TEST's requirements, although there \nmay be additional requirements for denoting an instance of COL as \nwell.  See also #$defnSufficient and #$defnIff."^^_string))) .
\"urn:uuid:123cf30b-c7a7-4a56-83fb-5414563303ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(defnNecessary, (1), Thing)) .
\"urn:uuid:f0cc84dd-1cc0-48cc-9f1b-c105c30a1697"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(defnNecessary, (1), Collection)) .
\"urn:uuid:9f8326d2-1ebc-4404-a5f6-b7fbf0506ae0"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(defnNecessary, genls, (1))) .
\"urn:uuid:23897016-d189-46d8-b1bd-0a856bbe451d"[silk#strict] .
istAsserted(BaseKB, definingMt(defnNecessary, BaseKB)) .
\"urn:uuid:6b8908c4-53b2-442d-a7ac-9efce8e96a32"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(defnNecessary, (2))) .
\"urn:uuid:337477ca-a9b9-4d86-9919-e83348847bf1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(defnSufficient, ("A #$CycInferenceDescriptorPredicate.  (#$defnSufficient COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a sufficient condition for a CycL term's denoting an instance of (see #$isa) the collection COL.  If TEST returns `T' (for `True') when applied to a particular term, then that term's denotatum is considered to be an instance of COL.  Note that TEST isn't necessarily a necessary test for membership in COL; that is, not all instances of COL must pass the test, unless TEST is also a #$defnNecessary for COL.  See the related predicates #$defnNecessary and #$defnIff."^^_string))) .
\"urn:uuid:55a938d2-8343-4512-a564-45fc0a2a7db4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(defnSufficient, (1), Thing)) .
\"urn:uuid:e47bb606-2676-4e76-82c2-ef632a054cd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(defnSufficient, (1), Collection)) .
istAsserted(BookkeepingMt, oldConstantName(defnSufficient, ("defn"^^_string))) .
\"urn:uuid:3908a0d9-a7f2-40ea-9543-5b6016bda9a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(defnSufficient, SetTheFormat)) .
\"urn:uuid:ffa0de13-d166-4f43-8fcb-9757695b61b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(defnSufficient, SetTheFormat)) .
\"urn:uuid:0dc4a59e-b3a9-44b7-bc73-d328d34320f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(defnSufficient, genls, (1))) .
\"urn:uuid:40d3c9a2-c740-4c7f-8b8d-32a273ffab7a"[silk#strict] .
istAsserted(BaseKB, definingMt(defnSufficient, BaseKB)) .
\"urn:uuid:0b85d19f-fa8d-41ab-b783-9d7add3bd35f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(defnSufficient, (2))) .
\"urn:uuid:284d5104-4c58-49b1-8c4a-ee778054b485"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(denotes, ("A #$MetaLanguagePredicate (q.v.) that relates #$CycLDenotationalTerm to their denotata: the things in the intended model of the CycL language that those terms denote or stand for.  <code>(#$denotes TERM THING)</code> means that <code>TERM</code> denotes <code>THING</code>.  <code>TERM</code> will often be explicitly quoted, by being wrapped in the syncategorematic quotation symbol '#$Quote'.  For example, the true sentence '(#$denotes (#$Quote #$Plato) #$Plato)' means that the CycL term '#$Plato' denotes the person #$Plato.  (Thus #$denotes's first argument-place is <i>not</i> ''implicitly quoted''; cf. #$quotedArgument).\n<p>\nBut note that the first argument of #$denotes might <i>not</i> be quoted at all.  Suppose (e.g.) that the term '#$Plato' were the CycL constant most beloved of #$Cyclists, and that a new constant 'CyclistsFavoriteConstant' were reified and defined so as to reflect this fact.  Then 'CyclistsFavoriteConstant' would refer to the CycL constant '#$Plato', which in turn denotes the man Plato; and so the sentence '(#$denotes CyclistsFavoriteConstant #$Plato)' -- which involves no quotation -- would be true.\n<p>\nNote also that not all CycL terms denote, not even all #$CycLClosedDenotationalTerms (q.v.).  For example, the term '(#$BorderBetweenFn #$Canada #$Mexico)' fails to denote anything (except perhaps in certain counterfactual contexts).\n<p>\nNote finally that the sentence '(#$denotes #$Plato #$Plato)' is of course <i>not</i> true, as it means that the man Plato is a CycL term that denotes the man Plato, which is a patent falsehood since no man is a CycL term and no man denotes anything.\n<p>\nSee also #$means, #$expresses, #$hasDenotatum, #$quotedIsa, #$EscapeQuote, and the shared #$NoteAboutQuotingInCycL."^^_string))) .
\"urn:uuid:9db1b906-03cb-4298-a430-eb5342e88f9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(denotes, (1), CycLDenotationalTerm)) .
\"urn:uuid:b52bdab5-689b-4230-b4f1-45ca90c6ba57"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(denotes, (2), Thing)) .
\"urn:uuid:97ce5fdf-0447-499e-81d2-f3559ca34a0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(denotes, SingleEntry)) .
\"urn:uuid:77275ab7-f412-4e78-9ded-6b90dbaacc85"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(denotes, SetTheFormat)) .
\"urn:uuid:61522a63-bab0-453e-b6a2-d83dad392b18"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(denotes, (2))) .
\"urn:uuid:9b4ccd5c-8839-442a-9cc6-22cad4f3f88a"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(denotes, Thing, Thing, (1))) .
\"urn:uuid:4e8a1541-0f8a-4ce3-acf9-34941d449ac7"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(denotes, denotes)) .
\"urn:uuid:ff6f6406-5c47-4237-8d60-7bb4beb5bb1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(different, ("A variable-arity predicate (see #$VariableArityRelation) that is used to state the non-identity of two or more things. <code>(#$different THING1..THINGn)</code> means that for any <code>THING</code>i and <code>THING</code>j (where 0 <= i <= n, 0 <= j <= n, and i =/ j), <code>THING</code>i is not identical with <code>THING</code>j.  That is, each of <code>THING</code>1, ..., <code>THING</code>n is distinct from all of the others.  Cf. #$equals."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(different, MetaVariableFn(("DIFFERENT"^^_string)))) .
\"urn:uuid:afe4a290-aaa6-4dff-8b6a-9a6d793893ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(different, SetTheFormat)) .
\"urn:uuid:325fa8bf-d04d-4ee8-b012-7c4173094e5a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(different, SetTheFormat)) .
\"urn:uuid:bd889746-4de2-4b90-ac57-e2e15a109a26"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(different, SetTheFormat)) .
\"urn:uuid:76a30b31-e2b5-4f16-8359-d1a8f57bf137"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(different, SetTheFormat)) .
\"urn:uuid:0cbcb8ad-be56-4fd3-bc05-ee02e16e40a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Format(different, SetTheFormat)) .
\"urn:uuid:4910b7b8-f2db-4406-9e85-71bd18c3ffe1"[silk#strict] .
istAsserted(BaseKB, arg6Format(different, SetTheFormat)) .
\"urn:uuid:a7c5e784-bdb3-4c23-9e03-6a64d25d7c04"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(different)) .
\"urn:uuid:2f1628df-837c-4329-b042-c114ed0ffd2a"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(different, SubLSymbolFn(("CYC-DIFFERENT"^^_string)))) .
\"urn:uuid:434a91c7-52cd-439b-8991-a60a1d2740df"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(differentSymbols)) .
\"urn:uuid:7d52090c-fd07-4598-9aa7-42bb41e46bb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(differentSymbols, ("This variable-arity predicate (see #$VariableArityRelation), all of whose argument-places are #$quotedArguments (q.v.), is used to make non-identity statements about two or more symbols. Stated loosely, (#$differentSymbols X1 X2 ... Xn) means that each of the Xi is a symbol that is different from all of the others.  Given that the arguments are ''quoted'', however, it is more accurate to say: A ground atomic formula (or ''GAF''; see #$CycLClosedAtomicSentence) consisting of the expression `#$differentSymbols' followed by the CycL expressions E1, ..., En (all enclosed within a pair of parentheses) is true if and only if each Ei is a different expression from all of the others.  Note that two symbols can denote the same thing (in ordinary circumstances) and still be different symbols.  As an example (using English expressions for convenience), the proper name `Bertrand Russell' and the descriptive phrase `the author of ''On Denoting''' are two different expressions, even though they both denote the same person. Two symbols can even share the same intensional meaning and yet be different symbols; e.g. `bachelor' and `unmarried man'.  The sentence `(#$differentSymbols #$BertrandRussell #$BertrandRussell)', on the other hand, is false.  See also #$equalSymbols and #$different."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(differentSymbols, ("~a are different symbols"^^_string), [[(1), MetaVariableFn(("AND"^^_string))]])) .
istAsserted(BookkeepingMt, oldConstantName(differentSymbols, ("different-Symbols"^^_string))) .
\"urn:uuid:df39e096-f466-4e7e-9ebc-44e30d42eda9"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(differentSymbols, SubLSymbolFn(("CYC-DIFFERENT-SYMBOLS"^^_string)))) .
\"urn:uuid:a46c047a-3b80-4930-af84-e1c50420047d"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(differentSymbols)) .
\"urn:uuid:04c355ed-622a-491a-9e07-45bcd0b39036"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(differentSymbols)) .
\"urn:uuid:fcaa0002-d4df-4f03-ab0b-88df44c515a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(differentSymbols, (5))) .
\"urn:uuid:c6e984d5-6d57-46c6-bd17-03287ff2e56e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(differentSymbols, (4))) .
\"urn:uuid:b97d8522-4dea-438b-af8d-6557a09d8514"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(differentSymbols, (3))) .
\"urn:uuid:316df5ee-4b54-4f16-9c93-87975cd73de6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(differentSymbols, (2))) .
\"urn:uuid:2cebefb6-a4ce-4c29-ac76-3cbf19c64d0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(differentSymbols, (1))) .
\"urn:uuid:d8ca6dea-5289-4d20-8464-ffc246a81856"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(disjointWith, ("A #$TaxonomicSlot predicate that relates #$Collections  (q.v.) that have no instances in common. <code>(#$disjointWith COL1 COL2)</code> means that <code>COL1</code> is disjoint with <code>COL2</code>: nothing is an instance of both. That is, there is no <code>THING</code> such that both <code>(#$isa THING COL1)</code> and <code>(#$isa THING COL2)</code> hold. For example, <code>(#$disjointWith #$Herbivore #$Carnivore)</code> holds because no animal is both a herbivore and a carnivore. Note that #$disjointWith is <b>not</b> irreflexive (see #$IrreflexiveBinaryPredicate): it is possible for a collection to be disjoint with itself, though only if it is empty (i.e. has no instances). Thus, for example, <code>(#$disjointWith #$Nothing #$Nothing)</code> holds.  Cf. #$intersectsWith.\n<p>\nAlso note that it is quite possible for two second (or higher) order collections to be disjoint even if an instance of one collection and an instance of the other collection themselves share instances.  Consider, for example, the disjoint collections #$SpatialThingTypeByShape and #$SpatialThingTypeByDimensionality.  #$RoundObject is an instance of the first and #$ThreeDimensionalThing is an instance of the second; and any solid spherical object is an instance of both of these latter collections."^^_string))) .
\"urn:uuid:7236d34d-2919-4e66-b0e7-bc9659cc30fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(disjointWith, (1), Thing)) .
\"urn:uuid:069f3a63-829d-4f6e-a34f-ca517080b45a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(disjointWith, (2), Thing)) .
\"urn:uuid:ac410a3b-3e64-4d21-9480-d0f31f755512"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(disjointWith, (1), Collection)) .
\"urn:uuid:4e98945e-018b-4396-8021-52c3f7674696"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(disjointWith, (2), Collection)) .
\"urn:uuid:5e93d361-f50d-4439-a6b0-51bf5c1644a8"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(disjointWith, (2), Collection)) .
\"urn:uuid:a7f6c054-9295-4bb8-a0e8-a7848c4d51db"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(disjointWith, (1), Collection)) .
\"urn:uuid:9747baef-4e34-476c-80b7-6a430337a9d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(disjointWith, SetTheFormat)) .
\"urn:uuid:e700eef8-02a9-42b5-ad92-9de6557e7ce2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(disjointWith, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(disjointWith, ("mutuallyDisjointWith"^^_string))) .
\"urn:uuid:8d0902af-719f-4a9b-b4f1-23314a9ab94d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(disjointWith, genls, (2))) .
\"urn:uuid:fceabf40-f940-4c97-a037-f83b262f26aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(disjointWith, genls, (1))) .
\"urn:uuid:f720e9b4-5817-4cf2-8857-05b675a904dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(distributesOutOfArg, (3), PositiveInteger)) .
\"urn:uuid:7e84d546-41e3-4287-93d2-149245bbde25"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(distributesOutOfArg, (1), Relation)) .
\"urn:uuid:e49e4972-2d24-4376-8a86-eb01cc28843b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(distributesOutOfArg, (2), Predicate)) .
\"urn:uuid:a8e1127d-f0a3-4d37-84c6-72bc921fc970"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(distributesOutOfArg, ("(#$distributesOutOfArg <reln> <pred> <n>) is a directive to the canonicalizer that relation <reln> distrbutes out of a predicate <pred> when it appears as the top-most relation in the predicate's arg <n>.  Specifically, it denotes (#$distributesOutOfArg <reln> <pred> <n>) denotes that the canonicalizer will translate\n<p>\n(<pred> <arg-1> ... <arg-n-1> (<reln> <arg-n1> <arg-n2> ... <arg-nm>) <arg-n+1> ..)\n<p>\ninto\n<p>\n(<reln> (<pred> <arg-1> ... <arg-n-1> <arg-n1> <arg-n+1> ...)\n(<pred> <arg-1> ... <arg-n-1> <arg-n2> <arg-n+1> ...)\n...\n(<pred> <arg-1> ... <arg-n-1> <arg-nm> <arg-n+1> ...))"^^_string))) .
\"urn:uuid:5e7fa1e7-1b4e-46d0-9cdc-716e1bf9afc5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(elInverse, ("A binary #$RuleMacroPredicate and a specialization of #$genlInverse that relates a binary EL-only (see #$ELRelation-OneWay) predicate with its non-EL-only ''inverse correlate''.   (#$elInverse PRED EL-PRED) means that whenever a sentence of the form (EL-PRED ARG1 ARG2) is used to make an assertion, the #$CycCanonicalizer ''transforms'' it into the logically equivalent form (PRED ARG2 ARG1), and the latter is what actually gets stored in the Knowledge Base.\n<p>\nFor example, (#$genlInverse #$genls #$specs) entails that if I assert the sentence '(#$specs #$Animal #$Cat)', what gets stored in the KB is the sentence '(#$genls #$Cat #$Animal)'."^^_string))) .
\"urn:uuid:550fd506-d806-4b26-a178-1bc9bd939bcf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(elInverse, (2), BinaryPredicate)) .
\"urn:uuid:75c7b61f-fbe3-4748-ba8a-1c1b59303e61"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(elInverse, (2), 'ELRelation-OneWay')) .
\"urn:uuid:c6dde25f-c743-4aad-987a-245df0ce4f1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(elInverse, (1), BinaryPredicate)) .
\"urn:uuid:93bf9e2d-097a-40da-a20e-52703e033d08"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(elInverse, SingleEntry)) .
\"urn:uuid:d247ab06-661a-43c9-95bb-43c4e9057bae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(elInverse, SingleEntry)) .
\"urn:uuid:cd515bc0-0e6b-4327-b18a-4aeabe8d1339"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentAsserted(elInverse)) .
\"urn:uuid:e7d4cf1d-39df-4e2e-8bdd-56360c42f36c"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(elInverse, (2))) .
\"urn:uuid:0a3faa9e-f128-4038-a580-b33ef8e8f969"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(elInverse, Thing, Thing, (1))) .
\"urn:uuid:bdff7117-3b4c-4ddd-8c39-0ab43fe38d5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(elInverse)) .
\"urn:uuid:3cd51243-4c99-44ab-83e1-015287248af5"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(elInverse, elInverse)) .
\"urn:uuid:09b7a15f-89f2-49b1-96b9-0ed3f1e9d00b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(elementOf, ("A very general binary predicate that relates a thing to any set or collection (see #$SetOrCollection) that it is a member or element of. <code>(#$elementOf THING SETORCOL)</code> means that <code>THING</code> is an element of <code>SETORCOL</code>.  \n<p>\n#$elementOf is a more general relation than #$isa.  Whereas #$isa is used exclusively to talk about membership in #$Collections,  #$elementOf can also be used to talk about membership in mathematical sets (see #$Set-Mathematical)."^^_string))) .
\"urn:uuid:f1695aea-9292-4a0a-8746-7a95aed13001"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(elementOf, (1), Thing)) .
\"urn:uuid:d2969b5e-ae55-4169-a339-f5b022dfa5c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(elementOf, (2), SetOrCollection)) .
\"urn:uuid:88ef50b4-cff2-4fc6-9996-3418257dc1af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(elementOf, SetTheFormat)) .
\"urn:uuid:db43df60-333d-44cd-8e7d-2a540364474c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(elementOf, SetTheFormat)) .
\"urn:uuid:9f32ce48-82ea-4212-a02f-1ec9162ef384"[silk#strict] .
istAsserted(BaseKB, definingMt(elementOf, CoreCycLMt)) .
\"urn:uuid:3b2bb765-5a64-4a6a-b6b8-099402996ec9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ephemeralTerm, (1), Thing)) .
\"urn:uuid:d3e7c7df-bfeb-402c-949c-e5fa61493cbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(ephemeralTerm, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:df9b1aa1-445c-476e-a9f6-71f1b3dd37fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ephemeralTerm, ("(#$ephemeralTerm TERM) states that TERM is a term that only has meaning in this particular copy of the knowledge base.  A such, it can be viewed as an ephemeral concept which could likely be forgotten at some future point in time, perhaps by an explicit 'forgetting' process.  See also #$termDependsOn."^^_string))) .
\"urn:uuid:5c1f7766-41de-46aa-9466-e6f7ee5bf0f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ephemeralTerm, (1))) .
\"urn:uuid:85d397e9-d193-4f30-bd7f-1c14ed79d9fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable('equalStrings-CaseInsensitive')) .
\"urn:uuid:1fc6e0bb-f1d5-49fa-8759-7635a5bae819"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('equalStrings-CaseInsensitive', ("(#$equalStrings-CaseInsensitive STRING1 STRING2) means that the #$CharacterStrings STRING1 and STRING2 contain the same characters in the same order, although some of the characters in STRING1 may differ in case from some of the characters in STRING2.  For example, (#$equalStrings-CaseInsensitive ''Foo'' ''fOo'') holds."^^_string))) .
\"urn:uuid:7b5f5989-f788-453d-bfb6-656fba20635d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('equalStrings-CaseInsensitive', (1), CharacterString)) .
\"urn:uuid:45081d20-dc7c-4866-a016-8a974c484ee4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('equalStrings-CaseInsensitive', (2), CharacterString)) .
istAsserted(BookkeepingMt, oldConstantName('equalStrings-CaseInsensitive', ("equals-CaseInsensitive"^^_string))) .
\"urn:uuid:809a5ed8-e97a-47f4-9875-8bee910e56ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden('equalStrings-CaseInsensitive')) .
\"urn:uuid:beeb9605-fcd3-4ce5-abdd-f53907558e47"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden('equalStrings-CaseInsensitive')) .
\"urn:uuid:6d9fdab0-39ae-40b2-a18a-24a7aca54502"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(equalSymbols, ("A binary #$MetaPredicate and a specialization of #$equals, both of whose arguments are #$quotedArguments (q.v.), that can be used to make identity assertions about symbols.  Stated loosely,  <code>(#$equalSymbols X Y)</code> means that <code>X</code> and <code>Y</code> are one and the same symbol.  Given that the arguments are ''quoted'', however, it is more accurate to say: A closed atomic formula consisting of the expression <code>#$equalSymbols</code> followed by CycL expressions <code>A</code> and <code>B</code> (all enclosed within a pair of parentheses) is true if and only if <code>A</code> and <code>B</code> are (two occurrences of) the same expression.\n<p>\nNote that this is stronger than merely saying that <code>A</code> and <code>B</code> denote the same thing.  As an example (using English expressions for convenience), the name 'Bertrand Russell' and the description 'the author of ''On Denoting''' are two different expressions, even though they both denote the same person.  Two symbols can even share the same intensional meaning and still be different symbols; e.g. 'bachelor' and 'unmarried male'.  The relation #$equalSymbols <i>does</i> hold, however, between 'bachelor' and 'bachelor' (at least if we pretend that 'bachelor' is a CycL expression), as it does between the CycL constant <code>#$BertrandRussell</code> and the CycL constant <code>#$BertrandRussell</code>.\n<p>\nSee also #$differentSymbols."^^_string))) .
\"urn:uuid:173e7530-d92b-4566-ac1b-5b3f975f5548"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(equalSymbols, (2), Thing)) .
\"urn:uuid:d9720b22-e811-4a03-9842-42ca4fcce99c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(equalSymbols, (1), Thing)) .
istAsserted(BookkeepingMt, oldConstantName(equalSymbols, ("equals-Symbols"^^_string))) .
\"urn:uuid:e5fe9fd1-5208-46d9-893e-b14c9c3a015a"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(equalSymbols)) .
\"urn:uuid:a96c02b2-9efc-453f-b3cc-739b25b0029a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(equalSymbols)) .
\"urn:uuid:b8be313e-1cc9-4c22-af1f-dc6042492523"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(equalSymbols)) .
\"urn:uuid:7522d9fb-2c6a-49c6-a8b5-bf133577be3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(equalSymbols, (2))) .
\"urn:uuid:74527eff-d1d4-4903-8e4c-384b4a4110d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(equalSymbols, (1))) .
\"urn:uuid:459a1c2c-7a21-4507-9a5e-6f77f511db8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(equals, ("The binary identity relation.  <code>(#$equals THING1 THING2)</code> means that <code>THING1</code> and <code>THING2</code> are ''numerically'' (as opposed to ''qualitatively'') identical, i.e. they are one and the same thing.  A sentence of the above form is true if and only if the terms occupying the two argument-places of '#$equals' denote the same thing."^^_string))) .
\"urn:uuid:519ea27f-4c9f-4764-8fba-8d0b2bfe7c5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(equals, (1), Thing)) .
\"urn:uuid:74aafc9f-d994-468c-9e08-7f3e605f486f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(equals, (2), Thing)) .
\"urn:uuid:410d0294-fe6a-4c0a-bade-ca137ca1a97b"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(equals, (2), Thing)) .
\"urn:uuid:fab05cba-c6ed-4113-86fe-e5431a05f3c6"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(equals, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(equals, MetaVariableFn(("EQUALS"^^_string)))) .
\"urn:uuid:d695abd2-74d0-40fd-8227-f5d6a5dd6a9a"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(equals, (1))) .
\"urn:uuid:aaf02cb8-833b-469a-a0f3-868b691aab71"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(equals, (2))) .
\"urn:uuid:a703d6b9-ea29-44f2-97fe-7573cb2c5ddc"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(equals, Thing, Thing, (1))) .
\"urn:uuid:5e264e45-0cea-4ea7-af48-a684ae3b776c"[silk#strict] .
istAsserted(BaseKB, definingMt(equals, LogicalTruthMt)) .
\"urn:uuid:23ddc9d2-437a-4981-8387-cb73a58b60ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(equiv, (2))) .
\"urn:uuid:4c53a6ab-530a-4585-b608-a6b0529d0ff3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(equiv, (1))) .
\"urn:uuid:7d355ab5-d1d7-49a6-8bf4-5d8a2072cd5a"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(equiv, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:a45e0b88-2ce1-408a-8d55-5a6ce9bc9fdd"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(equiv, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:8f20fa7c-68c4-441e-bc92-27241ea271b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(equiv, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:203d433e-a193-43c7-9f22-2b30a8d25c05"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(equiv, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:78e42c2d-0e47-409b-be30-7d0e7a786892"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(equiv, ("A #$LogicalConnective that represents bi-directional implication in #$CycL.  It takes two arguments, each of which must be an instance of #$ELSentence-Assertible. (#$equiv FORMULA-1 FORMULA-2) means that FORMULA-1 is true precisely when FORMULA-2 is true; in other words, FORMULA-1 is true if and only if FORMULA-2 is true.  (An EL #$equiv formula is translated during canonicalization into an equivalent, less compact, conjunction of #$implies formulas.) See also the predicate #$sentenceEquiv."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(equiv, ("~a if and only if ~a"^^_string), TheEmptyList)) .
\"urn:uuid:e463bc15-8e6c-4f79-b139-e96fb8c3ed2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(evaluate, ("A binary #$MetaLanguagePredicate that relates a thing to a thing that is known to denote it.  <code>(#$evaluate THING TERM)</code> means that <code>TERM</code> evalutes to <code>THING</code>: the Cyc system ''knows'' that <code>TERM</code> denotes <code>THING</code>.\n<p>\nNote that #$evaluate is #$notAssertible (q.v.).  Its most common uses are in rules or queries, with its first argument-place filled (syntactically speaking) with a variable.  In a query, #$evaluate is typically used to establish a binding between such a variable and an evaluatable expression.  If VAR is a variable, a literal of the form <code>(#$evaluate VAR TERM)</code> is satisfied by an HL module that evaluates <code>TERM</code> and binds <code>VAR</code> to the result.  For example, the literal '<code>(#$evaluate ?SUM (#$PlusFn 1 2))</code>' would bind '<code>?SUM</code>' to 3.  If #$evaluate's arg1 position is filled instead with a closed expression, then the HL module checks to see if the arg2 term evaluates to the denotatum of that arg1 expression.  For example, if asked the sentence '<code>(#$evaluate 3 (#$PlusFn 1 2))</code>' the system will return '#$True'."^^_string))) .
\"urn:uuid:77650b74-2a46-4205-a625-94659b991f83"[silk#strict] .
istAsserted(CoreCycLImplementationMt, notAssertible(evaluate)) .
\"urn:uuid:a566e060-5a8c-443e-a9fa-df36d55bc0d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluate, (2), Thing)) .
\"urn:uuid:6aca1944-1e22-46f5-9585-aeac533609c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluate, (1), Thing)) .
\"urn:uuid:6c2699ce-6656-47a9-9850-60cd594d53dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(evaluate)) .
\"urn:uuid:4fc19678-2393-4359-8bd4-9fa3b72b7152"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(evaluate)) .
\"urn:uuid:f0b97e89-5525-435b-9ead-21e28980700c"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(evaluate)) .
\"urn:uuid:7007403d-709f-4350-94de-b03244c60425"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(evaluate, (2))) .
\"urn:uuid:d7a71970-6563-47c0-a969-4ddf9bc5e0a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(evaluateAtEL, ("(#$evaluateAtEL FUNCTION) means that the canonicalizer will translate each non-atomic term (see the collection #$CycLNonAtomicTerm) whose  initial (or ''0th'' argument-place) term denotes FUNCTION into the value to which the non-atomic term evaluates.  For example, if (#$evaluateAtEL #$PlusFn) holds in  a #$Microtheory MT, then the non-atomic term `(#$PlusFn 2 3 4)' will canonicalize as `9' in that MT.  Note that a non-atomic term containing a nested non-atomic term whose initial term denotes another instance of #$EvaluatableFunction (call that instance OTHER-FUNCTION) will not canonicalize in this way, unless (#$evaluateAtEL OTHER-FUNCTION) is also true in MT.  For example, `(#$PlusFn 2 (#$DifferenceFn 3 4))' will not canonicalize as `1' in MT unless    \n(#$evaluateAtEL #$DifferenceFn) is also true in MT."^^_string))) .
\"urn:uuid:5ed8bd32-903c-4efb-9753-3cf8901f652a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluateAtEL, (1), EvaluatableFunction)) .
\"urn:uuid:ba678645-bed4-4eeb-bb32-aec49b6e8b91"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluateImmediately, (1), EvaluatableFunction)) .
\"urn:uuid:126d2775-13e3-4f72-957f-be498c8c36e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(evaluateImmediately, ("(#$evaluateImmediately FUNCTION) means that the canonicalizer will translate each non-atomic term (see the collection #$CycLNonAtomicTerm) whose initial (or ''0th'' argument-place) term denotes FUNCTION into the value to which the non-atomic term evaluates.  For example, if (#$evaluateImmediately #$PlusFn) held, then the non-atomic term `(#$PlusFn 2 3 4)' would canonicalize as `9'.  Note that a non-atomic term containing a nested non-atomic term whose initial term denotes another instance of #$EvaluatableFunction (call that instance OTHER-FUNCTION) will not canonicalize in this way, unless (#$evaluateImmediately OTHER-FUNCTION) is also true.  For example, `(#$PlusFn 2 (#$DifferenceFn 3 4))' would not canonicalize as `1' unless    \n(#$evaluateImmediately #$DifferenceFn) were also true."^^_string))) .
\"urn:uuid:b742d89f-8978-43ee-8a83-2cc8b55dd77b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(evaluationDefn, ("A #$CycInferenceDescriptorPredicate and #$InferenceRelatedBookkeepingPredicate that is used to relate an Cyc-evaluatable function or predicate to the name of the piece of code that is used to evaluate it.  (#$evaluationDefn RELN NAME) means that the #$SubLSymbol NAME is the name of a piece of Heuristic Level (SubL) code in the Cyc system that is used to compute the value of closed CycL formulas built from (the CycL name of) the #$EvaluatableRelation RELN.  For example, the sentence '(#$evaluationDefn #$MinusFn CYC-MINUS)' is asserted in the Knowledge Base.'"^^_string))) .
\"urn:uuid:badd08d9-4a93-4a9e-adac-081f7baede30"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluationDefn, (1), EvaluatableRelation)) .
\"urn:uuid:63c4eff3-6152-48a0-bbba-1558d961f7ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(evaluationDefn, singleEntryFormatInArgs)) .
\"urn:uuid:2e1bcfca-f172-49dc-9a6a-4ae532fa2913"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(evaluationDefn, openEntryFormatInArgs)) .
\"urn:uuid:dd11416d-2b1f-48e4-8980-1325fd21cc53"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(evaluationDefn, (2))) .
\"urn:uuid:28bd07a4-81b1-4b18-85eb-8b7ab8398c90"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(evaluationDefn, (1))) .
\"urn:uuid:fc602dfe-b8a4-4c6d-959b-8fc07e0af635"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(evaluationDefn, (2))) .
\"urn:uuid:f4e7b037-b290-493d-b762-eaa6f3696bf8"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(evaluationDefn, (2))) .
\"urn:uuid:b282610f-f8bf-453a-b842-2c2191b66c82"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(evaluationDefn, Thing, Thing, (1))) .
istAsserted(BookkeepingMt, oldConstantName(evaluationDefn, ("lispDefun"^^_string))) .
\"urn:uuid:034a5221-602e-4650-9539-723d9bea597b"[silk#strict] .
istAsserted(BaseKB, definingMt(evaluationDefn, BaseKB)) .
\"urn:uuid:1203459d-9860-48a5-b34e-b9a289b9d873"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(evaluationResultQuotedIsa, ("A binary #$MetaRelation that holds between relations and collections. #$evaluationResultQuotedIsa is primarily used to indicate that any value returned by a given evaluatable function is a quoted instance of a given collection. Where FUNC is a Function-Denotational, (#$evaluationResultQuotedIsa FUNC COL) means that FUNC returns a quoted instance of COL for any sequence of arguments for which FUNC is defined. That is, (#$quotedIsa (FUNC ARG1 ... ARGn) COL) holds for any sequence <ARG1, ..., ARGN> for which FUNC has a value. For example, '(#$evaluationResultQuotedIsa #$SubstringFn #$SubLString)' holds, and it entails (e.g.) '(#$quotedIsa (#$SubstringFn ''ABC'' 1 2) #$SubLString)'."^^_string))) .
\"urn:uuid:ab030b80-e5e3-42e9-898f-74fa47ab5ae8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(evaluationResultQuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:b8b4fba1-4867-4598-b413-c62104a70775"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluationResultQuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:343d8b3c-c9d8-4883-8ef4-93d645b12bf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(evaluationResultQuotedIsa, (1), EvaluatableRelation)) .
\"urn:uuid:461abcb9-6c2a-4925-9bc5-51f2318f6412"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(evaluationResultQuotedIsa, SetTheFormat)) .
\"urn:uuid:38fe191b-b645-4196-89c5-9d100b91dee6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(exactlyAssertedSentence, ("A #$KBDependentRelation (q.v.) and specialization of #$assertedSentence (q.v.) that is used to state that a given #$CycLSentence-Assertible has been asserted in the KB (in some accessible #$Microtheory). More exactly, (#$exactlyAssertedSentence SENT) is true in microtheory MT precisely when SENT canonicalizes without commutative handling of the sentence args into a set of clauses of the same form as the canonicalized form of some assertion in a microtheory accessible to MT. (The predicate is thus true both of assertions entered into the KB by hand and assertions deduced by Cyc from forward rules.)\n<p>\nThis predicate enables Cyc to select a subset of information when answering queries, filtering out more generic (asserted-without-commutative-canonicalization) information. Thus, for example, the query:\n<p>\n(#$assertedSentence (#$bordersOn #$CentralUSATimeZone #$EasternUSATimeZone))\n<p>\nwill return True (in appropriate microtheories), whereas:\n<p>\n(#$exactlyAssertedSentence (#$bordersOn #$CentralUSATimeZone #$EasternUSATimeZone))\n<p>\nwill not."^^_string))) .
\"urn:uuid:262c7751-d7f7-4ffb-b864-425468a29e11"[silk#strict] .
istAsserted(BaseKB, notAssertible(exactlyAssertedSentence)) .
\"urn:uuid:249bb8a9-8912-475c-85af-e98e6eec4269"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(exactlyAssertedSentence)) .
\"urn:uuid:e6ce26a2-2163-4547-ae38-792aa2731d13"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(exactlyAssertedSentence)) .
\"urn:uuid:37455d7a-f186-435a-aa0a-10bdcfc216f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(exactlyAssertedSentence)) .
\"urn:uuid:e7abed45-3ff8-41ad-8772-6ae2c38fc13c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exactlyAssertedSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:a8d22a9d-6eee-4f7c-b02e-5c572b4f1c19"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exactlyAssertedSentence, (1))) .
\"urn:uuid:4ff13d76-f2f5-4b31-aa80-14fea332881b"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(exactlyAssertedSentence, assertedSentence)) .
\"urn:uuid:39e1803a-be67-4dea-9095-532fe25e2f98"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(exampleAssertions, ("(#$exampleAssertions TERM ASSERTION) means that the #$CycLAssertion ASSERTION provides a good example of how to use the #$CycLReifiableDenotationalTerm TERM."^^_string))) .
\"urn:uuid:adf4a27a-1c6f-4853-8104-cf1fa82cd9f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(exampleAssertions, (1), Thing)) .
\"urn:uuid:b7eb810d-37fc-49af-a35f-aea230cf3c56"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(exampleAssertions, SetTheFormat)) .
\"urn:uuid:577b279e-ed27-49a2-9410-de85d922bfe4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exampleAssertions, (2), CycLAssertion)) .
\"urn:uuid:17109d3c-ebe1-4374-b1af-4bec260aa6fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exampleAssertions, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:9bf53937-b236-4c14-9fd8-949dfa243925"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exampleAssertions, (1))) .
\"urn:uuid:d0bedcd1-e2fb-4594-9504-02f0b8efe208"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exampleAssertions, (2))) .
\"urn:uuid:8223a971-4b35-4e8f-be69-a3358e0f336e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(except, ("(#$except ASSERTION) means that there is an exception to ASSERTION in the current microtheory such that ASSERTION is not known to be true.  If ASSERTION is a rule, it will not fire."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(except, ("exceptedAssertion"^^_string))) .
\"urn:uuid:5a76b631-1400-4d65-8300-35139eb45405"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(except, (1), CycLAssertion)) .
\"urn:uuid:7bfd527f-dab8-4c10-9c0e-d1b33c23dd0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(except, (1))) .
\"urn:uuid:5793e9f2-8124-43a6-b956-5ed2754ff49f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(exceptFor, ("A binary #$ExceptionPredicate that relates a general #$CycLAssertion to a thing (specified by a #$CycLReifiableDenotationalTerm) for which the assertion fails to hold, and thus under which the assertion should not be used as justification for other inferences.  <code>(#$exceptFor TERM ASSERTION)</code> means that <code>ASSERTION</code> fails to hold for the denotatum of <code>TERM</code>.  A default assumption is that <code>ASSERTION</code> <i>does</i> hold for everything other than the denotatum of <code>TERM</code> (or any other known exceptions there might be on <code>ASSERTION</code>).  For example,\n<pre>\n     (#$exceptFor\n      #$Taiwan-RepublicOfChina\n      (#$implies\n        (#$isa ?X #$ChineseProvince)\n        (#$geopoliticalSubdivision #$China-PeoplesRepublic ?X)))\n</pre>\nmeans that #$Taiwan-RepublicOfChina is an exception to the rule that every Chinese province is a geo-political subdivision of the People's Republic of China.\n<p>\n#$exceptFor is a special case of #$exceptWhen (q.v.), and is only applicable when <code>ASSERTION</code> has exactly one (implicitly) universally quantified variable.  <code>(#$exceptFor TERM ASSERTION)</code> prevents <code>TERM</code> from binding to that variable, thereby blocking any conclusions about the denotatum of <code>TERM</code> that Cyc might otherwise draw from <code>ASSERTION</code>.\n<p>\nNote that assertions made at the EL level with #$exceptFor are canonicalized into statements that do not contain #$exceptFor, but instead contain the predicate #$abnormal (q.v.)."^^_string))) .
\"urn:uuid:4c5b5e0b-6221-40d7-8fc7-941785ae0a8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(exceptFor, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(exceptFor, MetaVariableFn(("EXCEPT-FOR"^^_string)))) .
\"urn:uuid:b6e5e456-251f-407a-b07a-7e97a0482f52"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exceptFor, (2), CycLAssertion)) .
\"urn:uuid:b630d9db-9df7-448a-861a-b76fc83d13b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exceptFor, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:33e2e21c-108c-4eb2-a9df-9a68e6d8fd4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exceptFor, (1))) .
\"urn:uuid:2471b967-4920-4003-a72b-9611b0287169"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exceptFor, (2))) .
\"urn:uuid:244c7cd3-c23c-49ac-8dc1-a909685870b6"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(exceptFor, abnormal)) .
\"urn:uuid:9fca04c1-db33-4022-b1b1-b72ef9280805"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(exceptMt, ("(#$exceptMt MT) means that (#$except ASSERTION) is true for all ASSERTIONs asserted in MT. In other words, in the current microtheory ASSERTION is not known to be true.  If ASSERTION is a rule, it will not fire."^^_string))) .
\"urn:uuid:0672bd19-e693-444f-b4e1-b98b525ba8bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(exceptMt, (1), Microtheory)) .
\"urn:uuid:70c179cf-4ecc-49d7-9997-fe9473b3147e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(exceptWhen, ("A binary #$ExceptionPredicate that relates a general #$CycLAssertion to a condition (specified by a #$CycLSentence-Assertible) under which the assertion fails to hold, and thus under which the assertion should not be used as justification for other inferences.  <code>(#$exceptWhen EXCEPTION ASSERTION)</code> means that <code>ASSERTION</code> fails to hold in the case of <code>EXCEPTION</code>.  A default assumption is that <code>ASSERTION</code> <i>does</i> hold for all cases other than those covered by <code>EXCEPTION</code> (or by any other exception assertions there might be on <code>ASSERTION</code>).  For example, \n<pre>\n  (#$exceptWhen\n    (#$spatiallySubsumes #$NorthPoleOfEarth ?THING)\n    (#$implies \n      (#$isa ?THING #$GeographicalThing) \n      (#$thereExists ?OTHER \n        (#$northOf ?OTHER ?THING)))\n</pre>\t\nmeans that every geographical thing has something to the north of it, except when the former is spatially subsumed by the North Pole.  \n<p>\nNormally, as in the foregoing example, the <code>ASSERTION</code> is an (implicitly) universally quantified sentence, and the <code>EXCEPTION</code>, in effect, places a restriction on the range of values (for the universally quantified variables in <code>ASSERTION)</code> for which <code>ASSERTION</code> is true.  Since implicit universal quantification is always interpreted as having the widest possible scope, in the above example the occurrence of the variable <code>?THING</code> in the exception-giving sentence is interpreted as if it were bound by the same wide-scope universal quantifer that binds the two occurrences of <code>?THING</code> in the #$implies rule.\n<p>\nA common special case of #$exceptWhen is handled by #$exceptFor (q.v.).  \n<p>\nNote that assertions made at the EL level with #$exceptWhen are canonicalized into statements that do not contain #$exceptWhen, but instead contain the predicate #$abnormal (q.v.)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(exceptWhen, MetaVariableFn(("EXCEPT-WHEN"^^_string)))) .
\"urn:uuid:9387d1e0-cc07-49a4-a59d-a5241d13c2b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exceptWhen, (2), CycLAssertion)) .
\"urn:uuid:59dfb0d1-18e7-437c-9021-68c66a717f00"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(exceptWhen, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:d8478bef-a3d6-47dd-a1ac-3905cc4e416c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exceptWhen, (1))) .
\"urn:uuid:b4dab109-5b52-4d82-834a-016946a0f0d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(exceptWhen, (2))) .
\"urn:uuid:9af61760-65c6-46d7-a664-5021b2bec834"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(exceptWhen, abnormal)) .
\"urn:uuid:e03e11c4-d968-4416-8a0b-d30e293af6cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(expansion, ("Some relations (namely, instances of #$MacroRelation (q.v.)) can be defined in terms of more basic or primitive constructs. <code>(#$expansion RELATION FORMULA)</code> associates <code>RELATION</code> with the <code>FORMULA</code> that defines it. The arg2 is allowed to reference generic-argument keywords, such as :ARG1 :ARG2 which represent respectively the arg1 and the arg2 within uses of <code>RELATION</code>.  For example, <code>(#$expansion #$genls (#$implies (#$isa ?object :ARG1) (#$isa ?object :ARG2)))</code> indicates that the gaf <code>(#$genls #$Poodle #$Dog)</code> is defined as <code>(#$implies (#$isa ?object #$Poodle) (#$isa ?object #$Dog)))</code>. Importantly, the expansion-formula arg2 must be necessary and sufficient; it denotes the definition of the uses of relation arg1; there can be only one expansion for any relation.  Furthermore, no two relations can share a common expansion; thus, there can be only one possible contraction from a formula that corresponds to an expansion into a compact form that references expandable relations.  For example, <code>(#$implies (#$isa ?object #$Poodle) (#$isa ?object #$Dog)))</code> has the unambiguous contraction of <code>(#$genls #$Poodle #$Dog)</code>. The expansion arg2 can (and should when possible) make use of relations that have expansions.  Note that the example above references #$implies which would itself have the expansion <code>(#$or (#$not :ARG1) :ARG2)</code>.  Thus, the full expansion of a relation can involve recursive expansions.  For example, the full expansion of #$genls would be <code>(#$or (#$isa ?object :ARG1) (#$not (#$isa ?object :ARG2))))</code>.  No relation may reference itself (either directly or indirectly via recursion) in its expansion (or in its full recursive expansion).  See #$ELRelation, #$TermMacroFunction, #$expansionAxiom."^^_string))) .
\"urn:uuid:6e076892-0f77-4ec3-8caa-75615f64ae87"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(expansion, (2), AllowGenericArgVariables)) .
\"urn:uuid:52aab7c0-f99c-4b8c-bcab-ee01ea729630"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(expansion, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:f464eb58-dd6c-479e-a505-dbf30f685b25"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, argIsa(expansion, (2), Thing)) .
\"urn:uuid:49899c50-9642-4f9a-a096-5587d0e6927c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(expansion, singleEntryFormatInArgs)) .
\"urn:uuid:c3aac056-a849-4653-ae1e-f9136652990e"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, argQuotedIsa(expansion, (2), CycLExpression)) .
\"urn:uuid:e893be26-8923-4853-9017-63eb9a07275e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(expansion, (2))) .
\"urn:uuid:7b7d2e39-731b-4279-a146-bd114b50c56c"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(expansion, (2))) .
\"urn:uuid:2c08deef-4f34-4a64-9e32-7d95c7f29b3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(expansion, (2))) .
\"urn:uuid:d969b390-2aa9-4e1a-bebd-b81f00cbe070"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(expansion, Thing, Thing, (1))) .
\"urn:uuid:80ff7102-0a66-4e72-a107-f46256057b34"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(expansionDefn, ("(#$expansionDefn <Relation> <Symbol>) denotes that during canonicalization\nthe subl function definition of <Symbol> is used to transform an EL expression\n(<Relation> . <args>) into the appropriate HL formula."^^_string))) .
\"urn:uuid:899a78a8-efe3-422b-b8ea-d4100adaf5e0"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(expansionDefn, (2))) .
\"urn:uuid:b1c232cb-e72f-4590-adac-1e30ff24086d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(expansionDefn, (1), Relation)) .
\"urn:uuid:208fda5e-48e6-4360-8667-1dc12e06a6a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(expansionDefn, Thing, Thing, (1))) .
\"urn:uuid:e6b94869-fb21-42fc-9510-1d765919ed9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(expansionDefn, SingleEntry)) .
\"urn:uuid:9b7b2200-a1aa-488b-9f45-6d3aed6b528f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(expansionDefn, (2))) .
\"urn:uuid:affcb422-2e87-4e14-bfe7-e909577f4f7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(expresses, ("A #$MetaLanguagePredicate (q.v.) and a specialization of #$means (q.v.) that relates a CycL sentence to the #$Proposition (if any) it expresses with respect to the intended model of the CycL language.  <code>(#$expresses SENTENCE PROPOSITION)</code> means that <code>SENTENCE</code> expresses, or has as its <i>intensional</i> meaning, <code>PROPOSITION</code>.\nIn order to express a proposition (see #$CycLPropositionalSentence), a CycL sentence must at the very least be closed and obey the arity of its main operator.\n<p>\nFor example, the sentence\n<pre>\n  (#$likesAsFriend #$Muffet #$Murray)\n</pre>\nexpresses the proposition that Muffet likes Murray, and we can represent that fact as follows:\n<pre>\n  (#$expresses\n    (#$Quote (#$likesAsFriend #$Muffet #$Murray))\n    (#$ThatFn (#$likesAsFriend #$Muffet #$Murray)))\n</pre>\nNow the above sentence is of course nearly trivial, given the intimate connection that exists between the function #$ThatFn and the #$expresses relation.  But, as we shall see, not all <code>#$expresses</code> sentences are trivial.\n<p>\nAs the example illustrates, the first argument-term in an <code>#$expresses</code> statement might consist of a particular CycL sentence wrapped with <code>#$Quote</code>.  But note that this need not be the case.  Suppose the above <code>#$likesAsFriend</code> sentence happened to be the first CycL assertion made by Muffet.  We might then reify a constant named <i>MuffetsFirstCycLAssertion</i> to denote that sentence.  Then we could say:\n<pre>\n  (#$expresses\n    MuffetsFirstCycLAssertion\n    (#$ThatFn (#$likesAsFriend #$Muffet #$Murray)))\n</pre> \nAs the example also illustrates, the second argument-term in an <code>#$expresses</code> statement might consist of a non-atomic term formed by applying the functor <code>#$ThatFn</code> to a particular CycL sentence.  But this also need not be the case.  Suppose the proposition that Muffet likes Murray happened to be Murray's favorite proposition.  We might then reify a constant named <i>MurraysFavoriteProposition</i> to denote that proposition.  Then we could say:\n<pre>\n  (#$expresses\n    MuffetsFirstCycLAssertion\n    MurraysFavoriteProposition)\n</pre> \nSee also #$denotes."^^_string))) .
\"urn:uuid:dd85af64-4520-46e9-bd6e-03a895711d7c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(expresses, (2), Thing)) .
\"urn:uuid:83889172-b371-451f-9910-e86acc107fdc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(expresses, (1), CycLSentence)) .
\"urn:uuid:38167c45-5a5f-43ed-a34a-3356c0bd24f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(expresses, singleEntryFormatInArgs)) .
\"urn:uuid:ec5e4b3b-41dd-4a09-aeab-02bc4bc0755b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(expresses, openEntryFormatInArgs)) .
\"urn:uuid:ccd8b575-4c6c-4d39-821f-e2cf1ba43bc0"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(expresses, (1))) .
\"urn:uuid:dfab459d-938a-4a31-9837-6086ef8b6e2c"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(expresses, (2))) .
\"urn:uuid:3d0f86ab-86e5-4a89-bed4-af14d77b1f44"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(expresses, (2))) .
\"urn:uuid:2a1cca46-58b6-4f9e-becf-015b3c12004a"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(expresses, Thing, Thing, (1))) .
\"urn:uuid:765b4288-019a-49be-89a4-4775f45fc947"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(extConceptOverlapsColAndReln, ("(#$extConceptOverlapsColAndReln COL RELN SOURCE STRING) means\nthat the external structured data source SOURCE variously uses the term\nnamed by STRING as a value that semantically maps to the Cyc #$Collection\nCOL, and as a slot that maps to the Cyc #$BinaryPredicate RELN."^^_string))) .
\"urn:uuid:e5f524e5-d24b-471d-a5a9-162448bcc626"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(extConceptOverlapsColAndReln, (1), Thing)) .
\"urn:uuid:988ef3d7-de72-46c5-9914-9685215e0cbf"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(extConceptOverlapsColAndReln, (4))) .
\"urn:uuid:07f8017b-d1b1-42fe-9975-74d011e5a3b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(extConceptOverlapsColAndReln, (1), Collection)) .
\"urn:uuid:c60e7d77-c72b-46b1-a127-46bcc6c39aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(extConceptOverlapsColAndReln, (2), BinaryPredicate)) .
\"urn:uuid:4171bee5-c47c-42d1-a59a-710c98a23d89"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(extConceptOverlapsColAndReln, (4), CharacterString)) .
\"urn:uuid:26106e15-c148-47c1-b114-8c27a8726c16"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(extConceptOverlapsColAndReln, SingleEntry)) .
\"urn:uuid:d51f5be7-cdee-4af6-aec0-db663a9dc5d2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(extentCardinality, ("<code>(#$extentCardinality SETORCOL N)</code> means that there are <code>N</code> terms in the currently represented extent of #$SetOrCollection <code>SETORCOL</code>.  See also #$cardinality."^^_string))) .
\"urn:uuid:4637624d-902f-4316-b070-20bbccbfe3d9"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(extentCardinality, (2))) .
\"urn:uuid:ff90d9c6-dfc0-43dc-9e54-41ccfdc911b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(extentCardinality, (2), NonNegativeInteger)) .
\"urn:uuid:02566a82-4809-4347-af74-b09b8ac5cc7f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(extentCardinality, (1), SetOrCollection)) .
\"urn:uuid:daf61b2e-0d1f-4a76-83bf-8538ef4ace53"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(extentCardinality, Thing, Thing, (1))) .
\"urn:uuid:451748e4-508e-4e6c-a9ce-921c4eab84a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(extentCardinality, SingleEntry)) .
\"urn:uuid:f0d41d94-0fb9-49cf-9edd-87a091925611"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(extentCardinality)) .
\"urn:uuid:835910eb-a1f9-40bb-a38a-55d23fc194ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(fanOutArg, ("<code>(#$fanOutArg PRED N)</code> means that transitively-related assertions using <code>PRED</code> usually ''fan out'' in the direction of argument position <code>N</code>.  For example, (#$fanOutArg #$geographicalSubRegions 2) means that usually a geographical region has more direct sub-regions than super-regions, so for any region <code>REG</code> there will likely be more assertions of the form <code>(#$geographicalSubRegions REG SUB)</code> than there are assertions of the form <code>(#$geographicalSubRegions SUPER REG)</code>."^^_string))) .
\"urn:uuid:6eada60a-c424-42e1-bd14-2a2fe33cfe0a"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(fanOutArg, (2))) .
\"urn:uuid:edadd955-c978-48b9-98a7-82d65cb45463"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(fanOutArg, (1), BinaryPredicate)) .
\"urn:uuid:64ef4ca6-bdd0-488e-b13d-3a22283e9111"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(fanOutArg, (2), PositiveInteger)) .
\"urn:uuid:4dd3d7ad-6e5c-458c-8e99-e8842051ecbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(fanOutArg, Thing, Thing, (1))) .
\"urn:uuid:7c4d2f38-9fee-49c7-9fb7-8b05dfb81645"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(fanOutArg, singleEntryFormatInArgs)) .
\"urn:uuid:043fa37d-784b-456e-9c94-8f1d715a865b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(fanOutArg, openEntryFormatInArgs)) .
\"urn:uuid:af096771-ace9-483c-ad95-76be3195fb2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(followingValue, ("An instance of both #$OrderingPredicate and #$ComparisonPredicate (qq.v.), and a specialization of both #$colinearQuantities and #$lessThan (qq.v.).  #$followingValue is simply the restriction of the very general #$lessThan relation to colinear #$Quantity[ies] (q.v.).  <code>(#$followingValue LO-QUANT HI-QUANT)</code> means that <code>LO-QUANT</code> and <code>HI-QUANT</code> are colinear quantities such that <code>HI-QUANT</code> is a higher or greater value than <code>LO-QUANT</code>.  It follows that there is some (unspecified) linear ordering (see #$TotallyOrderedQuantityType) to which both <code>LO-QUANT</code> and <code>HI-QUANT</code> belong.\n<p>\nNote that the above sentence would typically be asserted only if one or both of <code>LO-QUANT</code> and <code>HI-QUANT</code> are instances of #$GenericQuantity (or the more general #$NonNumericScalarQuantity), and -- as is usually the case -- they are not grounded in numerically-quantifiable units of measure (see #$NoteAboutGivingGenericValueFunctionsNumericValues).  If <code>LO-QUANT</code> and <code>HI-QUANT</code> <i>do</i> have numerical grounding, a #$followingValue assertion is unnecessary since #$numericallyEquals, #$greaterThanOrEqualTo, and #$greaterThan are automatically computable using arithmetic relations holding between the respective minimums and maximums (see #$minQuantValue and #$maxQuantValue) of <code>LO-QUANT</code> and <code>HI-QUANT</code>.  For example, one might well use #$followingValue to state that (#$HighAmountFn #$Glamour) is more glamorous than (#$LowAmountFn #$Glamour); but it is unnecessary to make a #$followingValue assertion about (#$MilesPerHour 5) and (#$MilesPerHour 25 35), since #$greaterThan is automatically computable in that case.\n<p>\nSee also #$GenericValueFunction and #$followingValueOnScale."^^_string))) .
\"urn:uuid:5ae443e5-9b63-47bb-b888-02197b027cfd"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(followingValue, (2))) .
\"urn:uuid:7c0aae44-49d5-4082-a7df-1642a4134108"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(followingValue, (1))) .
\"urn:uuid:e5c3f8c0-094e-4960-918c-e26eb4380b77"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(followingValue, openEntryFormatInArgs)) .
\"urn:uuid:da7c13ab-5f35-4d1f-a4df-019ccc539094"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(followingValue, openEntryFormatInArgs)) .
\"urn:uuid:1c35845d-f935-4c4e-804a-3ef5c4ffff3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(followingValue, followingValue)) .
\"urn:uuid:fa5d1bd7-598c-4fc5-bdfc-faca5218503e"[silk#strict] .
istAsserted(UniversalVocabularyMt, omitArgIsa(forAll, (2))) .
\"urn:uuid:db7702a6-2478-40d5-b24e-b902d31359dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, omitArgIsa(forAll, (1))) .
\"urn:uuid:9f6acaff-2c23-4d5f-b8b8-2605b17b0eec"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(forAll, ("A binary #$Quantifier that corresponds to the standard universal quantifier of predicate calculus.  The relation #$forAll takes as its arguments a variable (#$ELVariable) and a sentence (#$ELSentence-Assertible) in which, typically, that variable occurs free.  A closed formula (see #$CycLClosedFormula) of the form (#$forAll VAR SENT) is a ''universally quantified'' sentence that states (roughly) that every thing in the universe of discourse satisfies SENT.  For example,\n<p>\n<pre>\n  (#$forAll ?THING (#$isa ?THING #$Individual))\n</pre>\n<p>\nmeans that everything is an individual.  And the sentence\n<p>\n<pre>\n  (#$forAll ?X\n    (#$implies\n      (#$isa ?X #$Cat)\n      (#$eatsWillingly ?X #$Grass-Plant)))\n</pre>\n<p>\nmeans that all cats eat grass.\n<p>\nA more precise definition of #$forAll is as follows.  Any occurence of VAR that is free in SENT is bound in (#$forAll VAR SENT).  If VAR is the only variable free in SENT, then (#$forAll VAR SENT) is a closed sentence that is true if and only if every thing that meets all of the argument-type constraints (see #$ArgTypePredicate) to which the position(s) in SENT occupied by VAR is (are) subject to satisfies SENT. If the variable VAR does _not_ occur free in SENT, then (#$forAll VAR SENT) is equivalent to SENT (and the '#$forAll' is said to be ''vacuous'').  If variables other than VAR occur free in SENT, then (#$forAll VAR SENT) is an open sentence in which those other variables are still free.\n<p>\nNote that, for the sake of convenience and readability, universally quantified assertions (i.e. ''rules'') in the Cyc Knowledge Base appear in the KB browser -- and may be asserted to the KB -- without (any of) their initial '#$forAll's.  Such assertions are considered to be ''implicitly quantified'': they are interpreted by the system just as if their initial quantifiers were explicitly present.  Thus the above sentence about cats would actually appear in the KB as:\n<p>\n<pre>\n  (#$implies\n    (#$isa ?X #$Cat)\n    (#$eatsWillingly ?X #$Grass-Plant)) .\n</pre>\n<p>\nNote also that certain #$RuleMacroPredicates (e.g. those with 'All' in their names) can be used to abbreviate universally quantified sentences.  Thus the same statement about cats can be even more tersely expressed with the atomic sentence\n<p>\n<pre>\n  (#$relationAllInstance #$eatsWillingly #$Cat #$Grass-Plant) .\n</pre>\n<p>\nCf. the existential quantifier #$thereExists."^^_string))) .
\"urn:uuid:c8aadcdc-d566-43cb-b9db-74d7c2822360"[silk#strict] .
istAsserted(BaseKB, scopingArg(forAll, (1))) .
istAsserted(EnglishParaphraseMt, genKeyword(forAll, MetaVariableFn(("FOR-ALL"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(forAll, ("for every ~a, ~a"^^_string), TheEmptyList)) .
istAsserted(BookkeepingMt, oldConstantName(forAll, ("ForAll"^^_string))) .
\"urn:uuid:e5ce793f-f056-4d06-9a8f-502a7028bbf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(forAll, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:9b32faca-a3c5-4a66-8c93-87911adc2aa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(forAll, (1), CycLVariable)) .
\"urn:uuid:dbd7697c-5711-418f-b55f-1b37d33dafa9"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(forAll, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:d87f5fcd-dd34-4c5b-8145-2681f842b2e6"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(forAll, (1), CycLVariable)) .
\"urn:uuid:4b1706d9-7a6a-4173-9733-80e3aa537aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(forAll, (2))) .
\"urn:uuid:4121c35a-d7d0-4d7d-90bb-52dd56b50bd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(forAll, (1))) .
\"urn:uuid:d87465c7-dd18-4d19-9f4c-31d5ba3ad2e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(formulaArity, ("(#$formulaArity FORMULA INTEGER) means that the CycL formula FORMULA contains INTEGER arguments. See also #$FormulaArityFn."^^_string))) .
\"urn:uuid:b6458f4d-80a0-4978-8a75-8ebbff1230b0"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(formulaArity, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:40382f30-5c1f-4cf3-8e94-ce33e8e0e5f1"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(formulaArity, (2))) .
\"urn:uuid:76c308d9-d1f8-4eb0-9d96-648553e4fb20"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(formulaArity, (1), Thing)) .
\"urn:uuid:4e267f65-dfb2-45d8-b7e0-dfed4ef713ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(formulaArity, (2), PositiveInteger)) .
\"urn:uuid:b0d49064-420e-446b-9a28-7ccd7a370231"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(formulaArity, Thing, Thing, (1))) .
\"urn:uuid:f0d23d8c-86dc-4777-8626-59f1f47b8496"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(formulaArity, singleEntryFormatInArgs)) .
\"urn:uuid:d74ed82d-7cbb-4557-a57b-729e091fae08"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(formulaArity)) .
\"urn:uuid:a22b5a18-34b1-4c1a-9722-f24c8c129aa7"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(formulaArity)) .
\"urn:uuid:be55cd22-fc04-4625-a108-96311df15b34"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(formulaArity)) .
\"urn:uuid:58987fe6-d9d0-4d81-ae26-07b689d9a462"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(formulaArity, (1), CycLFormula)) .
\"urn:uuid:2de1534a-2226-42d8-8fc2-ef5f1153e5b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(formulaArity, (1))) .
\"urn:uuid:8e9b1dce-69d5-4acf-b3b6-d7fff7258b28"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(forwardNonTriggerLiteral, ("An #$HLPredicate that is used to state which literals in a forward rule should not be allowed to re-trigger forward inference.  This is useful for placing pragmatic restrictions on the applicability of forward rules.  It is only useful when used via #$pragmaticRequirement on a forward rule.\n<p>\nA pragmatic requirement of the form\n<pre>\n(#$pragmaticRequirement (#$forwardNonTriggerLiteral FORMULA) RULE),\n</pre>\nwhere <code>FORMULA</code> is a literal in the antecedent of <code>RULE</code>, ensures that new assertions that are instantiations of <code>FORMULA</code> do not trigger <code>RULE</code>."^^_string))) .
\"urn:uuid:f4e7f048-916a-41b0-8bc8-f1ddb15c2e08"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(forwardNonTriggerLiteral, (1), CycLOpenSentence)) .
\"urn:uuid:4adb445d-5348-48d7-bf06-3fcc33bb04d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(forwardNonTriggerLiteral)) .
\"urn:uuid:dbd668c9-0f41-4e11-9a9d-7a00965d8cbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(forwardNonTriggerLiteral, (1))) .
\"urn:uuid:34140fbb-8be2-4a07-a07e-57ed15a3c387"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genFormat, ("The Common Lisp format string ARG2 can be applied to the argument list ARG3 to generate pseudo-English for the #$Cyc #$Relation ARG1"^^_string))) .
\"urn:uuid:bd2e2b2c-0efb-48d5-962a-1e58d41daff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genFormat, (2), CharacterString)) .
\"urn:uuid:1861009d-43af-49d7-bc0a-2e5230f0d37e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genFormat, (3), List)) .
\"urn:uuid:e70600d4-4be5-4f66-8728-a1cfc90a133b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genFormat, (1), Relation)) .
istAsserted(EnglishParaphraseMt, genKeyword(genFormat, MetaVariableFn(("GEN-FORMAT"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(genFormat, ("to generate English for assertions formed with ~a, the format string ~a is used with the extra information in this list: ~a"^^_string), [[(1), MetaVariableFn(("EQUALS"^^_string))], (2), (3)])) .
\"urn:uuid:dfbcaf1b-3563-44fd-926b-0726e63c99d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genFormat, (2), SubLString)) .
\"urn:uuid:b2519398-2855-463d-8041-08014518dcfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genFormat, (2))) .
\"urn:uuid:c5e37efc-7930-419b-9849-3642132a6029"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genFormat, (1))) .
\"urn:uuid:752f9789-12e5-40b2-b7f0-10adfcbc2480"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genKeyword, ("An #$NLGenerationPredicate that\nrelates a given CycL denotational term to the SubL keyword \nthat is used to represent it in generating natural language \nfrom CycL.  (#$genKeyword CYCL-TERM KEYWORD) means that \nKEYWORD represents CYCL-TERM in the generation of natural \nlanguage paraphrases of CycL expressions, e.g. in #$genFormat \n(q.v.) assertions."^^_string))) .
\"urn:uuid:91ddfe31-a7de-4c6f-8cf9-b5f264f53e63"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(genKeyword, (2))) .
\"urn:uuid:8dc407b6-5cde-4f42-8c8a-76116522ea77"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genKeyword, (1), Thing)) .
\"urn:uuid:2c7c6004-fc2c-4c04-a321-863a5e4a7d21"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(genKeyword, Thing, Thing, (1))) .
\"urn:uuid:4f30ec5c-2843-4e1e-b728-ca631a782f29"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(genKeyword, SingleEntry)) .
\"urn:uuid:3f074b52-5d9c-4eeb-a543-44646dae055a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(genKeyword, SingleEntry)) .
\"urn:uuid:8b668147-0834-4010-aecc-0c3324cb035b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genKeyword, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:f20eccf5-d113-4d24-b24d-30398cd546ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genKeyword, (2), SubLKeyword)) .
\"urn:uuid:4ab49c48-408e-4ef1-9e5a-5c6a67344217"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genKeyword, (1))) .
\"urn:uuid:2825659d-dd0a-451a-986f-b70f88e20db1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genKeyword, (2))) .
\"urn:uuid:9238296e-ab23-46d3-872a-9777ec45763c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genMassNoun, ("(#$genMassNoun TERM) means that the #$CycLReifiableDenotationalTerm TERM should be treated as a mass noun when CycL formulae containing TERM are paraphrased into English.  See also the related predicate #$prettyName."^^_string))) .
\"urn:uuid:7fb3b125-6160-44a5-8e31-62a7954ae590"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genMassNoun, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(genMassNoun, MetaVariableFn(("GEN-MASS-NOUN"^^_string)))) .
\"urn:uuid:5f48f9b9-5298-43f3-9c9d-86eda6ba7097"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genMassNoun, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:891c3603-4d6a-410c-8b5a-99637721a6ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genMassNoun, (1))) .
\"urn:uuid:0a09fcda-bb2a-4c3c-980f-7f75c095b680"[silk#strict] .
istAsserted(BaseKB, fanOutArg(genlCanonicalizerDirectives, (1))) .
\"urn:uuid:fb41a3a3-601d-433e-8af2-7b3fa51305d0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, notAssertible(genlCanonicalizerDirectives)) .
\"urn:uuid:4e91042f-ad2f-46a1-b58d-7a987048f790"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlCanonicalizerDirectives, (1), CanonicalizerDirective)) .
\"urn:uuid:1839ebf2-16de-4013-b741-eb9404aca85c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlCanonicalizerDirectives, (2), CanonicalizerDirective)) .
\"urn:uuid:a080c291-0ed3-4438-a9be-3cea1349aae0"[silk#strict] .
istAsserted(CoreCycLImplementationMt, comment(genlCanonicalizerDirectives, ("A transitive binary predicate that relates a given \n#$CanonicalizerDirective (q.v.) to more general ones.\n(#$genlCanonicalizerDirectives SPEC-DIRECTIVE GENL-DIRECTIVE) \nmeans that SPEC-DIRECTIVE is at least as specific a (set of) \ndirection(s) to the #$CycCanonicalizer as GENL-DIRECTIVE.  \nThat is, all the commands indicated by GENL-DIRECTIVE (and\npossibly others as well) are indicated by SPEC-DIRECTIVE.  \nFor example, (#$genlCanonicalizerDirectives\n#$LeaveSomeTermsAtELAndAllowKeywordVariables \n#$AllowKeywordVariables) holds."^^_string))) .
\"urn:uuid:e81f987f-4e59-48bc-8275-8d6689dc26da"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genlInverse, ("A #$MetaPredicate for stating that one binary  predicate is a generalization of the <i>inverse</i> of another binary predicate.   <code>(#$genlInverse PRED GENL-INV-PRED)</code> means that <code>GENL-INV-PRED</code> is a  ''generalized inverse'' of <code>PRED</code>.  That is, <code>(PRED ARG1 ARG2)</code> implies  <code>(GENL-INV-PRED ARG2 ARG1)</code>.  For example, <code>(#$genlInverse #$grandchildren #$ancestors)</code> means that grandparents are  ancestors of their grandchildren.  See also #$genlPreds and #$negationInverse."^^_string))) .
\"urn:uuid:132064cc-917a-4e28-947f-1185994c0341"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlInverse, (1), BinaryPredicate)) .
\"urn:uuid:e5f7e8d6-903e-42b9-851e-05eca21d3a1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlInverse, (2), BinaryPredicate)) .
\"urn:uuid:881117c5-6c0b-4a22-bf17-4edb9c4f7b8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genlMt, ("A reflexive and transitive #$BinaryPredicate that relates a #$Microtheory to a #$Microtheory.  <code>(#$genlMt SPEC-MT GENL-MT)</code> means that <code>SPEC-MT</code> is a specialization or extension of <code>GENL-MT</code>.  (Note that it need not be a <i>proper</i> specialization or extension.)  In particular, this entails that everything that is true in <code>GENL-MT</code> is also true in <code>SPEC-MT</code>.  This relation is sometimes expressed informally by saying that <code>SPEC-MT</code> ''sees'' <code>GENL-MT</code>."^^_string))) .
\"urn:uuid:da0fb565-0ee7-4d4f-b9d5-362b0f0cc1e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(genlMt, SetTheFormat)) .
\"urn:uuid:8fa2bf11-2698-4dc7-847d-615ed6cd35ff"[silk#strict] .
istAsserted(BaseKB, fanOutArg(genlMt, (1))) .
\"urn:uuid:103a8691-9fe5-45e6-9d70-514d063b22e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(genlMt, SetTheFormat)) .
\"urn:uuid:7728e12d-e2f7-4d87-9a8b-0e0b759e28c8"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(genlMt, Microtheory, BaseKB)) .
istAsserted(BookkeepingMt, oldConstantName(genlMt, ("baseMt"^^_string))) .
\"urn:uuid:e7975631-fcaa-4577-b916-6f0491990665"[silk#strict] .
istAsserted(BaseKB, argIsa(genlMt, (2), Microtheory)) .
\"urn:uuid:e07f5a0d-8fdc-46a2-b121-add708cc32ef"[silk#strict] .
istAsserted(BaseKB, argIsa(genlMt, (1), Microtheory)) .
\"urn:uuid:9126a1ad-533e-41eb-9198-102091adf19a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlMt, (1), Microtheory)) .
\"urn:uuid:eef5559d-b8e7-4927-a947-c7346be998e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlMt, (2), Microtheory)) .
\"urn:uuid:875eca6c-f95f-40e3-ad98-c594ce03c2d9"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(genlMt, (1), Microtheory)) .
\"urn:uuid:99d53542-eab4-49aa-a5ed-9b462bf8fb97"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(genlMt, (2), Microtheory)) .
\"urn:uuid:7512e560-e7ab-4c70-88f8-fc2db94ec6f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genlPreds, ("A #$MetaPredicate for stating that one predicate is a generalization of another.  <code>(#$genlPreds SPEC-PRED GENL-PRED)</code> means that <code>GENL-PRED</code> is a generalization of <code>SPEC-PRED</code>.  That is, <code>(GENL-PRED ARG1..ARGN)</code> holds whenever <code>(SPEC-PRED ARG1..ARGN)</code> holds.  For example, <code>(#$genlPreds #$touches #$near)</code> holds, as touching something implies being near it.\n<p>\nAs for the respective arities (see #$arity) of <code>SPEC-PRED</code> and <code>GENL-PRED</code>, (i) both predicates might have the same fixed-arity (see #$FixedArityRelation), (ii) both might have variable-arity (see #$VariableArityRelation), or (iii) <code>SPEC-PRED</code> might have a fixed-arity and <code>GENL-PRED</code> variable-arity.  (It cannot be the case that <code>SPEC-PRED</code> has variable-arity and <code>GENL-PRED</code> has a fixed-arity.)\n<p>\nSee also #$negationPreds, #$genlInverse, and #$negationInverse."^^_string))) .
\"urn:uuid:da6ee741-ff6c-4480-89d3-53be1d202f32"[silk#strict] .
istAsserted(BaseKB, fanOutArg(genlPreds, (1))) .
\"urn:uuid:d5172917-077a-42a7-ad72-477cc3b7f99f"[silk#strict] .
istAsserted(BaseKB, relationExistsAll(genlPreds, UnaryPredicate, UnaryPredicate)) .
\"urn:uuid:3f19db9c-d961-4c26-b181-44c53165daeb"[silk#strict] .
istAsserted(BaseKB, relationExistsAll(genlPreds, QuaternaryPredicate, QuaternaryPredicate)) .
\"urn:uuid:fc37c9a4-85ae-4c63-9d03-9e71cd8f396e"[silk#strict] .
istAsserted(BaseKB, relationExistsAll(genlPreds, BinaryPredicate, BinaryPredicate)) .
\"urn:uuid:6c8522fc-9e16-4c15-af6e-c51c494e5d2c"[silk#strict] .
istAsserted(BaseKB, relationExistsAll(genlPreds, TernaryPredicate, TernaryPredicate)) .
\"urn:uuid:ef58077f-1763-4ff5-b5f3-f80f4bc8e694"[silk#strict] .
istAsserted(BaseKB, relationExistsAll(genlPreds, QuintaryPredicate, QuintaryPredicate)) .
\"urn:uuid:7ad81cef-4ba2-4d38-9c7f-3f9a62886cd5"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), UnaryPredicate, (1), UnaryPredicate)) .
\"urn:uuid:ba38efdc-4959-4d2f-9199-cc681a337d63"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), QuaternaryPredicate, (1), QuaternaryPredicate)) .
\"urn:uuid:c17fc8cb-4afc-47bd-8310-33cace793df7"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), BinaryPredicate, (1), BinaryPredicate)) .
\"urn:uuid:5aaadf09-e747-4ee7-839c-a4e90fc838cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), FixedArityRelation, (1), FixedArityRelation)) .
\"urn:uuid:298ca9dd-e313-4a10-993f-fba3cf96c13b"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), TernaryPredicate, (1), TernaryPredicate)) .
\"urn:uuid:31f7f42b-cdde-45d2-942a-aec7c3d2bedc"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (2), QuintaryPredicate, (1), QuintaryPredicate)) .
\"urn:uuid:c161fd51-b26a-4256-8bbb-49b0b0c8a66b"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genlPreds, (1), VariableArityRelation, (2), VariableArityRelation)) .
\"urn:uuid:987893de-1ffd-4637-a6b7-831c2aace84b"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(genlPreds, IrreflexiveBinaryPredicate, different)) .
\"urn:uuid:3611ba56-2dd9-4876-af9c-a4ca0b47d440"[silk#strict] .
istAsserted(BaseKB, argIsa(genlPreds, (2), Predicate)) .
\"urn:uuid:c46d03cc-9185-40ac-a271-3391796d8597"[silk#strict] .
istAsserted(BaseKB, argIsa(genlPreds, (1), Predicate)) .
\"urn:uuid:238ce1d2-11cf-405a-9721-a6b64f0d8515"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlPreds, (1), Predicate)) .
\"urn:uuid:7dd5c471-8693-42de-99e2-db5bfc261601"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genlPreds, (2), Predicate)) .
\"urn:uuid:9a6cdc8a-4e50-4dae-b053-4ad3eba69db6"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, FixedArityRelation, FixedArityRelation)) .
\"urn:uuid:ec0cd0ea-e956-4aed-aa95-7fb8b250fb75"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, QuintaryPredicate, QuintaryPredicate)) .
\"urn:uuid:64f1b826-aab1-4daa-b7d1-a27041685820"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, UnaryPredicate, UnaryPredicate)) .
\"urn:uuid:caff33db-79e7-4e34-9f33-6840bbc0c9f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, BinaryPredicate, BinaryPredicate)) .
\"urn:uuid:4360eedc-f957-4bfa-91cb-d4a79ed07da1"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, QuaternaryPredicate, QuaternaryPredicate)) .
\"urn:uuid:2f669f78-976e-4521-acfa-3aaf19960f3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genlPreds, TernaryPredicate, TernaryPredicate)) .
\"urn:uuid:3ce0427c-fd4c-44e8-a48a-a5e62ad2ec0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(genlPreds, VariableArityRelation, VariableArityRelation)) .
\"urn:uuid:c839f76f-cab1-4c0b-bb85-3493509db27d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genlRules, ("(#$genlRules RULE-SPEC RULE-GENL) means that the set of binding tuples that satisfy the open (universally quantified) variables in the consequent of RULE-SPEC via an application of RULE-SPEC will be a subset of the set of binding tuples that satisfy the open (universally quantified) variables in the consequent of RULE-GENL via an application of RULE-GENL.  For example, the following holds\n\n<pre>\n   (#$genlRules\n      (#$ist FOO\n        (#$implies\n          (#$and\n           (cardiacValveRepairProcedure ?CVRP #$Plication-ValvularProcedure)\n           (#$rdf-type ?PROC #$HeartValveRepair-SurgicalProcedure)\n           (contains ?CVD ?CVRP)\n           (contains ?PROC ?CVD))\n          (#$isa ?PROC #$Plication-ValvularProcedure)))\n      (#$ist FOO \n       (#$implies\n         (#$rdf-type ?X #$HeartValveRepair-SurgicalProcedure)\n         (#$isa ?X #$HeartValveRepair-SurgicalProcedure)))) </pre>\n\n\nHence, if one was looking to return instances of #$HeartValveRepair-SurgicalProcedure, all other things being equal, there would be no need to query using both of these rules.  The rule in arg2 of genlRules here would get a superset of the answers that the rule in arg1 would return.\n "^^_string))) .
\"urn:uuid:6f1e436d-90fc-4998-9787-f5d4bb84e639"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genlRules, (2))) .
\"urn:uuid:22d3db11-b2b0-4438-8154-1de25ef0dc71"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(genlRules, (1))) .
\"urn:uuid:649af52e-1641-485c-850b-36694b7a1ded"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genlRules, (2), CycLRuleAssertion)) .
\"urn:uuid:75e548fd-bc25-4730-ad07-c1fde48ed15c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(genlRules, (1), CycLRuleAssertion)) .
\"urn:uuid:e2a8bd8f-72f9-4af2-be92-275a9862bb59"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(genls, ("A instance of #$TaxonomicSlotForCollections (q.v.) and  a specialization of #$generalizations.  #$genls relates a given collection  (see #$Collection) to those collections that subsume it.  More precisely, <code>(#$genls SUBCOL SUPERCOL)</code> means that <code>SUPERCOL</code> is a supercollection of <code>SUBCOL</code>:  anything that is an instance of (see #$isa) <code>SUBCOL</code> is also an instance of <code>SUPERCOL</code>.  For example, <code>(#$genls #$Dog #$Mammal)</code> holds.  #$genls is one of the most commonly-occurring predicates in the Cyc Knowledge Base, and one of  the relations most fundamental to the Cyc ontology.  See also #$subsetOf."^^_string))) .
\"urn:uuid:449e060b-6d90-458b-87a9-dc92a0de0355"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(genls, SetTheFormat)) .
\"urn:uuid:98f52c30-d143-4f52-9ded-9048b887728f"[silk#strict] .
istAsserted(BaseKB, fanOutArg(genls, (1))) .
\"urn:uuid:fdf2b48e-6cdf-4fd4-b44a-b772c5abf296"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(genls, SetTheFormat)) .
\"urn:uuid:c4e3f157-3c0d-477c-8913-d00d9224e868"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(genls, (2), SubLExpressionType, (1), SubLExpressionType)) .
\"urn:uuid:5bd57816-6e89-4a42-aad6-42f0cc3ec270"[silk#strict] .
istAsserted(BaseKB, relationAllInstance(genls, Collection, Thing)) .
\"urn:uuid:5f7c1f9e-6741-4c10-a205-9d6811977d57"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(genls, genls, (1))) .
\"urn:uuid:8dd31563-7509-4d3e-83ee-f66a0998d182"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(genls, genls, (2))) .
\"urn:uuid:c0e1f2cc-fe2a-4fc4-983b-ba14db383149"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(genls, (2), Thing)) .
\"urn:uuid:11467051-0135-4607-b12d-42a966a15faf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(genls, (1), Thing)) .
\"urn:uuid:bb06c824-30e6-40dc-8378-1bd82d189ba9"[silk#strict] .
istAsserted(BaseKB, argIsa(genls, (2), Collection)) .
\"urn:uuid:aaf4a0b3-e9b4-466b-a390-958f4c882720"[silk#strict] .
istAsserted(BaseKB, argIsa(genls, (1), Collection)) .
\"urn:uuid:257c13fd-fe34-4e88-945b-1a66233174cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genls, (1), Collection)) .
\"urn:uuid:fce60639-72aa-4712-9086-ed8f68685682"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(genls, (2), Collection)) .
\"urn:uuid:3b446ae9-1955-4299-827e-c6c261f1e8ab"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(genls, (1), Collection)) .
\"urn:uuid:78958b40-bbb6-40a0-ae3a-03d7a491ce37"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(genls, (2), Collection)) .
istAsserted(EnglishParaphraseMt, genKeyword(genls, MetaVariableFn(("GENLS"^^_string)))) .
\"urn:uuid:68327f4c-fcdb-42b0-87f4-f57c5eda639a"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(genls, SubLExpressionType, SubLExpressionType)) .
\"urn:uuid:9388f88e-ad00-4eac-bed4-928cfa7256f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('genls-GenlDenotesSpecInstances', ("A instance of #$TaxonomicSlotForCollections (q.v.) and a specialization of #$generalizations. #$genls-GenlDenotesSpecInstances relates a given #$SubLExpressionType collection (see #$Collection) to those collections whose instances it denotes. More precisely, (#$genls-GenlDenotesSpecInstances SUBCOL SUPERCOL) means that SUBCOL is a quoted subcollection of SUPERCOL: anything that is an instance of (see #$quotedIsa) SUBCOL is a quoted instance (see #$isa) of SUPERCOL."^^_string))) .
\"urn:uuid:1cfb65e8-c82c-4cd9-8df3-9c66385bdc45"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('genls-GenlDenotesSpecInstances', (2), SubLSExpression)) .
\"urn:uuid:360501bf-13ad-45c0-bce4-622cb09ad5ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('genls-GenlDenotesSpecInstances', (2), SubLExpressionType)) .
\"urn:uuid:3f396e59-51ff-4562-953c-1a8ac0036598"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('genls-GenlDenotesSpecInstances', (1), Collection)) .
\"urn:uuid:1508e3c3-035c-4097-8b2a-03babd529cbd"[silk#strict] .
istAsserted(BaseKB, fanOutArg('genls-GenlDenotesSpecInstances', (1))) .
\"urn:uuid:bc959a4e-b362-4fd6-8fd1-8cda53f0f917"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('genls-SpecDenotesGenlInstances', ("An instance of #$TaxonomicSlotForCollections (q.v.) and a specialization of #$generalizations. #$genls-SpecDenotesGenlInstances relates a collection (see #$Collection) to those collections which denote instances of it. More precisely, (#$genls-SpecDenotesGenlInstances SUBCOL SUPERCOL) means that SUPERCOL is a quoted supercollection of SUBCOL: anything that is quoted instance of (see #$quotedIsa) SUBCOL is an instance (see #$isa) of SUPERCOL. For example, (#$genls-SpecDenotesGenlInstances #$List-Extensional #$List) holds."^^_string))) .
\"urn:uuid:25c12e2d-f637-4780-84d8-39a124c82f32"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('genls-SpecDenotesGenlInstances', (1), SubLSExpression)) .
\"urn:uuid:c05af6dd-388a-4a7a-80c0-b9ff8069a0d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('genls-SpecDenotesGenlInstances', (2), Collection)) .
\"urn:uuid:eacd81db-c60a-481e-b1f7-2dbd848884af"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('genls-SpecDenotesGenlInstances', (1), SubLExpressionType)) .
\"urn:uuid:d761713a-7a21-47af-922d-0f1dbc84c237"[silk#strict] .
istAsserted(BaseKB, fanOutArg('genls-SpecDenotesGenlInstances', (1))) .
\"urn:uuid:3613ceaa-4b54-4685-b35c-9fd3a0c9f0ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(greaterThan, ("A #$NumericComparisonPredicate that is a generalization of the  mathematical greater-than ( > ) relation to #$ScalarIntervals (q.v.) of all sorts, including quantitative intervals (see #$NumericInterval and #$MeasurableQuantity) as well as point values (see #$ScalarPointValue).  <code>(#$greaterThan VALUE1 VALUE2)</code> means that  <code>VALUE1</code> is greater than <code>VALUE2</code> with respect to some scale that they  are both on.  More precisely, there is some #$TotallyOrderedScalarIntervalType SCALE that both <code>VALUE1</code> and <code>VALUE2</code> are instances of and either (i) <code>SCALE</code> is a specialization of  #$NumericInterval (e.g. #$RealNumber) and the minimum (see #$minQuantValue) of <code>VALUE1</code> is greater than the maximum (see #$maxQuantValue) of <code>VALUE2</code> or (ii) <code>(#$followingValueOnScale VALUE2 VALUE1 SCALE)</code> holds."^^_string))) .
\"urn:uuid:dc0f7004-7b35-47b4-be7c-fae0647e1bc9"[silk#strict] .
istAsserted(BaseKB, elInverse(greaterThan, lessThan)) .
\"urn:uuid:ee32addd-7b2b-4421-900d-26bf6616c57b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(greaterThan, (2), ScalarInterval)) .
\"urn:uuid:e10798b8-101c-4232-9ba1-582901e2750a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(greaterThan, (1), ScalarInterval)) .
\"urn:uuid:f9470ade-631b-402c-8c3c-df36273d1330"[silk#strict] .
istAsserted(BaseKB, argIsa(greaterThan, (1), ScalarInterval)) .
\"urn:uuid:9b69aac4-e449-45ba-88f0-aa3ec197d702"[silk#strict] .
istAsserted(BaseKB, argIsa(greaterThan, (2), ScalarInterval)) .
\"urn:uuid:71c7ecb5-39dd-4030-a633-7e9bf86dc62e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(greaterThan, SetTheFormat)) .
\"urn:uuid:883528d7-7da3-4069-917d-a77df36a2178"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(greaterThan, SetTheFormat)) .
\"urn:uuid:c0a27f71-446d-443b-a9c1-340c11a66f64"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(greaterThan, SubLSymbolFn(("CYC-GREATER-THAN"^^_string)))) .
\"urn:uuid:42ef3606-73f8-48f9-8cf5-41ae9474a4de"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(greaterThan, quantitySubsumes, (2))) .
\"urn:uuid:e7e93a9b-3b24-4e17-8fa5-822f899e7c71"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(greaterThan, greaterThan)) .
\"urn:uuid:28037f2d-6f8d-4dc2-bb8c-3ae8a81c59e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(greaterThanOrEqualTo, ("A #$NumericComparisonPredicate (q.v.) that is a generalization of the mathematical greater-than-or equal-to <code>(>=)</code> relation to #$ScalarIntervals (q.v.) of all sorts, including quantitative intervals (see #$NumericInterval and #$Quantity) as well as point values (see #$ScalarPointValue).  <code>(#$greaterThanOrEqualTo VALUE1 VALUE2)</code> means that <code>VALUE1</code> is greater than or equal to <code>VALUE2</code> with respect to some scale that they are both on.  More precisely, there is some #$TotallyOrderedScalarIntervalType <code>SCALE</code> that both <code>VALUE1</code> and <code>VALUE2</code> are instances of and either (i) <code>SCALE</code> is a specialization of #$NumericInterval (e.g. #$RealNumber) and the minimum (see #$minQuantValue) of <code>VALUE1</code> is greater than or equal to the maximum (see #$maxQuantValue) of <code>VALUE2</code>, (ii) <code>(#$followingValueOnScale VALUE2 VALUE1 SCALE)</code> holds, or (iii) <code>(#$equals VALUE1 VALUE2)</code> holds.\n<p>\nSee also #$greaterThan and #$lessThanOrEqualTo."^^_string))) .
\"urn:uuid:80b81db6-707c-4175-b4b6-5a79828f146a"[silk#strict] .
istAsserted(BaseKB, elInverse(greaterThanOrEqualTo, lessThanOrEqualTo)) .
\"urn:uuid:38eea0c7-7ce3-4503-82ae-b7c408bd4c09"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(greaterThanOrEqualTo, (1), ScalarInterval)) .
\"urn:uuid:0ccba479-9dc7-40f4-a783-3abfd142f892"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(greaterThanOrEqualTo, (2), ScalarInterval)) .
\"urn:uuid:d10786c2-0042-4814-9037-4b1c576fe0f8"[silk#strict] .
istAsserted(BaseKB, argIsa(greaterThanOrEqualTo, (1), ScalarInterval)) .
\"urn:uuid:b37ce3e5-d880-4bb3-8832-1f56444f6ea1"[silk#strict] .
istAsserted(BaseKB, argIsa(greaterThanOrEqualTo, (2), ScalarInterval)) .
\"urn:uuid:982643a8-f95e-4672-8886-a69c46e6969b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(greaterThanOrEqualTo, SetTheFormat)) .
\"urn:uuid:14d74ae3-87ac-4855-bf27-99456146644c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(greaterThanOrEqualTo, SetTheFormat)) .
\"urn:uuid:95c09f62-7a54-4b18-840d-86f91ec63575"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(greaterThanOrEqualTo, SubLSymbolFn(("CYC-GREATER-THAN-OR-EQUAL-TO"^^_string)))) .
\"urn:uuid:6a8a2a0e-53f5-46c4-90f1-52cfa4d84c7b"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(greaterThanOrEqualTo, lessThan)) .
\"urn:uuid:61d3dfdd-cbb7-4e90-9d2e-e3b04677040d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(highlyRelevantAssertion, ("A #$CycInferenceHeuristicRelevancePredicate. <code>(#$highlyRelevantAssertion ASSERTION)</code> states that the #$CycLAssertion <code>ASSERTION</code> should be heuristically considered highly relevant to inferences that are performed in a context in which <code>(#$highlyRelevantAssertion ASSERTION)</code> is visible.  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:035265aa-e7f5-40f5-bc5f-400fdfa13d6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(highlyRelevantAssertion, (1))) .
\"urn:uuid:69e1c309-fa89-4c47-8447-038fb223649f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(highlyRelevantAssertion, (1), CycLAssertion)) .
\"urn:uuid:81638561-8539-47bb-b225-53c35d736ca9"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(highlyRelevantAssertion, irrelevantAssertion)) .
\"urn:uuid:b4fe48b3-970e-44c4-b9ac-705ffc6a967f"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(highlyRelevantMt, irrelevantMt)) .
\"urn:uuid:7b3fffd0-add6-4670-997e-d5087325430b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(highlyRelevantMt, ("A #$CycInferenceHeuristicRelevancePredicate. (#$highlyRelevantMt MT) means that all assertions in the #$Microtheory MT should be heuristically considered highly relevant to inferences done in the #$Microtheory MT-1 in which (#$highlyRelevantMt MT) is asserted (where MT-1 and MT need not be the same).  As a consequence, note that when (#$highlyRelevantMt MT) is asserted in a #$Microtheory MT-1, each of the assertions in MT will be a #$highlyRelevantAssertion (q.v.) for inferences done in MT-1."^^_string))) .
\"urn:uuid:63675961-7a31-437b-8fb7-7b1ee396b05f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(highlyRelevantMt, (1), Microtheory)) .
\"urn:uuid:9dbf984b-661c-4e80-940c-29c329c1ef3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(highlyRelevantPredAssertion, ("(#$highlyRelevantPredAssertion PREDICATE ASSERTION) states that the given ASSERTION should be heuristically considered highly relevant to inferences concluding uses of the given PREDICATE in the current mt.  See also other instances #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:12792cdb-ae1f-42ea-b3ed-4c151dccba4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(highlyRelevantPredAssertion, (1), Predicate)) .
\"urn:uuid:f6a2647e-25ee-4de8-b9df-522a115e5749"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(highlyRelevantPredAssertion, (2), CycLAssertion)) .
\"urn:uuid:ba6ca3fa-a643-4cd2-8848-5aef29a0c000"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(highlyRelevantPredAssertion, (2))) .
\"urn:uuid:22b59344-ceb1-45b9-8cb1-ad0633c9dbe0"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(highlyRelevantPredAssertion, irrelevantPredAssertion)) .
\"urn:uuid:fbcf2e90-c856-4d91-a4c7-ea6bdcbae44d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(highlyRelevantTerm, ("A #$CycInferenceHeuristicRelevancePredicate. (#$highlyRelevantTerm TERM) states that the #$CycLClosedDenotationalTerm TERM should be heuristically considered highly relevant to inferences made in the current #$Microtheory.  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:506a720f-8677-45e4-b3d1-44c854616573"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(highlyRelevantTerm, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:3e9ed110-d4b3-4394-b548-0e9bc2cbf568"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(highlyRelevantTerm, (1))) .
\"urn:uuid:0d2d87c5-d63d-4dbe-ab79-4ddf04d8a190"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(highlyRelevantTerm, (1), Thing)) .
\"urn:uuid:323d70c6-2c2d-4c42-b874-ede9cafd0b05"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(hlPrototypicalInstance, ("(#$hlPrototypicalInstance TERM COL) means that TERM is a prototypical instance of COL at the HL.  It is assumed that TERM has only two asserted assertions on it: one #$hlPrototypicalInstance assertion and one assertion of the form (#$isa TERM COL).  The #$CycInferenceEngine makes use of the prototypical instance during assertions to cache the work done by forward inference.  It is used when asserting the first #$isa assertion on a term with no other assertions about it yet.  <b>Do not assert #$comments, #$cyclistNotes or any other assertions on prototypical instances.</b>  They are intentionally minimal."^^_string))) .
\"urn:uuid:d5a87ead-a7b9-4081-bd36-9e9ba1c0c9fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(hlPrototypicalInstance, (1), Thing)) .
\"urn:uuid:79981b6e-f0b3-4fec-96d9-f2bdf799cebd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(hlPrototypicalInstance, (2), Collection)) .
\"urn:uuid:3a2164bf-e505-4225-ab8e-094d3ac110b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(hlPrototypicalInstance, (1), HLPrototypicalTerm)) .
\"urn:uuid:04698d4d-bce5-489a-b233-c7ef387ac4ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(hlPrototypicalInstance, (1), CycLIndexedTerm)) .
\"urn:uuid:08a5c3d4-4542-40ef-bce4-33beea9e715f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(hlPrototypicalInstance, (1))) .
\"urn:uuid:aa23c46a-d0f8-4a20-9d70-b5ae8b2e4268"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(holdsIn, ("An instance of both #$TemporalPredicate and #$ModalPredicate that is used to state (in a somewhat indirect way) that a given sentence is true during a certain time period.  <code>(#$holdsIn TEMP SENT)</code> means that <code>SENT</code> is true at every moment in the #$temporalExtent (q.v.) of the #$TemporalThing <code>TEMP</code>.\n<p>\nFor example, the sentence <code>(#$holdsIn (#$YearFn 2003) (#$hasPets #$Curtis #$Patches-Cat))</code> means that throughout all of the year 2003 Curtis had Patches as a pet.  This entails (e.g.) that Curtis had Patches on 5 July 2003:\n<pre>\n  (#$holdsIn\n    (#$DayFn 5 (#$MonthFn #$July (#$YearFn 2003)))\n    (#$hasPets #$Curtis #$Patches-Cat))</code> .\n</pre>\n<p>\nSimilarly, <code>(#$holdsIn #$Patches-Cat (#$hasPets #$Curtis #$Patches-Cat))</code> means that Curtis has Patches as a pet for Patches's entire life.\n<p>\nSee also the more general predicate #$holdsSometimeDuring.\n<p>\nNote that a sentence of the form <code>(#$holdsIn TEMP (PRED ... ARGi ...))</code>, where <code>ARGi</code> is a #$TemporalThing, does <i>not</i> in general imply that <code>ARGi</code> temporally subsumes or even temporally intersects <code>TEMP</code>.  For example, <code>(#$holdsIn (#$YearFn 2003) (#$awareOf #$Curtis #$GeorgeWashington))</code> obviously doesn't imply that #$GeorgeWashington was alive in 2003.  <code>ARGi</code>'s temporally subsuming <code>TEMP</code> <i>does</i> follow, however, if <code>PRED</code> is a #$CotemporalPredicate that is #$contemporaryInArg (q.v.) in its <code>i</code>th argument-place (as #$hasPets is, in both argument-places).\n<p>\nNote also that there are two other ways to temporally-qualify sentences in CycL, which do not involve using #$holdsIn (or #$holdsSometimeDuring).  Both involve temporally qualifying the #$Microtheory in which the (otherwise unqualified) sentence is asserted, and either can be used to state something roughly equivalent to a #$holdsIn sentence.  Consider the first Curtis/Patches example above.  First, one could assert <code>(#$hasPets #$Curtis #$Patches-Cat)</code> in some microtheory <code>MT</code> such that <code>(#$holdsInTime-Always MT (#$YearFn 2003))</code>.  Second, one could assert <code>(#$hasPets #$Curtis #$Patches-Cat)</code> in a microtheory <code>MT'</code> such that both <code>(#$mtTimeIndex MT' (#$YearFn 2003))</code> and <code>(#$mtTimeParameter MT' #$TimePoint)</code> hold.  This later method, being the most developed and well-supported, is generally preferred over the others.\n<p>\nNote finally that it would be incorrect to assert a sentence like <code>(#$hasPets #$Curtis #$Patches-Cat)</code> in a non-temporally-qualified microtheory like the #$BaseKB, since Curtis didn't have Patches when (e.g.) he was a young boy, let alone in 3500 BCE."^^_string))) .
\"urn:uuid:a23796bf-06ce-4bb5-ab4d-d3410a77fcba"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(holdsIn, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:76d8a8f3-843b-4fd5-bd68-74ec65dbcfb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(holdsIn, (2))) .
\"urn:uuid:a1fc8e57-63cf-4513-a667-8c7943219d8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(hypotheticalTerm, (1), Thing)) .
\"urn:uuid:dd8b60c6-c0ca-4ca5-affd-485a410bfcdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(hypotheticalTerm, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:231a8dd8-e6e2-4d44-8f7d-a8938c4bcd20"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentAsserted(hypotheticalTerm)) .
\"urn:uuid:d0db9a7b-47e2-464b-a2f6-8c9d2e72bdef"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(hypotheticalTerm)) .
\"urn:uuid:d9b9761a-0fb5-426e-8cd8-b5bd75b6d680"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(hypotheticalTerm, (1))) .
\"urn:uuid:522976e2-c448-49ab-9f09-188897676bdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(hypotheticalTerm, ("(#$hypotheticalTerm TERM) states that TERM is a term that was hypothesized.  The most common reason a term is hypothesized is to pose a hypothetical query to Cyc."^^_string))) .
\"urn:uuid:9f27b3e3-8ee7-4a2c-ae4e-a320d976ee38"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(implies, ("A binary #$LogicalConnective (q.v.) that corresponds to the material implication operator of propositional calculus.  The #$implies relation takes two #$CycLSentence-Assertibles as its arguments; and the syntactic result of applying the term '#$implies' to two sentences is itself a sentence, called a ''conditional'' or ''implication''.  A sentence of the form (#$implies ANTECEDENT CONSEQUENT) is true if and only if ANTECEDENT is false or CONSEQUENT is true (or both).  Equivalently: it is not the case that ANTECEDENT is true and CONSEQUENT is false.  For example,\n<p>\n<pre>\n  (#$implies\n    (#$knows #$Muffet #$Patches-Cat)\n    (#$likesAsFriend #$Muffet #$Patches-Cat))\n</pre>\n<p>\nmeans that if Muffet knows Patches then she likes him.\n<p>\nCf. the predicate #$sentenceImplies, which is not a logical connective, and is primarily used in rules involving quantification over CycL sentences."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(implies, MetaVariableFn(("IMPLIES"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(implies, ("if ~a, then ~a"^^_string), TheEmptyList)) .
istAsserted(BookkeepingMt, oldConstantName(implies, ("LogImplication"^^_string))) .
\"urn:uuid:a49ca2f1-79f3-4380-85e0-56ed51f02cd5"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(implies, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:40530ed7-b655-4532-aa3b-4a5de2342b23"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(implies, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:a1636891-cc92-4c67-9f3b-dd77cd4a0fe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(implies, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:0ed02a97-098c-4989-bead-fecbdfbfb503"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(implies, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:052f0a28-ee81-414c-b5fb-1de815eadb51"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(implies, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:84b79d17-bef4-413e-a9f2-e52de06e4759"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(implies, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:2ce36c24-087f-49b0-9436-fe36427d6c3c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(implies, (2))) .
\"urn:uuid:3f123bb1-0179-4831-aa1d-3123f3aa3ee7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(implies, (1))) .
\"urn:uuid:5fa36387-8006-4fad-a2c7-d04f767a0cd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(independentArg, ("A #$MetaPredicate that is used to state, of a given\n(ternary) #$InterArgConstraintPredicate, that it is (always) used to constrain a relation in such a way that a certain specified argument-place of the relation is for the ''independent'' argument (with respect to that constraint).  (#$independentArg INT-ARG-PRED N) means that any sentence of the form (INT-ARG-PRED RELN ...) constrains RELN in some way that treats RELN's Nth argument as independent.  For example, (#$independentArg #$interArgIsa3-4 3) holds.  See the comment on #$InterArgConstraintPredicate for an explanation of what it means to be an ''independent'' argument in this sense.  Note that #$independentArg is contrained to apply only to _ternary_ inter-argument constraint predicates, as only they have already-fixed positions for the corresponding independent and dependent arguments; thus it cannot (on pain of semantic malformedness) be applied to the quintary inter-argument constraint predicates, such as #$interArgIsa."^^_string))) .
\"urn:uuid:ee2e5b61-d603-4bb6-b5c1-6d3836e6852d"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(independentArg, (2))) .
\"urn:uuid:e606cc41-7e30-45d0-ab3f-1d94d92c0ea8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(independentArg, (1), TernaryPredicate)) .
\"urn:uuid:7a3fe824-2573-4685-98f9-da3c47d663cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(independentArg, (2), NonNegativeInteger)) .
\"urn:uuid:51081554-bc75-4c4c-955d-4dd0945711c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(independentArg, Thing, Thing, (1))) .
\"urn:uuid:389d9f52-d998-4c84-b420-ad8912965d37"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(independentArg, SingleEntry)) .
\"urn:uuid:1e8bb566-adfe-4cdd-87d6-c005e281b7a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(independentArg, SetTheFormat)) .
\"urn:uuid:1c48e926-335b-4539-b218-cf2d042fad3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(indexicalReferent)) .
\"urn:uuid:1bf113a1-ad89-4931-90c0-c64224f41141"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(indexicalReferent, ("(#$indexicalReferent INDCONCEPT THING) means that in the context of the assertion, the #$IndexicalConcept INDCONCEPT has the referent THING.  This is a #$StrictlyFunctionalSlot, in keeping with the idea that the predicate will return one and only one 'value' for the second argument place at any given point in context space.  However, be advised that the arg2 will change from context to context."^^_string))) .
\"urn:uuid:465ad2f9-ff23-4faa-86d3-91f2ad077211"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(indexicalReferent, (2))) .
\"urn:uuid:de24ccd6-f613-4b88-a706-03ddb1599880"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(indexicalReferent, (1), Thing)) .
\"urn:uuid:24f40d79-f3da-47e8-8239-c531cb0fde40"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(indexicalReferent, (2), Thing)) .
\"urn:uuid:3ba3660e-b84f-4c0d-8ed8-a76a05b516e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(indexicalReferent, Thing, Thing, (1))) .
istAsserted(EnglishParaphraseMt, genFormat(indexicalReferent, ("the indexical term ~a refers to ~a"^^_string), [[(1), MetaVariableFn(("QUOTE"^^_string))], (2)])) .
\"urn:uuid:24bcc653-e573-44e8-a7dc-984727b4dd8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(indexicalReferent)) .
\"urn:uuid:fc9b88e1-d372-43fe-9cd1-87c4454aec90"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForValueInArg(indexicalReferent, ThisProblemStore, (1))) .
\"urn:uuid:4a4ea8f2-a730-4d3d-8ae6-08d986791f67"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForValueInArg(indexicalReferent, ThisInference, (1))) .
\"urn:uuid:365aa819-811b-41fa-ad11-3d21f52ab085"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForValueInArg(indexicalReferent, QueryMt, (1))) .
\"urn:uuid:1dc4a6cf-cf89-431c-b8d5-8cabf7d4c0f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForValueInArg(indexicalReferent, TheUser, (1))) .
\"urn:uuid:ef42cd41-e60e-4b01-a2af-fd89ba1a643b"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(indexicalReferent, (1))) .
\"urn:uuid:27f48ce6-72b8-411c-9da5-631b4aa6548c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(instanceElementType, ("A binary #$FirstOrderCollectionPredicate that relates types of sets to the types of elements they have in common.  More precisely, <code>(#$instanceElementType SETTYPE COLLECTION)</code> means that every #$elementOf every instance of (see #$isa) <code>SETTYPE</code> is an instance of <code>COLLECTION</code>.  For example, both of these hold:\n<pre>\n  (#$instanceElementType #$PointSet #$Point)\n\n  (#$instanceElementType #$Set-Mathematical #$Thing) . \n</pre>\nSee the corresponding function #$SetOfTypeFn, which takes a given collection to the collection of <i>all</i> sets whose elements are instances of the former.  And see #$typeGenls for a similar predicate that relates collections of <i>collections</i> (rather than collections of sets) to their common element types."^^_string))) .
\"urn:uuid:4499e753-f85a-4c21-bd43-56bcb8d03aca"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(instanceElementType, (2), Thing)) .
\"urn:uuid:9b59e8c2-6c7c-4c5e-8ef6-5d228417fb1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(instanceElementType, (1), 'Set-Mathematical')) .
\"urn:uuid:42ef3449-4a34-44f4-ae4a-bc0b6d420643"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentAsserted(instanceElementType)) .
\"urn:uuid:550acdc8-11ba-4831-a455-32b450fdd8aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(instanceElementType, (1), Collection)) .
\"urn:uuid:67800e8a-da9c-4265-b9be-b4cd4c29fd1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(instanceElementType, (2), Collection)) .
\"urn:uuid:b014f99b-5088-4b5f-aede-4f32b06bc05f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(instanceElementType)) .
\"urn:uuid:85ac6223-0074-44c3-83d4-99e0d7865ec1"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(integerBetween)) .
\"urn:uuid:c36d4cb6-3697-4c77-8330-09a7c00424eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(integerBetween, ("A ternary #$IntangibleObjectRelatingPredicate that holds among #$Integers only.  <code>(#$integerBetween LOW MED HIGH)</code> means that <code>HIGH</code> is #$greaterThanOrEqualTo <code>MED</code>, and <code>MED</code> is #$greaterThanOrEqualTo <code>LOW</code>."^^_string))) .
\"urn:uuid:11a0e8da-c646-4496-a6db-4af2728abb57"[silk#strict] .
istAsserted(BaseKB, notAssertible(integerBetween)) .
\"urn:uuid:7fc0b961-fdeb-483c-83f4-2c45282cd7be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(integerBetween, (3), Integer)) .
\"urn:uuid:478d1115-1990-43a2-abb7-433c0ed99a7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(integerBetween, (1), Integer)) .
\"urn:uuid:ecff0ae0-1e67-43c3-aa4e-387927c60fae"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(integerBetween, (2), Integer)) .
\"urn:uuid:ac3c5956-c954-482d-a056-0b20ca71ce9b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(integerBetween, openEntryFormatInArgs)) .
\"urn:uuid:71f9ec15-2939-4fe6-9a28-8e329749df9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(integerBetween, openEntryFormatInArgs)) .
\"urn:uuid:d01e8fbb-6405-48b7-94c3-808fdedf7e14"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(integerBetween)) .
\"urn:uuid:deedb8ff-82a6-4dd4-a9c2-565d85895622"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(integerBetween)) .
\"urn:uuid:5f56e16c-0ee3-4d40-b329-56f975081358"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(integerBetween, openEntryFormatInArgs)) .
\"urn:uuid:13b86419-7afa-49eb-9d62-82d7f60cf16e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgDifferent, ("A #$MetaRelation used for stating a certain kind of necessary condition for being an element of the domain of a given #$Relation (see #$relationDomain).  Thus (to put it in terms of the semantics of CycL expressions) #$interArgDifferent can be used for stating a certain kind of truth- or denotation-condition for a given relation-denoting expression.  (#$interArgDifferent RELN N M) means that RELN (if it is a #$Predicate or other #$TruthFunction) only holds among or (if it is a #$Function-Denotational) only has a value for sequences of arguments whose Nth and Mth members are distinct (see #$different).  That is (assuming without loss of generality that N < M): if RELN is a predicate or other ''truth-function'' then (RELN ... ARGN ... ARGM ...) holds only if ARGN and ARGM are distinct, and if RELN is a function then it is defined for (i.e. associates a value with) a sequence <THING-1, ..., THING-N, ..., THING-M, ...> only if THING-N and THING-M are distinct.  For example, (#$interArgDifferent #$opponentsInConflict 1 2) means that no-one is his or her own opponent in a conflict.\n<p>\nNote that this predicate trivially holds for any relation with respect those argument-places it has that are subject to mutually disjoint (see #$disjointWith and cf. #$cosatisfiableInArgs) argument-type constraints (see #$ArgTypePredicate)."^^_string))) .
\"urn:uuid:27d1b792-6dcc-4d98-a6fe-cb673def3c48"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgDifferent, (2), PositiveInteger)) .
\"urn:uuid:2ff82e33-b37e-460a-97c0-afe9fdebcee0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgDifferent, (1), Relation)) .
\"urn:uuid:cadb76e3-5f2b-4633-939b-ef53d98e2625"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgDifferent, (3), PositiveInteger)) .
\"urn:uuid:19bdab32-d6a6-480e-87b6-dd0be326a491"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgDifferent, SetTheFormat)) .
\"urn:uuid:0231d807-70ef-43cb-8ad8-50ec241b192b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgDifferent, SetTheFormat)) .
\"urn:uuid:bf668f30-3575-4297-86ad-537258fd3796"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgDifferent, SetTheFormat)) .
\"urn:uuid:ac1d1616-162c-410b-8457-3170d04d60f5"[silk#strict] .
istAsserted(BaseKB, commutativeInArgs(interArgDifferent, (2), (3))) .
\"urn:uuid:c499227d-ce82-492a-8ab4-e06462a379c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgDifferent(interArgDifferent, (2), (3))) .
\"urn:uuid:cb4eb52e-b0ae-4376-823b-6bf5c096724d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgFormat1-2', ("An instance of #$InterArgFormatPredicate (q.v.).\n(#$interArgFormat1-2 PRED COL FORMAT) means that FORMAT is a #$Format (q.v.)\nrequirement for the second argument-place of PRED when PRED's first argument\nis an instance of COL.  That is, with respect to a sentence of the form \n(PRED ARG1 ARG2 ... ARGN) in which ARG1 is an instance of COL, PRED's arg2\nposition (i.e. the position occupied by the metavariable `ARG2' in the \npreceding sentence-form) is subject to FORMAT.  See #$Format and its instances \nfor further explanation."^^_string))) .
\"urn:uuid:bd68c70a-90a6-4b0a-8303-e032c96fc0ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgFormat1-2', (1))) .
\"urn:uuid:2e2d6be0-6a83-4c30-a52e-8f26dfcea2d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgFormat1-2', (2), Thing)) .
\"urn:uuid:a21616ea-04e6-47a5-a3e2-9f85749b97cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgFormat1-2', (2), Collection)) .
\"urn:uuid:f03c4001-2c8b-4e17-929b-5af5f2376954"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgFormat1-2', (1), Predicate)) .
\"urn:uuid:d0c7ce6c-743a-405e-9b0b-d1431f76f1a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgFormat1-2', SetTheFormat)) .
\"urn:uuid:93b629ac-0d0c-4bf9-a93e-31d375d4f877"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgFormat1-2', SetTheFormat)) .
\"urn:uuid:97a74c88-bab3-42cd-a98f-f6443dbca5fa"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgFormat1-2', (2))) .
\"urn:uuid:7858155e-a2bc-44de-b044-1e81fae72ece"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgGenl1-2', ("(#$interArgGenl1-2 REL INDEPENDENT-COL DEPENDENT-COL) means that, when a spec of INDEPENDENT-COL appears as the first argument to REL, the second argument is constrained to be a spec of DEPENDENT-COL."^^_string))) .
\"urn:uuid:f5d7e451-ac2c-4fdb-8ade-e59b512e8938"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgGenl1-2', (1))) .
\"urn:uuid:1fc019a0-ab4d-41cc-9b72-deb9055972f1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgGenl1-2', (3), Collection)) .
\"urn:uuid:aaed2323-1428-49ec-be0b-cd2ccedbed7e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgGenl1-2', (1), Relation)) .
\"urn:uuid:b90aa988-5267-4f09-a593-c83162cc0a3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgGenl1-2', (2), Collection)) .
\"urn:uuid:079f9c1c-2571-43e4-825d-b1673c3b1149"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgGenl1-2', (2))) .
\"urn:uuid:112e733b-64a9-43f6-8d97-5bd907dba3cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgIsa, ("A quintary instance of #$InterArgIsaPredicate (q.v.).   <code>(#$interArgIsa RELN INDEP-ARGNUM INDEP-COL DEP-ARGNUM DEP-COL)</code> means that,  when an instance of <code>INDEP-COL</code> appears as the <code>INDEP-ARGNUM</code>th argument to <code>RELN</code>,  a necessary condition for semantic well-formedness is that the <code>DEP-ARGNUM</code>th argument must be an instance of <code>DEP-COL</code>.  That is, if <code>INDEP-INST</code> is an instance of <code>INDEP-COL</code>, then <code>(RELN</code> ... <code>INDEP-INST</code> ...), where <code>INDEP-INST</code> is the <code>INDEP-ARGNUM</code>th (or ''independent'') argument to <code>RELN</code>, is semantically well-formed only if the <code>DEP-ARGNUM</code>th (or ''dependent'') argument (which is some item in the sequence <... <code>INDEP-INST</code> ...> other than the <code>INDEP-ARGNUM</code>th) is an instance of <code>DEP-COL</code>.\n<p>\nFor example, (#$interArgIsa #$performedBy 1 #$PurposefulAction 2 #$IntelligentAgent) means that, if <code>ACT</code> is a #$PurposefulAction, then <code>(#$performedBy ACT AGENT)</code> is semantically well-formed only if <code>AGENT</code> is an #$IntelligentAgent.\n<p>\nFor an explanation of semantic well-formedness, see #$CycLExpression-Assertible and its direct specializations.  For a more general explanation of independent and dependent arguments in the present sense, see #$InterArgConstraintPredicate.  For similar to but less flexible predicates than #$interArgIsa, which have already-fixed positions for the independent and dependent arguments, see the ternary #$interArgIsa1-2 et al."^^_string))) .
\"urn:uuid:e7d2e14f-9ab2-442d-bfdc-774d217a2728"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgIsa, (5), Thing)) .
\"urn:uuid:a2e263f8-8c60-4e3e-bffb-751e1c22ab3a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgIsa, (3), Thing)) .
\"urn:uuid:3699ec0d-6b8d-477a-8725-98481b4919c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgIsa, (3), Collection)) .
\"urn:uuid:6b464b34-c2ce-4385-890a-43535400bb72"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgIsa, (2), PositiveInteger)) .
\"urn:uuid:d06106d9-0245-4c26-a676-ed3851e9850a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgIsa, (4), PositiveInteger)) .
\"urn:uuid:b49a1013-d7df-4b68-b6e8-b914670928ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgIsa, (5), Collection)) .
\"urn:uuid:7137c114-06e0-47cc-a799-3bc6634e07ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgIsa, (1), Relation)) .
\"urn:uuid:d727da01-7461-4514-8b10-ae13fb5bfe57"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgIsa, SetTheFormat)) .
\"urn:uuid:56112572-cea2-400b-9f2c-47a6bc50ecc9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgIsa, SetTheFormat)) .
\"urn:uuid:6b8e700d-e12f-4127-bc84-eb7c21b798fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgIsa, SetTheFormat)) .
\"urn:uuid:b7f50fa2-2e59-4b05-9719-ac89db67cfe1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(interArgIsa, SetTheFormat)) .
\"urn:uuid:cbf2e514-e2c5-42de-9a28-533f1c50c3e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Format(interArgIsa, SetTheFormat)) .
\"urn:uuid:97fdc726-bee3-49c6-aef4-6b638a90b0b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa1-2', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  <code>(#$interArgIsa1-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL)</code> means that, when an instance of <code>INDEPENDENT-ARG-COL</code> appears as the first argument to <code>RELN</code>, a necessary condition for semantic well-formedness is that the second argument must be an instance of <code>DEPENDENT-ARG-COL</code>.  That is, if <code>INST</code> is an instance of <code>INDEPENDENT-ARG-COL</code>, then <code>(RELN INST ARG2 ... ARGN)</code> is semantically well-formed only if <code>ARG2</code> is an instance of <code>DEPENDENT-ARG-COL</code>.\n<p>\nFor example, (#$interArgIsa1-2 #$performedBy #$PurposefulAction #$IntelligentAgent) means that, if <code>ACT</code> is a purposeful action, then (#$performedBy <code>ACT AGENT</code>) is semantically well-formed only if <code>AGENT</code> is an intelligent agent.  For an explanation of semantic well-formedness, see  #$CycLExpression-Assertible and its direct specializations.  See #$interArgIsa for a similar but more general predicate that is quintary, allowing the user to specify the positions of the independent and dependent arguments.\n<p>\nUse #$interArgCondIsa1-2 to conclude that arg2 is an instance of <code>DEPENDENT-ARG-COL</code> instead of having that as a constraint."^^_string))) .
\"urn:uuid:cb8234a4-e55d-4dd6-a3e6-aa2ef166f40a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-2', (3), Thing)) .
\"urn:uuid:7346e3f9-5ff1-40ac-98be-7f29d310920e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-2', (2), Thing)) .
\"urn:uuid:700adb82-0d69-4809-9b47-daa98dd23512"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa1-2', (1))) .
\"urn:uuid:26b31aef-e225-4b1d-a8ef-3532865521bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-2', (2), Collection)) .
\"urn:uuid:c35bebaa-4743-4b12-8c80-ba065baecadb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-2', (1), Relation)) .
\"urn:uuid:459e1380-b78f-4637-afa9-fc5dce6425d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-2', (3), Collection)) .
\"urn:uuid:8387c0eb-c360-47b0-833d-dbba64578cfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa1-2', SetTheFormat)) .
\"urn:uuid:6c2459f8-035c-46bd-ae3a-4744c1b0ddf3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa1-2', SetTheFormat)) .
\"urn:uuid:4a2b2a9e-3726-4a5c-9260-c1234b62a2c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa1-2', SetTheFormat)) .
\"urn:uuid:5d7d5d70-f2ce-49c6-9f8d-fee3b13958b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-2', genls, (2))) .
\"urn:uuid:98080565-b6bf-487a-86dd-f8b3996de5fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-2', genlPreds, (1))) .
\"urn:uuid:2c3dec59-d287-489a-95b2-52eb8ea2661a"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa1-2', genls, (3))) .
\"urn:uuid:ea51c6a7-7e51-4248-b409-f642701c1015"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa1-2', (2))) .
\"urn:uuid:1d2ab2be-6761-4bb1-970e-06566a6d776a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa1-3', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa1-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:6330d92e-7f1a-439d-9b07-c757f0d2ba35"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-3', (2), Thing)) .
\"urn:uuid:9070c760-1c94-4bfa-a631-d99c84fac715"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-3', (3), Thing)) .
\"urn:uuid:cd41cc02-51dc-4821-aebf-a4cd30d4ce12"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa1-3', (1))) .
\"urn:uuid:149e1c64-4dcd-4879-b1cc-a595d132516e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-3', (3), Collection)) .
\"urn:uuid:bf0e7488-8849-4b90-81b8-f7b13d7a7e78"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-3', (2), Collection)) .
\"urn:uuid:e4f69b18-86cc-42d7-a8b2-09744250f93c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-3', (1), Relation)) .
\"urn:uuid:678f2728-4448-4dad-ab3d-a2f926bff30d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa1-3', SetTheFormat)) .
\"urn:uuid:6c50f8c5-957d-476d-9f28-73f96364b7ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa1-3', SetTheFormat)) .
\"urn:uuid:29a3caa3-debc-4ace-9213-5fc6945c9f74"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa1-3', SetTheFormat)) .
\"urn:uuid:af3552df-ba6f-4147-9564-2f5a7f1a5158"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-3', genls, (2))) .
\"urn:uuid:54ff5251-c5e5-4b72-a352-6294f5544003"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-3', genlPreds, (1))) .
\"urn:uuid:2c0c692a-d0ec-47ca-8176-7082c719bea1"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa1-3', genls, (3))) .
\"urn:uuid:ddf3cea5-a92d-45a5-9e33-15a0e97f4563"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa1-3', (3))) .
\"urn:uuid:75dbf814-b06c-4496-bdfc-6c6a9c2b7385"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa1-4', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa1-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:5370d43d-101b-4fc2-939b-4fb77507872d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-4', (3), Thing)) .
\"urn:uuid:d61a950a-2e21-40e3-8d1f-d81b6609d697"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-4', (2), Thing)) .
\"urn:uuid:0c41bebb-a5a7-408c-aeb6-7dcdbd3b36d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa1-4', (1))) .
\"urn:uuid:9083755c-a653-4960-a435-b70513c1d81e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-4', (1), Relation)) .
\"urn:uuid:f2e34c97-18ab-4f90-ab92-492a9eb92a40"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-4', (3), Collection)) .
\"urn:uuid:b9d147ee-c4aa-430f-af31-6122b0bbcaf6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-4', (2), Collection)) .
\"urn:uuid:0d4e2abd-41e7-4169-bf66-b08695112ea8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa1-4', SetTheFormat)) .
\"urn:uuid:16ac8a20-a755-426b-a674-d44c2dad6f86"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa1-4', SetTheFormat)) .
\"urn:uuid:fa08b9a5-be91-4abd-9047-883f92381343"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa1-4', SetTheFormat)) .
\"urn:uuid:8e597307-fd58-47b3-bc9c-6bf6e51090ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-4', genlPreds, (1))) .
\"urn:uuid:9dd822e8-635c-476a-ab75-f44a644e8a02"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-4', genls, (2))) .
\"urn:uuid:a45257ac-0505-4a33-82f2-1d9f48718cd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa1-4', genls, (3))) .
\"urn:uuid:e59dc56b-aad0-4a36-9c07-e9783da3bd53"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa1-4', (4))) .
\"urn:uuid:8796a753-7637-4a0d-829f-1e8dc86ac874"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa1-5', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa1-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see #$CycLExpression-Assertible and its direct \nspecializations."^^_string))) .
\"urn:uuid:7c965e6f-f279-4ffb-a043-c03ac52a6930"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-5', (3), Thing)) .
\"urn:uuid:8d27b569-0efa-45a0-9855-094ace08cb0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa1-5', (2), Thing)) .
\"urn:uuid:8f001a1a-75b6-464c-a4ec-4631aba86dd8"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa1-5', (1))) .
\"urn:uuid:d93bc4ed-3537-439d-be98-2f571e0abd85"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-5', (1), Relation)) .
\"urn:uuid:0bb17b3b-18ba-44b3-a2ec-68a149c926ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-5', (2), Collection)) .
\"urn:uuid:1e0eafd9-7f53-40b6-af7d-f306fea797ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa1-5', (3), Collection)) .
\"urn:uuid:71dd141b-2de7-4b00-989e-5a3e2f916425"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa1-5', SetTheFormat)) .
\"urn:uuid:67a463b9-cf53-4180-b829-ea51b7aeaf0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa1-5', SetTheFormat)) .
\"urn:uuid:0b1ff433-1a2e-4bfd-a07b-560d4dfcbf0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa1-5', SetTheFormat)) .
\"urn:uuid:646878aa-b1f2-4842-b9cd-196255373fc4"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-5', genlPreds, (1))) .
\"urn:uuid:55ef7bb0-bf58-413c-90ef-773b2d9df883"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa1-5', genls, (2))) .
\"urn:uuid:72b4a7ec-68c5-4feb-ba13-92737c2c9655"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa1-5', genls, (3))) .
\"urn:uuid:c34a76b7-7a68-4ba8-9089-a6e024a81f0a"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa1-5', (5))) .
\"urn:uuid:09ddde3d-75d9-4b0c-8dcb-829c92cffbd6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa2-1', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   <code>(#$interArgIsa2-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL)</code> means that,  when an instance of <code>INDEPENDENT-ARG-COL</code> appears as the second argument to <code>RELN</code>,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of <code>DEPENDENT-ARG-COL</code>.  That is, if <code>INST</code> is an instance of <code>INDEPENDENT-ARG-COL</code>, then <code>(RELN ARG1 INST ... ARGN)</code>  is semantically well-formed only if <code>ARG1</code> is an instance of <code>DEPENDENT-ARG-COL</code>. For an explanation of semantic well-formedness, see #$CycLExpression-Assertible  and its direct specializations."^^_string))) .
\"urn:uuid:871aff0b-0182-44b2-9f06-ea2f4555af91"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-1', (3), Thing)) .
\"urn:uuid:2f151412-cece-4110-b20f-606acb08c55d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-1', (2), Thing)) .
\"urn:uuid:b6835f40-8f8b-4e14-a6fd-db11f711ebda"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa2-1', (2))) .
\"urn:uuid:3cb2e59c-9baf-4d02-9510-c09dba991381"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-1', (1), Relation)) .
\"urn:uuid:db127f01-bde5-4f7d-8647-3d6c742d8780"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-1', (3), Collection)) .
\"urn:uuid:6d5ee708-5128-4fb5-98cd-e7b8c575cdda"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-1', (2), Collection)) .
\"urn:uuid:3adc160b-820c-42e1-9798-6f4a8451c1f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa2-1', SetTheFormat)) .
\"urn:uuid:9b112296-17d6-4e10-bade-7105308739d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa2-1', SetTheFormat)) .
\"urn:uuid:45508037-7669-43fd-9f3a-f6ed86bf3b64"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa2-1', SetTheFormat)) .
\"urn:uuid:e47d0f75-53ea-4a76-949d-73578371b59a"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-1', genlPreds, (1))) .
\"urn:uuid:5afa9912-227c-4982-8f9f-03658f617c58"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-1', genls, (2))) .
\"urn:uuid:ba3562ee-ccb7-4f9d-87dd-b886d11b4f5b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa2-1', genls, (3))) .
\"urn:uuid:9032f5e6-80a8-4bd1-9b06-64850c71d79d"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa2-1', (1))) .
\"urn:uuid:cdcf48e9-62fd-495a-bc42-15867435601f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa2-3', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa2-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:d1fc3298-eef5-4747-b754-542e5e2a7e63"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-3', (3), Thing)) .
\"urn:uuid:497922d8-1452-470b-8a03-cdb9e8b29d75"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-3', (2), Thing)) .
\"urn:uuid:5b2b6d3f-de72-443e-9bed-2c1fa3bcc37b"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa2-3', (2))) .
\"urn:uuid:27858a9d-0ff4-404f-9398-47b0e58e9c18"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-3', (1), Relation)) .
\"urn:uuid:e0601104-88c8-439e-985c-f9b58b3f87b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-3', (3), Collection)) .
\"urn:uuid:6b5938b0-e81e-4485-830c-5d88544f4f62"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-3', (2), Collection)) .
\"urn:uuid:fdba32a4-6bab-46fd-93dd-105c5b867c71"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa2-3', SetTheFormat)) .
\"urn:uuid:602c4091-b7ec-4a30-9f29-8703d991375f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa2-3', SetTheFormat)) .
\"urn:uuid:9aee0488-cbeb-4bf2-bd37-5e5304589aae"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa2-3', SetTheFormat)) .
\"urn:uuid:0b5a08bb-8019-43e6-8ff8-ae431d2fc990"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-3', genls, (2))) .
\"urn:uuid:fff1ebae-93e0-4774-8e77-b626d16b9c0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-3', genlPreds, (1))) .
\"urn:uuid:71c91c51-620a-491b-a8ef-86c54718ac0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa2-3', genls, (3))) .
\"urn:uuid:a13e7c53-92d3-4a2d-aa15-ae9d6174edf0"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa2-3', (3))) .
\"urn:uuid:7cb753ae-590c-4275-a10b-c43fa5b02b1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa2-4', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa2-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:f03a67e8-c7d7-404a-92e7-fbc3ee4caea9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-4', (3), Thing)) .
\"urn:uuid:422786e7-b8a3-4f86-a1e2-13eda6b87594"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-4', (2), Thing)) .
\"urn:uuid:7ca20749-c5f2-4116-bd9e-209456e907eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa2-4', (2))) .
\"urn:uuid:7631e42b-f79d-408e-986f-df95a4a60534"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-4', (3), Collection)) .
\"urn:uuid:b69301b3-5c9d-4e9e-be20-dcb94192b966"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-4', (2), Collection)) .
\"urn:uuid:fa25f1b7-cfd6-4e75-9408-2d1d248b883a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-4', (1), Relation)) .
\"urn:uuid:11f965be-b580-4e48-a3d7-843780693bff"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa2-4', SetTheFormat)) .
\"urn:uuid:ce81d0bd-f6f8-4f3d-903c-3f267031ba71"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa2-4', SetTheFormat)) .
\"urn:uuid:263719b4-8305-4f21-b37d-0d1463a0738b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa2-4', SetTheFormat)) .
\"urn:uuid:ab7d2c39-b17f-469a-87ba-b454a6ad22b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-4', genls, (3))) .
\"urn:uuid:83216c56-03cd-4e1a-9e0e-9305c83b8dfb"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-4', genlPreds, (1))) .
\"urn:uuid:d091132c-6a7a-44e6-820e-e0fc58f617c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-4', genls, (2))) .
\"urn:uuid:955e3c7a-e5ea-4498-9adb-a50694fc89a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa2-4', genls, (3))) .
\"urn:uuid:97e210ef-8b4d-4b2a-9d63-c0dfa0492307"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa2-4', (4))) .
\"urn:uuid:61f42549-2284-4422-b83f-688d6fbca08d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa2-5', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa2-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see #$CycLExpression-Assertible and its direct \nspecializations."^^_string))) .
\"urn:uuid:1b7357c7-4bd1-436f-bb15-c020ccc5d857"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-5', (3), Thing)) .
\"urn:uuid:aa3904f3-1f96-45d9-a512-6b4289bb7f93"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa2-5', (2), Thing)) .
\"urn:uuid:4af53538-82ae-4261-9aa6-93da90a1058e"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa2-5', (2))) .
\"urn:uuid:ab19faec-dfc6-4efe-82c2-d467db7d66ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-5', (2), Collection)) .
\"urn:uuid:996412d4-fe9b-466c-bd4e-ba1a0c99e830"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-5', (3), Collection)) .
\"urn:uuid:44091089-4517-4704-8654-367d720bad2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa2-5', (1), Relation)) .
\"urn:uuid:66b5606a-3621-4c05-b8ad-a5d1541e0658"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa2-5', SetTheFormat)) .
\"urn:uuid:a50ea278-0aa9-472e-8e2f-662d4f9319f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa2-5', SetTheFormat)) .
\"urn:uuid:e0fb560e-5388-4c43-9512-bfffe23fbfc7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa2-5', SetTheFormat)) .
\"urn:uuid:6b7b7231-2e92-4434-86c1-ca780f7a158e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-5', genls, (2))) .
\"urn:uuid:7af6454e-d779-41fa-ad12-69816c336ccd"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa2-5', genlPreds, (1))) .
\"urn:uuid:2c177e13-c61f-4a65-a6ba-f7b3dc1d5839"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa2-5', genls, (3))) .
\"urn:uuid:81996682-466f-4be5-bf70-367900b6cf30"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa2-5', (5))) .
\"urn:uuid:d7904646-ec9d-4946-80b5-477f6124c45d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa3-1', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa3-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 INST ... ARGN) is semantically well-formed only  if ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:6850e60c-a6e8-492a-8b6c-181ceff9490e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-1', (2), Thing)) .
\"urn:uuid:92ff114b-d8f0-477c-8ce3-84cbceb026d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-1', (3), Thing)) .
\"urn:uuid:b4c8dec7-fea7-45d8-a3c8-cb43eb1a5a2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa3-1', (3))) .
\"urn:uuid:e2ef92f5-6fd6-4c80-8abe-5c0a435bfa30"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-1', (2), Collection)) .
\"urn:uuid:7fedfdc9-e92b-4c67-a3ce-4e71c63506ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-1', (3), Collection)) .
\"urn:uuid:484c2c8d-9803-4134-9280-805a658d94d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-1', (1), Relation)) .
\"urn:uuid:9a3bdd17-034f-48cd-9fa3-af2f196239d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa3-1', SetTheFormat)) .
\"urn:uuid:aa10cf3a-f5cc-411e-a9a0-1dd2fa409198"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa3-1', SetTheFormat)) .
\"urn:uuid:bd3b2fef-ed73-4b2a-8d1b-30f30d6ad82f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa3-1', SetTheFormat)) .
\"urn:uuid:63e8d859-4854-4649-b467-99fa5d6dab21"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-1', genlPreds, (1))) .
\"urn:uuid:6a6b9a3a-66bd-486a-a1a2-c7115b7017fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-1', genls, (2))) .
\"urn:uuid:df23b67c-a4f0-451e-b9f3-48d9d2881871"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa3-1', genls, (3))) .
\"urn:uuid:37f5c72e-8bd0-4bcf-b104-7766539a54b4"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa3-1', (1))) .
\"urn:uuid:11318076-0e60-4f9e-b6ae-8b8750bd0b4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa3-2', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa3-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 INST ... ARGN) is semantically well-formed only  if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:b9d74d1c-f7cc-4f64-8948-6a1704f6c66c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-2', (2), Thing)) .
\"urn:uuid:9c4f548a-3cf9-49de-b035-e8619080cd72"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-2', (3), Thing)) .
\"urn:uuid:2eb80fdd-06b7-4f38-b56b-b18ac4d5da22"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa3-2', (3))) .
\"urn:uuid:0c04d251-4956-462b-b94c-0e5f1fca6277"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-2', (3), Collection)) .
\"urn:uuid:3742acd2-22bb-40d6-84f3-9a9f83be7c50"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-2', (1), Relation)) .
\"urn:uuid:6eab1359-d73c-4bc4-a92a-6d21fff19b71"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-2', (2), Collection)) .
\"urn:uuid:0727e521-9a02-4c9a-a327-4efe510aebf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa3-2', SetTheFormat)) .
\"urn:uuid:8acdfd5c-084b-4521-a4b2-80fd79e96077"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa3-2', SetTheFormat)) .
\"urn:uuid:cab9d7a8-1e36-4374-8e37-afff88a7c982"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa3-2', SetTheFormat)) .
\"urn:uuid:c00fdd02-f87b-488c-b3ae-0b5cd6334881"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-2', genlPreds, (1))) .
\"urn:uuid:bd87f739-b6d2-47d3-b894-c6b79be90125"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-2', genls, (2))) .
\"urn:uuid:b83ee13d-d9fe-4176-a5e8-deb43588a9c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa3-2', genls, (3))) .
\"urn:uuid:2427718f-3470-48da-a367-f20d8dc781a9"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa3-2', (2))) .
\"urn:uuid:01eee752-f9d0-4db5-a394-9df83d913834"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa3-4', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa3-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 INST ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:953a8201-9ac2-483b-8642-581d590419c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-4', (2), Thing)) .
\"urn:uuid:39f2e556-991d-4327-85ae-a0e237ddb36b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-4', (3), Thing)) .
\"urn:uuid:0765f2f5-d92f-4a3e-b1c6-244848395436"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa3-4', (3))) .
\"urn:uuid:8690d761-6c12-4041-837a-806c64997658"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-4', (3), Collection)) .
\"urn:uuid:fabe8b89-fad8-4cf2-90c7-7033365185c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-4', (1), Relation)) .
\"urn:uuid:63f12d63-2c20-4a2e-9a2c-5ab7f3cf242f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-4', (2), Collection)) .
\"urn:uuid:4f94c714-6af8-4854-ae3b-794944080a4f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa3-4', SetTheFormat)) .
\"urn:uuid:82fdd472-a007-4c2e-89d9-650bf3abc4ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa3-4', SetTheFormat)) .
\"urn:uuid:68b68887-0705-466a-a3bf-1c1ae2357493"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa3-4', SetTheFormat)) .
\"urn:uuid:6fe94f64-56e5-480a-9c8f-bb2016e067f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-4', genlPreds, (1))) .
\"urn:uuid:24e090af-dfb6-4346-83de-16cc4ea18392"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-4', genls, (2))) .
\"urn:uuid:4ef3b184-db49-47a3-9e68-682d129368bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa3-4', genls, (3))) .
\"urn:uuid:1a78e5e5-2fc8-480d-bad0-cf019bf164de"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa3-4', (4))) .
\"urn:uuid:2ad17404-a4d0-4005-8e06-9d45f0d898ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa3-5', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa3-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 INST ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see #$CycLExpression-Assertible and its direct \nspecializations."^^_string))) .
\"urn:uuid:57f63327-9a75-4b88-8a52-8a668f5e3089"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-5', (2), Thing)) .
\"urn:uuid:9538ebb9-8918-46f9-a1be-8aba2f314583"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa3-5', (3), Thing)) .
\"urn:uuid:46f83490-f2db-4a6d-b254-df1381a86b44"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa3-5', (3))) .
\"urn:uuid:c7257780-00cb-4503-931b-3d29ed8cce8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-5', (3), Collection)) .
\"urn:uuid:d007be75-3143-4336-a49e-5c1a6f6bff44"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-5', (1), Relation)) .
\"urn:uuid:78f6234b-53f2-4142-90f5-b0da3dd1f90a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa3-5', (2), Collection)) .
\"urn:uuid:5ad2c976-e3c8-4914-9899-3f2b48cbd77a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa3-5', SetTheFormat)) .
\"urn:uuid:7d3561e3-45cf-457f-886e-e7628b99cec7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa3-5', SetTheFormat)) .
\"urn:uuid:e9ee0767-f77f-4423-ab5e-808e4c2c5b2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa3-5', SetTheFormat)) .
\"urn:uuid:4b9e580e-1bf3-4df0-b30b-3cf749220e1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-5', genls, (2))) .
\"urn:uuid:cfc87a8e-6ca3-41d2-a9f8-315a6e2f52a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa3-5', genlPreds, (1))) .
\"urn:uuid:6500936f-6a04-48b9-a8ac-d1c63ef0430e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa3-5', genls, (3))) .
\"urn:uuid:48eaef0d-8c43-47fc-ac3e-2f056aee4cde"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa3-5', (5))) .
\"urn:uuid:a167847f-9b78-49d8-bd18-166722de1590"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa4-1', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa4-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the first argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only \nif ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:149f0099-fdae-4867-835d-81861be55198"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-1', (2), Thing)) .
\"urn:uuid:04d8eece-b87a-463b-b3e0-39df29718328"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-1', (3), Thing)) .
\"urn:uuid:eb960b54-45fc-42d5-88db-a7981a7f1ea8"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa4-1', (4))) .
\"urn:uuid:0ecc91e4-5d6d-49ca-a05e-b2fe9160570a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-1', (3), Collection)) .
\"urn:uuid:c157e134-3340-44ab-a0da-054f3ea35a7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-1', (2), Collection)) .
\"urn:uuid:5d41dbd8-c412-4f2d-8f2b-3b9d368ef371"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-1', (1), Relation)) .
\"urn:uuid:518de814-f979-4729-9c5c-aba94c9d9524"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa4-1', SetTheFormat)) .
\"urn:uuid:371e483c-34dd-4cff-acc4-ddb2c7eb08b9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa4-1', SetTheFormat)) .
\"urn:uuid:d77cedaa-9aa2-4b04-8a65-82200bb74e82"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa4-1', SetTheFormat)) .
\"urn:uuid:abbdac41-df3f-4498-9ed7-e6f66e20e11c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-1', genls, (2))) .
\"urn:uuid:93392635-54d5-443c-972c-1596e4e363ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-1', genlPreds, (1))) .
\"urn:uuid:5a2ad108-4fc6-4d04-9f30-3ce1314bbc63"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa4-1', genls, (3))) .
\"urn:uuid:51021213-57fd-48eb-a757-20f6df9e923f"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa4-1', (1))) .
\"urn:uuid:97cd17fe-0491-4ebb-8320-c59b3fe250d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa4-2', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa4-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only  if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:6d9f9b13-4392-4af3-9a9e-af653af3c326"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-2', (3), Thing)) .
\"urn:uuid:6190c363-4445-41b8-9067-e26bee3130e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-2', (2), Thing)) .
\"urn:uuid:709cc7ad-5b37-435f-a80d-bc2a6299e39b"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa4-2', (4))) .
\"urn:uuid:f4acfb79-8865-49cd-bf13-52a02e000090"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-2', (3), Collection)) .
\"urn:uuid:1320c70f-a7e9-48fd-8b89-1979e2c0f050"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-2', (2), Collection)) .
\"urn:uuid:1d198848-c000-465b-834d-0e7df9195c68"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-2', (1), Relation)) .
\"urn:uuid:f45115e2-399d-4913-b629-206f6b4b4df6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa4-2', SetTheFormat)) .
\"urn:uuid:0dc03d64-0608-46c1-a6c0-334e20fb79fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa4-2', SetTheFormat)) .
\"urn:uuid:f06e5244-a9de-4be3-a274-01c695cdb5c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa4-2', SetTheFormat)) .
\"urn:uuid:4dedaec4-1f24-4700-9179-3df56b0ce197"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-2', genlPreds, (1))) .
\"urn:uuid:8efb4402-4ffe-491f-b78e-e1ade8517525"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-2', genls, (2))) .
\"urn:uuid:02eabfaf-0f18-4102-81ae-f5cc48f2d8a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa4-2', genls, (3))) .
\"urn:uuid:2a82981c-1b0f-43ee-a3c7-84fe7c4152b8"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa4-2', (2))) .
\"urn:uuid:e1caf68f-56a6-4377-8e30-46b2539e30f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa4-3', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa4-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:2e6e6c6b-1007-44c1-b695-89a542309ff6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-3', (2), Thing)) .
\"urn:uuid:c6689e39-5f05-4027-9619-830be1cce8ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-3', (3), Thing)) .
\"urn:uuid:efd64c86-b02a-4b8e-a725-b79a009c2764"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa4-3', (4))) .
\"urn:uuid:cb00838a-a8f5-4468-9f1c-dc3d4cdff5ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-3', (2), Collection)) .
\"urn:uuid:d062d3c2-f972-451e-8ee3-54f3d64ad401"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-3', (3), Collection)) .
\"urn:uuid:70903538-b0c7-4860-960c-19a0e519e6a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-3', (1), Relation)) .
\"urn:uuid:717aa6d3-8b4d-4932-ae7d-35605e868d29"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa4-3', SetTheFormat)) .
\"urn:uuid:f765fdbe-7364-4c98-b6d6-e675dec077c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa4-3', SetTheFormat)) .
\"urn:uuid:273b2d38-cc87-4cc4-a238-d5edd423f86d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa4-3', SetTheFormat)) .
\"urn:uuid:a4d7b984-3ee9-4439-a9d2-cf09658515f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-3', genlPreds, (1))) .
\"urn:uuid:078da327-783b-4577-ba25-1924892de9ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-3', genls, (2))) .
\"urn:uuid:b2af9d9d-d7b4-45f9-8576-e3d69e594b56"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa4-3', genls, (3))) .
\"urn:uuid:5b19cc76-c868-4420-8f5b-5e1861715864"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa4-3', (3))) .
\"urn:uuid:9d6790c2-ab15-4a77-b462-3767c5213377"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa4-5', ("A ternary instance of #$InterArgIsaPredicate (q.v.).  \n(#$interArgIsa4-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see #$CycLExpression-Assertible and its direct \nspecializations."^^_string))) .
\"urn:uuid:b848ce3f-ab29-424b-b340-bf85c266a743"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-5', (2), Thing)) .
\"urn:uuid:c94ef649-fe71-467e-90c2-fb9d23242783"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa4-5', (3), Thing)) .
\"urn:uuid:679339ca-f79d-465e-8f9d-6d8752241941"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa4-5', (4))) .
\"urn:uuid:eee6a83f-b1f8-4a96-ae13-e3ea063ba2ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-5', (3), Collection)) .
\"urn:uuid:7281b70d-b2b2-443f-bcd2-b129fd932e1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-5', (2), Collection)) .
\"urn:uuid:661180ef-9bb7-48de-ac90-186e952aadba"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa4-5', (1), Relation)) .
\"urn:uuid:b61c8c80-c753-43be-b244-279f1a7da850"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa4-5', SetTheFormat)) .
\"urn:uuid:88bf6603-bbc3-4bb4-9661-d369673f278e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa4-5', SetTheFormat)) .
\"urn:uuid:045c2348-baa7-4eaf-b489-e4eb8bec06e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa4-5', SetTheFormat)) .
\"urn:uuid:02ab9fdb-a4f5-40d2-ab18-d2e09ce0b592"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-5', genls, (2))) .
\"urn:uuid:f4977e4f-77ff-4454-93e4-b685f55ddb6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa4-5', genlPreds, (1))) .
\"urn:uuid:824f5646-8e42-4d69-8d2b-60436e75cf60"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa4-5', genls, (3))) .
\"urn:uuid:ec81d0b9-055f-4784-9487-06025579046e"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa4-5', (5))) .
\"urn:uuid:63dc46ea-415c-43d3-a529-596c71bc9ea9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa5-1', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa5-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically  well-formed only if ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation  of semantic well-formedness, see #$CycLExpression-Assertible and its direct  specializations."^^_string))) .
\"urn:uuid:481a4396-39dd-456f-b457-1b3d5931a005"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-1', (3), Thing)) .
\"urn:uuid:662ab605-8e2f-4f23-826c-b5364ce8e882"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-1', (2), Thing)) .
\"urn:uuid:19a5bcae-e52d-4efd-8016-16c5151e3072"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa5-1', (5))) .
\"urn:uuid:a898c700-0a10-4953-a62b-4ab6337b3de6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-1', (3), Collection)) .
\"urn:uuid:80004c52-eec6-4ec8-8bd9-ae658276e02b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-1', (2), Collection)) .
\"urn:uuid:fcc233cd-1bd1-466c-b0f8-718c07eb08fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-1', (1), QuintaryRelation)) .
\"urn:uuid:87204898-eb0a-438a-b4c7-2cbd710caec4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa5-1', SetTheFormat)) .
\"urn:uuid:7cb147ae-742d-4956-a4f5-457185cc0c3e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa5-1', SetTheFormat)) .
\"urn:uuid:eb386d06-b903-431d-af77-b4afc2cd20b6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa5-1', SetTheFormat)) .
\"urn:uuid:35b3775f-63e5-415d-a239-4f87172259fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-1', genls, (2))) .
\"urn:uuid:fe6346bf-9073-4d65-9a77-724ad24fb32c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-1', genlPreds, (1))) .
\"urn:uuid:aec061a7-50b1-4881-9ae4-23b9e6258386"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa5-1', genls, (3))) .
\"urn:uuid:a73d5257-2c4d-4ba3-807d-c6ddadc424b6"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa5-1', (1))) .
\"urn:uuid:1c8b0a35-d2b3-4591-93f6-33c2b42241bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa5-2', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa5-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically well-formed  only if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:6f125e68-31ad-4782-8c29-c9fd6e42bc32"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-2', (3), Thing)) .
\"urn:uuid:4e8d9d3a-5454-4cfe-b194-5f5e9ec48890"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-2', (2), Thing)) .
\"urn:uuid:02608e19-0520-4322-9ea9-6bf0af535d68"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa5-2', (5))) .
\"urn:uuid:4e6eddcc-d5c8-46e8-b21a-f596d3567f8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-2', (1), QuintaryRelation)) .
\"urn:uuid:4a9f23b8-ca85-4c18-ba11-ea10a41cd523"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-2', (2), Collection)) .
\"urn:uuid:b23e7af0-c96a-4970-9a89-be71c4e79d65"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-2', (3), Collection)) .
\"urn:uuid:40de6ca7-3fca-4bd6-bd59-5854bbbf7c58"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa5-2', SetTheFormat)) .
\"urn:uuid:655b596e-4ad1-46b7-857c-629d8df06372"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa5-2', SetTheFormat)) .
\"urn:uuid:2439d879-4c66-4868-b00d-e3d00741a88e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa5-2', SetTheFormat)) .
\"urn:uuid:5ea00854-e2a6-4f19-a7f2-a61178cef5cf"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-2', genls, (2))) .
\"urn:uuid:645e70d0-b945-4e7b-81f2-bd3c9db6f29e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-2', genlPreds, (1))) .
\"urn:uuid:85fc87a4-2b4b-4198-b6fb-37cdd8c700c9"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa5-2', genls, (3))) .
\"urn:uuid:ed7f27c5-d2f8-410d-8127-56fda2f15f49"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa5-2', (2))) .
\"urn:uuid:c40f106e-f9fe-417d-b767-2351862b2cb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa5-3', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa5-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the third argument  must be an instance of DEPENDENT-ARG-COL.  That is, if ARG-INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically well-formed  only if ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see #$CycLExpression-Assertible and its direct specializations."^^_string))) .
\"urn:uuid:fb0be240-5777-4a72-8778-d7d0fb03839e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-3', (2), Thing)) .
\"urn:uuid:13ea6b07-cd40-4e42-9338-ed290228211a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-3', (3), Thing)) .
\"urn:uuid:4d7e7339-2382-4bcd-8c81-4e81542cc2f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa5-3', (5))) .
\"urn:uuid:25b79ce1-fe21-4b00-b730-34bda1be3ff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-3', (1), QuintaryRelation)) .
\"urn:uuid:18c09748-e070-41b5-9365-ba1503060468"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-3', (1), Relation)) .
\"urn:uuid:9833ccb7-7f18-466b-b5e0-3223571fcb71"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-3', (3), Collection)) .
\"urn:uuid:fb88c963-9e3e-4569-ba55-bf37d077d6ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-3', (2), Collection)) .
\"urn:uuid:aff21f94-eb59-4be5-ba83-f48d01f1af60"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa5-3', SetTheFormat)) .
\"urn:uuid:912c08dd-d971-40c5-96a9-cd9f9c272031"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa5-3', SetTheFormat)) .
\"urn:uuid:e2b29fc5-926b-40f0-a023-eb892b4df784"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa5-3', SetTheFormat)) .
\"urn:uuid:684c1fb6-4eff-4426-bc5c-b2ee9da82da4"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-3', genls, (2))) .
\"urn:uuid:dec3fa52-8dce-4d5f-a948-14b35aa3783d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-3', genlPreds, (1))) .
\"urn:uuid:289e0ea5-cab3-4df8-a485-c7e013028bb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa5-3', genls, (3))) .
\"urn:uuid:425ab016-f76b-4c76-850d-38400d62c1fb"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa5-3', (3))) .
\"urn:uuid:47c7a0be-83f0-44b2-9dbb-7f9f54a7c73d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('interArgIsa5-4', ("A ternary instance of #$InterArgIsaPredicate (q.v.).   (#$interArgIsa5-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the fourth argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically  well-formed only if ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation  of semantic well-formedness, see #$CycLExpression-Assertible and its direct  specializations."^^_string))) .
\"urn:uuid:95ba0c46-7dca-4e6c-b059-9b852d3b9c58"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-4', (3), Thing)) .
\"urn:uuid:323d5c04-4188-4038-8cf8-35bbb69ffabb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl('interArgIsa5-4', (2), Thing)) .
\"urn:uuid:86d6cd11-0fe5-403f-8e3f-3a281a86ee5d"[silk#strict] .
istAsserted(UniversalVocabularyMt, independentArg('interArgIsa5-4', (5))) .
\"urn:uuid:53e45f7a-524b-4051-be54-6eb1dac7770f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-4', (3), Collection)) .
\"urn:uuid:4239edb7-66c5-4d32-b5e1-34ef8800fc4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-4', (1), QuintaryRelation)) .
\"urn:uuid:1887e44a-9a65-4602-a1c2-895f9cf7a712"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('interArgIsa5-4', (2), Collection)) .
\"urn:uuid:85b4c6e9-b11b-4633-9407-c3ad192208a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('interArgIsa5-4', SetTheFormat)) .
\"urn:uuid:f7a1f4d7-e9a7-4804-b4cc-4c89e6784882"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format('interArgIsa5-4', SetTheFormat)) .
\"urn:uuid:42e9a01d-99c0-4c8f-a4fb-f82d45a692bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('interArgIsa5-4', SetTheFormat)) .
\"urn:uuid:de2ff808-da96-42a0-a707-eb11cb3fdbeb"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-4', genlPreds, (1))) .
\"urn:uuid:a9784f69-6bf0-4fea-bf3a-d76363a8f222"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse('interArgIsa5-4', genls, (2))) .
\"urn:uuid:b4bfd4c3-b364-4ab4-a41a-34787e1b3e6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg('interArgIsa5-4', genls, (3))) .
\"urn:uuid:46e04087-3c28-4e70-861c-c289598bae2b"[silk#strict] .
istAsserted(CoreCycLMt, constrainsArg('interArgIsa5-4', (4))) .
\"urn:uuid:73f69ff7-1af3-4bfa-bcf3-54f61bf65ed1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgResultGenl, ("A quaternary #$MetaRelation predicate for stating that a certain kind of complex, partly #$genls based relationship holds between a given argument to a given function and the corresponding value that is returned. (#$interArgResultGenls FUNC N INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, when a subcollection of INDEPENDENT-ARG-COL appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is a subcollection of DEPENDENT-ARG-COL.  That is: if INST is a subcollection of INDEPENDENT-ARG-COL and (FUNC ARG(1) ... ARG(N-1) INST ...) = VALUE, then VALUE is a subcollection of DEPENDENT-ARG-COL.  Note that, unlike (e.g.) the #$InterArgTypePredicates, #$interArgResultGenl _cannot_ be used to put semantic well-formedness constraints on functions.  See also the similar but less flexible ternary #$interArg1ResultGenls et al."^^_string))) .
\"urn:uuid:39e330aa-ee59-42bb-a654-78083fcd1e33"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgResultGenl, (3), Thing)) .
\"urn:uuid:601bbde5-6f50-43db-9c48-d2764a656c0d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgResultGenl, (4), Thing)) .
\"urn:uuid:be14598e-e2a3-48e2-a22f-0db1009f5a4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenl, (3), Collection)) .
\"urn:uuid:13096154-c38f-491d-9df3-8216354d0943"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenl, (2), PositiveInteger)) .
\"urn:uuid:654e3f4d-e13c-4748-912e-301cf7a84da1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenl, (4), Collection)) .
\"urn:uuid:4967a4e9-fc39-4bdb-bf95-a65bc2a43b50"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenl, (1), 'Function-Denotational')) .
istAsserted(BookkeepingMt, oldConstantName(interArgResultGenl, ("interArgResultGenls"^^_string))) .
\"urn:uuid:49d5a533-f468-4c06-823f-60aa1734273a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgResultGenl, SetTheFormat)) .
\"urn:uuid:872d1ab3-90ed-4762-87a3-d426c4a6308a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgResultGenl, SetTheFormat)) .
\"urn:uuid:109987cd-d6ec-4c94-9af1-93f06e0a91c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgResultGenl, SetTheFormat)) .
\"urn:uuid:f0ff2d75-546b-4ce9-8a80-2996b3fd8291"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(interArgResultGenl, SetTheFormat)) .
\"urn:uuid:42ef78ff-5090-4826-af14-b3a55d1f416e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgResultGenlReln, ("A quintary #$MetaRelation predicate for stating that a certain  kind of complex, partly #$genls based relationship holds between a given  argument to a given function and the corresponding value that is returned.  (#$interArgResultGenlReln FUNC N RELATION RELATION-NAT-TERM-ARG RELATION-COLLECTION-ARG) means that, if there is a sentence asserted in the KB relating NAT-TERM and COLLECTION via RELATION and NAT-TERM is the RELATION-NAT-TERM-ARGth argument in the sentence and COLLECTION is the RELATION-COLLECTION-ARGth argument, then when NAT-TERM appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is a subcollection of COLLECTION. That is: if (RELATION ... NAT_TERM ... COLLECTION ...) or  (RELATION ... COLLECTION ... NAT_TERM  ...) is an asserted sentence, and (FUNC ARG(1) ... ARG(N-1) NAT_TERM ...) = VALUE, then VALUE is a subcollection of COLLECTION. Obviously, COLLECTION must be a collection; so RELATION's RELATION-COLLECTION-ARGth argument-place is likely to be isa  constrained (see #$argIsa) to #$Collection or some specialization thereof."^^_string))) .
\"urn:uuid:e8a791b5-7bf9-49d4-84b0-1184c816fe47"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Format(interArgResultGenlReln, SetTheFormat)) .
\"urn:uuid:e47b664b-57ed-4b3e-ae4f-5bab6478c528"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenlReln, (5), PositiveInteger)) .
\"urn:uuid:25188b86-f628-4457-975a-5f52fcfc536b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenlReln, (4), PositiveInteger)) .
\"urn:uuid:13d55ff7-1eb3-44f0-82d1-327feec1cd19"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenlReln, (3), Predicate)) .
\"urn:uuid:44285f22-e5d6-4624-ad8c-5b700e2055a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenlReln, (2), PositiveInteger)) .
\"urn:uuid:e07583bd-1031-48a7-ac5d-428f39714edc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultGenlReln, (1), 'Function-Denotational')) .
\"urn:uuid:767b76b3-af05-42ec-a261-05fd644fc77f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgResultGenlReln, SetTheFormat)) .
\"urn:uuid:1b814456-7734-42d6-b3c4-001cc5ee7885"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgResultGenlReln, SetTheFormat)) .
\"urn:uuid:3588e761-cf42-41b6-9cb9-f84b5a6d235c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgResultGenlReln, SetTheFormat)) .
\"urn:uuid:d7310514-9190-483d-9df0-eb6dc6bb3384"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(interArgResultGenlReln, SetTheFormat)) .
\"urn:uuid:dc8df143-cbdb-4f55-8b9f-6b2925ecfdde"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgResultIsa, ("A quaternary #$MetaRelation predicate for stating that a certain kind of complex, partly #$isa -based relationship holds between a given argument to a given function and the corresponding value that is returned.\n<p>\n<code>(#$interArgResultIsa FUNC N INDEP-ARG-COL DEP-ARG-COL)</code> means that, when an instance of <code>INDEP-ARG-COL</code> appears as the <code>N</code>th argument to <code>FUNC</code>, then (regardless of what the other arguments to <code>FUNC</code> might be) the value (if any) of that function for those arguments is an instance of <code>DEP-ARG-COL</code>.  That is: if <code>INST</code> is an instance of <code>INDEP-ARG-COL</code> and <code>(FUNC ARG1 ... ARGN-1 INST ...) = VALUE</code>, then <code>VALUE</code> is an instance of <code>DEP-ARG-COL</code>.\n<p>\nFor example, <code>(#$interArgResultIsa #$RoundUpFn 1 #$RealNumber #$Integer)</code> means that the rounding-up function #$RoundUpFn returns an integer whenever it is given a real number as its first (and only) argument.\n<p>\nNote that, unlike (e.g.) the #$InterArgTypePredicates, #$interArgResultIsa <i>cannot</i> be used to put semantic well-formedness constraints on functions.  See also the similar but less flexible ternary #$interArg1ResultIsa et al."^^_string))) .
\"urn:uuid:d491ec1c-6ecf-40fb-9742-af1425f46f0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgResultIsa, (4), Thing)) .
\"urn:uuid:3dd21696-4268-4fc5-a765-537f20768626"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(interArgResultIsa, (3), Thing)) .
\"urn:uuid:fc76d3c0-d897-458b-a42f-44837105adce"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsa, (4), Collection)) .
\"urn:uuid:d08b6f7d-c7f0-47da-b9ae-5df1700662e7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsa, (3), Collection)) .
\"urn:uuid:8e16dbde-358d-4bb9-abbe-109cddd6b796"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsa, (1), 'Function-Denotational')) .
\"urn:uuid:e92af11d-2b1f-48b2-8d7a-77176a8fb945"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsa, (2), PositiveInteger)) .
\"urn:uuid:89df8df2-608d-4724-aac7-2e7b046cf7d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgResultIsa, SetTheFormat)) .
\"urn:uuid:87deab00-f205-465e-b84f-7b6e17346747"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgResultIsa, SetTheFormat)) .
\"urn:uuid:90fc2a74-e17e-461c-9aeb-d554d62d1446"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgResultIsa, SetTheFormat)) .
\"urn:uuid:6c034691-b8df-4d5e-8c21-a36a6b9d94a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(interArgResultIsa, genls, (3))) .
\"urn:uuid:a9d37f18-456b-45a5-8998-dc612db710f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(interArgResultIsa, SetTheFormat)) .
\"urn:uuid:61b1c114-aac0-4f09-a9a7-1dde20701790"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(interArgResultIsaReln, ("A quintary #$MetaRelation predicate for stating that a certain kind of complex, partly #$isa based relationship holds between a given argument to a given function and the corresponding value that is returned. (#$interArgResultIsaReln FUNC N RELATION RELATION-NAT-TERM-ARG RELATION-COLLECTION-ARG) means that, if there is a sentence asserted in the KB relating NAT-TERM and COLLECTION via RELATION and NAT-TERM is the RELATION-NAT-TERM-ARGth argument in the sentence and COLLECTION is the RELATION-COLLECTION-ARGth argument, then when NAT-TERM appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is an instance of COLLECTION.  That is: if (RELATION ... NAT_TERM ... COLLECTION ...) or (RELATION ... COLLECTION ... NAT_TERM  ...) is an asserted sentence, and (FUNC ARG(1) ... ARG(N-1) NAT_TERM ...) = VALUE, then VALUE is an instance of COLLECTION. Obviously, COLLECTION must be a collection; so RELATION's RELATION-COLLECTION-ARGth argument-place is likely to be isa constrained (see #$argIsa) to #$Collection or some specialization thereof."^^_string))) .
\"urn:uuid:16391cb6-04db-48b1-87a6-1fc50118703e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg5Format(interArgResultIsaReln, SetTheFormat)) .
\"urn:uuid:069979e1-0ec3-4dbd-b249-c39753851567"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsaReln, (5), PositiveInteger)) .
\"urn:uuid:5e56b80c-1dc2-4371-8950-09b5d7468977"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsaReln, (4), PositiveInteger)) .
\"urn:uuid:27b89f30-a912-4d32-8834-114625139a5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsaReln, (3), Predicate)) .
\"urn:uuid:102ebf0d-4214-4a75-b334-39eb9e61b236"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsaReln, (2), PositiveInteger)) .
\"urn:uuid:ee5866ee-2af7-462f-b6e9-47bccfd17837"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(interArgResultIsaReln, (1), 'Function-Denotational')) .
\"urn:uuid:46340c9e-bb34-43f0-a34e-c7cd51f6b421"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(interArgResultIsaReln, SetTheFormat)) .
\"urn:uuid:37529521-5f0b-4059-984d-92c9bf455c4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(interArgResultIsaReln, SetTheFormat)) .
\"urn:uuid:dd4502c5-4b84-4bbc-9f7e-281af849be93"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(interArgResultIsaReln, SetTheFormat)) .
\"urn:uuid:4753414b-0faa-4f46-9dea-47607c340f45"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(interArgResultIsaReln, SetTheFormat)) .
\"urn:uuid:3b155782-a213-4958-9020-f71c0794ae15"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(irrelevantAssertion, (1))) .
\"urn:uuid:afff7663-7747-41db-ad1e-767bd3b18d21"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(irrelevantAssertion, (1), CycLAssertion)) .
\"urn:uuid:42abd228-4552-4dcb-a00a-a5cd66ebf069"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(irrelevantAssertion, ("A #$CycInferenceHeuristicRelevancePredicate. (#$irrelevantAssertion ASSERTION) states that the #$CycLAssertion ASSERTION should be heuristically considered very unlikely to be relevant to inferences in the current #$Microtheory.  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:daefbb1d-f3bd-40a3-b1a9-6612640cf66e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(irrelevantMt, ("A #$CycInferenceHeuristicRelevancePredicate. (#$irrelevantMt MT) means that all assertions made in the #$Microtheory MT should be heuristically considered very unlikely to be relevant to inferences done in the #$Microtheory MT-1 in which (#$irrelevantMt MT) is asserted (where MT-1 and MT need not be the same).  As a consequence, note that when (#$irrelevantMt MT) is asserted in a Microtheory MT-1, each of the assertions in MT will be an #$irrelevantAssertion (q.v.) for inferences done in MT-1."^^_string))) .
\"urn:uuid:984be13f-80ff-4f0a-9d63-9af8a0437a03"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(irrelevantMt, (1), Microtheory)) .
\"urn:uuid:48a7de7a-945c-4060-b2ff-4798d7fc873b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(irrelevantPredAssertion, ("(#$irrelevantPredAssertion PREDICATE ASSERTION) states that the given ASSERTION should be heuristically considered very unlikely to be relevant to inferences concluding uses of the given PREDICATE in the current mt.  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:ebfcf2b9-3a3e-4ff2-9c88-c5e163390580"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(irrelevantPredAssertion, (1), Predicate)) .
\"urn:uuid:092327f5-ddec-4ee0-ba6e-3cfaf6dcca08"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(irrelevantPredAssertion, (2), CycLAssertion)) .
\"urn:uuid:d88673c3-ec60-4948-a310-c759270febc2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(irrelevantPredAssertion, (2))) .
\"urn:uuid:27eb1588-0bbe-4b52-a5dc-0136afa59322"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(irrelevantTerm, ("A #$CycInferenceHeuristicRelevancePredicate. (#$irrelevantTerm TERM) states that the #$CycLClosedDenotationalTerm TERM should be heuristically considered less relevant to inferences made in the current #$Microtheory.  See also other instances of #$CycInferenceHeuristicRelevancePredicate."^^_string))) .
\"urn:uuid:c795b327-965c-42eb-bd4d-a63f86d146d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(irrelevantTerm, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:07ac7b44-b519-4f9c-9e7d-af651b1809c4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(irrelevantTerm, (1))) .
\"urn:uuid:42edc6e0-719c-4185-bec1-26a66156f748"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(irrelevantTerm, (1), Thing)) .
\"urn:uuid:5e7df371-bb1b-4d89-8dac-ffb00f561ae1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(isa, ("A #$TaxonomicSlot (q.v.) that relates things of any  kind to collections (see #$Collection) of which they are instances.   <code>(#$isa THING COL)</code> means that <code>THING</code> is an instance of the collection <code>COL</code>.   #$isa is by far the most commonly-occurring predicate in the Cyc Knowledge  Base, and is one of the relations most fundamental to the Cyc ontology. An important logical feature of #$isa is that it ''transfers through''  #$genls (q.v.): <code>(#$isa THING COL)</code> and <code>(#$genls COL SUPERCOL)</code> jointly  imply <code>(#$isa THING SUPERCOL)</code>.  This logical feature is expressed in a  rule that -- along with various other rules that also sanction the  derivation of #$isa sentences -- has been asserted to the Knowledge Base.   As a result, only a small fraction of the #$isa based ground atomic  formulas (or ''GAF''s; see #$CycLClosedAtomicSentence) the Cyc system  ''knows'' to be true have been manually asserted; the vast majority  have been derived, or are derivable, automatically by the Cyc inference  engine via the use of such rules.  See also #$elementOf."^^_string))) .
\"urn:uuid:30f4747f-ea39-4c4c-bc7b-d6c26ed248a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(isa, SetTheFormat)) .
\"urn:uuid:c8820b9d-975f-4f89-9f8a-b7f0b6f7b030"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(isa, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(isa, ("instanceOf"^^_string))) .
\"urn:uuid:c4f74d97-50f3-4ada-b2cd-3819bd6e926b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(isa, genls, (2))) .
\"urn:uuid:fb6edc16-7fd0-49e9-a29f-99b1b32865f8"[silk#strict] .
istAsserted(BaseKB, argGenl(isa, (2), Thing)) .
\"urn:uuid:61a25cf9-927d-4321-9d74-2342095677dc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(isa, (2), Thing)) .
\"urn:uuid:b37b1245-2d19-45bf-b55f-9daaa8aab0f7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(isa, (1), Thing)) .
\"urn:uuid:a7238fc4-547e-42e8-b37b-eb0a59ab8614"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(isa, (2), Collection)) .
\"urn:uuid:9fb0144d-a4b6-4804-ab60-9f2f02d242c2"[silk#strict] .
istAsserted(BaseKB, argIsa(isa, (2), Collection)) .
\"urn:uuid:bd50247d-185c-4411-b1c0-96903197c6fd"[silk#strict] .
istAsserted(BaseKB, argIsa(isa, (1), Thing)) .
\"urn:uuid:33df6d8c-8f23-486a-ae80-84a099de5628"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(isa, (1), Thing)) .
\"urn:uuid:0b3bd9b9-e6dd-4e25-8d84-d52c23350f21"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(isa, (2), Collection)) .
istAsserted(EnglishParaphraseMt, genKeyword(isa, MetaVariableFn(("ISA"^^_string)))) .
\"urn:uuid:438208bf-d3d5-4fdd-b303-4644b3bc29d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ist, ("This predicate relates a microtheory to any sentence that is true in it.  <code>(#$ist MT SENT)</code> means that the CycL sentence <code>SENT</code> (or, if you prefer, the proposition <code>SENT</code> expresses) is true in the microtheory <code>MT</code>.  Note that <code>SENT</code> need not actually be <i>asserted</i> in <code>MT</code>; <code>MT</code> might for example ''inherit'' <code>SENT</code> from a more general microtheory (see #$ist-Asserted), or <code>SENT</code> might be derivable from other sentences that are true in <code>MT</code>."^^_string))) .
\"urn:uuid:74b05b0a-6d7f-4286-bb27-f3a94d05c8bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ist, (1), Microtheory)) .
\"urn:uuid:5bc8c252-e53f-4e2f-b0f4-0c166791f746"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(ist, (1), Microtheory)) .
\"urn:uuid:7546dec4-19d3-4439-8aa5-e4e0815ccb5b"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(ist, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:26955db8-b870-479e-974e-44f2702435b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(ist, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:b399d0fb-df10-4c17-bb1d-8af8eda5e1c7"[silk#strict] .
istAsserted(BaseKB, sentenceDesignationArgnum(ist, (2))) .
\"urn:uuid:b59ccecf-4fe9-4163-a86c-8d1e59d56d8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ist, (2))) .
\"urn:uuid:247cef73-8534-4a7d-8c57-73e50e72885b"[silk#strict] .
istAsserted(BaseKB, microtheoryDesignationArgnum(ist, (1))) .
\"urn:uuid:9e03b531-58e8-41c2-bcf2-0fadf0ce7404"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(ist, genlMt, (1))) .
\"urn:uuid:8d7d5b3f-188d-4f95-912a-df93e23e8358"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(istAsserted, ("A #$MicrotheoryDesignatingPredicate that is used to relate CycL sentences to microtheories in which they are explicitly asserted. (#$ist-Asserted MT SENT) states that there is a #$CycLAssertion for SENT in the #$Microtheory MT.  This predicate is therefore a more specialized form of #$ist (q.v.) with the additional requirement that there be an actual assertion for SENT in MT.\n<p>\nNote that the above is also more precise than (#$ist MT (#$assertedSentence SENT)), which states that there is an assertion for SENT in some microtheory visible from (see #$genlMt) MT."^^_string))) .
\"urn:uuid:a645e492-1915-44c2-9985-8234d85f758e"[silk#strict] .
istAsserted(BaseKB, notAssertible(istAsserted)) .
\"urn:uuid:538d5bd4-d9f8-440d-b538-7715772bf30f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(istAsserted, (1), Microtheory)) .
\"urn:uuid:f5c6528c-1cb0-42b5-83b2-a8f69632f65c"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(istAsserted)) .
\"urn:uuid:e39e7787-2770-45a4-81c6-2e708c2df0bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(istAsserted, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:bcdf8981-9220-402a-ae73-34a2a0305e18"[silk#strict] .
istAsserted(BaseKB, sentenceDesignationArgnum(istAsserted, (2))) .
\"urn:uuid:54fbd111-0ca4-460a-9c63-2fd526ee5ddf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(istAsserted, (2))) .
\"urn:uuid:f09f08fa-a242-4fe8-8c55-2251e551d130"[silk#strict] .
istAsserted(BaseKB, microtheoryDesignationArgnum(istAsserted, (1))) .
\"urn:uuid:8bcf9da9-9809-4e49-af2d-f1498c61a08a"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(istAsserted)) .
\"urn:uuid:f748b250-b2c6-4f2f-9c06-7790a0e27abe"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(istAsserted)) .
\"urn:uuid:eeafa577-4bae-4472-b38a-fc91597d6bdc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(knownAntecedentRule, ("A #$MetaKnowledgePredicate that is used to state a strong pragmatic directive to the #$CycInferenceEngine.  Asserting (#$knownAntecedentRule RULE) tells the inference engine to automatically generate a removal module to implement RULE; i.e. to solve queries unifying with the consequent of RULE by attempting to prove the substituted antecedent of RULE.  When this removal module is used during inference, it attempts to prove the substituted antecedent via removal only (see #$knownSentence).  It does not preclude other uses of RULE in inference."^^_string))) .
\"urn:uuid:ba5b1d66-2d1c-47fa-b064-a881d8afaa40"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(knownAntecedentRule, (1))) .
\"urn:uuid:d5b8c60b-841f-4e69-9c57-2015471e173a"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(knownAntecedentRule, backchainRequired)) .
\"urn:uuid:37829284-bde1-40fd-989a-dfd97ba0a781"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(knownAntecedentRule, knownSentence)) .
\"urn:uuid:51ff49ad-164c-4352-9082-9a5ca4cf59f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(knownAntecedentRule, (1), CycLRuleAssertion)) .
\"urn:uuid:9ade67f5-90e2-422c-beda-92dd9f9accb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(knownSentence)) .
\"urn:uuid:4a5c7791-796f-46e1-8f59-f1beaadf34c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(knownSentence, ("A #$KBDependentRelation (q.v.) and  specialization of #$trueSentence (q.v.) that is used to state  that a given sentence is ''known'' to be true to the Cyc system. More precisely, (#$knownSentence SENT) means that SENT is provable  by the Cyc inference engine from sentences currently in the Knowledge  Base.  #$knownSentence is a non-assertible predicate (see  #$notAssertible).  Note that this predicate is not to be confused  with #$assertedSentence, which is used to state that a given  sentence is explicitly asserted in the KB."^^_string))) .
\"urn:uuid:af894a46-5123-429b-8637-0b8d2ae89d20"[silk#strict] .
istAsserted(BaseKB, notAssertible(knownSentence)) .
istAsserted(BookkeepingMt, oldConstantName(knownSentence, ("knownFormula"^^_string))) .
\"urn:uuid:a4690bc6-0636-4c50-8b15-d0c92a37787f"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(knownSentence)) .
\"urn:uuid:2f1bc334-c09f-4aae-ae54-644f04cc4ade"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(knownSentence)) .
\"urn:uuid:27aa9276-6847-4e21-a383-0011c6d465f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(knownSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:8de3e2d3-43aa-44ad-ab5a-d6e636b015a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(knownSentence, (1))) .
\"urn:uuid:2758c11a-4fd7-4296-80b3-24075de70db2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(lessThan, ("A #$NumericComparisonPredicate that is a  generalization of the mathematical less-than ( < ) relation to  #$ScalarIntervals (q.v.) of all sorts, including quantitative  intervals as well as point values (see #$ScalarPointValue).   (#$lessThan VALUE1 VALUE2) means that VALUE1 is less than VALUE2  with respect to some scale that they are both on.  More precisely,  there is some #$TotallyOrderedScalarIntervalType SCALE that both  VALUE1 and VALUE2 are instances of and either (i) SCALE is a  specialization of #$NumericInterval (e.g. #$RealNumber) and the  maximum (see #$maxQuantValue) of VALUE1 is less than the  minimum (see #$minQuantValue) of VALUE2 or (ii)  (#$followingValueOnScale VALUE1 VALUE2 SCALE) holds.  Note that  #$lessThan is an #$ELRelation (q.v.), and the above sentence would actually canonicalize to (#$greaterThan VALUE2 VALUE1)."^^_string))) .
\"urn:uuid:f1f2f67b-a169-4546-b4dc-bc4d38ec6aab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(lessThan, (2), ScalarInterval)) .
\"urn:uuid:10a01c1f-86ba-42ef-92ee-b00aa085ad38"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(lessThan, (1), ScalarInterval)) .
\"urn:uuid:cfa3d562-d849-4711-b387-fb12a76ed72f"[silk#strict] .
istAsserted(BaseKB, argIsa(lessThan, (1), ScalarInterval)) .
\"urn:uuid:1f8f0902-5872-4760-8ed2-a78150702f80"[silk#strict] .
istAsserted(BaseKB, argIsa(lessThan, (2), ScalarInterval)) .
\"urn:uuid:7767fbdd-5292-40e4-9425-c0afc679fba4"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(lessThan, SubLSymbolFn(("CYC-LESS-THAN"^^_string)))) .
\"urn:uuid:34d3524a-e335-4cca-be87-fe005c01846c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(lessThan, quantitySubsumes, (1))) .
\"urn:uuid:65f1b90d-3d77-4706-ae20-21581a661a2f"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(lessThan, lessThan)) .
\"urn:uuid:4c08ec19-c2e0-4060-a2a9-914fcb81b95c"[silk#strict] .
istAsserted(BaseKB, expansion(lessThan, greaterThan(MetaVariableFn(("ARG2"^^_string)), MetaVariableFn(("ARG1"^^_string))))) .
\"urn:uuid:48313af4-bc6f-421d-aae0-8d225fea2e34"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(lessThanOrEqualTo, ("A #$NumericComparisonPredicate that is a generalization of the  mathematical less-than-or-equal-to ( <= ) relation to  #$ScalarIntervals (q.v.) of all sorts, including quantitative  intervals as well as point values (see #$ScalarPointValue).   (#$lessThanOrEqualTo VALUE1 VALUE2) means that VALUE1 is  less than or equal to VALUE2 with respect to some scale that  they are both on.  More precisely, there is some  #$TotallyOrderedScalarIntervalType SCALE that both VALUE1 and  VALUE2 are instances of and either (i) the maximum  (see #$maxQuantValue) of VALUE1 is less than or equal to the  minimum (see #$minQuantValue) of VALUE2, (ii)  (#$followingValueOnScale VALUE1 VALUE2 SCALE) holds, or (iii) (#$equals VALUE1 VALUE2) holds.  Note that  #$lessThanOrEqualTo is an #$ELRelation (q.v.), and the above  sentence would actually canonicalize to  (#$greaterThanOrEqualTo VALUE2 VALUE1)."^^_string))) .
\"urn:uuid:a7391bb3-82ed-4376-a232-e9f735d9a594"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(lessThanOrEqualTo, (1), ScalarInterval)) .
\"urn:uuid:b469b302-017e-4377-bccb-6eabee596053"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(lessThanOrEqualTo, (2), ScalarInterval)) .
\"urn:uuid:0f7940c7-8c2b-467b-95b1-16630a3642a3"[silk#strict] .
istAsserted(BaseKB, argIsa(lessThanOrEqualTo, (1), ScalarInterval)) .
\"urn:uuid:cac2374e-1aed-4800-8fee-8ac5963c3890"[silk#strict] .
istAsserted(BaseKB, argIsa(lessThanOrEqualTo, (2), ScalarInterval)) .
\"urn:uuid:3449b626-5f7e-47a8-a77b-21339a3f4d26"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(lessThanOrEqualTo, SubLSymbolFn(("CYC-LESS-THAN-OR-EQUAL-TO"^^_string)))) .
\"urn:uuid:35651a49-8b39-4c1a-a780-756ec8ff8e91"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(lessThanOrEqualTo, greaterThan)) .
\"urn:uuid:f714a62d-efd0-4ac3-b5e6-7397afc7684f"[silk#strict] .
istAsserted(BaseKB, expansion(lessThanOrEqualTo, greaterThanOrEqualTo(MetaVariableFn(("ARG2"^^_string)), MetaVariableFn(("ARG1"^^_string))))) .
\"urn:uuid:dc9af05a-46f1-41fa-b5ea-005490eb7c77"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(maxQuantValue, ("A specialization of #$scalarBounds (q.v.) that relates a given #$ScalarInterval (q.v.) to the maximum #$ScalarPointValue (q.v.) it subsumes (see #$quantitySubsumes). <code>(#$maxQuantValue SCALAR POINT)</code> means that the upper limit of <code>SCALAR</code> is <code>POINT</code>.\n<p>\nFor example, if all mailroom employees earned from five to eight dollars per hour, <code>(#$maxQuantValue ''MailroomPayRange'' (#$DollarsPerHour 8))</code> would hold.  Other examples:\n<pre>\n  (#$maxQuantValue (#$Mile 15 20) (#$Mile 20))\n\n  (#$maxQuantValue (#$Unity 6 12) 12).\n</pre>\n<p>\nSee also #$minQuantValue and #$pointQuantValue."^^_string))) .
\"urn:uuid:863a4e40-d907-498d-9eca-bfe16e10b71e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(maxQuantValue, (1), ScalarInterval)) .
\"urn:uuid:f1e49dd8-d2fa-4461-90d8-a90ef1130901"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(maxQuantValue, (2), ScalarPointValue)) .
\"urn:uuid:d8cdbd36-b3c4-471e-8bd1-f42d3875b7af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(maxQuantValue, singleEntryFormatInArgs)) .
\"urn:uuid:d280cfad-0209-4197-8de4-7180ad392ac5"[silk#strict] .
istAsserted(BaseKB, fanOutArg(maxQuantValue, (2))) .
\"urn:uuid:59272efa-9ea5-414c-bd1d-3868b381469e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(maxQuantValue, openEntryFormatInArgs)) .
\"urn:uuid:9c41a638-308e-40c9-a5d3-06c4a83959c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(maxQuantValue, (1))) .
\"urn:uuid:2fe749ff-6a86-47fa-98bc-7de839229399"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(maxQuantValue, (2))) .
\"urn:uuid:fc10b049-beb6-4f43-92a8-bf9ceb19f1ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(maxQuantValue, (2))) .
\"urn:uuid:3f55547c-ceca-44e9-89a4-a4f64b341b94"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(maxQuantValue, Thing, Thing, (1))) .
\"urn:uuid:42305334-3bf8-4924-be9c-d7638a08a4d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(means, ("A MetaLanguagePredicate (q.v.) that relates #$SubLSExpressions to their meanings: the things in the intended model of the CycL language that those terms denote, refer to, stand for, or express. <code>(#$means TERM THING)</code> means that <code>TERM</code> denotes, refers to, stands for, or expresses <code>THING</code>. <code>TERM</code> will often be explicitly quoted, by being wrapped in the syncategorematic quotation symbol '#$Quote'. For example, the true sentence '(#$means (#$Quote #$Plato) #$Plato)' means that the CycL term 'Plato' means (denotes) the person Plato. (Thus #$means's first argument-place is <i>not</i> ''implicitly quoted''; cf. #$quotedArgument).\n<p>\nBut note that the first argument of #$means might not be quoted at all. Suppose (e.g.) that the term 'Plato' were the CycL constant most beloved of Cyclists, and that a new constant 'CyclistsFavoriteConstant' were reified and defined so as to reflect this fact. Then 'CyclistsFavoriteConstant' would denote the CycL constant 'Plato', which in turn denotes the man Plato; and so the sentence '(#$means CyclistsFavoriteConstant Plato)' -- which involves no quotation -- would be true.\n<p>\nNote finally that the sentence '(#$means #$Plato #$Plato)' is of course <i>not</i> true, as it means that the man Plato is a CycL term that denotes the man Plato, which is a patent falsehood since no man is a CycL term and no man denotes anything.\n<p>\nSee also #$expresses, #$denotes, #$hasDenotatum, #$quotedIsa, #$EscapeQuote, and the shared #$NoteAboutQuotingInCycL."^^_string))) .
\"urn:uuid:6a75cd9d-78d7-4645-8f6c-6af17532a4c7"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(means, (2))) .
\"urn:uuid:a389a6df-99f6-4e6f-9b52-36d23193eab6"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(means, (2))) .
\"urn:uuid:f61d99cf-e806-48e4-b9b2-35929b1bfdca"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(means, (1), SubLSExpression)) .
\"urn:uuid:876813fc-c04f-4829-8441-f0a7a999cb97"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(means, (2), Thing)) .
\"urn:uuid:3685f4c9-233f-4124-a9b9-36479736e04f"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(means, Thing, Thing, (1))) .
\"urn:uuid:7e36b021-77b3-4548-a961-805b79c7def6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(means, singleEntryFormatInArgs)) .
\"urn:uuid:77484793-d6b0-4801-a66a-b84825a2da30"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(means, SetTheFormat)) .
\"urn:uuid:466f39f4-e0bb-480d-b6eb-be52844a4baa"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(means, means)) .
\"urn:uuid:f7e7b395-0c4a-49da-9225-17fc39b2fabc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(meetsPragmaticRequirement, (1), List)) .
\"urn:uuid:5e1817b4-b7ab-42dd-b5bf-4d1c182a624d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(meetsPragmaticRequirement, (2))) .
\"urn:uuid:8d617136-6963-454e-bfa8-fa27b8c7d8f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(meetsPragmaticRequirement, ("A #$MetaKnowledgePredicate that is used to express that a pragmatic precondition on a given rule is satisfied.  The predicate takes as arguments a list of CycL variables and an asserted rule (see #$CycLRuleAssertion) in which those variables occur ''free''.  At the EL (''epistemological level''), #$meetsPragmaticRequirement sentences are not asserted as GAFs, but appear instead as the consequents of system-generated #$implies rules.  For a given sequence of values for the respective variables <code>VAR1</code>, ..., <code>VARn</code>, <code>(#$meetsPragmaticRequirement (#$TheList VAR1 ... VARn) RULE)</code> means that some pragmatic precondition placed on <code>RULE</code>'s being used by the Cyc inference engine (see #$pragmaticRequirement) is satisfied with respect to those values.\n<p>\nLet's make this more precise and explicit.  A pragmatic precondition for a rule is written like so:\n<p>\n<pre>\n   (#$pragmaticRequirement CONDITION RULE)\n</pre>\n<p>\nand gets canonicalized into a rule involving #$meetsPragmaticRequirement like so:\n<p>\n<pre>\n   (#$implies\n     CONDITION\n    (#$meetsPragmaticRequirement (#$TheList VAR1 ... VARn) RULE)),\n</pre>\n<p>\nwhere <code>VAR1, ..., VARn</code> are all and only the variables that occur free in <code>RULE</code> and thus include all (and possibly only) the variables that occur free in <code>CONDITION</code> (i.e. as <code>RULE</code> and <code>CONDITION</code> explicitly appear in the KB browser, without consideration of their having ''implicit'' initial universal quantifiers).\n<p>\nThe above #$meetsPragmaticRequirement rule is used in inference similarly to an #$abnormal rule.  If <code>CONDITION</code> is not known to hold for a given sequence of values <code><VAL1, ..., VALn></code> for its variables <code><VAR1, ..., VARn></code>, then those values do not ''meet the pragmatic requirement'' for <code>RULE</code>; and hence inference will not proceed using <code><VAL1, ..., VALn></code> with <code>RULE</code>.\n<p>\nThe effect of the foregoing is that any asserted rule <code>RULE</code> is implicitly treated by the Cyc inference engine as if it had the form\n<p>\n<pre>\n (#$implies\n  (#$meetsPragmaticRequirement (#$TheList VAR1 ... VARn) RULE)\n   RULE)\n</pre>\n<p>\n(with <code>VAR1, ..., VARn</code> as described above).\n<p>\nThis convention allows the logical content of a rule to be expressed independently of any pragmatic preconditions for its being used in inference.  If a rule has multiple pragmatic requirements, it must meet all of them to be used in inference.\n<p>\nAlso see #$abnormal, which is syntactically similar and has a related  interpretation."^^_string))) .
\"urn:uuid:b25f07a5-462c-4740-bf7f-db143de1ceff"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(meetsPragmaticRequirement, (2), CycLAssertion)) .
\"urn:uuid:96a642bb-bfbe-41d7-886f-3b6be721a68c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(microtheoryDesignationArgnum, ("Used to specify which argument of a given #$MicrotheoryDesignatingRelation\ndesignates the microtheory in which to interpret some formula."^^_string))) .
\"urn:uuid:0ce7611f-1cfa-45e5-a566-707635c004ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(microtheoryDesignationArgnum, (2), PositiveInteger)) .
\"urn:uuid:21979b06-2370-4300-bf0e-b396965885fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(microtheoryDesignationArgnum, (1), MicrotheoryDesignatingRelation)) .
\"urn:uuid:17276e74-f92b-4fe7-b964-67ba47dfec3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(microtheoryDesignationArgnum, genlPreds, (1))) .
\"urn:uuid:20206b98-158b-40e2-bf27-82e745026fa3"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(minQuantValue, ("A specialization of #$scalarBounds (q.v.) that relates a given #$ScalarInterval (q.v.) to the minimum #$ScalarPointValue (q.v.) it subsumes (see #$quantitySubsumes). <code>(#$minQuantValue SCALAR POINT)</code> means that the lower limit of <code>SCALAR</code> is <code>POINT</code>.\n<p>\nFor example, if all mailroom employees earned from five to eight dollars per hour, <code>(#$minQuantValue ''MailroomPayRange'' (#$DollarsPerHour 5))</code> would hold.  Other examples:\n<pre>\n  (#$minQuantValue (#$Mile 15 20) (#$Mile 15))\n\n  (#$minQuantValue (#$Unity 6 12) 6).\n</pre>\n<p>\nSee also #$maxQuantValue and #$pointQuantValue."^^_string))) .
\"urn:uuid:07fc46e3-6d97-420f-aa91-886fb16b55d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(minQuantValue, (2), ScalarPointValue)) .
\"urn:uuid:868991e7-6d57-4607-bd96-a630ac4b2baf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(minQuantValue, (1), ScalarInterval)) .
\"urn:uuid:db7c5a43-2662-40d3-9aaf-79eb0be08fa8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(minQuantValue, singleEntryFormatInArgs)) .
\"urn:uuid:7070299c-e711-4355-af8b-a9bb2688b304"[silk#strict] .
istAsserted(BaseKB, fanOutArg(minQuantValue, (2))) .
\"urn:uuid:f8e6d311-d27e-4fd7-8ee2-a861da8deac4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(minQuantValue, openEntryFormatInArgs)) .
\"urn:uuid:f99baae8-6d3d-49ca-8108-e5ad9575e1f5"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(minQuantValue, (1))) .
\"urn:uuid:484ec524-17e7-40b8-b217-25b6040fd7cc"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(minQuantValue, (2))) .
\"urn:uuid:a473218b-d0b7-4899-9642-61d3d802a7b1"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(minQuantValue, (2))) .
\"urn:uuid:032db45f-fa5f-4e57-b5b3-93a7ce0d82b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(minQuantValue, Thing, Thing, (1))) .
\"urn:uuid:4a01eb09-eae4-484d-be33-94c7a563c4ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(minimize, ("#$minimize allows Cyc to assume that a statement is not\ntrue unless it is known to be true.  Specifically, if for some\nbindings of the variables that appear in the minimized formula the\nformula with the bindings substituted in cannot be proved, then assume\nthe negation of the formula with the bindings substituted in.  From an\nexample in the KB: (#$minimize (#$disjointWith ?Collection\n?Collection)) and binding ?Collection to #$Poodle means if we cannot\nprove (#$disjointWith #$Poodle #$Poodle) assume (#$not (#$disjointWith\n#$Poodle #$Poodle, i.e. assume every #$Collection is nonempty unless\nwe know otherwise.  In the case where we bind ?Collection to some\nother variable ?Y and substituting in means if we cannot show\n(#$disjointWith ?Y ?Y) then assume the negation, (#$not (#$forAll ?Y\n(#$disjointWith ?Y ?Y))) which is equivalent to (#$thereExists ?Y\n(#$not (#$disjointWith ?Y ?Y))). This is one of the predicates that\nhas been created to allow Cyc to do negation by failure.  Other\nrelated predicates are #$minimizeExtent and #$minimizeExtentForArg. "^^_string))) .
\"urn:uuid:4a234e16-bc04-4ccb-ba5d-f60b1dc208bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(minimize, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:0f2a4110-5525-4b41-aab5-ab6f6b1faedb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(minimize, (1))) .
\"urn:uuid:94ced260-7fa0-46f8-ac78-9105f60fe7e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(minimizeExtent, ("An instance of both #$MetaKnowledgePredicate and #$MetaPredicate (qq.v.) that is used to state that the Cyc system will ''assume'' that a (sequence of) thing(s) is not in the extension (see #$relationExtension) of a given predicate if the #$CycInferenceEngine is unable to prove that it is.  \n<p>\n<code>(#$minimizeExtent PRED)</code> means that, for any sequence of things <code><THING1, ..., THINGn></code> such that <code>(PRED THING1 ... THINGn)</code> holds, the fact that this holds is either expressed by some GAF (i.e. a ''ground atomic formula''; see #$CycLClosedAtomicSentence) that is asserted in the Cyc Knowledge Base or is deducible via the inference engine from what is in the KB.  \n<p>\nThe practical import of a #$minimizeExtent assertion is that it reflects an underlying assumption that if the inference engine cannot prove some given sentence of the form <code>(PRED ARG1 ... ARGN)</code>, then that fact constitutes an argument for its negation <code>(#$not (PRED ARG1 ... ARGN))</code>; and, if the ''negation by failure'' inference parameter is turned on, the inference engine will actually conclude that this negation is true.  Note that a #$minimizeExtent assertion is weaker than the corresponding #$completeExtentEnumerable (q.v.) assertion would be, in that the latter does not require that the inference engine attempt to deduce <code>(PRED ARG1 ... ARGn)</code> before concluding that it is not true.  See also #$minimizeExtentForArg and the shared #$NoteOnClosedWorldAssumption."^^_string))) .
\"urn:uuid:1de9680a-75e1-42d5-b9f5-23a77eda5ba5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(minimizeExtent, (1), Predicate)) .
\"urn:uuid:5ef4e2d3-c948-4398-aa2e-06921006bcef"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(minimizeExtent, SetTheFormat)) .
\"urn:uuid:e7c242e6-5c0c-4a57-84f7-2c2164d7383f"[silk#strict] .
istAsserted(BaseKB, relationAll(minimizeExtent, BookkeepingPredicate)) .
\"urn:uuid:727d8206-adf7-4331-b2dc-4fe49b7096bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(mtVisible, ("A unary #$EvaluatablePredicate that applies to a #$Microtheory.  <code>(#$mtVisible MT)</code> means that the contents of <code>MT</code> are visible in the current query context.  \n\nIn general, \n<pre>\n(#$genlMt MT1 MT2) \n</pre>\nentails \n<pre>\n(#$ist MT1 (#$mtVisible MT2),\n</pre>\nbut the converse does not hold.  In particular, it fails when <code>MT1</code> is a #$ProblemSolvingCntxt.  For example, \n<pre>\n(#$ist #$EverythingPSC (#$mtVisible #$HumanSocialLifeMt))\n</pre>\nholds (in #$BaseKB), but\n<pre>\n(#$genlMt #$EverythingPSC #$HumanSocialLifeMt)\n</pre>\ndoes not hold (in #$BaseKB)."^^_string))) .
\"urn:uuid:91516d16-84cb-429f-900d-ea905417c5ca"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(mtVisible)) .
\"urn:uuid:c62aec38-b5d6-41b0-b7a0-e5479eb19138"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(mtVisible)) .
\"urn:uuid:fb17690b-3537-49ed-b1e5-98c73e504c1e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(mtVisible, (1), Microtheory)) .
\"urn:uuid:d5f85fdc-7a2f-4668-9d21-acc4386b0ebd"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(multiplicationUnits, ("A ternary predicate that relates #$UnitOfMeasure (q.v.) functions.  <code>(#$multiplicationUnits UNIT1 UNIT2 PRODUNIT)</code> means that <code>PRODUNIT</code> is the unit-of-measure that always returns the product of the values returned by <code>UNIT1</code> and <code>UNIT2</code> for two respective arguments (or argument-sequences) when it is itself applied to the product of those arguments (or sequences).  That is, whenever <code>(UNIT1 . ARGS1) = VALUE1</code> and <code>(UNIT2 . ARGS2) = VALUE2</code>, then <code>(PRODUNIT (#$TimesFn ARGS1 ARGS2)) = (#$TimesFn VALUE1 VALUE2)</code>.\n<p>\nFor example, (#$multiplicationUnits #$Mile #$Mile #$SquareMile) holds, and thus (#$TimesFn (#$Mile 2) (#$Mile 3)) is equal to (#$SquareMile 6).\n<p>\nThe predicate #$multiplicationUnits corresponds to (see #$functionCorrespondingPredicate) both of the functions #$UnitProductFn and #$PerFn (qq.v.).  Thus,\n<p>\n\t<code>(#$multiplicationUnits UNIT1 UNIT2 PRODUNIT)</code>\n<p>\nis equivalent to\n<p>\n\t<code>(#$equals PRODUNIT (#$UnitProductFn UNIT1 UNIT2))</code>\n<p>\nis equivalent to\n<p>\n\t<code>(#$equals UNIT1 (#$PerFn PRODUNIT UNIT2))</code> ."^^_string))) .
\"urn:uuid:68146114-aa08-4ce9-a5b8-8591812ee216"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(multiplicationUnits, (1))) .
\"urn:uuid:5ca00e9f-7169-4654-a573-83df2aabbe0c"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(multiplicationUnits, (2))) .
\"urn:uuid:671f0158-e9b1-40d2-ba3c-c38ff0b20c2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(multiplicationUnits, (2))) .
\"urn:uuid:308019bc-443d-4d0f-9704-1e79fc28554a"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(multiplicationUnits, (1))) .
\"urn:uuid:be918aaf-d0f1-4f84-a83b-d6c1489b1d06"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(multiplicationUnits, (3))) .
\"urn:uuid:19695132-e339-41d0-b514-abdc07277c43"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(multiplicationUnits, (3), UnitOfMeasure)) .
\"urn:uuid:b14f174e-2b68-41c8-aac0-29c2176cc71a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(multiplicationUnits, (2), UnitOfMeasure)) .
\"urn:uuid:090ba139-b26a-441d-b12e-2f61c5c2ad2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(multiplicationUnits, (1), UnitOfMeasure)) .
\"urn:uuid:a4519039-ee36-4bac-a586-a3e9fd563090"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(multiplicationUnits, singleEntryFormatInArgs)) .
\"urn:uuid:78759174-8400-45dd-ab61-1bafa612afe5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(multiplicationUnits, singleEntryFormatInArgs)) .
\"urn:uuid:2b9539cf-af13-4933-ac9b-e8b2d4850570"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(multiplicationUnits, singleEntryFormatInArgs)) .
\"urn:uuid:013fe995-0192-4471-998e-55f851e9ae94"[silk#strict] .
istAsserted(BaseKB, commutativeInArgs(multiplicationUnits, (1), (2))) .
\"urn:uuid:3437732f-66ae-4302-b583-a7bbd48d3d13"[silk#strict] .
istAsserted(BookkeepingMt, comment(myCreationPurpose, ("A #$BookkeepingPredicate and a #$DocumentationConstant that relates a CycL constant (or other reifiable denotational term) to the Cyc-based project for which the term was created.  (#$myCreationPurpose TERM PROJECT) means that TERM was created as part of work that was done for PROJECT, and implies that the creator of TERM (see #$myCreator) was working PROJECT at the time."^^_string))) .
\"urn:uuid:e43729c0-860c-4d02-a75c-032215ed8f23"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(myCreationPurpose, (1), Thing)) .
istAsserted(BookkeepingMt, argIsa(myCreationPurpose, (1), Thing)) .
istAsserted(BookkeepingMt, arg2Format(myCreationPurpose, singleEntryFormatInArgs)) .
istAsserted(BookkeepingMt, arg1Format(myCreationPurpose, openEntryFormatInArgs)) .
\"urn:uuid:edb0e4a6-e0e1-4468-a4b8-f927a5000f33"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(myCreationPurpose)) .
\"urn:uuid:6b1337cb-54fc-4611-8e84-7bd4f2802d99"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(myCreationPurpose, (1), CycLReifiableDenotationalTerm)) .
istAsserted(BookkeepingMt, argQuotedIsa(myCreationPurpose, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:60dc20cd-e72d-4568-8961-bca73e6cc696"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(myCreationPurpose, (1))) .
istAsserted(BookkeepingMt, openEntryFormatInArgs(myCreationPurpose, (1))) .
istAsserted(BookkeepingMt, singleEntryFormatInArgs(myCreationPurpose, (2))) .
\"urn:uuid:988a1aa4-8ee4-4359-a062-af2c6e3c6e20"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(myCreationPurpose)) .
\"urn:uuid:da063963-85b9-47a9-9c34-71188499413d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(myCreationPurpose)) .
\"urn:uuid:dcbec095-ae5e-4355-9b9c-94bffcd5f174"[silk#strict] .
istAsserted(BaseKB, definingMt(myCreationPurpose, BookkeepingMt)) .
\"urn:uuid:7286e974-7587-43b3-9273-0ef671a99242"[silk#strict] .
istAsserted(BookkeepingMt, comment(myCreationSecond, ("(#$myCreationSecond CONSTANT SECOND) means that the #$CycLConstant CONSTANT was created at the #$CycUniversalSecond SECOND on the day CONSTANT was created (the related predicate #$myCreationTime (q.v.) relates a #$CycLConstant to the day it was created).  The format of SECOND is HHMMSS; that is, the first two digits give the hour of the day on which the constant was created, the second two digits give the minute of the hour at which the constant was created, and the last two digits give the second of the minute at which the constant was created.  For example, midnight is 000000 (or simply 0), noon is 120000, 3:42:59 pm is 154259, and 11:59:59 pm is 235959."^^_string))) .
istAsserted(BookkeepingMt, singleEntryFormatInArgs(myCreationSecond, (2))) .
\"urn:uuid:19bbeb4c-7fc0-4559-89ac-50ccec356996"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(myCreationSecond, (2))) .
\"urn:uuid:ce65df23-963f-4414-9171-3bca7acf1fe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(myCreationSecond, (1), Thing)) .
istAsserted(BookkeepingMt, argIsa(myCreationSecond, (1), Thing)) .
\"urn:uuid:ee1028a6-2cde-4515-aae4-fa1d3cb1ee1b"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(myCreationSecond, Thing, Thing, (1))) .
\"urn:uuid:8377d20e-811d-44b1-8ed6-76f688e94df1"[silk#strict] .
istAsserted(BookkeepingMt, arg2Format(myCreationSecond, SingleEntry)) .
\"urn:uuid:c10db86d-d975-4d2f-9ced-35256535749c"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(myCreationSecond)) .
istAsserted(BookkeepingMt, backchainForbidden(myCreationSecond)) .
\"urn:uuid:fcae6d1f-0fdd-4ccf-8b8f-de6becd2fc3e"[silk#strict] .
istAsserted(BookkeepingMt, completeExtentEnumerable(myCreationSecond)) .
\"urn:uuid:8dbc40f1-8ec9-4f4e-802b-86b49ccab1f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(myCreationSecond, (1), CycLConstant)) .
istAsserted(BookkeepingMt, argQuotedIsa(myCreationSecond, (1), CycLConstant)) .
\"urn:uuid:7b737f35-81e8-4246-bf9c-6c87c6cb32ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(myCreationSecond, (1))) .
istAsserted(BookkeepingMt, comment(myCreationTime, ("<code>(#$myCreationTime CONSTANT TIME)</code> means that the #$CycLConstant <code>CONSTANT</code> was created at <code>TIME</code>, an instance of #$CycUniversalDate.  The format of <code>TIME</code> is YYYYMMDD; that is, the first four digits give the year in which the constant was created, the next two digits give the month in which it was created, and the final two digits give the day of the month on which it was created. For example, 19910309 is March 9, 1991."^^_string))) .
\"urn:uuid:cf6e7184-a460-4525-9fdf-cab30bccf667"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(myCreationTime, (1), Thing)) .
istAsserted(BookkeepingMt, argIsa(myCreationTime, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(myCreationTime, MetaVariableFn(("MY-CREATION-TIME"^^_string)))) .
\"urn:uuid:74881c01-957d-4292-b4db-8e0f315f0ee9"[silk#strict] .
istAsserted(BookkeepingMt, arg2Format(myCreationTime, SingleEntry)) .
\"urn:uuid:21d18cea-4e86-4dfe-97e1-2f617843d6d0"[silk#strict] .
istAsserted(BookkeepingMt, arg1Format(myCreationTime, SetTheFormat)) .
\"urn:uuid:c8bae798-e048-4c5f-bab1-9d6a1ea5aade"[silk#strict] .
istAsserted(BookkeepingMt, completeExtentEnumerable(myCreationTime)) .
\"urn:uuid:e4b03d7e-5f63-4d6a-bcc4-bbc03bd91ffa"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(myCreationTime, (1), CycLConstant)) .
istAsserted(BookkeepingMt, argQuotedIsa(myCreationTime, (1), CycLConstant)) .
\"urn:uuid:06f82309-051f-4360-9bfe-53b7cb472a32"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(myCreationTime, (1))) .
istAsserted(BookkeepingMt, singleEntryFormatInArgs(myCreationTime, (2))) .
\"urn:uuid:845a4f01-e815-4160-9b51-f2fb611abcaf"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(myCreationTime, (2))) .
\"urn:uuid:1cedb56d-b07a-42ff-9b60-88cf7272a3da"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(myCreationTime, Thing, Thing, (1))) .
\"urn:uuid:b9076244-0319-4fc0-ae01-bd68642c28e9"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(myCreationTime)) .
istAsserted(BookkeepingMt, backchainForbidden(myCreationTime)) .
\"urn:uuid:04da18a1-c787-4d2b-93ef-6191fe48122b"[silk#strict] .
istAsserted(BaseKB, definingMt(myCreationTime, BookkeepingMt)) .
istAsserted(BookkeepingMt, comment(myCreator, ("<code>(#$myCreator X Y)</code> means that <code>Y</code> is the constant representing the person who introduced the constant <code>X</code> into the Cyc vocabulary. In general, the editing interfaces to the Cyc KB only allow the KB to be modified when an instance of #$Cyclist is designated as the author of the changes.  See also #$sourceOfTerm-Person."^^_string))) .
\"urn:uuid:289c5e5d-f8b1-4e87-b1e6-e624717c15f6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(myCreator, (1), Thing)) .
\"urn:uuid:ed476305-ccb0-47bb-b6af-6e7e8f393ccc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(myCreator, (2), Cyclist)) .
istAsserted(BookkeepingMt, argIsa(myCreator, (1), Thing)) .
istAsserted(BookkeepingMt, argIsa(myCreator, (2), Cyclist)) .
istAsserted(EnglishParaphraseMt, genKeyword(myCreator, MetaVariableFn(("MY-CREATOR"^^_string)))) .
\"urn:uuid:95c394d5-22a3-4a50-827a-6543eef45e93"[silk#strict] .
istAsserted(BookkeepingMt, arg2Format(myCreator, SingleEntry)) .
\"urn:uuid:3a8608e5-953b-423c-8ad8-c0745c0f7b4e"[silk#strict] .
istAsserted(BookkeepingMt, completeExtentEnumerable(myCreator)) .
\"urn:uuid:4d0ea29f-1669-4578-983c-0ac8ad9c4c11"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(myCreator, (1), CycLReifiableDenotationalTerm)) .
istAsserted(BookkeepingMt, argQuotedIsa(myCreator, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:5832834d-2f0c-4de1-b804-8afae9beb544"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(myCreator, (1))) .
istAsserted(BookkeepingMt, singleEntryFormatInArgs(myCreator, (2))) .
\"urn:uuid:5ab8247f-5d07-476d-87a2-f72e9b8c8666"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(myCreator, (2))) .
\"urn:uuid:31fdcd8f-4126-4d85-afed-e55944d3b036"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(myCreator, Thing, Thing, (1))) .
\"urn:uuid:ff02b5b6-b1cb-422a-854b-9cb47cf5133a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(myCreator)) .
istAsserted(BookkeepingMt, backchainForbidden(myCreator)) .
\"urn:uuid:a5ef7251-1450-43b3-a7e9-b5c80099e9e7"[silk#strict] .
istAsserted(BaseKB, definingMt(myCreator, BookkeepingMt)) .
\"urn:uuid:80ad20d0-f50b-4ff7-b153-fbeea9362109"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nand, ("The #$LogicalConnective that represents the NAND operator in #$CycL. (#$nand P Q) is equivalent to (#$not (#$and P Q))."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(nand, ("either ~a or ~a is false"^^_string), TheEmptyList)) .
\"urn:uuid:7ba9a609-a956-4c36-b9bb-97783bd0eff5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(nand, (2))) .
\"urn:uuid:e91a9fc1-6c49-42f3-8ea3-350a423e4ea1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(nand, (1))) .
\"urn:uuid:25fc0852-9f23-4906-bff5-09db0d2aca54"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(nand, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:27f583dc-30c0-43f2-b94c-166639ce9b96"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(nand, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:67409766-c1bc-4b63-a8da-5430feab85ee"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(nand, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:a7a086cc-14c7-4ad0-be63-8586471e7be1"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(nand, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:3faae876-83cd-4bf0-b64f-566993cf3267"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(natArgument, ("(#$natArgument NAT N TERM) means that TERM is in the Nth argument position of the non-atomic term NAT.  For example,  (#$natArgument (#$JuvenileFn #$Dog) 1 #$Dog).  Note that (#$termOfUnit NAT (FUNCTION ... ARGN ...)) implies  (#$natArgument NAT N ARGN)."^^_string))) .
\"urn:uuid:3f176c93-9c38-4a3f-bf15-42400a1eb9d1"[silk#strict] .
istAsserted(BaseKB, notAssertible(natArgument)) .
\"urn:uuid:631b084b-9777-4a48-8688-2125456dfa56"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natArgument, (1), Thing)) .
\"urn:uuid:cf2fdb85-2813-444c-b0ef-988021bc2448"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natArgument, (3), Thing)) .
\"urn:uuid:3c1f9dad-d841-4ce9-983f-2aca625c4b64"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natArgument, (2), NonNegativeInteger)) .
\"urn:uuid:2c11c23b-e28e-489c-8a48-3297ae2ed90f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(natArgument, openEntryFormatInArgs)) .
\"urn:uuid:7819ca4a-ffbb-4fb9-900b-6d0c576f111f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(natArgument, singleEntryFormatInArgs)) .
\"urn:uuid:4d2cb15a-5e54-43ae-ad46-267ea997d829"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(natArgument)) .
\"urn:uuid:75ac8ff4-3ab3-4175-9ae9-f90b558bee36"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(natArgument)) .
\"urn:uuid:fae96f25-0a49-4119-9594-1ae19f87a472"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(natArgument, openEntryFormatInArgs)) .
\"urn:uuid:9f569ede-b0ff-41a4-9217-1afeb870b5df"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(natArgument)) .
\"urn:uuid:cdef2004-f81c-40e7-bfeb-31b612bfe05b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(natArgument, (1), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:d0c02406-f43a-4baa-b739-bc4505b5a437"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(natArgument, (1))) .
\"urn:uuid:77d5475d-fa38-471c-a43e-54cc825cb1da"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(natArgumentsEqual, ("(#$natArgumentsEqual NAT1 NAT2) means that the\narguments of NAT1 and NAT2 unify.  For example,  (#$natArgumentsEqual (#$FemaleFn #$Dog) (#$MaleFn #$Dog).  More precisely, (#$and (#$termOfUnit NAT1 (FUNCTION1 . ARGS)) (#$termOfUnit NAT2 (FUNCTION2 . ARGS))) implies  (#$natArgumentsEqual NAT1 NAT2)."^^_string))) .
\"urn:uuid:9ddd8bf4-9d8b-4f35-ab6a-0329ca65b691"[silk#strict] .
istAsserted(BaseKB, notAssertible(natArgumentsEqual)) .
\"urn:uuid:8bf6649c-810d-4fe0-b366-df46b99a5190"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natArgumentsEqual, (2), Thing)) .
\"urn:uuid:c13dec8e-ad99-4adc-b3ff-33606cca171c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natArgumentsEqual, (1), Thing)) .
\"urn:uuid:72ab2c69-7c2c-4c2d-934a-4fb42ff8423b"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(natArgumentsEqual)) .
\"urn:uuid:ab56c4aa-b910-49bd-a4a6-acb011523b61"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(natArgumentsEqual)) .
\"urn:uuid:d831e5fa-84e2-466d-878c-03b98be17d42"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(natArgumentsEqual)) .
\"urn:uuid:94e5fce3-b87b-4f77-9f58-abe3f9b012df"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(natArgumentsEqual, (2), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:f4ef9d7d-c981-46d8-94f6-d38fb7ddf9ef"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(natArgumentsEqual, (1), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:860f1960-86e3-4c9c-a673-0eb738e4ba3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(natArgumentsEqual, (2))) .
\"urn:uuid:cb5ea6e2-8d28-4f50-bf54-c91a03cfba22"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(natArgumentsEqual, (1))) .
\"urn:uuid:74137c1e-98c3-4ae8-8f0e-4971f6f6175a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(natFunction, ("(#$natFunction NAT FUNCTION) states that FUNCTION is the function used in the non-atomic term NAT.  For example,  (#$natFunction (#$JuvenileFn #$Dog) #$JuvenileFn).  More precisely, (#$termOfUnit NAT (FUNCTION ...)) implies  (#$natFunction NAT FUNCTION)."^^_string))) .
\"urn:uuid:bce57cb9-3baa-4643-b544-0ab38dd353f5"[silk#strict] .
istAsserted(BaseKB, notAssertible(natFunction)) .
\"urn:uuid:f3df536a-aab1-41db-80a7-4da5a571e1be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natFunction, (1), Thing)) .
\"urn:uuid:7e1bff5f-de39-451a-aa03-b90b0131f841"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(natFunction, (2), ReifiableFunction)) .
\"urn:uuid:a5499b6e-4eae-40e5-af54-b4052f661c5f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(natFunction, singleEntryFormatInArgs)) .
\"urn:uuid:27ab45b3-8967-4173-aeed-f6541ecd6d16"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(natFunction, openEntryFormatInArgs)) .
\"urn:uuid:a7990267-d446-460a-afc1-29e37ec0fef1"[silk#strict] .
istAsserted(BaseKB, relationAllExists(natFunction, 'CycLNonAtomicTerm-ClosedFunctor', ReifiableFunction)) .
\"urn:uuid:7563ae30-afbe-4654-9d19-3f8a65e7972a"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(natFunction)) .
\"urn:uuid:a6c49517-b6c3-431e-9579-dd6a351bc21b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(natFunction, (1), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:5e16ee19-61f2-4f9b-8754-9ea005d6123f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(natFunction, (1))) .
\"urn:uuid:2e2c6446-b2af-42a4-bec2-46677d55b2d5"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(natFunction, (2))) .
\"urn:uuid:a1dfbf50-dd05-494e-98da-628a8e519ddf"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(natFunction, Thing, Thing, (1))) .
\"urn:uuid:43a064ba-9e34-4af6-95d2-7675948d8cf7"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(natFunction)) .
\"urn:uuid:f8c27edc-dac5-4f62-ab4a-22715a8f918d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(natFunction)) .
\"urn:uuid:74c97684-8fba-4862-b6e8-95e8ef4bbd46"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestCommonGenlMt)) .
\"urn:uuid:f933676f-da75-42d7-9d14-8033a69698b5"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestCommonGenlMt)) .
\"urn:uuid:d778f42e-d471-44bb-a67c-df3554019960"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenlMt, (3), Microtheory)) .
\"urn:uuid:4f79d1f0-0e08-469f-b2d8-3387788dfb70"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenlMt, (2), Microtheory)) .
\"urn:uuid:c9e23cc5-4d9f-42a1-bdcc-1cddf48958a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenlMt, (1), Microtheory)) .
\"urn:uuid:2de832dc-917d-4a4d-baa9-7b6c4645eb54"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestCommonGenlMt, ("(#$nearestCommonGenlMt MT-1 MT-2 NEAR-MT) relates microtheories MT-1 and MT-2 to the nearest unsubsumed microtheories NEAR-MT of which both are spec microtheories.  This predicate is #$notAssertible, since it must always be recomputed from the current state of the #$genlMt hierarchy."^^_string))) .
\"urn:uuid:35d4a8b9-c088-4231-8b09-e9571d0e1a1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestCommonGenls, ("A #$TaxonomicPredicateForCollections that relates two collections to their nearest common generalizations represented in the Cyc Knowledge Base.  <code>(#$nearestCommonGenls COL1 COL2 NEAREST-GENL)</code> means that (i) <code>NEAREST-GENL</code> in known in the Cyc Knowledge Base to subsume (via #$genls) both <code>COL1</code> and <code>COL2</code> and (ii) there is no proper specialization of <code>NEAREST-GENL</code> that is known to subsume both <code>COL1</code> and <code>COL2</code>.\n<p>\nNote that #$nearestCommonGenls is <i>not</i> functional with respect to its third argument, as a pair of collections might have several nearest common generalizations, all orthogonal to each other.  Note also that this predicate is #$notAssertible, since it must always be recomputed from the current state of the represented #$genls heirarchy.  \n<p>\nSee also #$nearestCommonIsa and #$nearestCommonSpecs."^^_string))) .
\"urn:uuid:6c064fff-61cd-44d1-9027-3c33f5971c84"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonGenls, (2), Thing)) .
\"urn:uuid:20af1268-bfb5-437a-a498-bc74778d10d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonGenls, (1), Thing)) .
\"urn:uuid:5e223f45-4422-47ad-b06c-21a68ef21866"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonGenls, (3), Thing)) .
\"urn:uuid:6ce543b9-c77c-4675-b00e-8e3d6618661f"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestCommonGenls)) .
\"urn:uuid:2a6f0597-0333-4b88-9887-8e82da90102f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenls, (1), Collection)) .
\"urn:uuid:d4ab860a-69ef-456d-93f8-68994051ad1d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenls, (2), Collection)) .
\"urn:uuid:ec7ce4bc-19c0-4bb3-9a78-0234ab1e4104"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonGenls, (3), Collection)) .
\"urn:uuid:d107a6f7-7ec2-47c9-b423-a5525185903e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestCommonGenls)) .
\"urn:uuid:15a8fdb3-44d6-4d80-b196-a70b32e0a495"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestCommonIsa, ("(#$nearestCommonIsa THING1 THING2 NEAR-COL) means that NEAR-COL is a ''nearest'' collection of which both THING1 and THING2 are instances.  That is, both (#$isa THING1 NEAR-COL) and (#$isa THING2 NEAR-COL) hold, and there is no reified #$Collection NEARER-COL distinct from NEAR-COL such that (#$isa THING1 NEARER-COL), (#$isa THING2 NEARER-COL) and (#$genls NEARER-COL NEAR-COL) all hold.  Note that this predicate is non-assertible (see #$notAssertible), since its extension at any given time depends upon (and so must be computed from) the current state of the #$isa and #$genls hierarchies in the Cyc Knowledge Base. See also #$nearestCommonGenls and #$nearestCommonSpecs."^^_string))) .
\"urn:uuid:a25c594d-93b4-499a-ba37-2a61bea21c47"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonIsa, (3), Thing)) .
\"urn:uuid:fdefedeb-e4f8-4b37-9928-434adfc3f0c4"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestCommonIsa)) .
\"urn:uuid:8b8014fe-242b-44e4-a20c-9b0b6c8f2421"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonIsa, (1), Thing)) .
\"urn:uuid:cf0e59df-5c0b-4b2c-82b3-64fb2b0e2e69"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonIsa, (2), Thing)) .
\"urn:uuid:70b75a14-d35c-4081-b305-50200892895f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonIsa, (3), Collection)) .
istAsserted(EnglishParaphraseMt, genFormat(nearestCommonIsa, ("both ~a and ~a are ~a"^^_string), [(1), (2), [(3), [MetaVariableFn(("PN-MASS-NUMBER"^^_string)), MetaVariableFn(("PN-SINGULAR"^^_string)), MetaVariableFn(("MASS-NUMBER"^^_string))], MetaVariableFn(("GERUND"^^_string)), MetaVariableFn(("AGENTIVE-SG"^^_string)), MetaVariableFn(("SINGULAR"^^_string)), MetaVariableFn(("A-THE-WORD"^^_string))]])) .
\"urn:uuid:6ebecb54-28b6-4b2f-a33f-1ecef18c9daa"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestCommonIsa)) .
\"urn:uuid:59472633-d9c1-439a-88c7-075310664821"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestCommonSpecs, ("(#$nearestCommonSpecs COL-1 COL-2 NEAR-SPEC) relates collections COL-1 and COL-2 to the nearest unsubsumed collections NEAR-SPEC of which are subsets of both COL-1 and COL-2. This predicate is #$notAssertible, since it  must always be recomputed from the current state of the #$genls heirarchy.  For comparison, see also #$nearestCommonIsa and #$nearestCommonGenls."^^_string))) .
\"urn:uuid:a224b89d-69c2-4297-a7f2-0ce0172e2700"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonSpecs, (3), Thing)) .
\"urn:uuid:6bb46707-2fb5-43e4-84c2-ff97157588d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonSpecs, (1), Thing)) .
\"urn:uuid:2970243d-f6a3-443b-9203-bab47e62965d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestCommonSpecs, (2), Thing)) .
\"urn:uuid:57300ef2-ca7c-41cf-9a4c-ab7934c16b1f"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestCommonSpecs)) .
\"urn:uuid:c02e2d9c-3271-49a7-8d66-6bfff0ef174e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonSpecs, (2), Collection)) .
\"urn:uuid:ab9d350b-af1f-474c-8cd0-2514cdc073aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonSpecs, (3), Collection)) .
\"urn:uuid:c66dbb79-364a-4b5e-af47-a7a3b641e366"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestCommonSpecs, (1), Collection)) .
\"urn:uuid:8345138b-5a31-4f28-a3ed-7b9b03876621"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestCommonSpecs)) .
\"urn:uuid:4b986252-e330-4aa6-a431-a332dbc9d9a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestDifferentGenls, ("(#$nearestDifferentGenls COL-1 COL-2 NEAR-DIFF) relates collections COL-1 and COL-2 to the nearest unsubsumed collections NEAR-DIFF of which COL-1 is a subset but COL-2 is not. This predicate is #$notAssertible, since it  must always be recomputed from the current state of the #$genls heirarchy.  For comparison, see #$nearestDifferentIsa."^^_string))) .
\"urn:uuid:74f46331-35a9-4510-903b-fccd5be94a4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestDifferentGenls, (1), Thing)) .
\"urn:uuid:6d185ca1-21fa-4e5b-8d73-c7b61553613c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestDifferentGenls, (3), Thing)) .
\"urn:uuid:364e8cf1-a255-4dc5-9bda-de4a4bd7f6ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestDifferentGenls, (2), Thing)) .
\"urn:uuid:262b9023-101a-41f2-95b9-38469d8c1308"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestDifferentGenls)) .
\"urn:uuid:a15f61e0-98ce-4013-826b-fcc1184b54e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentGenls, (3), Collection)) .
\"urn:uuid:5c4ab531-c0d2-419f-a985-6d418fe6b9ba"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentGenls, (2), Collection)) .
\"urn:uuid:2c083d7b-579d-422e-bae8-875af89d8de0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentGenls, (1), Collection)) .
\"urn:uuid:b963bb11-37f2-4d88-8b53-39c4a1925332"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestDifferentGenls)) .
\"urn:uuid:7254ecbe-2fdc-4a44-ab35-0581ad1e601e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestDifferentIsa, ("(#$nearestDifferentIsa OBJ-1 OBJ-2 NEAR-DIFF) means that NEAR-DIFF is a ''nearest'' collection of which OBJ-1 is an instance, but OBJ-2 is not. That is, (#$isa OBJ-1 NEAR-DIFF) holds, but (#$isa OBJ-2 NEAR-DIFF) does not, and there is no reified #$Collection OTHER-COL distinct from NEAR-DIFF such that (#$isa OBJ-1 OTHER-COL) holds, (#$isa OBJ-2 OTHER-COL) does not hold, and (#$genls OTHER-COL NEAR-DIFF) holds. Note that this predicate is #$notAssertible, since it must always be recomputed from the current state of the #$isa and #$genls hierarchy. For comparison, see #$nearestDifferentGenls."^^_string))) .
\"urn:uuid:f95bb6a5-c754-48e0-8696-8dbc2928802c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestDifferentIsa, (3), Thing)) .
\"urn:uuid:d55ede28-1267-48ce-a06e-fb71d33e8be0"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestDifferentIsa)) .
\"urn:uuid:459dc8a8-7b3c-44b3-879b-664334befd52"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentIsa, (3), Collection)) .
\"urn:uuid:f34d801e-ef46-4397-8d25-1847db97953b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentIsa, (1), Thing)) .
\"urn:uuid:38ac7a48-bbde-46f1-a23f-ed7d3b0397bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestDifferentIsa, (2), Thing)) .
\"urn:uuid:a22e087c-571e-4a66-8704-a690eff9427f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestDifferentIsa)) .
\"urn:uuid:dd170bf1-bdb8-43f7-bc2f-a4bf55e9a9fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestGenlMt, ("A specialization of #$genlMt.  (#$nearestGenlMt MT NEAR-MT) means that NEAR-MT is a ''nearest'' microtheory of which MT is a specialization.  That is, (#$genlMt MT NEAR-MT) holds, MT is not identical to NEAR-MT, and there is no reified #$Microtheory NEARER-MT distinct from MT and NEAR-MT such that both (#$genlMt MT NEARER-MT) and (#$genlMt NEARER-MT NEAR-MT) hold.  Note that #$nearestGenlMt is non-assertible (see #$notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the #$genlMt hierarchy in the Cyc Knowledge Base."^^_string))) .
\"urn:uuid:e62cf1ca-aec0-48d0-8b83-7ab53bbcb678"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestGenlMt)) .
\"urn:uuid:6a7bda9e-f9ce-4a7e-b1dd-6aabef45c76f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenlMt, (1), Microtheory)) .
\"urn:uuid:543d80ce-7f10-4544-b6ec-ac30ea703790"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenlMt, (2), Microtheory)) .
\"urn:uuid:74b16e53-0abf-4b9d-943a-1c890b7ede8e"[silk#strict] .
istAsserted(BaseKB, fanOutArg(nearestGenlMt, (1))) .
\"urn:uuid:62846562-692d-4b8f-b2cb-9a67cbfdb80a"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestGenlMt)) .
\"urn:uuid:da62bcef-cd6d-4586-a6f3-c4693c8717c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(nearestGenlMt, nearestGenlMt)) .
\"urn:uuid:e0ed78df-aa28-412b-b9db-bb7b98c7e866"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestGenlPreds, ("A #$TaxonomicSlotForPredicates and a specialization of #$genlPreds (q.v.).  (#$nearestGenlPreds PRED NEAR-PRED) means that NEAR-PRED  is a ''nearest'' generalization of PRED.  That is, (#$genlPreds PRED NEAR-PRED)  holds, PRED is not identical to NEAR-PRED, and there is no reified #$Predicate  OTHER-PRED distinct from PRED and NEAR-PRED such that both  (#$genlPreds PRED OTHER-PRED) and (#$genlPreds OTHER-PRED NEAR-PRED) hold.  Note   that #$nearestGenlPreds is non-assertible (see #$notAssertible), since its  extension at any given time depends upon (and so must be recomputed from) the  current state of the #$genlPreds hierarchy in the Cyc Knowledge Base."^^_string))) .
\"urn:uuid:e1a4b2aa-5f07-4f13-a532-c98df416daee"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestGenlPreds)) .
\"urn:uuid:a74c1d39-cad2-4a08-bb33-d5fffea88d8a"[silk#strict] .
istAsserted(BaseKB, argIsa(nearestGenlPreds, (2), Predicate)) .
\"urn:uuid:3a51315a-86cd-4fa5-a439-ce81288c40d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenlPreds, (2), Predicate)) .
\"urn:uuid:3b955609-b3ec-4a8f-823b-763fdb796a66"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenlPreds, (1), Predicate)) .
\"urn:uuid:6a8f1344-e108-4f73-b222-8d5f53344197"[silk#strict] .
istAsserted(BaseKB, fanOutArg(nearestGenlPreds, (1))) .
\"urn:uuid:16fc20e2-e9b8-4a79-9026-ab0bdb1bf911"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestGenlPreds)) .
\"urn:uuid:1d77b85d-3ea3-456f-925e-eba18cc30699"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationInverse(nearestGenlPreds, nearestGenlPreds)) .
\"urn:uuid:dd2e81a9-ec10-478c-a530-c23f920238ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestGenls, ("A #$TaxonomicSlotForCollections and a #$KBDependentRelation (qq.v.) that is a specialization of #$genls. \n<code>(#$nearestGenls COL NEAR-COL)</code> means that <code>NEAR-COL</code> is a ''nearest'' generalization of <code>COL</code>.  More precisely:\n<p>\n(i) <code>(#$genls COL NEAR-COL)</code> holds, <br>\n(ii) <code>COL</code> is not identical to <code>NEAR-COL</code>, <br>\n(iii) both <code>COL</code> and <code>NEAR-COL</code> are reified, and <br>\n(iv) there is no reified #$Collection <code>NEARER-COL</code> distinct from <code>COL</code> and <code>NEAR-COL</code> such that both <code>(#$genls COL NEARER-COL)</code> and <code>(#$genls NEARER-COL NEAR-COL)</code> hold.\n<p>\nNote that #$nearestGenls is non-assertible (see #$notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the #$genls hierarchy in the Cyc Knowledge Base."^^_string))) .
\"urn:uuid:272e705c-74e4-48b3-99c2-f1b9a6660096"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestGenls, (1), Thing)) .
\"urn:uuid:ee7f016a-254b-4262-8783-1d9a0052d199"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestGenls, (2), Thing)) .
\"urn:uuid:39471694-f258-40bb-9bca-6a992f2dca1e"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestGenls)) .
\"urn:uuid:81215af2-547e-45ea-9ef8-6e4ef54ea9df"[silk#strict] .
istAsserted(BaseKB, argIsa(nearestGenls, (1), Collection)) .
\"urn:uuid:7fbbefae-3722-4f96-ba0c-17d0e0405a07"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenls, (1), Collection)) .
\"urn:uuid:17d59f9c-e19b-4914-8dc4-e9dc53bc3773"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestGenls, (2), Collection)) .
\"urn:uuid:1c64dd11-8a77-4544-b22e-bdefc3293b66"[silk#strict] .
istAsserted(BaseKB, fanOutArg(nearestGenls, (1))) .
\"urn:uuid:64816418-8039-47cf-92c3-98fc709443ac"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestGenls)) .
\"urn:uuid:ba005f01-afff-424e-80b0-e3fdec3a2e47"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nearestIsa, ("A #$TaxonomicSlotForAnyThing, and a specialization of #$isa (q.v.).  (#$nearestIsa OBJ COL) means that COL is a ''nearest'' collection of which OBJ is an instance.  That is, (#$isa OBJ COL) holds, OBJ is not identical to COL, and there is no reified #$Collection NEARER-COL distinct from OBJ and COL such that both (#$isa OBJ NEARER-COL) and (#$genls NEARER-COL COL) hold.  Note that #$nearestIsa is non-assertible (see #$notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the #$isa and #$genls hierarchy in the Cyc Knowledge Base."^^_string))) .
\"urn:uuid:f3f9cefb-743c-421a-91d3-3b84b1b8d450"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(nearestIsa, (2), Thing)) .
\"urn:uuid:162dc311-36ce-4f5a-adbb-e2e8ca03184e"[silk#strict] .
istAsserted(BaseKB, notAssertible(nearestIsa)) .
\"urn:uuid:18819c0d-152e-4c4f-a4ea-61bbd95b28f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestIsa, (1), Thing)) .
\"urn:uuid:35956d47-5bbc-4d20-a6f6-f00dfd6de462"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nearestIsa, (2), Collection)) .
\"urn:uuid:de5cdc7c-88f6-4c6b-9b56-9243f81c09e2"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nearestIsa)) .
\"urn:uuid:9d5400b1-fffd-489f-a69d-587081bed47e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(negationInverse, ("A #$MetaPredicate for stating that each of two binary predicates is a logical ''contrary'' of the other's inverse. <code>(#$negationInverse BINPRED1 BINPRED2)</code> means that if <code>BINPRED1</code> holds between a pair <code><THING1, THING2></code>, then <code>BINPRED2</code> does <i>not</i> hold between the inverse pair <code><THING2, THING1></code> (and vice versa).  In other words, <code>(#$negationInverse BINPRED1 BINPRED2)</code> is equivalent to <code>(#$not (#$and (BINPRED1 ARG1 ARG2) (BINPRED2 ARG2 ARG1)))</code>.\n<p>\nNote that any #$AsymmetricBinaryPredicate is related to itself by #$negationInverse.  For example, (#$negationInverse #$subordinates #$subordinates) holds, since if one person is a subordinate of another, the latter person cannot at the same time also be a subordinate of the former.  See also #$negationPreds and #$genlInverse."^^_string))) .
\"urn:uuid:780171af-efe8-4c55-ba34-2a0e9ba01bf5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationInverse, (2), BinaryPredicate)) .
\"urn:uuid:28f736fe-4c18-429f-9f5c-97f432981b6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationInverse, (1), BinaryPredicate)) .
\"urn:uuid:099dd840-a4e9-42fc-aa65-ad84e1b1072e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(negationInverse, SetTheFormat)) .
\"urn:uuid:c505d3fe-e95e-4bea-9cd1-a7ace5a462f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(negationInverse, SetTheFormat)) .
\"urn:uuid:bd7648a4-8611-44a2-b9c1-9e4a27dae670"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(negationMt, ("(#$negationMt MT-1 MT-2) means that the domain assumptions of the #$Microtheory MT-1 are inconsistent with those of the #$Microtheory MT-2, and no lifting can occur between MT-1 and MT-2 (i.e. assertions made in one microtheory should not be made visible to the other microtheory). For cases where two microtheories differ not in domain assumptions but purely in content (assertions made within those microtheories), see the less specialized #$contradictoryMt."^^_string))) .
\"urn:uuid:4393c32b-e5a6-41b1-9b40-801766d9d272"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationMt, (1), Microtheory)) .
\"urn:uuid:15b2948d-a783-411e-9179-398280d3368f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationMt, (2), Microtheory)) .
\"urn:uuid:1769f001-6dea-4aca-95c5-258009bf632b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(negationPreds, ("A #$MetaPredicate for stating that two predicates are logical ''contraries'' of one another.  <code>(#$negationPreds PRED1 PRED2)</code> means that if <code>PRED1</code> holds among a given sequence of things, then <code>PRED2</code> does <i>not</i> hold among that sequence (and vice versa).  Thus it is equivalent to \n\n<pre>  (#$not (#$and (PRED1 . ARGS) (PRED2 . ARGS))) .</pre>  \n\nFor example, (#$negationPreds #$owns #$rents) holds, as one cannot both own and rent a given thing at the same time.   \n<p>\nNote that the argument types of <code>PRED1</code> and <code>PRED2</code> need not be the same, they merely must not be disjoint.  Note also that <code>PRED1</code> and <code>PRED2</code> are constrained (see e.g. #$interArgIsa) either to both having the same fixed-arity (see #$FixedArityRelation) or to both having variable-arity (see #$VariableArityRelations).     \n<p>\nSee also #$genlPreds and #$negationInverse."^^_string))) .
\"urn:uuid:12cdedc4-757c-4591-8f34-abfc56280200"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationPreds, (1), Predicate)) .
\"urn:uuid:336ca30f-44a2-4ce9-bd25-7193c103df0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(negationPreds, (2), Predicate)) .
\"urn:uuid:ebb99f52-6789-4b87-ac86-8c073b452a53"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(negationPreds, SetTheFormat)) .
\"urn:uuid:e94834db-8523-4eb0-9d2a-17a448fffb72"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(negationPreds, SetTheFormat)) .
\"urn:uuid:87183ee8-a798-4c93-88c6-4a5d430adadc"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, VariableArityRelation, VariableArityRelation)) .
\"urn:uuid:99e15442-be8b-4e39-8a76-eac973328139"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, UnaryPredicate, UnaryPredicate)) .
\"urn:uuid:763fc8c2-55bc-4d1b-8d51-3995c8a592cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, BinaryPredicate, BinaryPredicate)) .
\"urn:uuid:0127eba9-ff58-421a-9e5a-0235f244efd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, TernaryPredicate, TernaryPredicate)) .
\"urn:uuid:c2ab19ba-438d-46a3-bf83-f16c085773f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, QuaternaryPredicate, QuaternaryPredicate)) .
\"urn:uuid:02c64cd8-0a17-4d59-93c1-b3c70081be6c"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa2-1'(negationPreds, QuintaryPredicate, QuintaryPredicate)) .
\"urn:uuid:22372b61-70b6-42d5-90d1-8d41a063fe7d"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, VariableArityRelation, VariableArityRelation)) .
\"urn:uuid:7ac3d8dd-6a1c-4c7e-9fc0-13d77a980e10"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, UnaryPredicate, UnaryPredicate)) .
\"urn:uuid:60d41dce-3d35-448a-8f8d-a9325af037dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, BinaryPredicate, BinaryPredicate)) .
\"urn:uuid:c19a9014-81a8-427c-8e19-8f1cf5bea8e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, TernaryPredicate, TernaryPredicate)) .
\"urn:uuid:6283a2fb-3789-4f0a-801f-6995e956a738"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, QuaternaryPredicate, QuaternaryPredicate)) .
\"urn:uuid:70d2ea08-8403-456d-bcc2-7a8146726a60"[silk#strict] .
istAsserted(UniversalVocabularyMt, 'interArgIsa1-2'(negationPreds, QuintaryPredicate, QuintaryPredicate)) .
\"urn:uuid:10bc234a-6a8f-4a43-949e-5f97d8421356"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), BinaryPredicate, (1), BinaryPredicate)) .
\"urn:uuid:f8d43d40-fc09-459f-9f55-beeaa5ab0e3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), VariableArityRelation, (1), VariableArityRelation)) .
\"urn:uuid:b581ea1d-da5f-4d20-91f4-92f23fc9c2b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), QuintaryPredicate, (1), QuintaryPredicate)) .
\"urn:uuid:a3710307-916e-41cd-8e99-f041314f8574"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), TernaryPredicate, (1), TernaryPredicate)) .
\"urn:uuid:80329a11-f01a-49c1-952f-7eee84b07491"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), UnaryPredicate, (1), UnaryPredicate)) .
\"urn:uuid:f06e3ec5-bf07-4667-ae0d-723200d09e96"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (2), QuaternaryPredicate, (1), QuaternaryPredicate)) .
\"urn:uuid:0653e835-6b0b-4ca4-97f2-973dc6252824"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), QuaternaryPredicate, (2), QuaternaryPredicate)) .
\"urn:uuid:9de842b3-be85-4345-8fb4-a4e735df5d2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), UnaryPredicate, (2), UnaryPredicate)) .
\"urn:uuid:2380bf65-33d0-445d-9bfe-9e44e808531f"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), BinaryPredicate, (2), BinaryPredicate)) .
\"urn:uuid:dde78b8c-a271-4c4a-a056-4c2fe4ffe05a"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), QuintaryPredicate, (2), QuintaryPredicate)) .
\"urn:uuid:b7dd274f-5864-4b33-b9cb-1407bf14af84"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), TernaryPredicate, (2), TernaryPredicate)) .
\"urn:uuid:3836e9cd-4e38-442f-ae1d-d7087a08988b"[silk#strict] .
istAsserted(UniversalVocabularyMt, interArgIsa(negationPreds, (1), VariableArityRelation, (2), VariableArityRelation)) .
\"urn:uuid:5181562f-7478-40dc-8ce2-e1ea7774ce2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(negationPreds, genlPreds, (2))) .
\"urn:uuid:873677c6-04dd-42f9-afba-bcab54bd099b"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(negationPreds, genlPreds, (1))) .
\"urn:uuid:790c2c9c-fadf-4432-9ea2-aec160684f91"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nonAbducibleWithValueInArg, (3), PositiveInteger)) .
\"urn:uuid:329ce085-9b40-49ef-aeec-53841ee6a6db"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nonAbducibleWithValueInArg, (2), Thing)) .
\"urn:uuid:57db28bb-3d6c-47d6-b948-9153aeb8d16c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nonAbducibleWithValueInArg, (1), Predicate)) .
\"urn:uuid:75764d9a-c9c0-4788-8b3d-3bc3df0534c1"[silk#strict] .
istAsserted(CoreCycLMt, comment(nonAbducibleWithValueInArg, ("A ternary predicate that is an instance of #$AbductionConstraintConstant (q.v.) and that can apply to a predicate and a specified value for a specified argument-place. \n<p>\n(#$nonAbducibleWithValueInArg PRED VALUE N) means that, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine cannot use abduction to hypothesize that any non-abduced terms are legitimate bindings for those variables.\n<p>\nFor example, (#$nonAbducibleWithValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, so Cyc cannot use abduction to hypothesize that Sealand is a member of the IMF.  (Note that this does not mean that Cyc cannot prove that some abduced term is a member of the IMF.)"^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(nor, ("neither ~a nor ~a"^^_string), TheEmptyList)) .
\"urn:uuid:33f7d001-ebe6-4a73-9138-85e34d4ddb5f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nor, ("The #$LogicalConnective that represents the NOR operator in #$CycL. (#$nor P Q) is equivalent to (#$not (#$or P Q))."^^_string))) .
\"urn:uuid:b1197166-dad5-42e1-b9ec-bc91b3b59973"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(nor, (2))) .
\"urn:uuid:ee977d21-9681-4bc7-ae04-fcf78e7c57c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(nor, (1))) .
\"urn:uuid:16fbefe1-6079-4f11-8e10-615356b2d04f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(nor, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:1d889fe8-0bb9-47e4-bccc-1a0d16549951"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(nor, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:d82f8fc9-95af-48bc-ab80-0128d455f29d"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(nor, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:ab4e8ecd-1f69-4dcb-8ed9-250c7ef8e914"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(nor, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:d23480a5-78bf-41f1-b7c4-333ca4899b2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(not, ("An instance of both #$LogicalConnective and #$UnaryRelation.  which takes an instance of #CycLSentence-Assertible as its argument. (#$not SENT) is true if and only if SENT is false (and false if and only if SENT is true)."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(not, MetaVariableFn(("NOT"^^_string)))) .
istAsserted(BookkeepingMt, oldConstantName(not, ("LogNot"^^_string))) .
\"urn:uuid:f27448f6-c43d-4ee3-b522-dfc0fa1f9ac6"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(not, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:22a2ab09-a0bc-4751-94d9-4e43ac771d71"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(not, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:076395a6-d27d-44f7-a38b-2c1bdb624751"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(not, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:cad4c014-3a13-4542-a590-c02b785f1da0"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(not, (1))) .
\"urn:uuid:e3e131da-d540-4529-b5b4-1c681e8dea69"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(notAssertible, ("A #$MetaPredicate for stating a certain restriction regarding the use of a given #$Predicate in assertions to the Cyc Knowledge Base.  (#$notAssertible PRED) means that no ground atomic formula (or ''GAF''; see #$CycLClosedAtomicSentence) whose initial (or ''0th'' argument-place) term denotes PRED can be asserted to the KB.  In many cases, PRED will be an #$EvaluatablePredicate whose extent is (re)computed as necessary and never cached in the KB.  \n<p>\nSee also #$notAssertibleCollection, which constrains collections \nin a similar fashion."^^_string))) .
\"urn:uuid:5de56abe-9e19-4f01-9b7b-eaba82a083be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(notAssertible, (1), Predicate)) .
\"urn:uuid:c403f5d1-9bc9-4950-8f96-7daed88e75ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(notAssertibleCollection, ("A #$UnaryPredicate used for stating a certain restriction regarding the use of a given #$Collection in assertions to the Cyc Knowledge Base.  (#$notAssertibleCollection COL) means that no ground atomic formula (or ''GAF''; see #$CycLClosedAtomicSentence) whose initial (or ''0th'' argument-place) term is `#$isa', and whose 2nd argument-place term denotes COL, can be asserted to the KB.  See also #$notAssertible, which constrains predicates in a similar fashion."^^_string))) .
\"urn:uuid:b621963d-8c02-4594-ac20-2678671eba2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(notAssertibleCollection, (1), Thing)) .
\"urn:uuid:88d2aa8b-3e33-4598-8098-056b36ad313e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(notAssertibleCollection, (1), Collection)) .
\"urn:uuid:0c21edc4-ec74-4897-8d05-7a8ff201fc15"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(notAssertibleMt, ("(#$notAssertibleMt MT) states that the #$Microtheory MT cannot be used as the microtheory of an assertion made to the KB; i.e., MT might be a microtheory used as scaffolding or one whose assertions are known to be complete.  See also #$notAssertibleCollection, and #$notAssertible."^^_string))) .
\"urn:uuid:bfd06a7e-ab4b-4f24-b89f-013f4492e367"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(notAssertibleMt, (1), Microtheory)) .
istAsserted(EnglishParaphraseMt, genFormat(notAssertibleMt, ("Sentences cannot be asserted in ~a"^^_string), [[(1), MetaVariableFn(("EQUALS"^^_string))]])) .
\"urn:uuid:d315875f-d067-4462-9069-59736b6aa38d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nthLargestElement, ("(#$nthLargestElement X N SET FUNCTION) means that X is an element of SET that has precisely N-1 other elements with a larger value for FUNCTION. For example, (#$nthLargestElement #$Alaska-State 1 #$State-UnitedStates (#$FunctionToArg 2 #$areaOfRegion)) means that Alaska is the largest state (no elements have a larger #$areaOfRegion). Yet there may be more #$nthLargestElements. For example, (#$nthLargestElement ?X 1 (#$TheSet 1 2 3 -3) #$AbsoluteValueFn) is true for both 3 and -3 ; when the elements in the set are ordered according to their absolute value both 3 and -3 are largest elements. See also #$nthSmallestElement."^^_string))) .
\"urn:uuid:9f7a7d49-4db9-484c-b306-c5432f52d6a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthLargestElement, (4), UnaryFunction)) .
\"urn:uuid:17cfacdf-b41a-426f-b7c9-9c14740b0416"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthLargestElement, (2), PositiveInteger)) .
\"urn:uuid:cb03a01b-2e9b-4ee5-ba3c-58abf65bda6e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthLargestElement, (3), SetOrCollection)) .
\"urn:uuid:efede025-037c-4137-88a1-f575b897a315"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthLargestElement, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(nthLargestElement, MetaVariableFn(("NTH-LARGEST-ELEMENT"^^_string)))) .
\"urn:uuid:abc984f9-60ee-49d0-a19b-4cfdc729b1a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(nthSmallestElement, ("(#$nthSmallestElement X N SET FUNCTION) means that X is an element of SET that has precisely N-1 other elements with a smaller value for FUNCTION. For example, (#$nthSmallestElement #$RhodeIsland-State 1 #$State-UnitedStates (#$FunctionToArg 2 #$areaOfRegion)). Yet there may be more #$nthSmallestElements. For example, (#$nthSmallestElement ?X 3 (#$TheSet 1 2 3 -3) #$AbsoluteValueFn) is true for both 3 and -3 - when the elements in the set are ordered according to their absolute value both 3 and -3 are 3rd smallest elements. "^^_string))) .
\"urn:uuid:af4e4b7e-52b9-4ffb-95e7-0792f87b8744"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthSmallestElement, (4), UnaryFunction)) .
\"urn:uuid:5c56c47d-2306-420f-8bb3-4c3b97045a5f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthSmallestElement, (3), SetOrCollection)) .
\"urn:uuid:e628ce5e-c098-44f2-b49e-1590bf4b47c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthSmallestElement, (2), PositiveInteger)) .
\"urn:uuid:67d5a708-3ff0-44ff-802b-d8638960046c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(nthSmallestElement, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(nthSmallestElement, MetaVariableFn(("NTH-SMALLEST-ELEMENT"^^_string)))) .
\"urn:uuid:73fc5135-a7de-4a1b-9ffe-f07e95a22f40"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(nthSmallestElement, openEntryFormatInArgs)) .
\"urn:uuid:03e775ce-dbe7-4120-8250-3ba38ef4b2af"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(nthSmallestElement, openEntryFormatInArgs)) .
\"urn:uuid:826d06f3-2351-4169-aad0-a44356cb6b2e"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(nthSmallestElement)) .
\"urn:uuid:20710c5d-b069-4e79-9b37-5a73ae3d3a5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(nthSmallestElement, openEntryFormatInArgs)) .
\"urn:uuid:da214ae4-c0f3-4776-b372-efa8d4e3e962"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(nthSmallestElement, openEntryFormatInArgs)) .
\"urn:uuid:d1c05c2b-6d5a-44b4-98a2-639186dcd5ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(numericallyEquals, ("A #$NumericComparisonPredicate that is applicable to #$ScalarIntervals (<i>q.v.</i>) of all sorts, including quantitative intervals (see #$NumericInterval and #$Quantity) as well as point values (see #$ScalarPointValue).  <code>(#$numericallyEquals VALUE1 VALUE2)</code> means that <code>VALUE1</code> is equal to <code>VALUE2</code> with respect to some scale that they are both on.  More precisely, there is some #$TotallyOrderedScalarIntervalType <code>SCALE</code> that <code>VALUE1</code> and <code>VALUE2</code> are instances of and the minimum (see #$minQuantValue) of <code>VALUE1</code> is equal to the minimum of <code>VALUE2</code> and the maximum (see #$maxQuantValue) of <code>VALUE1</code> is equal to the maximum of <code>VALUE2</code>.\n<p>\nNote that #$numericallyEquals is <i>not</i> a specialization of #$equals (<i>q.v.</i>), as numeric values of different sorts can be ''numerically  equivalent'' without being considered identical (e.g. the #$Integer 1 and the #$RealNumber 1.0)."^^_string))) .
\"urn:uuid:d77c3fea-64fa-46c3-aec3-f9fa6e135b85"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(numericallyEquals, (1), ScalarInterval)) .
\"urn:uuid:174133df-7714-4403-8737-7be9dfeb6c99"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(numericallyEquals, (2), ScalarInterval)) .
\"urn:uuid:5d43753a-a806-4ecf-95ab-3ed9db54c9ff"[silk#strict] .
istAsserted(BaseKB, argIsa(numericallyEquals, (1), ScalarInterval)) .
\"urn:uuid:2eb68eea-d036-41d7-8e56-2cc6499a8998"[silk#strict] .
istAsserted(BaseKB, argIsa(numericallyEquals, (2), ScalarInterval)) .
\"urn:uuid:50fe5bf3-629e-4679-b1a6-a657fbdac10b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(numericallyEquals, SetTheFormat)) .
\"urn:uuid:afd4bf93-afe5-4819-8c72-9ab58017a840"[silk#strict] .
istAsserted(BaseKB, fanOutArg(numericallyEquals, (2))) .
\"urn:uuid:98ad4ae2-7729-4a17-91b0-b6f7590cb8e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(numericallyEquals, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(numericallyEquals, ("numericallyEqual"^^_string))) .
\"urn:uuid:538d7376-ac40-44d4-b04d-1814d2548ea7"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(numericallyEquals, SubLSymbolFn(("CYC-NUMERICALLY-EQUAL"^^_string)))) .
\"urn:uuid:aac87727-c41a-4fc7-9fd2-05f7cf9f4c83"[silk#strict] .
istAsserted(BookkeepingMt, comment(oldConstantName, ("This bookkeeping predicate relates a CycL constant to a former ''name'' of that constant.  More accurately, (#$oldConstantName CONSTANT STRING) means that the underlying data structure currently associated with the CycL expression CONSTANT was formerly associated instead with the SubL string STRING.  If CONSTANT has undergone multiple ''renames'', STRING will \nnormally be its most recent former ''name''.  While #$oldConstantName sentences \ncan be asserted and edited by hand, they are asserted automatically when a Rename is done in the Knowledge Base."^^_string))) .
istAsserted(BookkeepingMt, argIsa(oldConstantName, (1), Thing)) .
istAsserted(BookkeepingMt, argIsa(oldConstantName, (2), CharacterString)) .
\"urn:uuid:46afad68-5fa3-4c40-bc06-8ee1af536300"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(oldConstantName, (1), Thing)) .
\"urn:uuid:e3a415c7-5b07-4a9d-ac6a-f7e683255e81"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(oldConstantName, (2), CharacterString)) .
\"urn:uuid:ac6894d7-857c-4285-a61d-f6b7d6bd7fdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(oldConstantName, (1), CycLConstant)) .
\"urn:uuid:4b7f7a3c-de92-4ced-933d-ae511aab6499"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(oldConstantName, (2), SubLString)) .
istAsserted(BookkeepingMt, argQuotedIsa(oldConstantName, (1), CycLConstant)) .
istAsserted(BookkeepingMt, argQuotedIsa(oldConstantName, (2), SubLString)) .
\"urn:uuid:51635226-448d-43f9-9b35-96249d3eb97e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(oldConstantName, (1))) .
\"urn:uuid:69ca38a7-5d76-49dc-9795-899c48cff22e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(oldConstantName, (2))) .
\"urn:uuid:c3baa528-fe8e-4cac-b74c-a9c5a743dd65"[silk#strict] .
istAsserted(BaseKB, definingMt(oldConstantName, BookkeepingMt)) .
\"urn:uuid:9280e627-29ba-4494-9cab-706dbca83c29"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(omitArgIsa, (2), NonNegativeInteger)) .
\"urn:uuid:fe9d85f2-866d-408a-9e92-f44b90c55b9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(omitArgIsa, (1), Relation)) .
\"urn:uuid:fe6d04fc-954d-40e1-a4da-8cf58dcb3a9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentAsserted(omitArgIsa)) .
\"urn:uuid:1cce13b9-5c44-4c75-bf00-b2f0cda5956e"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(omitArgIsa)) .
\"urn:uuid:a7b7fa77-829d-487b-a851-7418378edf05"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(omitArgIsa, ("<code>(#$omitArgIsa RELN N)</code> means that the relation <code>RELN</code> is not asserted to have a non-quoted argument constraint in its <code>N</code>th argument position, due to limitations of the Cyc system.  Since every relation relates things to other things, in principle every argument position for every relation should have an #$argIsa constraint; however, asserting some #$argIsa constraints will cause certain Cyc tests to fail."^^_string))) .
\"urn:uuid:e0b07ef0-bc49-41ba-b2c1-f870d55bd5e1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(opaqueArgument, ("A binary #$MetaLanguagePredicate that can be used to state that a given argument-place of a given CycL relation-denoting expression is <i>denotationally opaque</i>.  \n<p>\n<code>(#$opaqueArgument REL N)</code> means that if in a closed compound expression built from the CycL expression for <code>REL</code> -- i.e. a ground atomic formula (or <i>gaf</i>) if <code>REL</code> is a predicate or a closed non-atomic term (or <i>nat</i>) if <code>REL</code> is a function -- the term appearing in <code>REL</code>'s <code>N</code>th argument-place is replaced with another term having the same denotatum (or truth-value, if the term is a sentence), there is no guarantee that the resulting gaf (or nat) will itself have the same truth-value (or denotatum) as the original.  \n<p>\nMost argument-places of most relation-denoting expressions do  allow such substitutions to be made freely, and are thus <i>denotationally transparent</i>.  For example, given that (#$equals #$Cicero #$Tully), the truth of <code>(#$residesInRegion #$Cicero #$CityOfRomeItaly)</code> entails the truth of  <code>(#$residesInRegion #$Tully #$CityOfRomeItaly)</code>.  This shows that #$residesInRegion's first argument-place is denotationally transparent. On the other hand, if Caesar were seeking #$Cicero and found him then (<code>#$objectFound-Definite CaesarsSearchForCicero Caesar #$Cicero)</code> would be true; but <code>(#$objectFound-Definite CaesarsSearchForCicero Caesar #$Tully)</code> might nevertheless be false, because Caesar might not know that #$Tully is #$Cicero and thus might not realize that in finding #$Cicero he had found #$Tully.  Having such a realization is a necessary condition for #$objectFound-Definite's holding, which shows that this relation's third argument-place is denotationally opaque.  \n<p>\nAccording to one well-known semantics for denotational opacity (viz. #$GottlobFrege's), a term appearing in an opaque context (in most cases) denotes (not its ordinary denotatum, but) what is ordinarily its <i>intensional meaning</i> or <i>sense</i> (or <i>Sinn</i>, in Frege's native German).  \n<p>\n#$quotedArgument (q.v.) is a specialization of #$opaqueArgument, and a term appearing in a <i>quoted</i> context is interpreted as denoting <i>itself</i> (rather than its usual denotatum)."^^_string))) .
\"urn:uuid:7fbf37ae-587a-4820-a032-62e938fb1d02"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(opaqueArgument, (2), PositiveInteger)) .
\"urn:uuid:6248379b-8b24-45d8-9577-6a2651052bdd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(opaqueArgument, (1), Relation)) .
\"urn:uuid:8a0c98b5-8f0f-45ff-80e7-b6d021a0af20"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(opaqueArgument, openEntryFormatInArgs)) .
\"urn:uuid:200d04b0-7c38-493d-bbde-35001158a830"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(opaqueArgument, openEntryFormatInArgs)) .
\"urn:uuid:852fc86d-0706-4375-86fc-d47018b76243"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(opaqueArgument, (1))) .
\"urn:uuid:303b1ea4-312b-4c57-934c-677673a13f54"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(openEntryFormatInArgs, ("An instance of #$SpecificEntryFormatPredicate (q.v.).  <code>(#$openEntryFormatInArgs PRED N)</code> means that, for any particular way of fixing the other arguments to <code>PRED</code> besides the <code>N</code>th, there might be any number (including zero) of things such that, if taken as the <code>N</code>th argument, <code>PRED</code> holds of those arguments.  For example, #$openEntryFormatInArgs holds of #$biologicalMother with respect to its first argument-place, since a given female animal might have any number of offspring.  \n<p>\nUnlike the other reified instances of #$SpecificEntryFormatPredicate, #$openEntryFormatInArgs actually places no restriction at all on what <code>PRED</code> might or might not hold of with respect to the specified argument-place.  But one should not infer from this that #$openEntryFormatInArgs assertions are pointless; for they forestall duplication of effort by serving notice that the entry-format of a given argument-place has previously been considered and #$openEntryFormatInArgs was deemed appropriate.  \n<p>\n#$openEntryFormatInArgs is the most commonly-encountered specific entry-format in the Cyc Knowledge Base.  Contrast with #$singleEntryFormatInArgs."^^_string))) .
\"urn:uuid:c167b7dc-e7e6-4fb2-8fff-912da7a7d24d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(openEntryFormatInArgs, (1), Predicate)) .
\"urn:uuid:42b5849e-d99e-443f-8572-ddf662c6dba3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(openEntryFormatInArgs, (2), PositiveInteger)) .
\"urn:uuid:57c8cdf6-6308-45bc-b2ca-2e92fdd69bc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(operatorFormulas, ("A non-assertible #$MetaLanguagePredicate and specialization of #$termFormulas (q.v.) that relates CycL operators to CycL formulas in which they occur as the main operator.  <code>(#$operatorFormulas OPERATOR FORMULA)</code> means that <code>OPERATOR</code> occurs as the main operator (i.e. in the ''arg0'' position) of <code>FORMULA</code>.  \n<p>\nNote that both argument-places of #$operatorFormulas are implicitly ''quoted'' (see #$quotedArgument). So if the above #$operatorFormulas sentence is closed (see #$CycLClosedAtomicSentence), the two CycL expressions it mentions, <code>OPERATOR</code> and <code>FORMULA</code>, actually <i>appear in</i> that sentence -- as names of themselves.  Thus, the sentence \n\n<pre>  (#$operatorFormulas #$bordersOn (#$bordersOn #$France #$Germany))</pre> \n\nis true, due to the manifest fact that the <i>term</i> <code>#$bordersOn</code> occurs as the main operator in the sentence <code>(#$bordersOn #$France #$Germany)</code>. \n<p>\nNote that <code>FORMULA</code> in the above need not be true (if it's a sentence) or even semantically well-formed."^^_string))) .
\"urn:uuid:bbff94c4-a475-4d71-b28a-cbc6f34d1281"[silk#strict] .
istAsserted(BaseKB, notAssertible(operatorFormulas)) .
\"urn:uuid:60090461-04c4-4a7f-93b6-da060c9ce787"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(operatorFormulas, (1), Thing)) .
\"urn:uuid:e43a535d-e2f2-4b6f-bfa2-827bd03eb23a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(operatorFormulas, (2), Thing)) .
\"urn:uuid:79f42e03-c27c-49b5-ae9d-e362e9fa416d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(operatorFormulas, (1), Relation)) .
\"urn:uuid:3607d27c-9241-4677-a1ee-fd5a86f25855"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(operatorFormulas, openEntryFormatInArgs)) .
\"urn:uuid:933e0b38-3b54-4481-9f99-2e59e4409ac4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(operatorFormulas, singleEntryFormatInArgs)) .
\"urn:uuid:e3448081-216d-4d75-b774-6bd38d210c3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(operatorFormulas)) .
\"urn:uuid:cf7507b5-6831-46f2-b825-356139116464"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(operatorFormulas, (1), CycLClosedDenotationalTerm)) .
\"urn:uuid:fa8721c5-57ee-497e-9f5e-e8e9d3754b4a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(operatorFormulas, (2), CycLFormula)) .
\"urn:uuid:37b945ca-996c-426c-a603-6dc8a243a08a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(operatorFormulas, (2))) .
\"urn:uuid:44f3a25b-1e99-43f9-a366-6b2c8e79759e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(operatorFormulas, (1))) .
\"urn:uuid:f9ee1651-337e-4e0f-ac94-01270d580662"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(operatorFormulas, (2))) .
\"urn:uuid:aaee4848-643d-48e1-ac71-de9ee44e32b9"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(operatorFormulas, (1))) .
\"urn:uuid:32b9b2d8-9476-4cd8-9d66-58b7bf7122ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(operatorFormulas, (1))) .
\"urn:uuid:1b76ae49-0cca-429f-a3b9-5ac0496fff52"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(operatorFormulas)) .
\"urn:uuid:0d11f19b-3629-49aa-8ab8-146c4c2d8c64"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(cyc#or, ("A #$LogicalConnective that represents disjunction in #$CycL. It is a #$VariableArityRelation, taking an arbitrary number of instances of #$CycLSentence-Assertible as arguments.  (#$or P Q ... Z) is true if and only if at least one of the sentences P, Q, ..., or Z is true."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(cyc#or, MetaVariableFn(("OR"^^_string)))) .
istAsserted(BookkeepingMt, oldConstantName(cyc#or, ("LogOr"^^_string))) .
\"urn:uuid:cd42bab3-525c-4c13-8e71-16b4a1712624"[silk#strict] .
istAsserted(LogicalTruthMt, argAndRestQuotedIsa(cyc#or, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:8052ff82-97c8-49ca-8a36-62c63ad7b8e4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(cyc#or, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:c0d6bf03-070e-473a-9e03-12336e548038"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(cyc#or, (1))) .
\"urn:uuid:4ea87e96-f756-4887-8722-c89301c13568"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(overlappingExternalConcept, ("A predicate for mapping terms from an external data source to closely related concepts represented in Cyc.  <code>(#$overlappingExternalConcept THING SOURCE STRING)</code> means that in the external data source <code>SOURCE</code>, the meaning of <code>STRING</code> has significant semantic overlap with <code>THING</code>."^^_string))) .
\"urn:uuid:79a1a582-cb71-4025-9d46-bb87bf82ecf4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(overlappingExternalConcept, (3), CharacterString)) .
\"urn:uuid:2f75e05f-a962-4cf6-bde0-dd3cd0ac774b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(overlappingExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:7f77caca-c161-4b53-af9e-a4c1136c792c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(overlappingExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:b2de3bbe-399b-4d30-9528-202cf0994ab8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(overlappingExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:467a5d9e-3357-41b7-8b58-5f87ce8f951c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(overlappingExternalConcept, (1))) .
\"urn:uuid:9744e6c2-545d-4796-b4ef-f4ba336e1c3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(performSubL, ("<code>(#$performSubL SUBL)</code> states that the SubL expression <code>SUBL</code> has been successfully evaluated for side-effect.  #$performSubL is evaluated as late in an inference proof as possible.  See also #$trueSubL which evaluates usually as soon as possible in an inference.  For example, <code>(#$performSubL (#$ExpandSubLFn () (print ''Done'')))</code> will print out the string ''Done'' as a given proof path completes.  See #$ExpandSubLFn for a way to denote SubL within CycL.  See also #$EvaluateSubLFn."^^_string))) .
\"urn:uuid:92fb0d75-1228-45e1-a9e4-1e433321993c"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(performSubL)) .
\"urn:uuid:5aa734a7-5204-4845-b93a-cd3a46fe6309"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(performSubL)) .
\"urn:uuid:764a72e0-818e-4f93-a53f-d176888f8e71"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(performSubL)) .
\"urn:uuid:a10f8842-181d-4455-b522-216c6d594b47"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(performSubL, (1))) .
\"urn:uuid:74c8eb4e-dba9-4a80-b4d8-06c1e768a452"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(pointQuantValue, ("A #$NumericComparisonPredicate and a specialization of #$numericallyEquals, #$minQuantValue, and #$maxQuantValue (qq.v.).  #$pointQuantValue is essentially the relation #$numericallyEquals restricted to scalar point-values, with the additional proviso that its first argument must be given using a reifiable CycL term.  Thus a sentence of the form\n<p>\n\t<code>(#$pointQuantValue REIFIABLE-TERM OTHER-TERM)</code>\n<p>\nis true if and only if <code>REIFIABLE-TERM</code> is a #$CycLReifiableDenotationalTerm (q.v.), and <code>REIFIABLE-TERM</code> and <code>OTHER-TERM</code> denote the same #$ScalarPointValue (q.v.).\n<p>\nThis predicate is primarily used to state the equivalence of a reified scalar-denoting term (e.g. '#$Zero', '#$AvogadrosNumber', '#$SpeedOfLight') with an appropriate unreifiable term.  For example, both of the following sentences hold:\n<p>\n<pre>\n  (#$pointQuantValue #$Zero 0)\n</pre>\n<p>\n<pre>\n  (#$pointQuantValue\n    #$SpeedOfLight\n    (#$PerFn (#$Mile 186000) (#$HoursDuration 1))'  .\n</pre>"^^_string))) .
\"urn:uuid:c2704957-8705-41a7-a17b-c06cdd59029c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(pointQuantValue, (1), Thing)) .
\"urn:uuid:a827e511-f636-42aa-aa9a-c7f3fdd0319b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(pointQuantValue, (2), ScalarPointValue)) .
\"urn:uuid:614f1844-c7bc-4929-aa84-dc7271cf1984"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(pointQuantValue, (1), ScalarPointValue)) .
\"urn:uuid:7e141aaf-c208-4ab7-8249-a28644a64f28"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(pointQuantValue, singleEntryFormatInArgs)) .
\"urn:uuid:c27c392a-1437-4a5a-a221-f362eee51fd9"[silk#strict] .
istAsserted(BaseKB, fanOutArg(pointQuantValue, (2))) .
\"urn:uuid:a8e7de7b-cd34-459f-9cb2-ae389e5a2efe"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(pointQuantValue, openEntryFormatInArgs)) .
\"urn:uuid:085eb900-2dc5-4463-91bf-7811850db9b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(pointQuantValue, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:c1e0b2bf-bae8-4985-99a9-75c206482af1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(pointQuantValue, (1))) .
\"urn:uuid:4ba3c4ef-3da6-48c1-bca4-dc31b2ef5988"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(pointQuantValue, (1))) .
\"urn:uuid:54eccce4-c2d8-4118-9023-972e4d7c38a9"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(pointQuantValue, (2))) .
\"urn:uuid:7f7d6e1e-a927-49b0-8de8-7fb50d45c5a8"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(pointQuantValue, (2))) .
\"urn:uuid:8b7c7038-c89d-4992-8831-241564698ccd"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(pointQuantValue, Thing, Thing, (1))) .
\"urn:uuid:7e5b3997-36dd-4bdd-8051-4db10713d72f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(pragmaticRequirement, ("A #$MetaKnowledgePredicate that is used to place a certain kind of pragmatic precondition on the use of a given asserted rule (see #$CycLRuleAssertion). (#$pragmaticRequirement SENTENCE RULE) means that SENTENCE expresses a necessary condition on RULE's being used in any proof carried out by the Cyc inference engine. The effect of asserting this is virtually the same as that of asserting (#$exceptWhen (#$unknownSentence SENTENCE) RULE): it blocks the use of RULE when SENTENCE is not currently ''known'' by the Cyc system to be true. SENTENCE should not contain disjuncts (or canonicalize into disjuncts). Upon assertion to the knowledge base, a #$pragmaticRequirement sentence is transformed by the canonicalizer into a rule involving #$pragmaticallyNormal (q.v.)."^^_string))) .
istAsserted(BookkeepingMt, oldConstantName(pragmaticRequirement, ("pragmaticImplies"^^_string))) .
\"urn:uuid:9ed16619-669e-4a15-ad9d-6c83202b70a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(pragmaticRequirement)) .
\"urn:uuid:1f4d3416-a263-4d3a-8c69-af4dccc194af"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(pragmaticRequirement)) .
\"urn:uuid:480373d8-b3d0-4f3c-9a4a-77a1eecb7ad5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(pragmaticRequirement, (1), 'CycLSentence-Askable')) .
\"urn:uuid:fb8484a0-91b6-4134-b897-d1b158b75bb8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(pragmaticRequirement, (2), CycLRuleAssertion)) .
\"urn:uuid:4ee5ab64-cf05-4bea-a76c-b71eb3624f77"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(pragmaticRequirement, (2))) .
\"urn:uuid:caf3b370-ce7a-43b4-abfe-ca0ebbd97dbb"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(pragmaticRequirement, (1))) .
\"urn:uuid:ff72c162-a841-43ff-a0cb-716a10048a23"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(pragmaticRequirement, meetsPragmaticRequirement)) .
\"urn:uuid:09beb671-6ef3-4873-bf8f-994b865f684f"[silk#strict] .
istAsserted(BaseKB, conceptuallyRelated(pragmaticRequirement, pragmaticallyNormal)) .
\"urn:uuid:66b82e55-8abb-4c76-954f-3342fe004664"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(pragmaticallyNormal, ("A #$MetaKnowledgePredicate that is used to express that certain pragmatic preconditions on a given rule are satisfied.  The predicate takes as arguments a list of CycL variables and an asserted rule (see #$CycLRuleAssertion) in which those variables occur ''free''.  At the EL (''epistemological level''), #$pragmaticallyNormal sentences are not asserted as GAFs, but appear instead as the antecedents of system-generated #$implies rules.  For a given sequence of values for the respective variables VAR1, ..., VARn,    (#$pragmaticallyNormal (#$TheList VAR1 ... VARn) RULE) means that any pragmatic preconditions placed on RULE's being used by the Cyc inference engine (see #$pragmaticRequirement) are satisfied with respect to those values.\n<p>\nLet's make this more precise and explicit.  A pragmatic precondition for a rule is written like so:\n<p>\n(#$pragmaticRequirement CONDITION RULE)\n<p>\nand gets canonicalized into a rule involving #$pragmaticallyNormal like so:\n<p>\n(#$implies\n(#$pragmaticallyNormal (#$TheList VAR1 ... VARn) RULE)\nCONDITION),\n<p>\nwhere VAR1, ..., VARn are all and only the variables that occur free in RULE and thus include all (and possibly only) the variables that occur free in CONDITION (i.e. as RULE and CONDITION explicitly appear in the KB browser, without consideration of their having ''implicit'' initial universal quantifiers).\n<p>\nThe above #$pragmaticallyNormal rule is used in inference as though it were a #$constraint rule.  If CONDITION does not hold for a given sequence of values <VAL1, ..., VALn> for its variables <VAR1, ..., VARn>, then those values are not ''pragmatically normal'' for RULE; and hence inference will not proceed using <VAL1, ..., VALn> with RULE.\n<p>\nThe effect of the foregoing is that any asserted rule RULE is implicitly treated by the Cyc inference engine as if it had the form\n<p>\n(#$implies\n(#$pragmaticallyNormal (#$TheList VAR1 ... VARn) RULE)\nRULE)\n<p>\n(with VAR1, ..., VARn as described above).\n<p>\nThis convention allows the logical content of a rule to be expressed independently of any pragmatic preconditions for its being used in inference.\n<p>\nAlso see #$abnormal, which is syntactically similar and has a related  interpretation that makes it roughly the complement of #$pragmaticallyNormal."^^_string))) .
\"urn:uuid:2703d80f-7e38-4b81-9619-1506a0cd929e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(pragmaticallyNormal, (1), List)) .
\"urn:uuid:bff8b1df-c03e-4441-85c4-11c57a0b65b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(pragmaticallyNormal, (2), CycLAssertion)) .
\"urn:uuid:7131f576-a651-4722-821c-71dc64fe4adc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(pragmaticallyNormal, (2))) .
\"urn:uuid:a06892ba-e762-43a8-8469-8230ce7b2d20"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(predicateConventionMt, ("(#$predicateConventionMt PRED MT) means that the predicate extent of the predicate PRED, by convention, is asserted in MT."^^_string))) .
\"urn:uuid:e9bea50d-b7e0-4eaf-8d36-d95cf2d26b63"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(predicateConventionMt, (2), Microtheory)) .
\"urn:uuid:e1a5986f-eed7-499d-b774-bbf5003c9e8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(predicateConventionMt, (1), Predicate)) .
\"urn:uuid:2674bde3-a032-48a9-82f3-fe6cfdfed163"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(predicateConventionMt, singleEntryFormatInArgs)) .
\"urn:uuid:16eecddf-bf90-41cc-906f-e698e0a57e24"[silk#strict] .
istAsserted(BaseKB, predicateConventionMt(predicateConventionMt, BaseKB)) .
\"urn:uuid:abf7ecb9-e2dd-439a-9f8e-259b85e957a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(preservesGenlsInArg, ("<code>(#$preservesGenlsInArg FUNCTION N)</code> means that the #$CollectionDenotingFunction <code>FUNCTION</code> has the following properties: \n<p>\n(1) argument place <code>N</code> of <code>FUNCTION</code> is constrained to instances of #$Collection, and <br>\n(2) if <code>COLLECTION1</code> and <code>COLLECTION2</code> can both serve as the <code>N</code>th argument of <code>FUNCTION</code>, and <code>COLLECTION2</code> is a specialization of <code>COLLECTION1</code> (so that <code>(#$genls COLLECTION2 COLLECTION1)</code> holds), then <code>(#$genls (FUNCTION ARG_1 ARG_2 ... ARG_N-1 COLLECTION2   ... ARG-M) (FUNCTION ARG_1 ARG_2 .. ARG_N-1 COLLECTION1 ... ARG-M))</code> also holds, where <code>ARG_1</code>, <code>ARG_2</code>, ..., <code>ARG_M</code> (where <code>M</code> is the #$arity of <code>FUNCTION</code>) are admitted arguments for <code>FUNCTION</code> (see #$admittedArgument).  \n<p>\nFor example, (#$preservesGenlsInArg #$GroupFn 1) holds because <code>(#$genls COL-2 COL-1)</code> implies <code>(#$genls (#$GroupFn COL-2) (#$GroupFn COL-1))</code>, for all collections <code>COL-1</code> and <code>COL-2</code> that satisfy the argument constraints for #$GroupFn.  \n<p>\nSimilarly, (#$preservesGenlsInArg #$SubcollectionOfByTypeFn 2) holds because <code>(#$genls COL-2 COL-1)</code> implies <code>(#$genls (#$SubcollectionOfByTypeFn FIXED-ARG COL-2) (#$SubcollectionOfByTypeFn FIXED-ARG COL-1))</code> for all collections <code>COL-1</code> and <code>COL-2</code>, and all arguments <code>FIXED-ARG</code>, that satisfy the appropriate argument constraints for #$SubcollectionOfByTypeFn.  See also the collection #$GenlsPreservingFunction."^^_string))) .
\"urn:uuid:c9721726-06a2-4914-beb7-4620ae0d2314"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(preservesGenlsInArg, (2), PositiveInteger)) .
\"urn:uuid:0a668595-98c9-438e-9775-c967ec1510e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(preservesGenlsInArg, (1), CollectionDenotingFunction)) .
\"urn:uuid:96ceea8d-508e-4a4d-8fa7-717762e489f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(preservesGenlsInArg, openEntryFormatInArgs)) .
\"urn:uuid:8b916343-c59a-4a7e-928a-f02818d2684a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(preservesGenlsInArg, openEntryFormatInArgs)) .
\"urn:uuid:3db04493-bd4a-4ffc-be99-e3b0da869ada"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(prettyString, ("(#$prettyString TERM STRING) means that STRING is the English word or expression (sequence of words) commonly used to refer to TERM.  The predicate #$prettyString is used by the code which generates CycL to English paraphrases, but its applicability is not restricted to this use."^^_string))) .
\"urn:uuid:d4015b51-9467-4bfc-91df-af3de8549b05"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(prettyString, (2))) .
\"urn:uuid:92ae565a-77e0-4d5e-b1aa-c0c61f8ace08"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(prettyString, (2), CharacterString)) .
\"urn:uuid:346dc7ed-7c53-4d71-841a-4e60f8c07d58"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(prettyString, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(prettyString, MetaVariableFn(("PRETTY-NAME"^^_string)))) .
\"urn:uuid:ba73edbd-65bd-4bc4-9861-03a2fd1b401d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(prettyString, SetTheFormat)) .
\"urn:uuid:e07a8ff2-fd5f-4345-b987-82cce66522f4"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(prettyString, SetTheFormat)) .
\"urn:uuid:e400a5ca-e142-4a8d-b9d0-ac0e30867893"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(prettyString, (2), SubLString)) .
\"urn:uuid:eb9657a1-a75b-4ac2-ab53-beb2fc50c295"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(prettyString, (2))) .
\"urn:uuid:d1ea9ff8-acf0-49d4-8db0-e1ad25780f83"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('prettyString-Canonical', ("(#$prettyString TERM STRING) means that STRING is the English word or expression (sequence of words) commonly used to refer to TERM.  The predicate #$prettyString is used by the code which generates CycL to English paraphrases, but its applicability is not restricted to this use."^^_string))) .
\"urn:uuid:9aa773f3-a01e-4bce-9d45-0db3c2a09921"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs('prettyString-Canonical', (2))) .
\"urn:uuid:5feebc56-5243-427c-8aac-42a4f874404b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('prettyString-Canonical', (2), CharacterString)) .
\"urn:uuid:1f9e6c6d-8d6a-4f20-bfa7-f5c6e42e2d04"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('prettyString-Canonical', (1), Thing)) .
\"urn:uuid:a6f2ae88-e2d3-498e-8983-c76f497448b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax('prettyString-Canonical', Thing, Thing, (1))) .
\"urn:uuid:d01e490f-ea9f-4b4e-af80-a224c5faf436"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format('prettyString-Canonical', SingleEntry)) .
\"urn:uuid:69f5e453-91b6-4fdf-bc5d-b4456de915f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format('prettyString-Canonical', SetTheFormat)) .
\"urn:uuid:9e8aaf05-159b-431b-8f40-804e77994484"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa('prettyString-Canonical', (2), SubLString)) .
\"urn:uuid:20d59e58-6430-4819-8d1f-1b2aa23c236c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument('prettyString-Canonical', (2))) .
\"urn:uuid:711d12b0-f7c6-4407-813f-dc335ee98a2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(provableViaDefns, (1), CycLSentence)) .
\"urn:uuid:ca838947-f05f-4b91-910a-0a1619fa8d04"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(provableViaDefns, (1))) .
\"urn:uuid:f006ccff-9ec8-4ebc-8be4-42f620d37c55"[silk#strict] .
istAsserted(UniversalVocabularyMt, evaluationDefn(provableViaDefns, SubLSymbolFn(("CYC-PROVABLE-VIA-DEFNS"^^_string)))) .
\"urn:uuid:836760e8-703c-4208-a13f-5bdc4b7c05ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(provableViaDefns, ("(#$provableViaDefns <code>SENTENCE</code>) means that <code>SENTENCE</code> is an atomic sentence with a predicate of #$isa or #$quotedIsa that is provable using #$defnIff and #$defnSufficient assertions, and the relationships between them (via #$genls).  Notably, <code>SENTENCE</code> is provable <i>without</i> using any asserted #$isa or #$quotedIsa assertions."^^_string))) .
\"urn:uuid:84b419a6-c44a-4c81-81fc-4498364b5f3d"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(provableViaDefns)) .
\"urn:uuid:1bbbc87d-174d-4307-9fd3-bbee8baf0e87"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quantityIntersects, ("A binary predicate that relates numerically measurable #$ScalarIntervals (q.v.) that intersect or overlap.  <code>(#$quantityIntersects SCALAR1 SCALAR2)</code> means that  <code>SCALAR1</code> and <code>SCALAR2</code> intersect. More precisely: there is  some scalar interval (which might even be as small as an  instance of #$ScalarPointValue) that is subsumed by (see #$quantitySubsumes) both <code>SCALAR1</code> and <code>SCALAR2</code>.\n<p>\nFor example, (#$Meter 2 5) -- the #$Distance of between 2 and 5 meters inclusive -- intersects both (#$Meter 3 4) and (#$Meter 3 7), but does not intersect (#$Meter 6 7)."^^_string))) .
\"urn:uuid:8089ef37-7194-4a10-9fc9-07d7b4cb8f56"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quantityIntersects, (2), ScalarInterval)) .
\"urn:uuid:6595ede6-73dd-402f-a2ad-ef39fe3f16bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quantityIntersects, (1), ScalarInterval)) .
\"urn:uuid:60303fa9-611c-42ea-a582-1ab44b833b7d"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(quantityIntersects, SubLSymbolFn(("CYC-QUANTITY-INTERSECTS"^^_string)))) .
\"urn:uuid:1c2e78c7-9d40-4d50-8012-884bcbd70f9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quantitySubsumes, ("A specialization of both #$quantityIntersects and #$intangibleParts, this predicate relates a given numerically measurable #$ScalarInterval to those scalar intervals that it subsumes or that ''fall completely inside'' it.    <code>(#$quantitySubsumes SUPER SUB)</code> means that both (i) the maximum (see #$maxQuantValue) of <code>SUPER</code> is #$greaterThanOrEqualTo the maximum of <code>SUB</code> and (ii) the minimum (see #$minQuantValue) of <code>SUPER</code> is #$lessThanOrEqualTo the minimum of <code>SUB</code>.\n<p>\nFor example, (#$Meter 2 5) -- the #$Distance of between 2 and 5 meters inclusive -- subsumes both (#$Meter 3 4) and (#$Meter 3 5), but not (#$Meter 3 6)."^^_string))) .
\"urn:uuid:f503ecb8-8767-4753-bd10-42c5359ec7a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quantitySubsumes, (2), ScalarInterval)) .
\"urn:uuid:2912ff50-123c-48ed-ae87-49bf6296c43e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quantitySubsumes, (1), ScalarInterval)) .
\"urn:uuid:b9c197b2-d66e-466e-b2b6-975f685710ae"[silk#strict] .
istAsserted(BaseKB, fanOutArg(quantitySubsumes, (2))) .
\"urn:uuid:01aa8095-35d7-43f5-86e4-452a7f775ec6"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(quantitySubsumes, SubLSymbolFn(("CYC-QUANTITY-SUBSUMES"^^_string)))) .
\"urn:uuid:41652f23-dc14-4873-865e-e277bc751cfe"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(querySentence, meetsPragmaticRequirement)) .
\"urn:uuid:1fa61bf9-e9d5-489d-92bc-e811d878651d"[silk#strict] .
istAsserted(UniversalVocabularyMt, conceptuallyRelated(querySentence, pragmaticRequirement)) .
\"urn:uuid:0d096654-137c-4e83-a39d-78fdf4460d25"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(querySentence)) .
\"urn:uuid:99005c38-0961-46e9-a8c6-d1d48aba99be"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(querySentence, ("#$querySentence is an HL level predicate that allows for special handling of a sentence (especially nested sentences) as a top level query during the process of canonicalization.  #$querySentence is not-assertible.  It should not be used in any assertions."^^_string))) .
\"urn:uuid:04c3c4fc-4f27-4b29-a58f-cd7a170950bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(querySentence, (1), CycLSentence)) .
\"urn:uuid:73fd4caf-323a-4a8f-880b-ad7166fa0614"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(querySentence, (1))) .
\"urn:uuid:d0019049-0625-48de-b483-793421cdce0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedArgument, ("A specialization of #$opaqueArgument (q.v.).  #$quotedArgument is a binary #$MetaLanguagePredicate used to state that a given argument-place of a given CycL relation-denoting expression is an <i>implicitly quoted</i> context, in the sense that a symbol appearing in that context denotes <i>itself</i> (as opposed to whatever that symbol might denote, if anything, in ordinary non-quoted contexts).  \n<p>\n<code>(#$quotedArgument REL N)</code> means that in a closed compound expression built from <code>REL</code> -- i.e. a ground atomic sentence (or <i>gaf</i>) if <code>REL</code> is a predicate or a closed non-atomic term (or <i>nat</i>) if <code>REL</code> is a function -- the term (i.e. the CycL expression) <code>EXPR</code> appearing in <code>REL</code>'s <code>N</code>th argument-place is taken to denote <i>itself</i> (i.e. that very expression <code>EXPR</code>).  \n<p>\n#$quotedArgument thus makes possible a kind of a self-reference in CycL. Relations with quoted argument-places can be used to make statements about particular CycL expressions, without quoting those expressions explicitly (cf. #$Quote).\n<p>\nFor example, the first argument-place of the predicate #$myCreator is quoted and its second argument-place is not.  Thus in the sentence <code>(#$myCreator #$PlanetEarth #$Maeda)</code>, the CycL constant <code>#$PlanetEarth</code> denotes that constant itself (and not the actual planet Earth), while the constant <code>#$Maeda</code> simply denotes the person Maeda (and not a CycL expression).  Hence the above sentence correctly states that Maeda created (i.e. reified) the CycL constant <code>#$PlanetEarth</code>; it does <i>not</i> state the absurdity that he created the planet Earth.  In ordinary non-quoted contexts, of course, <code>#$PlanetEarth</code> denotes the planet and not the constant.\n<p>\nSee also #$quotedCollection and #$NoteAboutUseVersusMention."^^_string))) .
\"urn:uuid:faf8ef48-b41a-435c-bf2d-e044c4fdc235"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedArgument, ("The main (longer) comment on this predicate was written to explain the role of #$quotedArgument in an earlier approach for referring to CycL expressions in the CycL language that is currently (April 2002) being phased out in favor of a new approach.  Whereas the earlier approach enabled self-reference only by means of a sort of ''implicit quotation'', the new approach involves a mechanism for explicitly quoting CycL expressions (by putting them inside something analogous to quotation marks).  #$quotedArgument, unlike #$quotedCollection (q.v.), still has a role to play with respect to the new approach, and its main comment will soon revised to better explain that role.  For an explanation of the new approach to quoting, see the shared #$NoteAboutQuotingInCycL and the constants that share that note."^^_string))) .
\"urn:uuid:f6a10b0d-4148-4264-97d7-d3671f8a2c0f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedArgument, (1), Relation)) .
\"urn:uuid:ccbcdbfd-eebe-4080-bba0-c846d2246415"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedArgument, (2), PositiveInteger)) .
\"urn:uuid:364bfc87-cada-4a6e-81a8-c4b19dc09db8"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(quotedArgument)) .
\"urn:uuid:c69c9d7e-1c9b-488e-badd-640d05d4f73e"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(quotedArgument)) .
\"urn:uuid:7781ae0b-7e3d-4543-8d10-bfdd09e981d4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(quotedArgument, (1))) .
\"urn:uuid:cd65eac8-6494-417e-b3e5-62e50bc72c06"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedDefnIff, ("A #$CycInferenceDescriptorPredicate. (#$quotedDefnIff COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a necessary and sufficient condition for a CycL term's denoting a quoted instance of (see #$quotedIsa) the collection COL. If and only if TEST returns `T' (for `True') when applied to a particular term can that term's denotatum be considered a quoted instance of COL; all and only terms that denote quoted instances of COL must fulfill TEST's requirements.  However, terms asserted to be quoted instances of the collection COL using #$quotedIsa are exempt from fulfilling TEST's requirements. See also #$quotedDefnNecessary and #$quotedDefnSufficient."^^_string))) .
\"urn:uuid:df300265-b18a-484f-a8ac-ad286e3859a2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(quotedDefnIff, (1), SubLSExpression)) .
\"urn:uuid:abb2fa17-8145-4a64-a750-1015c3673898"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedDefnIff, (1), SubLExpressionType)) .
\"urn:uuid:efc12661-5d0a-4e8a-801d-79d77ae63b5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(quotedDefnIff, (2))) .
\"urn:uuid:97f22d6d-f0e3-47ec-a237-276370c0b4b0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedDefnNecessary, ("A #$CycInferenceDescriptorPredicate. (#$quotedDefnNecessary COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a necessary condition for a CycL term's denoting a quoted instance of (see #$quotedIsa) the collection COL. Only if TEST returns `T' (for `True') when applied to a particular term can that term's denotatum be considered a quoted instance of COL; all terms that denote quoted instances of COL must fulfill TEST's requirements, although there may be additional requirements for denoting an instance of COL as well. However, terms asserted to be quoted instances of the collection COL using #$quotedIsa are exempt from fulfilling TEST's requirements. See also #$quotedDefnSufficient and #$quotedDefnIff."^^_string))) .
\"urn:uuid:790b3aa6-5176-485f-aee8-e48a0c62aac7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(quotedDefnNecessary, (1), SubLSExpression)) .
\"urn:uuid:004ab1de-4ba3-4534-a334-6d585e2a2f09"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedDefnNecessary, (1), SubLExpressionType)) .
\"urn:uuid:1782876e-af07-42e5-913c-367a90890bb2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(quotedDefnNecessary, (2))) .
\"urn:uuid:bcca1cb4-0acc-4f39-8f23-73ab428709bf"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedDefnSufficient, ("A #$CycInferenceDescriptorPredicate. (#$quotedDefnSufficient COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a sufficient condition for a CycL term's denoting a quoted instance of (see #$quotedIsa) the collection COL. If TEST returns `T' (for `True') when applied to a particular term, then that term's denotatum is considered to be a quoted instance of COL. Note that TEST isn't necessarily a necessary test for quoted membership in COL; that is, not all quoted instances of COL must pass the test, unless TEST is also a #$defnNecessary for COL, or the term is asserted to be a quoted instance of COL using #$quotedIsa. See the related predicates #$quotedDefnNecessary and #$quotedDefnIff."^^_string))) .
\"urn:uuid:234a3d35-f338-4042-ad0a-5effea3c7a1c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(quotedDefnSufficient, (1), SubLSExpression)) .
\"urn:uuid:47c820b9-ef4b-424f-a0bc-7dbf7c013f83"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedDefnSufficient, (1), SubLExpressionType)) .
\"urn:uuid:d5cb75f0-5f40-48ee-8c18-e67822c743d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(quotedDefnSufficient, (2))) .
\"urn:uuid:b736eea9-f361-4709-be44-01d7e6996ff6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(quotedIsa, ("A binary #$MetaLanguagePredicate (q.v.) that relates CycL expressions to the #$SubLExpressionTypes (q.v.) of which they are instances.  #$quotedIsa is thus like a restricted version of #$isa (q.v.), but with one important difference: the first argument-place of #$quotedIsa is ''implicitly quoted'' (see #$quotedArgument).  So a ground atomic sentence of the form <code>(#$quotedIsa THING EXPR-TYPE)</code> does <i>not</i> mean that <code>THING</code> itself is an instance of <code>EXPR-TYPE</code>.  Rather, such a sentence is partly self-referential, and means that the particular <i>CycL expression</i> appearing in the sentence's own first argument-position is an instance of <code>EXPR-TYPE</code>.  Thus, #$quotedIsa provides a convenient shorthand for stating certain things that would otherwise require explicit quotation (or some other device for naming expressions).\n<p>\nThis is better illustrated with a specific example.  Suppose we wish to state that the CycL constant <code>#$IndianOcean</code> is an instance of the CycL expression type #$PublicConstant.  We cannot express this with the straightforward #$isa sentence <code>(#$isa #$IndianOcean #$PublicConstant)</code>, as that states the falsehood that the IndianOcean itself -- which is <i>not</i> a constant but a body of water -- is a public constant.  But we can express precisely what we want like this:\n<pre>\n  (#$quotedIsa #$IndianOcean #$PublicConstant) .\n</pre>  \nNow #$quotedIsa is a #$MacroRelation (q.v.), and by its #$expansion any given #$quotedIsa sentence is equivalent to some #$isa sentence with an <i>explicitly</i> quoted first argument.  The sentence displayed above turns out to be equivalent to: \n<pre>\n  (#$isa (#$Quote #$IndianOcean) #$PublicConstant).\n</pre> \nBut the #$quotedIsa version has two related practical advantages over the #$isa version.  First, the former is syntactically simpler than the latter.  Second, the simpler syntax of the former makes it easier to browse in the Knowedge Base: while the #$quotedIsa version is conveniently indexed under the KB Browser page for the constant <code>#$IndianOcean</code>, the #$isa version would apparently be indexed under a separate, brand new page for the term <code>(#$Quote #$IndianOcean)</code>. Generalizing the point, #$quotedIsa lets us avoid having potentially to double the number of pages currently in the browser.\n<p>\nFor the semantically more complicated (but rarely encountered) case in which #$quotedIsa's first argument-place is filled with an <i>open</i> expression, see the accompanying #$cyclistNotes."^^_string))) .
\"urn:uuid:2c192532-1a4f-42c1-b2c0-b29ee1bd07d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(quotedIsa, (2), SubLSExpression)) .
\"urn:uuid:c94074be-095b-4f18-bc2d-dbb5ec55b8b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:13323c5e-2e8b-40fc-8d86-f73bd51dff40"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(quotedIsa, (1), Thing)) .
\"urn:uuid:f8b1acd1-5d0f-454b-be73-e0d3bdc20782"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(quotedIsa, SetTheFormat)) .
\"urn:uuid:375da45f-4705-4e6e-8460-6dd52b3ac6fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(quotedIsa, (1))) .
\"urn:uuid:1da856db-12d7-4955-b55d-64186ec49789"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(quotedIsa, genls, (2))) .
\"urn:uuid:602c750e-cd4d-47d3-a086-d87ad7235f45"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ratioOfTo, ("The predicate corresponding to #$QuotientFn.  (#$ratioOfTo NUM-1 NUM-2 NUM-3) holds just in case the ratio of NUM-1 to NUM-2 is NUM-3; that is, just in case  (#$QuotientFn NUM-1 NUM-2) = NUM-3.  For example, (#$ratioOfTo 1 2 0.5) is true because 1 divided by 2 is 0.5."^^_string))) .
\"urn:uuid:44cd7e6c-02b0-4675-bf7a-d1f8540bff20"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(ratioOfTo, (3))) .
\"urn:uuid:18935ba4-e15a-4785-95ce-d3ab092ed797"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ratioOfTo, (2), ScalarInterval)) .
\"urn:uuid:67e0e6b2-9142-49a1-9e91-00da1ad6d8b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ratioOfTo, (1), ScalarInterval)) .
\"urn:uuid:112ed44f-1b0a-46b4-b43d-ed030930d3e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ratioOfTo, (3), ScalarInterval)) .
\"urn:uuid:4851764e-1279-41e7-b0e8-9cb2729f4477"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulationDirectionInMode, ("(#$reformulationDirectionInMode DIRECTION MODE RULE), when\nasserted in the microtheory MT, tells the #$CycLReformulator whether to use RULE\nin the forward (#$ReformulationForwardDirection) or backward\n(#$ReformulationBackwardDirection) direction when reformulating\n#$CycLExpressions in MT or a specMt thereof, and when operating in the mode MODE.\nIt will reformulate the 'from' arg into the 'to' arg,\nbased on DIRECTION.  #$ReformulationNeitherDirection\nindicates the rule is not to be used at all in this mt.\nThis concept of direction has nothing to do with the forward vs. backward rule\ndistinction in inference."^^_string))) .
\"urn:uuid:1b27102a-55e9-4c68-bc4e-ba6fefba5621"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulationDirectionInMode, (3))) .
\"urn:uuid:373d1eba-f4fa-4b5e-8113-ceabcbbc3d4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulationPrecondition, ("(#$reformulationPrecondition DIRECTION PRECONDITION RULE), asserted in\nthe microtheory MT, means that the #$CycLReformulator may only use\nRULE in MT in the DIRECTION direction (reformulating the 'from' arg\ninto the 'to' arg) if PRECONDITION holds.  PRECONDITION must be a closed CycL query, which will be asked during reformulation, and either proven true or fail to be proven."^^_string))) .
\"urn:uuid:a6f1d453-b13d-4286-a28a-104bdf6936a9"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulationPrecondition, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:b93af6da-7f0a-47cd-bb62-5a002f9ad9a0"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, argIsa(reformulationPrecondition, (2), Thing)) .
\"urn:uuid:9822c8bc-0161-47b7-99c3-f3c8ef106baf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulationPrecondition, (3))) .
\"urn:uuid:ae48680e-0402-4b13-99fa-85c87dfd4ea5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulatorEquals, ("A #$CycLReformulationRulePredicate that relates two CycL denotational terms.  When asserted in a #$Microtheory MT, (#$reformulatorEquals TERM-1 TERM-2) means that the #$CycLDenotationalTerm TERM-1 may be reformulated into the #$CycLDenotationalTerm TERM-2, or vice-versa (based on meta-properties of this rule and what mode the reformulator is in), in any #$Microtheory SPEC-MT such that (#$genlMt SPEC-MT MT) holds.  Free variables in TERM-1 and TERM-2 are shared, and may bind with CycL terms which match the template.  Note that (#$reformulatorEquals TERM-1 TERM-2) does _not_ necessarily imply (#$equals TERM-1 TERM-2), although this implication would hold if the reformualtion is a #$TruthPreservingReformulation (q.v.)."^^_string))) .
\"urn:uuid:7c16fbbb-08c4-443c-b2e6-262e7f5bbb2a"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorEquals, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:643f39a7-bc60-43f4-b4be-82d315219541"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorEquals, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:ba18dfaf-bbdc-4c4b-8e62-3209d9f9e30e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(reformulatorEquals, (2), Thing)) .
\"urn:uuid:bcd6d8ee-0497-4d9c-b45f-1bb7a59ffac7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(reformulatorEquals, (1), Thing)) .
\"urn:uuid:71964b1c-b895-45ea-baa9-6406627411cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorEquals, (2), CycLDenotationalTerm)) .
\"urn:uuid:14d5e302-c99c-40fd-9c6b-82ac86b23ba3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorEquals, (1), CycLDenotationalTerm)) .
\"urn:uuid:f30dfa21-5bff-4c96-98c4-8d24d0b3dbc8"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorEquals, (1))) .
\"urn:uuid:eb7d683f-cd6e-43b3-a274-398d44587551"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorEquals, (2))) .
\"urn:uuid:5e083baa-03aa-4982-a52f-cfc3cb9443c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulatorEquiv, ("A #$CycLReformulationRulePredicate that relates two CycL sentences.  When asserted in a #$Microtheory MT, (#$reformulatorEquiv SENTENCE-1 SENTENCE-2) means that the #$CycLSentence SENTENCE-1 may be reformulated into the #$CycLSentence SENTENCE-2, or vice versa (based on meta-properties of this rule and what mode the reformulator is in), in any #$Microtheory SPEC-MT such that (#$genlMt SPEC-MT MT) holds.  Free variables in SENTENCE-1 and SENTENCE-2 are shared, and may bind with CycL sentences which match the template.  Note that (#$reformulatorEquiv SENTENCE-1 SENTENCE-2) does _not_ necessarily imply (#$equiv SENTENCE-1 SENTENCE-2), although this implication would hold if the reformulation is a #$TruthPreservingReformulation (q.v.)."^^_string))) .
\"urn:uuid:3eba5b46-fb36-46c2-b1f8-b369535a8afc"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorEquiv, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:3e374bf5-955f-4244-9d8b-ab055cc568a1"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorEquiv, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:44447558-bb86-48af-86fc-0fdcd7a898e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorEquiv, (2), CycLSentence)) .
\"urn:uuid:eed3a370-f1dc-4bf6-8d1d-ac95e9049332"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorEquiv, (1), CycLSentence)) .
\"urn:uuid:1d13c5d2-e8cc-4962-820a-dc51691b5b45"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorEquiv, (1))) .
\"urn:uuid:b3c33d91-ff16-41da-b71b-2b6868fa575f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorEquiv, (2))) .
\"urn:uuid:deb0af02-5a05-4e89-a60b-5ac60c267e56"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulatorRule, ("(#$reformulatorRule EXPR-1 EXPR-2), asserted in the\nmicrotheory MT, means that EXPR-1 may be reformulated into EXPR-2 (or\nvice versa, based on meta-properties of this rule and what mode the\nreformulator is in) in MT\nor a specMt thereof.  Free variables in EXPR-1 and EXPR-2 are shared,\nand may bind with CycL expressions which match the template. Truth\nand semantics are not necessarily preserved (see #$TruthPreservingReformulation).\nUse the more specific predicates #$reformulatorEquiv and #$reformulatorEquals\nwhen applicable."^^_string))) .
\"urn:uuid:09482d8e-ddae-40f3-a1c1-0b25dddbde47"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorRule, (1), LeaveSomeTermsAtEL)) .
\"urn:uuid:e05621a6-f270-43cd-86e0-f79281530ec7"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(reformulatorRule, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:61bcc3d7-fbe4-4544-92e7-99ad0125f76f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(reformulatorRule, (1), Thing)) .
\"urn:uuid:988c8fdf-e715-4f14-bf37-9e424aa8a050"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(reformulatorRule, (2), Thing)) .
\"urn:uuid:39d0e207-aa35-4340-9b05-70bf5a4335b7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorRule, (2), CycLExpression)) .
\"urn:uuid:48f618a2-a940-4b0e-bc76-8ff311455ab1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(reformulatorRule, (1), CycLExpression)) .
\"urn:uuid:fc8efe33-0566-4ba4-8aa8-93a2ad78c69a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorRule, (1))) .
\"urn:uuid:f490e1c5-073b-4787-8ce5-4e8a3f7b9d06"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorRule, (2))) .
\"urn:uuid:7ac4df74-0927-41be-990a-4ccb756d767e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(reformulatorRuleProperties, ("(#$reformulatorRuleProperties PROP RULE) means that RULE has\nthe property PROP.  Most reformulator directives express an assertion\nof the form 'The reformulator should do X', for some X.  In contrast,\n#$reformulatorRuleProperties assertions are stronger, in that they\nexpress intrinsic properties of reformulator rules, and it is a\nconsequence that the reformulator should do X in order to be\ncorrect.  For example, a reformulator directive could say 'For this\nreformulator rule, if in tersification mode, the reformulator should reformulate\nthe second argument into the first argument.', whereas a reformulator\nrule property could say 'This reformulator rule's first argument is\nmore terse than its second argument.'  The latter implies the former."^^_string))) .
\"urn:uuid:1e9983e7-0223-4875-80e7-f493cf1a8661"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(reformulatorRuleProperties, (2))) .
\"urn:uuid:dcb12450-4dce-40d3-8e74-6374cb3c1d67"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAll, ("A binary #$RuleMacroPredicate that relates a given unary predicate to a collection of things that the predicate holds of.  <code>(#$relationAll PRED COL)</code> means that, for every instance <code>INST</code> of <code>COL</code>, <code>(PRED INST)</code> holds.  Thus <code>(#$relationAll PRED COL)</code> is equivalent to -- and so can be used in effect as shorthand for -- (the unversal closure of) the more complex form:\n<pre>\n  (#$implies \n    (#$isa <b>?INST</b> COL) \n    (PRED <b>?INST</b>)) .\n</pre>\nFor example, <code>(#$relationAll #$assertedSentence #$CycLAssertion)</code> means that all #$CycLAssertions are asserted sentences.  \n<p>\nSee also #$relationOnly and the shared #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:4963cc77-0205-42df-ac9c-b654a73fa91d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAll, (2), Thing)) .
\"urn:uuid:3c5c09e1-aec5-4391-8b3e-cd8569674b2d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAll, (2), Collection)) .
\"urn:uuid:b8d288e4-8457-43b8-85f3-ee1651d11384"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAll, (1), UnaryPredicate)) .
\"urn:uuid:1f5cf861-bccb-45a2-a6ff-ea96b4525b8d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAll, openEntryFormatInArgs)) .
\"urn:uuid:b2060063-6656-4832-af27-77d7cb0736cb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAll, openEntryFormatInArgs)) .
\"urn:uuid:710d82b3-e82b-403d-9cb7-841886609284"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAll, genls, (2))) .
\"urn:uuid:e73fff09-cfd3-44c4-8360-b4099973bfa9"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAll, genlPreds, (1))) .
\"urn:uuid:d98e4da9-c3e5-41fd-8523-48a904d59785"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAllExists, ("A ternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain relation to two collections. <code>(#$relationAllExists BINPRED COL1 COL2)</code> means that for any instance <code>INST1</code> of <code>COL1</code>, there exists some instance <code>INST2</code> of <code>COL2</code> such that <code>(BINPRED INST1 INST2)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n  (#$implies\n    (#$isa ?INST1 COL1)\n    (#$thereExists ?INST2\n      (#$and\n        (#$isa ?INST2 COL2)\n        (BINPRED ?INST1 ?INST2)))).\n</pre>\n<p>\nFor example, <code>(#$relationAllExists #$temporalBoundsContain #$CalendarWeek #$Wednesday)</code> means that every calendar week contains a Wednesday.  See also #$relationExistsAll and #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:123d72d7-5095-44c5-98c8-2299db62e2c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExists, (3), Thing)) .
\"urn:uuid:0f904afe-4255-4b50-b422-e6251eb9a1ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExists, (2), Thing)) .
\"urn:uuid:ba8012f4-7a25-4d7a-be06-7d12af0c793e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExists, (2), Collection)) .
\"urn:uuid:a8cb0bb5-c685-48be-bbbf-3d50763ef8be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExists, (3), Collection)) .
\"urn:uuid:ac8b2603-5e34-4d66-bf73-3ff848753c8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExists, (1), BinaryPredicate)) .
\"urn:uuid:50ab4820-62d3-456b-8951-c6d802b9f8d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAllExists, openEntryFormatInArgs)) .
\"urn:uuid:4c53246e-a812-4b1a-8700-bcfff5842e1a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationAllExists, openEntryFormatInArgs)) .
\"urn:uuid:1c433377-eece-4723-8834-a424a6cdffd0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAllExists, openEntryFormatInArgs)) .
\"urn:uuid:a66a46d4-f95d-4c03-b964-dadb3c7e0f31"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExists, genls, (2))) .
\"urn:uuid:68a76024-713b-4c44-967f-a3dbd77f0d63"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAllExists, genlPreds, (1))) .
\"urn:uuid:8fd856e6-4978-4e8d-ac9d-1ca64c44b5ce"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAllExists, genls, (3))) .
\"urn:uuid:8ab31903-b3be-4db2-802f-69ec4cda2dc0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAllExistsCount, ("A quaternary #$RuleMacroPredicate that is a specialization of both #$relationAllExistsMin and #$relationAllExistsMax (qq.v.).  <code>(#$relationAllExistsCount BINPRED COL1 COL2 N)</code> means that for any instance <code>INST</code> of <code>COL1</code> there are exactly <code>N</code> instances <code>INST1</code>, ..., <code>INSTn</code> of <code>COL2</code> such that <code>(BINPRED INST INSTi)</code> holds (for 1 <code><= i <= N)</code>. It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<pre>\n  (#$implies\n    (#$isa ?INST COL1)\n    (#$thereExistExactly N ?INST-I\n      (#$and\n        (#$isa ?INST-I COL2)\n        (BINPRED ?INST ?INST-I))))\n</pre>\n<p>\n(wherein the variable <code>?INST</code> is interpreted as if it were bound by an initial universal quantifier).\n<p>\nFor example, <code>(#$relationAllExistsCount #$anatomicalParts #$Dog #$Leg 4)</code> means that all dogs have four legs.\n<p>\nCf. #$relationExistsCountAll, and see the #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:2b44871f-c94e-41e0-9f69-7ca819d49045"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsCount, (2), Thing)) .
\"urn:uuid:4535997b-2be1-4e50-938f-c6b91c02e537"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsCount, (3), Thing)) .
\"urn:uuid:fa0c818f-5d54-4534-a4bc-d06fbd0ed29b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsCount, (1), BinaryPredicate)) .
\"urn:uuid:755cfe06-ad24-490c-a389-c724ea80b4c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsCount, (4), NonNegativeInteger)) .
\"urn:uuid:1b6f46fa-c615-44b9-8c85-2ed1f35714be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsCount, (3), Collection)) .
\"urn:uuid:45b6e5f5-07bb-4f58-aaf6-0ffe01ec1d8a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsCount, (2), Collection)) .
\"urn:uuid:06b8f7c1-0d67-431d-8cfc-15e06ea533d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAllExistsCount, openEntryFormatInArgs)) .
\"urn:uuid:0d144c49-37d6-46a4-96e4-0342e29744e3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationAllExistsCount, openEntryFormatInArgs)) .
\"urn:uuid:d70c25ef-8ea3-4986-86fe-f584c5c33d88"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAllExistsCount, openEntryFormatInArgs)) .
\"urn:uuid:3d1caac2-e937-4dbd-80bf-dee3c18ca5ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationAllExistsCount, singleEntryFormatInArgs)) .
istAsserted(BookkeepingMt, oldConstantName(relationAllExistsCount, ("relationTypeCount"^^_string))) .
\"urn:uuid:721221ea-1bc9-4a26-9549-486b7d5bd109"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExistsCount, genls, (2))) .
\"urn:uuid:99fe825c-4d48-4885-83d6-7800d3ef7161"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAllExistsMax, ("A quaternary #$RuleMacroPredicate that can be used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (#$relationAllExistsMax BINPRED COL1 COL2 N) means that for any instance INST of COL1 there are at most N instances (INST(1), ..., INST(N)) of COL2 such that (BINPRED INST INST(i)) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(#$implies\n(#$isa ?INST COL1)\n(#$thereExistAtMost N ?INST-I\n(#$and\n(#$isa ?INST-I COL2)\n(BINPRED ?INST INST-I)))) .\n<p>\nFor example, `(#$relationAllExistsMax #$anatomicalParts #$Dog #$Leg 4)' means that all dogs have at most four legs.\n<p>\nCf. #$relationExistsMaxAll; also see #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:7edd9733-664e-4f66-9b2f-979e52864bda"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsMax, (3), Thing)) .
\"urn:uuid:1309469e-58dc-488d-8f1d-5b5faefd9acf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsMax, (2), Thing)) .
\"urn:uuid:70be63d2-575c-4049-b078-8405029b825e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMax, (4), NonNegativeInteger)) .
\"urn:uuid:61a08d16-9056-4612-b558-d745a9c72207"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMax, (1), BinaryPredicate)) .
\"urn:uuid:1f831b25-bb2f-4196-90f0-84d5c5855b9f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMax, (3), Collection)) .
\"urn:uuid:2e40ca04-9888-4465-879d-40faef53ed86"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMax, (2), Collection)) .
\"urn:uuid:adf11841-9b97-4f75-84ef-aac48cf71660"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAllExistsMax, openEntryFormatInArgs)) .
\"urn:uuid:23e472e8-1360-4aee-9ec1-58e6cf21cf18"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationAllExistsMax, openEntryFormatInArgs)) .
\"urn:uuid:a86f154a-f49b-4c23-9a06-09416a0c230c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAllExistsMax, openEntryFormatInArgs)) .
\"urn:uuid:b7def09a-08aa-4e03-88c7-b1cc3b6b7197"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExistsMax, genls, (3))) .
\"urn:uuid:fb22b4a5-87c2-4a2d-90e8-a319f700bd38"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExistsMax, genls, (2))) .
\"urn:uuid:b5507217-500c-424f-97fd-627c00bec5c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExistsMax, genlPreds, (1))) .
\"urn:uuid:0cc8d1eb-8fba-40e1-b935-37959df11eaa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationAllExistsMax, openEntryFormatInArgs)) .
\"urn:uuid:b6b13f18-36f7-40de-8e1d-c2fb7f8a63f9"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAllExistsMin, ("A quaternary #$RuleMacroPredicate that can be used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (#$relationAllExistsMin BINPRED COL1 COL2 N) means that for any instance INST of COL1 there are at least N instances (INST(1), ..., INST(N)) of COL2 such that (BINPRED INST INST(i)) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(#$implies\n(#$isa ?INST COL1)\n(#$thereExistAtLeast N ?INST-I\n(#$and\n(#$isa ?INST-I COL2)\n(BINPRED ?INST ?INST-I)))) .\n<p>\nFor example, `(#$relationAllExistsMin #$subEvents #$EatingEvent #$Swallowing 1)' means that every act of eating includes at least one swallowing. Cf. #$relationExistsMinAll, and see #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:473af880-839b-4875-acda-1eb3a042ba77"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsMin, (2), Thing)) .
\"urn:uuid:3e6e9d4f-df1e-4130-8e7d-86712fe89140"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllExistsMin, (3), Thing)) .
\"urn:uuid:f21355a5-dd0e-4045-afba-0901b7d2e9e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMin, (2), Collection)) .
\"urn:uuid:b2810c7e-929c-495d-bba7-76ebf82968fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMin, (1), BinaryPredicate)) .
\"urn:uuid:da009c36-63bf-4d9a-9898-4a79e492f1c5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMin, (3), Collection)) .
\"urn:uuid:5914a69e-be8c-48ce-ad61-b9dc615872be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllExistsMin, (4), NonNegativeInteger)) .
\"urn:uuid:8c14f678-5c4f-4837-ace2-e3ea5eace7f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAllExistsMin, openEntryFormatInArgs)) .
\"urn:uuid:bf1c9357-7a38-45c0-a833-e4208ba265d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationAllExistsMin, openEntryFormatInArgs)) .
\"urn:uuid:326e90a7-e18a-45d2-9099-d42bb898d8a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAllExistsMin, openEntryFormatInArgs)) .
\"urn:uuid:71f6bc80-af51-4870-b1d0-9e4564de20a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllExistsMin, genls, (2))) .
\"urn:uuid:99e61d35-f2a0-4527-a5fe-f3ac509d34c3"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAllExistsMin, genls, (3))) .
\"urn:uuid:1ead173d-71eb-434d-a07d-f745c7f421c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAllExistsMin, genlPreds, (1))) .
\"urn:uuid:caf5d1bb-684d-4975-befd-71c61967cf29"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationAllExistsMin, openEntryFormatInArgs)) .
\"urn:uuid:0d7f0fa1-5928-4168-bc5b-2a284b2c5011"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationAllInstance, ("A ternary #$RuleMacroPredicate that is used to state that a given binary predicate holds between all instances of a given collection and a given thing. <code>(#$relationAllInstance PRED COL THING)</code> means that every instance <code>INST</code> of <code>COL</code> bears the relation <code>PRED</code> to <code>THING</code> such that <code>(PRED INST THING)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n     (#$implies\n          (#$isa ?INST COL)\n          (PRED ?INST THING)) .\n</pre>\n<p>\nFor example, '(#$relationAllInstance #$maxSpeed #$GolfCart (#$MilesPerHour 15))' means that the maximum speed of every golf cart is 15 miles per hour. Cf. #$relationInstanceAll, and see #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:b98d16df-842b-4878-b5a4-87cd05bdb469"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationAllInstance, (2), Thing)) .
\"urn:uuid:f599112b-914d-44d7-acab-a2422e6d5fd1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllInstance, (3), Thing)) .
\"urn:uuid:c11cef93-3e67-4d41-b08b-484e5f0c0bc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllInstance, (2), Collection)) .
\"urn:uuid:aa119c44-4b11-4c91-ba3d-a6a06e0ed50a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationAllInstance, (1), BinaryPredicate)) .
\"urn:uuid:d45e210e-474a-4e26-af23-8e5bd74385f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationAllInstance, openEntryFormatInArgs)) .
\"urn:uuid:a969f4a7-4ec5-47f6-982e-8c395579badc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationAllInstance, openEntryFormatInArgs)) .
\"urn:uuid:0bb55fa9-08e3-486c-aa8a-519d747500c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationAllInstance, openEntryFormatInArgs)) .
\"urn:uuid:c92550f3-0164-41da-ac92-596f09900091"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllInstance, quantitySubsumes, (3))) .
\"urn:uuid:c224c281-6370-4a1e-a3d2-a47707900a29"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationAllInstance, genls, (2))) .
\"urn:uuid:3af1a223-baa8-42e8-a0b7-3cdbf68854ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationAllInstance, genlPreds, (1))) .
\"urn:uuid:e2ae1c20-91d9-42a0-b64e-cff4d00f50cc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExistsAll, ("A ternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain relation to two collections.  <code>(#$relationExistsAll BINPRED COL1 COL2)</code> means that for any instance <code>INST2</code> of <code>COL2</code>, there exists some instance <code>INST1</code> of <code>COL1</code> such that <code>(BINPRED INST1 INST2)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form\n<pre>\n  (#$implies\n    (#$isa ?INST2 COL2)\n    (#$thereExists ?INST1\n      (#$and\n        (#$isa ?INST1 COL1)\n        (BINPRED ?INST1 ?INST2)))).\n</pre>\nFor example, <code>(#$relationExistsAll #$adjacentTo #$Harbor #$PortCity)</code> means that for every port city there exists a harbor to which the city is adjacent.  See also #$relationAllExists and #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:2ed2d780-7893-4ea4-a173-39f763c7a54d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsAll, (2), Thing)) .
\"urn:uuid:22f903df-b26b-4f6b-b6b4-c2fd394d6508"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsAll, (3), Thing)) .
\"urn:uuid:284deb8a-0ac3-485b-b9f9-df489e883d79"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsAll, (3), Collection)) .
\"urn:uuid:f5a6b6ca-783e-46a4-a096-0098abbc7652"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsAll, (1), BinaryPredicate)) .
\"urn:uuid:5a076fe3-ff08-4677-a49f-1098fd50ad3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsAll, (2), Collection)) .
\"urn:uuid:0015e8ac-8470-4ccb-9f2a-3f098f69df01"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExistsAll, openEntryFormatInArgs)) .
\"urn:uuid:3581f2b0-93ef-4bbe-b859-d81a0787f0a1"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationExistsAll, openEntryFormatInArgs)) .
\"urn:uuid:2e5f23a9-ee88-49ce-b985-10610cb9e084"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationExistsAll, openEntryFormatInArgs)) .
\"urn:uuid:11652ffb-4989-4957-a551-aec9338d6fa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationExistsAll, genls, (3))) .
\"urn:uuid:fdd5f5fa-a595-4f5b-946a-0a1b60ebe412"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsAll, genlPreds, (1))) .
\"urn:uuid:762f6acf-9d7c-4b14-bbaf-12735f8d7be3"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsAll, genls, (2))) .
\"urn:uuid:1122f23b-3cbd-45cf-a0e7-6965bcc9cee5"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExistsCountAll, ("A quaternary #$RuleMacroPredicate (q.v.) that is used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (#$relationExistsCountAll BINPRED COL1 COL2 N) means that for every instance INST of COL2 there are exactly N instances of COL1 (INST(1), ..., INST(N)) such that (BINPRED INST(i) INST) holds (for 1 <= i <= N).  It is equivalent to (and so can be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n  (#$implies\n    (#$isa ?INST COL2)\n    (#$thereExistExactly N ?INST-I\n      (#$and\n             (#$isa ?INST COL1)\n             (BINPRED ?INST-I ?INST)))) .\n</pre>\n<p>\nFor example, (#$relationExistsCountAll #$anatomicalParts #$Animal #$Head-AnimalBodyPart 1) means that every animal head is a part of exactly one animal.  See also #$relationAllExistsCount and #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:f43dbe7c-9546-4291-9211-bf0ef18e71bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsCountAll, (2), Thing)) .
\"urn:uuid:7728f4d5-4563-4570-9d5a-1682af607d0e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsCountAll, (3), Thing)) .
\"urn:uuid:4b545656-4db6-44a7-9026-227a0ce10aa6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsCountAll, (2), Collection)) .
\"urn:uuid:6e996ffb-65c6-4930-84e5-7696d1152393"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsCountAll, (4), NonNegativeInteger)) .
\"urn:uuid:78f99663-883e-44ee-94da-bb77a9b87a93"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsCountAll, (3), Collection)) .
\"urn:uuid:f2f63540-6412-4372-a52e-cf34613df998"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsCountAll, (1), BinaryPredicate)) .
\"urn:uuid:f27f17ff-48b7-403c-9ac5-fa52bfab0989"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExistsCountAll, openEntryFormatInArgs)) .
\"urn:uuid:bb34daba-b4d9-440f-94b7-a1566b326547"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationExistsCountAll, openEntryFormatInArgs)) .
\"urn:uuid:d2201370-3f93-44f2-b2d8-a2f25e3f26d3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationExistsCountAll, openEntryFormatInArgs)) .
\"urn:uuid:154984fe-9a81-4941-bd05-0d9aeb1d1609"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsCountAll, genls, (2))) .
\"urn:uuid:06d11cc6-65cd-46fd-866c-9204d4fb4fed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationExistsCountAll, singleEntryFormatInArgs)) .
\"urn:uuid:99ae72f2-fd09-43cb-a489-a689424cb991"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExistsInstance, ("A ternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate holds between some instance of a given collection and a given thing.  <code>(#$relationExistsInstance BINPRED COL THING)</code> means that there exists an instance <code>INST</code> of <code>COL</code> such that <code>(BINPRED INST THING)</code> holds.  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n(#$thereExists ?INST\n  (#$and\n     (#$isa ?INST COL)\n     (PRED ?INST THING))) .\n</pre>\n<p>\nFor example, (#$relationExistsInstance #$eventOccursAt #$IllegalDrugActivity #$Sweden) means that there exists illegal drug activity in Sweden.  See also the shared  #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:56c2739a-611a-495e-a879-3d5207ad7a48"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsInstance, (2), Thing)) .
\"urn:uuid:8ade4eef-5ddc-4208-923c-106c2466afa8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsInstance, (3), Thing)) .
\"urn:uuid:d124457d-6df8-43cf-ae18-2d36164265ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsInstance, (2), Collection)) .
\"urn:uuid:bb4a5f74-9308-4f3e-8708-6731ddfb87e0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsInstance, (1), BinaryPredicate)) .
\"urn:uuid:5cb4f656-89d1-4483-a0b6-67d6a94d35fa"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExistsInstance, openEntryFormatInArgs)) .
\"urn:uuid:78fbc95d-1bb4-413a-ac98-e01f4f5cfa04"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationExistsInstance, openEntryFormatInArgs)) .
\"urn:uuid:58f30289-ddb3-4a7e-a841-8be35713d3bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationExistsInstance, openEntryFormatInArgs)) .
\"urn:uuid:a2b4b502-02e0-48e9-89f8-1cb5e7512804"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsInstance, genls, (2))) .
\"urn:uuid:7516f4d7-1ee6-446f-a50e-d5a41156240e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsInstance, genlPreds, (1))) .
\"urn:uuid:31f192f5-dfc4-4e76-b6e9-0778f1975dda"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExistsMaxAll, ("A quaternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain numerical relation with respect to two collections.  <code>(#$relationExistsMaxAll BINPRED COL1 COL2 N)</code> means that for any instance <code>INST</code> of <code>COL2</code>, there are at most <code>N</code> instances of <code>(INST(1), ..., INST(N))</code> of <code>COL1</code> such that <code>(BINPRED INST(i) INST)</code> holds (for 1 <= <code>i</code> <= <code>N</code>).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<pre>\n  (#$implies\n    (#$isa INST COL2)\n    (#$thereExistAtMost N ?INST-I\n      (#$and\n        (#$isa ?INST-I COL1)\n        (BINPRED ?INST-I INST)))).\n</pre>\nFor example, <code>(#$relationExistsMaxAll #$physicalParts #$Hand #$Finger 1)</code> means that every finger is part of at most one hand.  Cf. #$relationAllExistsMax, and see the shared #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:fc73a21a-feff-4855-be4c-8ba9b09fda8e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsMaxAll, (3), Thing)) .
\"urn:uuid:31044c8e-a3a1-46e7-a824-60c6ecec7531"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsMaxAll, (2), Thing)) .
\"urn:uuid:e5ef2c11-9190-42dd-b8ba-48d235d3ea0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMaxAll, (4), NonNegativeInteger)) .
\"urn:uuid:bf00407a-fc56-441f-a6ba-eaa7cb6e981a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMaxAll, (2), Collection)) .
\"urn:uuid:ca70858d-1b55-48c3-ade8-d7940931e74f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMaxAll, (1), BinaryPredicate)) .
\"urn:uuid:33bd0820-23c0-4445-981c-ad675f5c6517"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMaxAll, (3), Collection)) .
\"urn:uuid:09461af8-fb74-4d01-bc5b-417dbdfcb569"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExistsMaxAll, openEntryFormatInArgs)) .
\"urn:uuid:c5372b24-fd27-49eb-b66a-fe4e8a28621d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationExistsMaxAll, openEntryFormatInArgs)) .
\"urn:uuid:d465ca5a-6381-4f39-aeab-1a16aeba0437"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationExistsMaxAll, openEntryFormatInArgs)) .
\"urn:uuid:b774b4dd-b96b-4485-bec7-2d5bbd8def98"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationExistsMaxAll, genls, (3))) .
\"urn:uuid:a24a220e-8234-41cb-a28d-c8c5b73d78e9"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationExistsMaxAll, genls, (2))) .
\"urn:uuid:0778aa27-9325-473c-bd01-8d031cef4c97"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationExistsMaxAll, genlPreds, (1))) .
\"urn:uuid:32d09fc1-435e-4127-ac6e-620ccd4f3d65"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationExistsMaxAll, openEntryFormatInArgs)) .
\"urn:uuid:9597f062-c5fb-42bf-8a83-c2a84965b924"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExistsMinAll, ("A quaternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain numerical relation with respect to two collections.  (#$relationExistsMinAll BINPRED COL1 COL2 N) means that for any instance INST of COL2, there are at least N instances of (INST(1), ..., INST(N)) of COL1 such that (BINPRED INST(i) INST) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(#$implies\n(#$isa INST COL2)\n(#$thereExistAtLeast N ?INST-I\n(#$and\n(#$isa ?INST-I COL1)\n(BINPRED ?INST-I INST)))) .\n<p>\nFor example, `(#$relationExistsMinAll #$physicalParts #$Hand #$Finger 1)' means that every finger is part of at least one hand.  Cf. #$relationAllExistsMin, and see the shared #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:c46a7ca0-0236-42e6-ba0f-ec611a60b7a6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsMinAll, (2), Thing)) .
\"urn:uuid:70dd4892-62bf-4f43-844e-cb683d761904"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationExistsMinAll, (3), Thing)) .
\"urn:uuid:f382c1ad-df92-419f-8ef8-c36ad96af564"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMinAll, (2), Collection)) .
\"urn:uuid:f143d39f-a35e-45a7-a964-e289dafc4caf"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMinAll, (4), NonNegativeInteger)) .
\"urn:uuid:b1fea77f-77ce-4faa-bda1-738b6cdd0714"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMinAll, (1), BinaryPredicate)) .
\"urn:uuid:a224f92a-6aaa-4253-a26a-755538aa2232"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationExistsMinAll, (3), Collection)) .
\"urn:uuid:fac8f81c-ea8e-4b69-a005-a6c08ea3d07d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExistsMinAll, openEntryFormatInArgs)) .
\"urn:uuid:15677371-4d75-41b5-93ae-1f1ef38666e8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationExistsMinAll, openEntryFormatInArgs)) .
\"urn:uuid:c75ea32d-cec5-43f9-8c23-1c5df7b69883"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationExistsMinAll, openEntryFormatInArgs)) .
\"urn:uuid:e1bab990-dba9-4ab5-87d7-604cf3b9bc4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationExistsMinAll, genls, (2))) .
\"urn:uuid:73afac06-5f86-4da5-a4cc-bf77d8445dba"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsMinAll, genlPreds, (1))) .
\"urn:uuid:4e0ed2c8-2e57-46ab-998f-bdb4a025ac66"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationExistsMinAll, genls, (3))) .
\"urn:uuid:d34182e1-aa05-4e06-b177-5edc831941ac"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg4Format(relationExistsMinAll, openEntryFormatInArgs)) .
\"urn:uuid:67f6d369-597b-44a7-adf4-4b4fd7b0fdeb"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationExpansion, ("ARG2 is a CycL expression which indicates the meaning of expressions in which the relation ARG1 is the operator (i.e., in which ARG1 is in the 0th argument position).  In ARG2, the variables ?arg1, ?arg2, ?arg3, ?arg4, and ?arg5 correspond to the objects in the argument positions 1, 2, 3, 4, and 5, respectively, in expressions which have ARG1 as the operator."^^_string))) .
\"urn:uuid:1b003f22-1a05-446b-8d80-7c9f2dc6a3c3"[silk#strict] .
istAsserted(BaseKB, notAssertible(relationExpansion)) .
istAsserted(EnglishParaphraseMt, genKeyword(relationExpansion, MetaVariableFn(("RELATION-EXPANSION"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(relationExpansion, ("one CycL expansion for assertions which have ~a in the operator position is ~a"^^_string), [[(1), MetaVariableFn(("EQUALS"^^_string))], [(2), MetaVariableFn(("EQUALS"^^_string))]])) .
\"urn:uuid:ba8b3582-98d2-4026-b415-63d9e5081341"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationExpansion, SetTheFormat)) .
\"urn:uuid:93da791e-9c75-499c-962b-2a92a1dd36e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(relationExpansion, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:2cf4ea82-2793-4b7b-ad16-fa3e25b050c0"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(relationExpansion, (2))) .
\"urn:uuid:78422aff-fa2a-46a3-aa9a-87a2d2f799d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationInstanceAll, ("A ternary #$RuleMacroPredicate that is used to state that a given binary predicate holds between a given thing and all instances of a given collection. (#$relationInstanceAll BINPRED THING COL) means that THING bears the relation PRED to every instance INST of COL such that (BINPRED THING INST) holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(#$implies\n(#$isa ?INST COL)\n(BINPRED THING ?INST)) .\n<p>\nFor example, `(#$relationInstanceAll #$geopoliticalSubdivision #$UnitedStatesOfAmerica #$State-UnitedStates)' means that each State in the Union is a subdivision of the United States.  Cf. #$relationAllInstance, and see #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:1dcf0a11-074b-46e9-97ef-1880f2232a73"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationInstanceAll, (3), Thing)) .
\"urn:uuid:4c4241c4-5c54-462c-9633-5442a5cf0aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceAll, (2), Thing)) .
\"urn:uuid:788e9e2c-0f2c-4846-96af-ed18ba19259b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceAll, (1), BinaryPredicate)) .
\"urn:uuid:4af08bd6-f9a5-4954-9960-55654e4a5336"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceAll, (3), Collection)) .
\"urn:uuid:30f88bce-3905-483b-951e-d834a6cc82bc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationInstanceAll, openEntryFormatInArgs)) .
\"urn:uuid:e51f8756-3bbc-4aa0-9dff-14c40d7dfc20"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationInstanceAll, openEntryFormatInArgs)) .
\"urn:uuid:967f26f8-8e33-4e6f-aaab-67894b708389"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationInstanceAll, openEntryFormatInArgs)) .
\"urn:uuid:e1f73bb9-a904-4321-af36-03b975352097"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(relationInstanceAll, genls, (3))) .
\"urn:uuid:c44c1b42-1d1f-4a88-bf6f-da5dce2532d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationInstanceAll, genlPreds, (1))) .
\"urn:uuid:1f8d0e6a-efb9-4647-a1b5-b5b39cf4a0e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationInstanceExists, ("A ternary #$RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate holds between a specified thing and some instance of a given collection.  <code>(#$relationInstanceExists PRED THING COL)</code> means that there exists an instance <code>INST</code> of <code>COL</code> such that <code>(PRED THING INST)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n     (#$thereExists ?INST\n          (#$and\n               (#$isa ?INST COL)\n               (PRED THING ?INST))) .\n</pre>\n<p>\nFor example, '(#$relationInstanceExists #$geographicalSubRegions #$Iran #$OilField)' means that there exists an oilfield in Iran.  Cf. #$relationExistsInstance, and see the shared #$NoteAboutUseOfRuleMacroPredicates."^^_string))) .
\"urn:uuid:c00574ec-4697-4a72-b54b-d63c9a882a53"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(relationInstanceExists, (3), Thing)) .
\"urn:uuid:a476ad57-8cbe-4332-8b28-1e419d24560c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceExists, (3), Collection)) .
\"urn:uuid:b7ad3466-8a8a-4f72-be62-5b326a1c13be"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceExists, (2), Thing)) .
\"urn:uuid:a292958a-e69d-4dc3-80d0-d884c5bf45d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceExists, (1), BinaryPredicate)) .
\"urn:uuid:b113dbc0-3ca3-4993-ba31-8eacc70c0aea"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(relationInstanceExists, SetTheFormat)) .
\"urn:uuid:18b98ba5-a3cd-4a6b-a994-9948e2fb244a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(relationInstanceExists, SetTheFormat)) .
\"urn:uuid:33d59743-38e4-428e-beed-d17e18559af2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(relationInstanceExists, SetTheFormat)) .
\"urn:uuid:0714ad49-43cf-435d-8f4c-fbd25792b61c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationInstanceExists, genls, (3))) .
\"urn:uuid:2b03f77f-f0f2-4f1d-a73e-01b582ad587c"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationInstanceExists, genlPreds, (1))) .
\"urn:uuid:d7ccac5b-9e08-4a02-a4d9-40c67dff0b13"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationInstanceMember, ("(#$relationInstanceMember PRED INST GROUP) states that for every MEMBER of GROUP the following is true: (PRED INST MEMBER).  This predicate enables one to make claims about the members of a group by referencing only the group itself."^^_string))) .
\"urn:uuid:a75f79db-9949-4122-ba07-af8c5aef1de0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceMember, (1), BinaryPredicate)) .
\"urn:uuid:63ac0dc6-9874-457c-86f9-1654f1c88283"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationInstanceMember, (2), Thing)) .
\"urn:uuid:cbcc1b3d-acc4-484a-a1d5-9bb7a033afb6"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationInstanceMember, genlPreds, (1))) .
\"urn:uuid:4771e053-08f1-4e74-a300-1fe894c3161d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(relationMemberInstance, ("(#$relationMemberInstance PRED GROUP INST) states that for every MEMBER of GROUP the following is true: (PRED MEMBER INST).  This predicate enables one to make claims about the members of a group by referencing only the group itself."^^_string))) .
\"urn:uuid:2dbbe432-66b8-4712-938a-dcad2b4e78d9"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationMemberInstance, (3), Thing)) .
\"urn:uuid:cdee8e92-47f8-499b-ab44-a23a34ecbd52"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(relationMemberInstance, (1), BinaryPredicate)) .
\"urn:uuid:48e74544-5942-4ff3-8bfd-242f526c15af"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(relationMemberInstance, genlPreds, (1))) .
\"urn:uuid:2c590758-774d-407a-b11c-793bc6a448b8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(requiredArg1Pred, ("A #$MetaPredicate for stating that every instance of a given collection is related to some thing or things by a given predicate.  <code>(#$requiredArg1Pred COL PRED)</code> means that for every  instance <code>INST</code> of <code>COL</code>, there exists some sequence <code>ARGS</code> such that <code>(PRED INST . ARGS)</code> holds.  For example, (#$requiredArg1Pred #$Organization #$hasMembers) means that every organization has at least one member.  \n<p>\nSee also #$requiredArg2Pred and #$requiredArg3Pred."^^_string))) .
\"urn:uuid:6a2781fc-b4da-4247-a186-e872b1a6401c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(requiredArg1Pred, (1), Thing)) .
\"urn:uuid:87df5c1a-8849-43b7-b2b3-20bc2b328373"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg1Pred, (1), Collection)) .
\"urn:uuid:c26cf30f-1c23-41d0-b418-bc2648a10ee0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg1Pred, (2), Predicate)) .
\"urn:uuid:5e06d466-ac13-4ab9-a375-29a66e33e969"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(requiredArg1Pred, SetTheFormat)) .
\"urn:uuid:3fcbb536-6e4c-4c03-b52c-ec743acd49f0"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(requiredArg1Pred, SetTheFormat)) .
\"urn:uuid:cae21b67-2882-433b-9480-495f1738e086"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(requiredArg1Pred, genls, (1))) .
\"urn:uuid:1eb63342-856c-454f-b5cb-ede1fdb09cae"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(requiredArg1Pred, genlPreds, (2))) .
\"urn:uuid:ff26232c-3175-4ed9-9535-fc24a3827f20"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(requiredArg2Pred, ("A #$MetaPredicate for stating that every  instance of a given collection is related (as the ''arg2'') to some  thing or things by a given predicate.  (#$requiredArg2Pred COL PRED)  means that for every instance INST of COL, there exists some sequence  <X1, X3, ..., Xn> of such that (PRED X1 INST X3 ... Xn) holds.  For  example, (#$requiredArg2Pred #$Side #$objectSides) means that every  side is the side of at least one object.  See also #$requiredArg1Pred."^^_string))) .
\"urn:uuid:6635a809-9194-44a0-b3e0-d9887fb40238"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(requiredArg2Pred, (1), Thing)) .
\"urn:uuid:3fa89da1-20f3-46e1-b6a2-f94e581ef11f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg2Pred, (2), Predicate)) .
\"urn:uuid:92cc0730-8abe-4d90-a0d9-3c690f7ea490"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg2Pred, (1), Collection)) .
istAsserted(EnglishParaphraseMt, genFormat(requiredArg2Pred, ("every ~a is arg 2 of ~a relation"^^_string), [(1), [(2), MetaVariableFn(("QUOTE"^^_string)), MetaVariableFn(("A-THE-WORD"^^_string))]])) .
\"urn:uuid:adab89cf-bb7f-4b90-be80-0452d6ace61b"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(requiredArg2Pred, SetTheFormat)) .
\"urn:uuid:477de765-1e0f-45a1-9e66-276f4f6d0acc"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(requiredArg2Pred, SetTheFormat)) .
\"urn:uuid:4ddd4abd-d6ac-480c-99f4-11a48c3da3d0"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(requiredArg2Pred, genls, (1))) .
\"urn:uuid:8ccc8409-f891-45b2-a11b-f0beede8f245"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(requiredArg2Pred, genlPreds, (2))) .
\"urn:uuid:4872c44f-66fc-493f-a5ad-8fa6af1e2084"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(requiredArg3Pred, ("A #$MetaPredicate for stating that every instance of a given collection is related (as the ''arg3'') to some things by a given predicate.  <code>(#$requiredArg3Pred COL PRED)</code>  means that for every instance <code>INST</code> of <code>COL</code>, there exists some sequence  <<code>X1</code>, <code>X2</code>,..., <code>Xn</code>> such that <code>(PRED X1 X2 INST</code> ... <code>Xn)</code> holds.  For  example, (#$requiredArg3Pred #$ConflictEvent #$opponentsInConflict) means that every conflict involves (at least) two opponents.  See also #$requiredArg1Pred and #$requiredArg2Pred."^^_string))) .
\"urn:uuid:84df4227-3b01-4ef6-9940-a1b2ee003a0b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(requiredArg3Pred, (1), Thing)) .
\"urn:uuid:763f2b4a-2255-4d2b-811f-2e9fdb294cd2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg3Pred, (2), Predicate)) .
\"urn:uuid:50ce3da9-3e3c-4182-9894-8cf1d8ce8add"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(requiredArg3Pred, (1), Collection)) .
\"urn:uuid:91ed8a4e-b59d-4cd3-9901-6e9470a13239"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultGenl, ("A #$MetaFunction that is used to specify that a \ngiven collection is a supercollection of any value returned by a given #$CollectionDenotingFunction (q.v.).  <code>(#$resultGenl COLFUNC COL)</code> means that when <code>COLFUNC</code> is applied to any sequence of arguments <code>ARGS</code> for which it is defined, the resulting value will be a subcollection of <code>COL</code>.  That is, <code>(#$genls (COLFUNC . ARGS) COL)</code> holds.  \n<p>\nFor example, <code>(#$resultGenl #$UsingAFn #$Action)</code> implies that the collection of acts done using any given type of object is a type of action, <code>(#$resultGenl #$AttemptingFn #$PurposefulAction)</code> implies that the attempts at a given type of action constitute a type of purposeful act, and <code>(#$resultGenl #$JointTypeBetweenFn #$Joint-Physical)</code> means that the collection of joints between two given types of things is a type of physical joint.  \n<p>\nSee also #$resultIsa."^^_string))) .
\"urn:uuid:a3528fbe-322d-4eff-b983-c251de8cee85"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(resultGenl, (2), Thing)) .
\"urn:uuid:c4855c42-deff-4726-bad2-dfa3b88f082e"[silk#strict] .
istAsserted(BaseKB, argIsa(resultGenl, (1), Relation)) .
\"urn:uuid:3a12f224-81dc-463b-8ab8-ddfec40e3d01"[silk#strict] .
istAsserted(BaseKB, argIsa(resultGenl, (2), Collection)) .
\"urn:uuid:156d72f3-e18d-4716-8d4a-6ecca3b0a259"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultGenl, (1), CollectionDenotingFunction)) .
\"urn:uuid:4f8f2c5a-d218-47cf-9d9c-8feecab7bffc"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultGenl, (2), Collection)) .
\"urn:uuid:28ebee18-c8f3-4f8c-b250-808c7cb864a3"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(resultGenl, SetTheFormat)) .
istAsserted(BookkeepingMt, oldConstantName(resultGenl, ("usesAreSpecsOf"^^_string))) .
\"urn:uuid:c36c5626-4abc-4cef-bcad-9a01c7123d07"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(resultGenl, genls, (2))) .
\"urn:uuid:55f55c49-5982-4b16-bf2b-6cfe8f806b8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultGenlArg, ("A #$MetaFunction predicate that holds of certain #$CollectionRelatingFunctions with respect to certain argument-places.  (#$resultGenlArg FUNC N) means that FUNC always returns a subcollection of its own corresponding Nth-place argument, and that FUNC is ''#$genls preserving'' in that argument-place.  More precisely: (i) the value of FUNC for any sequence of arguments for which it is defined is a subcollection of the Nth item in that sequence (i.e. (#$genls (FUNC ARG1..ARGN..) ARGN)) and (ii) (#$preservesGenlsInArg FUNC N) holds.  For example, (#$resultGenlArg #$JuvenileFn 1) entails (#$genls (#$JuvenileFn #$Dog) #$Dog) and -- given that (#$genls #$Dog #$Mammal) --   (#$genls (#$JuvenileFn #$Dog) (#$JuvenileFn #$Mammal)).  See also #$resultIsaArg and #$resultGenl."^^_string))) .
\"urn:uuid:b8263921-0c69-4084-9462-e8d340e30c93"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultGenlArg, (2), PositiveInteger)) .
\"urn:uuid:1d53b3ea-cb97-45e4-ba43-d05d0b0d8dab"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultIsa, ("A binary #$MetaFunction that is used to indicate that any value returned by a given function (see #$Function-Denotational) is an instance of a given collection.  <code>(#$resultIsa FUNC COL)</code> means that <code>FUNC</code> returns an instance of <code>COL</code> for any sequence of arguments for which <code>FUNC</code> is defined.  That is, <code>(#$isa (FUNC . ARGS) COL)</code> holds for any sequence <code>ARGS</code> for which <code>FUNC</code> has a value (see #$valueOfFunctionForArgs and #$relationDomain).  \n<p>\nFor example, <code>(#$resultIsa #$PlusFn #$ScalarInterval)</code> holds, and it entails (e.g.) <code>(#$isa (#$PlusFn 2 2) #$ScalarInterval)</code>.  \n<p>\nSee also #$resultGenl."^^_string))) .
\"urn:uuid:09375168-8428-4995-a44f-9fff073b3682"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(resultIsa, (2), Thing)) .
\"urn:uuid:001d84f4-0dd5-4b52-8e30-f284b851e24d"[silk#strict] .
istAsserted(BaseKB, argIsa(resultIsa, (1), Relation)) .
\"urn:uuid:2f45dee8-1cdd-44f2-9014-c5c035c8ef90"[silk#strict] .
istAsserted(BaseKB, argIsa(resultIsa, (2), Collection)) .
\"urn:uuid:e97fc242-457f-4d3f-acd4-cc82a403e9fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsa, (1), 'Function-Denotational')) .
\"urn:uuid:7f1b0922-ce09-4b3b-a867-63797fe14ba0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsa, (2), Collection)) .
\"urn:uuid:34762e8f-b8fb-42df-8964-5b6e3b60de7c"[silk#strict] .
istAsserted(LogicalTruthMt, argIsa(resultIsa, (2), Collection)) .
\"urn:uuid:1301695c-8fb4-41aa-a222-0b47f5e80796"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(resultIsa, SetTheFormat)) .
\"urn:uuid:7a938dbb-ad62-4eb8-86e5-9fc39f754dfc"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllInstance(resultIsa, UnitOfMeasure, ScalarInterval)) .
\"urn:uuid:e9aee2ea-dfc2-40b5-9d9c-f488fcd547f2"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllInstance(resultIsa, CollectionDenotingFunction, Collection)) .
istAsserted(BookkeepingMt, oldConstantName(resultIsa, ("resultType"^^_string))) .
\"urn:uuid:d40ff261-0eaf-4b2d-812d-f9b5368923fb"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(resultIsa, genls, (2))) .
\"urn:uuid:fe34bb1c-9ed1-47f0-bdb5-3b197d22261a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultIsaArg, ("A #$MetaRelation predicate.  <code>(#$resultIsaArg FUNC N)</code>  means that the value returned by <code>FUNC</code> for any given sequence of arguments  is an instance of the <code>N</code>th argument in that sequence.  That is, if  <code>(FUNC ARG1 ... ARGN ...) = VALUE</code>, then <code>(#$isa VALUE ARGN)</code> holds.  Obviously, <code>ARGN</code> must be a collection; so <code>FUNC</code>'s <code>N</code>th argument-place is likely to be constrained (via #$argIsa) to be an instance of #$Collection or some specialization thereof.\n<p>\nFor example, (#$resultIsaArg #$The 1) entails that (#$The #$Dog) is an instance of #$Dog.\n<p>\nSee also #$resultGenlArg and #$resultIsa."^^_string))) .
\"urn:uuid:8612502c-53c4-4f9a-9291-39b7a878f4e6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsaArg, (1), 'Function-Denotational')) .
\"urn:uuid:67ae1932-e959-46dd-8cff-3a3d088a5462"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsaArg, (2), PositiveInteger)) .
\"urn:uuid:113e58da-a25a-4147-9e2f-6f4d691b8d9e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(resultIsaArg, SetTheFormat)) .
\"urn:uuid:6a9061a4-1599-461e-bb5e-ddb9cb79d0f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(resultIsaArg, SetTheFormat)) .
\"urn:uuid:c681230e-124c-47d4-9eec-73bdb5d337ff"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultIsaArgIsa, ("(#$resultIsaArgIsa FUNC INT) means that the NAT resulting from a use of FUNC is a member of the same explicitly asserted collections that the term\nin arg position INT is a member of."^^_string))) .
\"urn:uuid:73d1fb1a-3581-4e15-9fc2-8ef9ebe203d1"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentAsserted(resultIsaArgIsa)) .
\"urn:uuid:55a6fbe1-1cbf-4649-83ef-c363053bc925"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsaArgIsa, (1), 'Function-Denotational')) .
\"urn:uuid:2b904b1e-c3a7-446b-a4ac-b666eb978a33"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultIsaArgIsa, (2), PositiveInteger)) .
\"urn:uuid:c5b1717a-c731-4755-b3f5-4da8848a06e5"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(resultIsaArgIsa, openEntryFormatInArgs)) .
\"urn:uuid:cf9e5cba-d869-4568-9566-71e7c6c914b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(resultIsaArgIsa)) .
\"urn:uuid:a1152be3-4ec7-4570-8ad8-300911c01c99"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(resultIsaArgIsa, openEntryFormatInArgs)) .
\"urn:uuid:0cb14364-0181-4a1d-8b23-cc69a1a1e976"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(resultQuotedIsa, ("A binary #$MetaRelation predicate that holds between functions and expression-types. #$resultQuotedIsa indicates that any value returned by a given #$Function-Denotational is a ''quoted instance'' of a given expression-type.   More correctly, <code>(#$resultQuotedIsa FUNC TYPE)</code> means that, for any term-sequence <code>ARGS</code>, if the expression <code>(FUNC . ARGS)</code> is an #$admittedNAT (q.v.), then it is an instance of the #$SubLExpressionType <code>TYPE</code>.  That is, the following holds:\n<pre>\n  (#$quotedIsa (FUNC . ARGS) TYPE)\n</pre>\nAnd, equivalently, so does:\n<pre>\n  (#$isa (#$Quote (FUNC . ARGS)) TYPE)\n</pre>\n\nTo contrast this predicate with #$resultIsa: <code>(#$resultIsa FUNC COL)</code> holds just in case each #$defined term of the form <code>(FUNC . ARGS)</code> <i>denotes</i> an instance of <code>COL</code>, whereas <code>(#$resultQuotedIsa FUNC COL)</code> holds just in case each admitted (i.e. syntactically and semantically well-formed) term of the form <code>(FUNC . ARGS)</code> <i>is itself</i> an instance of <code>COL</code>."^^_string))) .
\"urn:uuid:9bec0fac-d60c-4c71-a1d1-049a50a87b49"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(resultQuotedIsa, (2), SubLSExpression)) .
\"urn:uuid:cf359b07-94c1-47ae-9dca-d5686f6ca1ea"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultQuotedIsa, (2), SubLExpressionType)) .
\"urn:uuid:7de99e37-a91b-4ea0-88f2-37418b0c35eb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(resultQuotedIsa, (1), 'Function-Denotational')) .
\"urn:uuid:17eafaf3-143e-45e9-ab55-fa3a34b07805"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(resultQuotedIsa, SetTheFormat)) .
\"urn:uuid:64b0fd27-81d1-41e8-9e0d-5e2063e9bfa2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(resultQuotedIsa, SetTheFormat)) .
\"urn:uuid:06908b81-a840-4af5-b910-9be2b912e1ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(rewriteOf, ("A specialization of #$equals and a #$CycLReformulatorConstant that relates pairs of #$CycLClosedDenotationalTerms.   #$rewriteOf is, in a sense, a ''directional'' version of #$equals.  <code>(#$rewriteOf FAVORED-TERM DISFAVORED-TERM)</code> means that (1) <code>FAVORED-TERM</code> and <code>DISFAVORED-TERM</code> denote the same thing, and (2) <code>FAVORED-TERM</code> is deemed worthy of being privileged over <code>DISFAVORED-TERM</code> in the following senses: assertions made on <code>DISFAVORED-TERM</code> will be propagated to <code>FAVORED-TERM</code>, and whenever possible attempts to reason about  <code>DISFAVORED-TERM</code> will be transformed into attempts to reason about <code>FAVORED-TERM</code>.  The propagated assertions will differ from the original assertions only in that the propagated assertions will be the result of substituting <code>FAVORED-TERM</code> for <code>DISFAVORED-TERM</code> wherever <code>DISFAVORED-TERM</code> occurs in the original assertions.  Note that substitution does not happen in the opposite direction.  That is, assertions containing <code>FAVORED-TERM</code> will not propagate to <code>DISFAVORED-TERM</code>.\n<p>\nOne common use of #$rewriteOf is that in which <code>FAVORED-TERM</code> is a syntactically simpler term than <code>DISFAVORED-TERM</code>.  For example, <code>FAVORED-TERM</code> may contain fewer nested terms that denote #$Function-Denotationals than does <code>DISFAVORED-TERM</code>.  (#$rewriteOf #$UnitedStatesNavy (#$NavyFn #$UnitedStatesOfAmerica)) is a good example of this common sort of use.\n<p>\nNote that #$rewriteOf expresses a strictly conventional notion of ''directional'' equality. Pragmatic considerations, not ontology, will dictate which term is chosen to occur as the privileged (left-hand side) term in a #$rewriteOf assertion.  Thus, in the example the fact that simpler terms are generally easier to use (remember, manipulate, etc.) dictates that #$UnitedStatesNavy should be a rewrite of (#$NavyFn #$UnitedStatesOfAmerica), and not vice versa."^^_string))) .
\"urn:uuid:26a4c600-5bed-4dce-be80-7e5e51f3195c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(rewriteOf, (1), Thing)) .
\"urn:uuid:1e4b86de-d932-49fe-a395-97dbfe8e0add"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(rewriteOf, (2), Thing)) .
\"urn:uuid:2a109b01-a6f7-4aaf-9515-1e2808af7132"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(rewriteOf, openEntryFormatInArgs)) .
\"urn:uuid:a09699c3-353f-45be-bed7-08f628eae22a"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(rewriteOf, singleEntryFormatInArgs)) .
\"urn:uuid:f851d699-4af5-4537-a4e5-6e4c11bdc41a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(rewriteOf, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:75a0b68f-0d17-4489-8ea8-b42af364fb0c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(rewriteOf, (2), CycLClosedDenotationalTerm)) .
\"urn:uuid:4891b40f-8025-43ab-9692-4eb20a120679"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(rewriteOf, (1))) .
\"urn:uuid:02c342ef-a49e-439c-a821-4e3f5064dd14"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(rewriteOf, (2))) .
\"urn:uuid:043c698a-3727-4009-b19e-dd1751971794"[silk#strict] .
istAsserted(UniversalVocabularyMt, openEntryFormatInArgs(rewriteOf, (2))) .
\"urn:uuid:b12a2647-ee5e-45fc-9e30-edb4ea898a6f"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(rewriteOf, (2))) .
\"urn:uuid:49e4ade4-2d60-4fcd-8a53-2e9c487ae6ec"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(rewriteOf, (1))) .
\"urn:uuid:84fe5c51-7e9c-41d1-bdc2-7f113e60be4c"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(rewriteOf, (1))) .
\"urn:uuid:d8de30c8-c2e4-4b26-af07-328fa06e3fbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(rewriteOf, Thing, Thing, (1))) .
\"urn:uuid:44a28d7e-785b-4c5a-8e47-1f5f26046e2a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ruleAfterAdding, ("Whenever a new rule is asserted, #$ruleAfterAddings are called on each literal of the rule.  The particular #$ruleAfterAddings called depend on the predicate of the literal.  (#$ruleAfterAdding PRED HOOK) means that HOOK will be called on each of the rule's literals whose predicate is PRED.  If the rule has multiple literals containing predicate with #$ruleAfterAdding, the order of execution is not guaranteed.  Also, #$ruleAfterAddings are retriggered on the addition of new arguments to an existing rule."^^_string))) .
\"urn:uuid:b60d95be-d7f8-4af2-aca8-bbd0f1805a8c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ruleAfterAdding, (1), Predicate)) .
\"urn:uuid:494a291f-01a3-42bd-a0aa-33f68c6ca729"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(ruleAfterAdding, SetTheFormat)) .
\"urn:uuid:ed475e6d-f57b-4911-90a4-b178a958c5b4"[silk#strict] .
istAsserted(BaseKB, definingMt(ruleAfterAdding, BaseKB)) .
\"urn:uuid:4b3c5224-c236-42a1-9152-43750fa56177"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ruleAfterAdding, (2))) .
\"urn:uuid:fb770c75-ca99-49bf-98e0-bbdcbb8cab62"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ruleAfterRemoving, ("Whenever a new rule is unasserted, #$ruleAfterRemovings are called on each literal of the rule.  The particular #$ruleAfterRemovings called depend on the predicate of the literal.  (#$ruleAfterRemoving PRED HOOK) means that HOOK will be called on each of the rule's literals whose predicate is PRED.  If the rule has multiple literals containing predicate with #$ruleAfterRemoving the order of execution is not guaranteed.  Also, #$ruleAfterRemovings are retriggered on the removal of the each argument to a rule."^^_string))) .
\"urn:uuid:71e1d105-b74d-4e80-bc22-de99b03d171e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ruleAfterRemoving, (1), Predicate)) .
\"urn:uuid:abb8b23e-d454-4361-bc2e-ec0487e3e1d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(ruleAfterRemoving, SetTheFormat)) .
\"urn:uuid:e9dabad6-36bf-459c-9633-98463c715db2"[silk#strict] .
istAsserted(BaseKB, definingMt(ruleAfterRemoving, BaseKB)) .
\"urn:uuid:ed5fca84-4695-4151-8d33-587e1a228286"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(ruleAfterRemoving, (2))) .
\"urn:uuid:2511e85a-f434-4e45-826d-713cce4f2216"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(ruleTemplateDirection, ("A #$MetaKnowledgePredicate. (#$ruleTemplateDirection TEMPLATE DIRECTION) states that all assertions which are instantiations of TEMPLATE should  have a direction of DIRECTION."^^_string))) .
\"urn:uuid:22682c61-cd18-48b4-ae20-3513838dacee"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ruleTemplateDirection, (1), RuleTemplate)) .
\"urn:uuid:ac7c2846-49bc-473a-be1c-397ef5de2b25"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(ruleTemplateDirection, (2), CycLAssertionDirection)) .
\"urn:uuid:1ebd62e5-2ba0-4b61-b032-5e87b621f661"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(salientAssertions, ("(#$salientAssertions TERM ASSERTION) means that ASSERTION has been deemed one of the assertions most useful to examine when one is trying to figure out the intended meaning of TERM.  Thus, ASSERTION will normally contain TERM, and should be something that has been asserted on its own in the KB as well.  Statements using #$salientAssertions are primarily intended for human consumption, and are not normally used by the Cyc inference engine."^^_string))) .
\"urn:uuid:2b10852e-05a2-4b2b-aea7-7e6f63b18b31"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(salientAssertions, (1), Thing)) .
\"urn:uuid:e239fbf0-25c8-4042-904e-6b19e340ccc6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(salientAssertions, SetTheFormat)) .
\"urn:uuid:f33af07f-e73c-4f0d-8fb2-2840e022baa2"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(salientAssertions, SetTheFormat)) .
\"urn:uuid:4bcca72c-f024-44e4-a0e3-6fce44464949"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(salientAssertions, (2), CycLAssertion)) .
\"urn:uuid:1555013e-7c67-4d8e-95d5-411f36b7ab04"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(salientAssertions, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:91fb65dd-2a9b-408c-a341-a623be212c69"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(salientAssertions, (1))) .
\"urn:uuid:8f4c919e-d201-4f41-97c4-9236d8fc5c1f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(salientAssertions, (2))) .
\"urn:uuid:84b26fb0-6e83-4a9a-8f61-268926a4df00"[silk#strict] .
istAsserted(BaseKB, completeExtentAsserted(salientAssertions)) .
\"urn:uuid:f3d042a1-9967-4353-a722-ebfa7e4b7e53"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(salientAssertions)) .
\"urn:uuid:88e35de1-0532-44a7-9a16-df4f36052168"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(scopingArg, ("A binary #$MetaRelation that relates a #$ScopingRelation (q.v.) to an integer indicating the argument-place of the former that takes a variable or list of variables.  (#$scopingArg RELN N) means that RELN's Nth argument is a variable or variable-list (see #$CycLVariable and #$CycLVariableList) such that it (they) and any other occurrences of the same variable(s) that occur free in the CycL formula serving as the ''scoped'' argument (see #$scopedFormulaArg) to RELN is (are) bound with respect to the entire RELN-based formula.  For example, (#$scopingArg #$thereExists 1) entails that in the sentence\n<p>\n<pre>\n  (#$thereExists ?KIT\n    (#$and\n      (#$isa ?KIT #$Cat)\n      (#$isa ?KIT #$BlackColor)))\n</pre>\n<p>\neach occurrence of the variable '?KIT' is bound by the quantifier #$thereExists."^^_string))) .
\"urn:uuid:8c9c5fab-a7b1-4067-8109-d51b2a9e3fc6"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(scopingArg, (2))) .
\"urn:uuid:cac42312-1562-49a0-9cbe-add4793ba08c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(scopingArg, (2), NonNegativeInteger)) .
\"urn:uuid:77b7048c-bd21-4db1-b829-460fa1560020"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(scopingArg, (1), ScopingRelation)) .
\"urn:uuid:0eccc216-eb0e-43ee-8dc1-5f62abfc69c2"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(scopingArg, Thing, Thing, (1))) .
\"urn:uuid:2e18c53e-da80-4e42-a642-cb4547c23ebf"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(sentenceDesignationArgnum, ("Used to specify which argument of a given #$MicrotheoryDesignatingRelation\ndesignates the CycL sentence to be interpreted in a specific microtheory."^^_string))) .
\"urn:uuid:7f57d2ce-6233-4835-8888-9a29504128c8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(sentenceDesignationArgnum, (2), PositiveInteger)) .
\"urn:uuid:da038a31-6434-4ce4-a418-7f179c70f843"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(sentenceDesignationArgnum, (1), MicrotheoryDesignatingRelation)) .
istAsserted(BookkeepingMt, oldConstantName(sentenceDesignationArgnum, ("formulaDesignationArgnum"^^_string))) .
\"urn:uuid:fd382e78-4a99-4a80-bad0-70517e33f5da"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArgInverse(sentenceDesignationArgnum, genlPreds, (1))) .
\"urn:uuid:63cf1c8f-976a-4224-8170-ed072416799e"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(sentenceEquiv)) .
\"urn:uuid:bcf29f48-8d48-416c-b2e5-77ff3ab90f5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(sentenceEquiv, ("(#$sentenceEquiv FORMULA-1 FORMULA-2) means that  the #$ELSentence-Assertible FORMULA-1 is logically equivalent to the #$ELSentence-Assertible FORMULA-2.  This predicate is very similar to #$equiv, but #$equiv is an instance of #$LogicalConnective, while #$sentenceEquiv is an instance of #$Predicate.  #$sentenceEquiv is primarily intended to be used for rules that quantify over CycL formulas."^^_string))) .
\"urn:uuid:d5a24716-ef2b-4eae-bba4-45c74764765e"[silk#strict] .
istAsserted(BaseKB, notAssertible(sentenceEquiv)) .
istAsserted(EnglishParaphraseMt, genFormat(sentenceEquiv, ("the formula ~a is logically equivalent to the formula ~a"^^_string), [[(1), MetaVariableFn(("QUOTE"^^_string))], [(2), MetaVariableFn(("QUOTE"^^_string))]])) .
istAsserted(BookkeepingMt, oldConstantName(sentenceEquiv, ("formulaEquiv"^^_string))) .
\"urn:uuid:52ffd87f-efa0-4421-8731-4fb1e227c486"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(sentenceEquiv)) .
\"urn:uuid:97a7662e-fbae-4c97-9628-75c93cfb8d7d"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(sentenceEquiv)) .
\"urn:uuid:fb9577eb-7a9b-4aa8-9de4-f0ad31fb2b3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(sentenceEquiv, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:5193f6d6-9e0a-4b12-9a80-b5cc99aeb712"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(sentenceEquiv, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:3988b1b0-c372-4e77-8f61-15772d209732"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sentenceEquiv, (2))) .
\"urn:uuid:a94a3b41-6ef2-42f1-b272-addf8f604a40"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sentenceEquiv, (1))) .
\"urn:uuid:8629723e-4dfe-4a95-8e9a-89fa9e794aa1"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(sentenceImplies)) .
\"urn:uuid:8be0d4e7-4339-4733-a856-d1d4c8b3bfc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(sentenceImplies, ("A binary predicate that represents logical entailment in CycL.  <code>(#$sentenceImplies ANTECEDENT CONSEQUENT)</code> means that <code>CONSEQUENT</code> can be derived from <code>ANTECEDENT</code> using purely logical transformations.  For example, this holds by double negation:\n<pre>\n  (#$sentenceImplies\n    (#$isa #$Muffet #$Poodle)\n    (#$not (#$not (#$isa #$Muffet #$Poodle))) .\n</pre>\nNote that there are cases in which <code>(#$implies ANTECEDENT CONSEQUENT)</code> is analytically true, or necessarily true in some sense of necessity weaker than logical necessity, such that <code>(#$sentenceImplies ANTECEDENT CONSEQUENT)</code> is false.  For example, whereas:\n<pre>\n  (#$implies (#$isa #$Muffet #$Poodle) (#$isa #$Muffet #$Dog))\n</pre>\nis analytically true or in some sense necessarily true,\n<pre>\n  (#$sentenceImplies (#$isa #$Muffet #$Poodle) (#$isa #$Muffet #$Dog))\n</pre>\nis not true, since the material conditional is not logically valid.\n<p>\n#$sentenceImplies also differs from #$implies in that whereas #$implies is a #$LogicalConnective (q.v.), #$sentenceImplies is merely a predicate that holds between sentences.  #$sentenceImplies is primarily intended to be used for rules that quantify over CycL sentences."^^_string))) .
\"urn:uuid:3972f8d2-0a93-45ab-891f-8d6ba4fc4f43"[silk#strict] .
istAsserted(BaseKB, notAssertible(sentenceImplies)) .
istAsserted(BookkeepingMt, oldConstantName(sentenceImplies, ("formulaImplies"^^_string))) .
\"urn:uuid:5b839002-2ffd-43c3-bcac-2361c59d8cb0"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(sentenceImplies)) .
\"urn:uuid:9cf8118b-98fb-44d1-90b9-41bf74e9c788"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(sentenceImplies, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:c1cb7777-5323-4735-8494-45a0c213134a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(sentenceImplies, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:f9a49bbe-f4c6-40ee-ac4b-62da1ecd39e2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sentenceImplies, (1))) .
\"urn:uuid:5958ffb0-dfcc-4964-88be-1f799b379dbf"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sentenceImplies, (2))) .
\"urn:uuid:17f77eed-b92f-4104-a0f0-44f6c5b8e74d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(sentenceTruth, ("A #$KBDependentRelation (q.v.) that is used to state the truth of a given CycL sentence. (#$sentenceTruth SENT TRUTH) means that the CycL sentence SENT has the truth value TRUTH, which is either #$True or #$False."^^_string))) .
\"urn:uuid:4d17d11b-59fb-4057-8831-05aa407c0642"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(sentenceTruth)) .
\"urn:uuid:96f59949-5cb1-4022-93f8-5a5d4a8ba837"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(sentenceTruth, (2))) .
\"urn:uuid:f9565f62-be84-4d1c-a838-ef746e9b9d35"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(sentenceTruth, (2))) .
\"urn:uuid:8e36d491-ede0-4c8a-b972-5bb3d4209a65"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(sentenceTruth, (2), TruthValue)) .
\"urn:uuid:7f1d8daa-626c-44f2-a97b-e408a7f1d60c"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(sentenceTruth, Thing, Thing, (1))) .
\"urn:uuid:f5df57a9-ba25-477a-b605-c06d8f420e91"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(sentenceTruth, singleEntryFormatInArgs)) .
\"urn:uuid:7af2b2bb-9702-4460-91fb-9cf4eee768af"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainRequired(sentenceTruth)) .
\"urn:uuid:890734b7-541a-4063-bfdf-1b06ed606704"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(sharedNotes, ("A predicate-denoting constant that is an instance of #$DocumentationPredicate.  It is sometimes useful to include the same piece of text in the documentation of two or more constants or other #$CycLIndexedTerms. Rather than actually duplicating text in the Knowledge Base, one can create a #$SharedNote (q.v.): a piece of text that is to serve as this shared documentation, and which is itself the comment (see #$comment) on the #$SharedNote's constant.  (Thus the constants for shared-notes actually denote their own comments.)  (#$sharedNotes TERM NOTE) means that NOTE is a string of text (see #$TextString) serving as shared documentation partly about TERM.  Since #$SharedNotes are typically _shared_, there are likely to be one or more other indexed terms having NOTE as their shared-note as well."^^_string))) .
\"urn:uuid:4a09c51d-b742-4128-8e4a-a103832923d6"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(sharedNotes, (1), Thing)) .
\"urn:uuid:af28509c-f061-449a-9bc8-3d31003f6f75"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(sharedNotes, (2), Individual)) .
\"urn:uuid:9203df03-bdd7-4649-b234-6b021676caa6"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(sharedNotes, SetTheFormat)) .
\"urn:uuid:7782f375-c1bd-497b-828f-4f1cd435b070"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(sharedNotes, SetTheFormat)) .
\"urn:uuid:03589385-127a-4d6a-a9f5-ea2aba804317"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(sharedNotes, (1), CycLIndexedTerm)) .
\"urn:uuid:adc84488-d5d3-464c-b867-0482c54771b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sharedNotes, (2))) .
\"urn:uuid:4d45793b-8bb9-43fb-b87b-82b99b9fd770"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(sharedNotes, (1))) .
\"urn:uuid:93fcf096-51c4-4eb7-9f81-d2a1ca6417a0"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(siblingDisjointExceptions, ("A predicate that is  used to make exceptions to constraints normally imposed by some instance of #$SiblingDisjointCollectionType or #$SiblingDisjointSetOrCollectionType (qq.v.).  <code>(#$siblingDisjointExceptions SETORCOL1 SETORCOL2)</code> means that the pair consisting of <code>SETORCOL1</code> and <code>SETORCOL2</code> is exempt from the disjointness constraint that would otherwise be imposed because those set-or-collections are both elements of some instance of #$SiblingDisjointCollectionType or #$SiblingDisjointSetOrCollectionType.  (See these collections' comments for a full explanation of the constraints.)   \n<p>\nFor example, #$SensoryNerve and #$CranialNerve are both instances of #$OrganismPartType, which in turn is an instance of #$SiblingDisjointCollectionType.  Consequently, since #$SensoryNerve is not a specialization of #$CranialNerve (or vice versa), the two collections have a default disjointness constraint placed between them.  However, such a disjointness constraint should be blocked, since any instance of #$OpticNerve is an instance of both #$SensoryNerve and #$CranialNerve.  By asserting <code>(#$siblingDisjointExceptions #$SensoryNerve #$CranialNerve)</code>, we block the disjointness constraint between those two collections, without disturbing the constraints between each of those collections and all their other (sibling) instances of the parent collection #$OrganismPartType."^^_string))) .
\"urn:uuid:6c19bfee-dcf3-4cf3-bd2a-4630730290c7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(siblingDisjointExceptions, (1), Thing)) .
\"urn:uuid:2a959660-0b72-4029-a42b-b12aa9e3e92a"[silk#strict] .
istAsserted(UniversalVocabularyMt, argGenl(siblingDisjointExceptions, (2), Thing)) .
\"urn:uuid:65f184fe-c409-4cd2-8d3e-9c05f5d68829"[silk#strict] .
istAsserted(BaseKB, argIsa(siblingDisjointExceptions, (1), SetOrCollection)) .
\"urn:uuid:8769cd18-d312-41e0-894c-aab16608fa2e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(siblingDisjointExceptions, (2), SetOrCollection)) .
\"urn:uuid:8c64e5a7-77db-4c84-8f56-a2e2199d0979"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(siblingDisjointExceptions, (1), SetOrCollection)) .
\"urn:uuid:91229674-a1bb-4070-8af3-c65131f9c0b4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(singleEntryFormatInArgs, ("An instance of #$SpecificEntryFormatPredicate (q.v.).  <code>(#$singleEntryFormatInArgs PRED N)</code> means that, for any particular way of fixing the other arguments to <code>PRED</code> besides the <code>N</code>th, there is at most one thing such that, if taken as the <code>N</code>th argument, <code>PRED</code> holds of those arguments.  That is, if the sequences <code><... ARGN ...></code> and <code><... ARGN-PRIME ...></code> differ at most in their <code>N</code>th items and both <code>(PRED ... ARGN ...)</code> and <code>(PRED ... ARGN-PRIME ...)</code> hold, then <code>ARGN = ARGN-PRIME</code> (see #$equals).  For example, #$singleEntryFormatInArgs holds of #$biologicalMother with respect to its second argument-place, since an animal can only have one biological mother.  A predicate with a single-entry format argument-place is thus a #$StrictlyFunctionalPredicate (q.v.) that is ''functional'' with respect to that argument-place (see #$strictlyFunctionalInArgs).  Contrast with #$openEntryFormatInArgs."^^_string))) .
\"urn:uuid:5af25f9b-40aa-4ecc-a43c-e6ce6f2e8bf2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(singleEntryFormatInArgs, (2), PositiveInteger)) .
\"urn:uuid:805d3ce0-5b0d-4931-aee5-674634811a11"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(skolem, ("An #$InferenceRelatedBookkeepingPredicate (q.v.) that appears in system-generated assertions.  #$skolem holds of all instances of #$SkolemFunction, and exists solely for internal bookkeeping purposes.  The set of supports for a #$skolem assertion of the form (#$skolem FUNCTOR) is the set of defining assertions of FUNCTOR."^^_string))) .
\"urn:uuid:d0915c2c-8f10-4b1c-98ca-d7e44a50a087"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(skolem, (1), SkolemFunction)) .
\"urn:uuid:276df4e8-1fe4-4a23-8321-e28f2832340d"[silk#strict] .
istAsserted(BaseKB, definingMt(skolem, BaseKB)) .
\"urn:uuid:935fa42e-23d5-4680-8210-623f3630d296"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(skolem, (1))) .
\"urn:uuid:7b2d1a11-05b8-4c00-8103-c365d1b54383"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(skolemizeForward, ("(#$skolemizeForward FUNC) tells the inference engine that terms should be generated for fully-bound uses of FUNC during forward inference."^^_string))) .
\"urn:uuid:680875d1-e26e-453d-901d-d48dffa263ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(skolemizeForward, (1))) .
\"urn:uuid:7bccdab8-dda4-4e14-a6ba-65a3422910ab"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(skolemizeForward, (1), ReifiableFunction)) .
\"urn:uuid:d988fdc7-f988-4cb9-960b-b5fc6dfcc78a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(stringPrecedes, ("A binary predicate that relates an instance of #$CharacterString to another intance of #$CharacterString. <code>(#$stringPrecedes EARLY LATER)</code> means that <code>EARLY</code> is a string that comes earlier than <code>LATER</code> using the standard lexicographic sort for strings.  For example, (#$stringPrecedes ''cat'' ''dog''). See also #$stringPrecedes-CaseInsensitive for the case insensitive analog of this predicate."^^_string))) .
\"urn:uuid:4d161d04-c034-4581-9d95-021f4ef217b5"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(stringPrecedes, (2), CharacterString)) .
\"urn:uuid:83dcb37e-a3dc-4ef6-aafe-ecada2b4c835"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(stringPrecedes, (1), CharacterString)) .
\"urn:uuid:a638d877-d5dc-49be-b9e9-740c27fc68fe"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(stringPrecedes, SubLSymbolFn(("CYC-STRING-PRECEDES"^^_string)))) .
\"urn:uuid:781234a3-b478-4fc8-9dc1-002aae8cf924"[silk#strict] .
istAsserted(BaseKB, evaluationDefn('stringPrecedes-CaseInsensitive', SubLSymbolFn(("CYC-STRING-PRECEDES-CASE-INSENSITIVE"^^_string)))) .
\"urn:uuid:5d03d034-a0f8-4268-bbd4-349832982275"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('stringPrecedes-CaseInsensitive', ("A binary predicate that relates an instance of #$CharacterString to another intance of #$CharacterString. <code>(#$stringPrecedes-CaseInsensitive EARLY LATER)</code> means that <code>EARLY</code> is a string that comes earlier than <code>LATER</code> using the standard lexicographic sort for strings when case is ignored.  For example, (#$stringPrecedes-CaseInsensitive ''cat'' ''DOG''). See also #$stringPrecedes for the case sensitive analog of this predicate."^^_string))) .
\"urn:uuid:3d2d2331-35e3-446a-b329-df940f2383dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('stringPrecedes-CaseInsensitive', (2), CharacterString)) .
\"urn:uuid:58cdf12a-9f4d-4d8d-b63b-db8d556cc7d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('stringPrecedes-CaseInsensitive', (1), CharacterString)) .
\"urn:uuid:98d2a85c-8636-425e-bbc2-17c9f9883f88"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(strongestAssertedSentence, ("(#$strongestAssertedSentence <code>SENTENCE</code>) means that SENTENCE is asserted in the Cyc KB, and that no strictly 'stronger version' of SENTENCE is asserted in the Cyc KB.  For an explanation of what constitutes a 'stronger version', see #$assertedMoreSpecifically.  #$strongestAssertedSentence is basically a conjunction of #$assertedSentence and #$not #$assertedMoreSpecifically."^^_string))) .
\"urn:uuid:a7406a06-78dc-4316-8c8b-0a74183f34fb"[silk#strict] .
istAsserted(BaseKB, notAssertible(strongestAssertedSentence)) .
\"urn:uuid:49640466-81bc-4d80-8fe4-19794c56bd81"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(strongestAssertedSentence)) .
\"urn:uuid:df8fa5e3-e36c-4393-99f7-3490d5f9ce8f"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(strongestAssertedSentence)) .
\"urn:uuid:f0239f30-7d53-44a1-be6d-9511b9658a39"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAll(strongestAssertedSentence, CycLAssertion)) .
\"urn:uuid:8f897b1d-f6f5-423b-9c03-9b52fd91474d"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(strongestAssertedSentence)) .
\"urn:uuid:d6f6b809-a93f-4b64-88ee-28e825d7ad6f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(strongestAssertedSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:0f11d3a8-44f3-4a13-8f66-6b2f2bb97451"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(strongestAssertedSentence, (1))) .
\"urn:uuid:6a7c7e43-3a7c-40f6-9e02-2cc6d0f360a4"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(subsetOf, ("This predicate relates a set or collection <code>SUB</code> to a set or collection <code>SUPER</code> whenever the extent (see #$extent) of <code>SUB</code> is a  subset of the extent of <code>SUPER</code>.  That is, <code>(#$subsetOf SUB SUPER)</code> means that  every element of (see #$elementOf) <code>SUB</code> is an element of <code>SUPER</code>.  #$subsetOf is thus a generalization both of the subset relation in set theory and of #$genls (q.v.); and (unlike either of those other relations) #$subsetOf can hold between a set and a collection, or between a collection and a set."^^_string))) .
\"urn:uuid:b2758c74-6a37-45be-9c52-ef918cd2872d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(subsetOf, (1), SetOrCollection)) .
\"urn:uuid:def9bd52-f1d7-4c7d-92af-e1a209e13663"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(subsetOf, (2), SetOrCollection)) .
\"urn:uuid:bd26364f-2abe-4809-b9c6-67a6d40b6e11"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(subsetOf, SetTheFormat)) .
\"urn:uuid:3758f330-569a-4dfc-9b71-4cf1153084b8"[silk#strict] .
istAsserted(BaseKB, fanOutArg(subsetOf, (1))) .
\"urn:uuid:11213e4c-084a-4cf7-b543-06c4f5c0fc91"[silk#strict] .
istAsserted(BaseKB, relationInstanceAll(subsetOf, TheEmptySet, SetOrCollection)) .
\"urn:uuid:0d235aa2-e81b-45e5-b192-8722d5d2acbf"[silk#strict] .
istAsserted(BaseKB, transitiveViaArgInverse(subsetOf, subsetOf, (1))) .
\"urn:uuid:a9b2e294-1be2-4b59-b900-a3a979e719cd"[silk#strict] .
istAsserted(BaseKB, transitiveViaArg(subsetOf, subsetOf, (2))) .
\"urn:uuid:30180bb9-63f0-494e-87a7-c526f0b1633f"[silk#strict] .
istAsserted(UniversalVocabularyMt, transitiveViaArg(subsetOf, subsetOf, (2))) .
\"urn:uuid:1dbc50d4-5d6e-428d-bec3-7e7ca7b21ee7"[silk#strict] .
istAsserted(BaseKB, definingMt(subsetOf, CoreCycLMt)) .
\"urn:uuid:b31383cb-542e-4e14-87b0-2f5c2618335f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(substring, ("A binary predicate that relates an instance of #$CharacterString to another intance of #$CharacterString. <code>(#$substring SUBSTRING STRING)</code> means that <code>SUBSTRING</code> is a substring of <code>STRING</code>."^^_string))) .
\"urn:uuid:4868fc67-e13f-4e91-afcb-2da1ef676295"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(substring, (2), CharacterString)) .
\"urn:uuid:0f21212f-0fc3-4dc3-8857-4ace7eb1dee1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(substring, (1), CharacterString)) .
istAsserted(EnglishParaphraseMt, genFormat(substring, ("~s is a substring of ~s"^^_string), [(1), (2)])) .
\"urn:uuid:ff7b3829-9be4-4697-ba31-98cf366cf323"[silk#strict] .
istAsserted(BaseKB, fanOutArg(substring, (2))) .
\"urn:uuid:3733bd11-cf9f-4309-815e-3562150e9519"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(substring, SubLSymbolFn(("CYC-SUBSTRING-PREDICATE"^^_string)))) .
\"urn:uuid:fd82967d-6d32-418c-b799-59f781289c4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment('substring-CaseInsensitive', ("<code>(#$substring-CaseInsensitive SUBSTRING STRING)</code> means that the <code>#$CharacterString SUBSTRING</code> is a substring of the <code>#$CharacterString STRING</code> with case ignored in both <code>SUBSTRING</code> and <code>STRING</code>. For case-sensitive tagging use the more specialized predicate, <code>#$substring</code>."^^_string))) .
\"urn:uuid:ca231d43-c293-4cf3-9ea7-d9931ec974dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('substring-CaseInsensitive', (2), CharacterString)) .
\"urn:uuid:118e6f99-d00e-4200-8138-f396952802b2"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa('substring-CaseInsensitive', (1), CharacterString)) .
istAsserted(EnglishParaphraseMt, genFormat('substring-CaseInsensitive', ("~s is a case-insensitive substring of ~s"^^_string), TheEmptyList)) .
\"urn:uuid:4fd31e7a-ca50-40ce-be28-e869bd9bfe13"[silk#strict] .
istAsserted(BaseKB, evaluationDefn('substring-CaseInsensitive', SubLSymbolFn(("CYC-SUBSTRING-CASE-INSENSITIVE-PREDICATE"^^_string)))) .
\"urn:uuid:b9f5cac8-d3b9-4012-b7ac-a82fb768af8b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(synonymousExternalConcept, ("<code>(#$synonymousExternalConcept THING SOURCE STRING)</code> means that as it occurs in the external data source <code>SOURCE</code>, the string <code>STRING</code> denotes <code>THING</code>."^^_string))) .
\"urn:uuid:575abf8c-5a96-4366-bb16-eda9b5967977"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(synonymousExternalConcept, (3), CharacterString)) .
\"urn:uuid:bac85f71-44ee-400e-876e-91d4bf2c4e4e"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(synonymousExternalConcept, (1), Thing)) .
\"urn:uuid:7eac0e36-7393-4ef7-a59b-9212c8183a11"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(synonymousExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:2453a570-936c-417e-b24f-86e6eb067e66"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(synonymousExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:85202aa3-197d-4084-9280-3478cd36c8fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(synonymousExternalConcept, openEntryFormatInArgs)) .
\"urn:uuid:649cb3cf-de69-4e84-b4b1-936328ff70ee"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(termChosen, ("(#$termChosen TERM) is true for any closed Cyc TERM, and indicates that TERM has been chosen from the set of terms in the universe of discourse.  This predicate is primarily used on a variable so that the moment of choice of a particular term as the binding for that variable can be identified.  There should never be methods for generating bindings for non-closed #$termChosen literals."^^_string))) .
\"urn:uuid:dec616fa-40c6-4391-9464-fd2a647ff24e"[silk#strict] .
istAsserted(BaseKB, notAssertible(termChosen)) .
\"urn:uuid:4c5f8b5b-26f8-4f5f-8241-ffb087a98cde"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termChosen, (1), Thing)) .
\"urn:uuid:59ad6db2-de7f-4e5e-a89b-cfcd46c5ecf5"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(termChosen)) .
\"urn:uuid:3891b36b-3cda-4fbe-b5cf-e2f8c424ced8"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(termChosen)) .
\"urn:uuid:3694c5df-987b-4692-898b-627932138a9d"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(termChosen)) .
\"urn:uuid:bfda6c37-914e-4f97-a534-aeae885af337"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(termDependsOn, ("(#$termDependsOn DEP-TERM INDEP-TERM) states that the reason for the existence of the term DEP-TERM in the Cyc knowledge base is completely dependent on the continued existence of the term INDEP-TERM.  Thus, if INDEP-TERM should ever be removed from the knowledge base, then DEP-TERM should also be immediately removed.  This relationship is automatically maintained between reified non-atomic terms (NATs) and the terms from which they are constructed."^^_string))) .
\"urn:uuid:f682f63d-d123-4fc2-8d7d-1d588d62efe0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termDependsOn, (2), Thing)) .
\"urn:uuid:258a005a-bf45-48b9-b3b1-d6f0c736450d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termDependsOn, (1), Thing)) .
\"urn:uuid:28f1c725-c0f2-4a1a-9b0a-c786a0d37c03"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(termDependsOn)) .
\"urn:uuid:2ea73e3a-7739-4646-b8b5-87ff711a8b28"[silk#strict] .
istAsserted(BaseKB, definingMt(termDependsOn, BaseKB)) .
\"urn:uuid:3c546446-eb88-48d3-9aaa-7519af0ab33b"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerable(termDependsOn)) .
\"urn:uuid:3afcabdd-edc9-4ebc-a779-2359788ebbc3"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(termDependsOn, (2), CycLReifiableDenotationalTerm)) .
\"urn:uuid:ef10c046-1869-4873-90c7-58f4ea94459c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(termDependsOn, (1), CycLReifiableDenotationalTerm)) .
\"urn:uuid:d1a899af-43d2-4ca3-98c2-772ad465dd0a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(termDependsOn, (2))) .
\"urn:uuid:8fc2b70e-4fd3-4407-b1d3-301f79a709a5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(termDependsOn, (1))) .
\"urn:uuid:16a84da0-6ce2-490e-a95a-26e7fdc0b170"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(termExternalIDString, ("A predicate which relates any #$CycLExpression to an external\nidentification string which is guaranteed to uniquely identify the\nexpression in both time and space. (#$termExternalIDString EXPRESSION\nID-STRING) states that the #$HLExternalIDString ID-STRING is the string\nrepresentation of the unique external id for the #$CycLExpression\nEXPRESSION. For obvious reasons, this predicate is #$notAssertible.\nAlso, note that this predicate is *not* a generalization of\n#$constantGUID, since the latter relates a #$CycLConstant to an\nentirely different string.  That is to say, the #$termExternalIDString\nof a #$CycLConstant is not the same string as its #$constantGUID."^^_string))) .
\"urn:uuid:391d4d6e-336e-441a-a663-2f5e4bf40275"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(termExternalIDString, (2))) .
\"urn:uuid:2b01ac8e-95aa-4480-80a4-68be5095885f"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertible(termExternalIDString)) .
\"urn:uuid:dcd97f18-8bac-4042-8185-5a18457189c1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termExternalIDString, (1), Thing)) .
\"urn:uuid:f77a5462-0177-4dd1-82a9-323c5a4ba4dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termExternalIDString, (2), HLExternalIDString)) .
\"urn:uuid:7b78baa6-2b39-4a71-9a36-27ef1b0fa402"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(termExternalIDString, Thing, Thing, (1))) .
\"urn:uuid:b2a8b14f-56a7-4afc-bc13-24d0aa99349e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(termExternalIDString, SingleEntry)) .
\"urn:uuid:4a8f0e19-afa1-4b5d-8bd1-9de8c1605c4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(termExternalIDString)) .
\"urn:uuid:45f4c4bd-683e-48f9-b192-060fe6743b00"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(termExternalIDString, SingleEntry)) .
\"urn:uuid:d6b16bcf-9a7a-4a55-896a-a61d0cf091aa"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(termExternalIDString, (1), CycLExpression)) .
\"urn:uuid:360a1793-ace4-4121-a74d-81d34c21a2fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(termExternalIDString, (1))) .
\"urn:uuid:8d0169c1-4809-4b12-9859-ae7dc3b6d252"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(termOfUnit, ("An #$InferenceRelatedBookkeepingPredicate (q.v.) that appears in system-generated assertions.  #$termOfUnit relates unreified reifiable non-atomic terms (''NATs'') to indexed data structures reified by the system.  #$termOfUnit GAF (see #$CycLClosedAtomicSentence) assertions\nare added by the system when an unreified reifiable NAT first appears in a CycL sentence that is added to the knowledge base.  When such a NAT is first used in a sentence, the Cyc system automatically creates an indexed data structure to reify the NAT.  A name is automatically assigned to the new data structure by the Cyc system.  (Typically, this name is character-for-character identical to the unreified reifiable NAT itself; but one should not be misled by this into thinking that #$termOfUnit is a specialization of #$equals.)  The predicate #$termOfUnit relates the system-generated data structure to the original NAT.  <code>(#$termOfUnit DATA-STRUCTURE NAT)</code> means that the data structure <code>DATA-STRUCTURE</code> was created to reify the value of the non-atomic term <code>NAT</code>, and that <code>NAT</code> refers to <code>DATA-STRUCTURE</code>, which in turn denotes something in the range of the function in the 0th (or ''arg 0'') position of <code>NAT</code>.\n<p>\nFor example, if an assertion such as (#$isa (#$RepairingFn #$Automobile) #$ProductType) introduced the unreified reifiable NAT (#$RepairingFn #$Automobile) in the Cyc knowledge base, the system would create a data structure to reify the value of (#$RepairingFn #$Automobile).  The system would assign the name `(#$RepairingFn #$Automobile)' to the newly-created data structure.  The system would also associate the newly-reified data structure with the unreified refiable NAT by means of the #$termOfUnit assertion (#$termOfUnit (#$RepairingFn #$Automobile) (#$RepairingFn #$Automobile)).\n<p>\nNote that #$termOfUnit assertions are made in the #$BaseKB because the relation between a NAT and the data structure reified for it is meant to hold in all contexts.  \n<p>\nOne should view #$termOfUnit assertions as bits of bookkeeping knowledge that are very rarely, if ever, entered into the Cyc knowledge base by hand. See #$retainTerm -- the predicate to use to create a NART that one wishes to remain in the Cyc KB even if no substantive additional assertions are made about it. NARTs that have only #$termOfUnit assertions made about them are removed from the KB at build time."^^_string))) .
\"urn:uuid:4b25efed-55c2-45e8-babf-906b75183512"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termOfUnit, (2), Thing)) .
\"urn:uuid:2ad8d9da-825c-4015-8dd6-1120928e5be0"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(termOfUnit, (1), Thing)) .
istAsserted(EnglishParaphraseMt, genKeyword(termOfUnit, MetaVariableFn(("TERM-OF-UNIT"^^_string)))) .
\"urn:uuid:c23daa98-728c-47c7-9aa0-390e67380e4d"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(termOfUnit, SingleEntry)) .
\"urn:uuid:76505e09-16c6-4d50-aa9b-a39687349741"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(termOfUnit, singleEntryFormatInArgs)) .
\"urn:uuid:acd7685a-9965-4c96-908f-ce20959e802c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(termOfUnit, SingleEntry)) .
\"urn:uuid:2f27abd6-bead-4fb9-85aa-06326ed74102"[silk#strict] .
istAsserted(LogicalTruthImplementationMt, argQuotedIsa(termOfUnit, (1), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:fd4e6081-a2e3-4b52-b9df-b01336e3ce90"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(termOfUnit, (2), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:99168aa3-b44d-4438-bb7a-7a9b7763b359"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(termOfUnit, (1), CycLReifiableNonAtomicTerm)) .
\"urn:uuid:42900981-6d13-4f98-9552-a033163f625c"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(termOfUnit, (2))) .
\"urn:uuid:ffbafbb1-72a6-41e0-8f69-6b91bd8c6799"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(termOfUnit, (1))) .
\"urn:uuid:e39b35be-8b6b-44de-bc4a-056c212da154"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(termOfUnit)) .
\"urn:uuid:3fbdfb37-756d-4fdf-afbb-6da7ce095fec"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(termOfUnit, (1))) .
\"urn:uuid:88d94328-87ff-408d-ab4d-d9b9663a0f85"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(termOfUnit, (2))) .
\"urn:uuid:468ad745-75a9-4a45-83e7-eb2f1d0fe8d8"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForArg(termOfUnit, (2))) .
\"urn:uuid:26f7dcf4-a4aa-4d0b-86f9-b21274d02661"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentEnumerableForArg(termOfUnit, (1))) .
\"urn:uuid:6939d8bb-6615-4937-8c65-630544495b5c"[silk#strict] .
istAsserted(UniversalVocabularyMt, relationAllExistsMax(termOfUnit, Thing, Thing, (1))) .
\"urn:uuid:dbc032d5-9c1a-4857-b783-10f745623506"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(termOfUnit)) .
\"urn:uuid:4501053b-9550-43c2-891d-ea438398daba"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(termOfUnit)) .
\"urn:uuid:b5934089-54c7-45b3-a811-77650317a238"[silk#strict] .
istAsserted(BaseKB, definingMt(termOfUnit, BaseKB)) .
\"urn:uuid:26c4c37a-af61-43ef-9124-2311232c7f3b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(thereExistAtLeast, ("An #$ExistentialQuantifier (q.v.) and a specialized (albeit higher arity) version of #$thereExists (q.v.).  Compared to the latter, standard existential quantifier, #$thereExistAtLeast has an extra argument-place for specifying how many things (at the least) satisfy a given condition (specified by an #$ELSentence-Assertible, in which the also-specified #$ELVariable will typically occur free).  A closed sentence of the form (#$thereExistAtLeast NUM VAR SENT) means that there are at least NUM distinct things that satisfy SENT, i.e. that render SENT true when taken as the value of VAR.  For example, the sentence\n<p>\n<pre>\n  (#$thereExistAtLeast 7 ?X (#$isa ?X #$Sea))\n</pre>\n<p>\nmeans that there are at least seven seas.\n<p>\nIn the degenerate case where VAR does not appear free in SENT, then (#$thereExistAtLeast NUM VAR SENT) is equivalent to SENT.\n<p>\nSee also #$thereExistAtMost, #$thereExistExactly."^^_string))) .
\"urn:uuid:2954e325-35f8-403a-ac5a-4d72ac541926"[silk#strict] .
istAsserted(BaseKB, scopingArg(thereExistAtLeast, (2))) .
\"urn:uuid:bb8a7ba6-31ff-4a11-a79a-b5b676c6569c"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(thereExistAtLeast, (1), PositiveInteger)) .
istAsserted(EnglishParaphraseMt, genKeyword(thereExistAtLeast, MetaVariableFn(("THERE-EXIST-AT-LEAST"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(thereExistAtLeast, ("there ~a at least ~a ~a such that ~a"^^_string), [[("is"^^_string), ("are"^^_string)], (1), (2), (3)])) .
istAsserted(BookkeepingMt, oldConstantName(thereExistAtLeast, ("ThereExistAtLeast"^^_string))) .
\"urn:uuid:21dcb9f0-58b0-441f-b9a5-76b1109bfd87"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(thereExistAtMost, ("An #$ExistentialQuantifier (q.v.) and a specialized (albeit higher arity) version of #$thereExists (q.v.).  Compared to the latter, standard existential quantifier, #$thereExistAtLeast has an extra argument-place for specifying how many things (at the most) satisfy a given condition (specified by an #$ELSentence-Assertible, in which the also-specified #$ELVariable will typically occur free).  A closed sentence of the form (#$thereExistAtMost NUM VAR SENT) means that there are at most NUM distinct things that satisfy SENT, i.e. that render SENT true when taken as the value of VAR.  For example, the sentence\n<p>\n<pre>\n  (#$thereExistAtMost 7 ?X (#$isa ?X #$Sea))\n</pre>\n<p>\nmeans that there are at most seven seas.\n<p>\nIn the degenerate case where VAR does not appear free in SENT, then (#$thereExistAtMost NUM VAR SENT) is equivalent to SENT.\n<p>\nSee also #$thereExistAtLeast, #$thereExistExactly."^^_string))) .
\"urn:uuid:a90d342d-3bb3-45ce-b161-3ae6a1a1c798"[silk#strict] .
istAsserted(BaseKB, scopingArg(thereExistAtMost, (2))) .
\"urn:uuid:88a73451-f33a-490f-b78c-b6a5fa20b647"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(thereExistAtMost, (1), PositiveInteger)) .
istAsserted(EnglishParaphraseMt, genKeyword(thereExistAtMost, MetaVariableFn(("THERE-EXIST-AT-MOST"^^_string)))) .
istAsserted(EnglishParaphraseMt, genFormat(thereExistAtMost, ("there ~a at most ~a ~a such that ~a"^^_string), [[("is"^^_string), ("are"^^_string)], (1), (2), (3)])) .
istAsserted(BookkeepingMt, oldConstantName(thereExistAtMost, ("ThereExistAtMost"^^_string))) .
\"urn:uuid:afcf046c-8fb9-435d-9877-e827ad9656bd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExistAtMost, (3), 'CycLSentence-Assertible')) .
\"urn:uuid:17187e82-4c2e-46fc-883a-b18c15ae17bb"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExistAtMost, (2), CycLVariable)) .
\"urn:uuid:f348b54a-09a6-4021-8a25-d304abbe5c74"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExistAtMost, (2))) .
\"urn:uuid:51c20c8b-824e-4e42-b8e2-a70af8512577"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExistAtMost, (3))) .
\"urn:uuid:754093bb-976e-44a8-93a1-971f2bdc4dbc"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(thereExistExactly, ("An #$ExistentialQuantifier (q.v.) and a specialization of both #$thereExistAtLeast and  #$thereExistAtMost (qq.v.).  Compared to the standard existential quantifier #$thereExists, #$thereExistExactly has an extra argument-place for specifying exactly how many things satisfy a given condition (specified by an #$CycLSentence-Assertible, in which the also-specified #$CycLVariable will typically occur free).  A closed sentence of the form <code>(#$thereExistExactly NUM VAR SENT)</code> means that there are exactly<code> NUM</code> distinct things that satisfy <code>SENT</code>, i.e. that render <code>SENT</code> true when taken as the value of <code>VAR</code>.  For example, the sentence\n<p>\n<pre>\n  (#$thereExistExactly 7 ?X (#$isa ?X #$Sea))\n</pre>\n<p>\nmeans that there are exactly seven seas.\n<p>\nIn the degenerate case where <code>VAR</code> does not appear free in <code>SENT</code>, then <code>(#$thereExistExactly NUM VAR SENT)</code> is equivalent to <code>SENT</code>."^^_string))) .
\"urn:uuid:08ee043c-2771-4670-933e-b74038d648bf"[silk#strict] .
istAsserted(BaseKB, scopingArg(thereExistExactly, (2))) .
\"urn:uuid:7167fb72-58a2-447b-b7e9-58af2ed23973"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(thereExistExactly, (1), NonNegativeInteger)) .
istAsserted(EnglishParaphraseMt, genKeyword(thereExistExactly, MetaVariableFn(("THERE-EXIST-EXACTLY"^^_string)))) .
istAsserted(BookkeepingMt, oldConstantName(thereExistExactly, ("ThereExistExactly"^^_string))) .
\"urn:uuid:6c597811-59a8-4a05-9f63-7ef5e37ea017"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExistExactly, (3), 'CycLSentence-Assertible')) .
\"urn:uuid:0aa89a02-9619-4339-8063-fde0fd13b5dd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExistExactly, (2), CycLVariable)) .
\"urn:uuid:2716df9d-da88-4b3c-85ae-1e10639cb568"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExistExactly, (2))) .
\"urn:uuid:25ecf62d-8f13-4447-9ca5-04ae8aa5b1fc"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExistExactly, (3))) .
\"urn:uuid:acc6f8c7-f332-4e5c-9886-68db54c09ce2"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(thereExists, ("An #$ExistentialQuantifier (q.v.) that corresponds to the standard existential quantifier of predicate calculus.  #$thereExists takes as its arguments an #$ELVariable and an #$ELSentence-Assertible (such that, typically, the former occurs free in the latter).  (#$thereExists VAR SENT) means that there is at least one thing THING such that SENT is true of it.  That is, if some given CycL term that denotes THING were substituted for each free occurrence of VAR in SENT, the result would be a true sentence.  For example, `(#$thereExists ?X (#$mother ?X #$GeorgeWBush))' means that George W. Bush has a (i.e. at least one) mother; and\n<p>\n(#$forAll ?PER\n(#$implies\n(#$isa ?PER #$Person)\n(#$thereExists ?MOM\n(#$mother ?MOM ?PER))))\n<p>\nmeans that every person has a mother.  Note that some existential statements can be represented more tersely in CycL using other instances of #$ExistentialQuantifier, such as #$thereExistAtMost or #$thereExistExactly.  Also see the #$cyclistNotes for #$thereExists."^^_string))) .
istAsserted(EnglishParaphraseMt, genKeyword(thereExists, MetaVariableFn(("THERE-EXISTS"^^_string)))) .
\"urn:uuid:764d9d53-de4e-40a4-a034-d41b9d1c1e28"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExists, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:b2577433-96b6-4286-aea6-d9ddbf0ee074"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(thereExists, (1), CycLVariable)) .
\"urn:uuid:822e7203-fdb6-41ea-8fa8-cddee51b0b37"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(thereExists, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:d1bec1a6-6503-455c-ae10-af70f5b662e0"[silk#strict] .
istAsserted(LogicalTruthMt, argQuotedIsa(thereExists, (1), CycLVariable)) .
\"urn:uuid:ac10e44d-a1e6-44be-814f-499424bcec6a"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExists, (2))) .
\"urn:uuid:73509204-aafb-4483-ba76-d5caf487de00"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(thereExists, (1))) .
\"urn:uuid:33f0a5dc-4466-44c0-938c-b65ea53f6596"[silk#strict] .
istAsserted(UniversalVocabularyMt, omitArgIsa(thereExists, (2))) .
\"urn:uuid:eeb54cb7-a423-4196-87a0-6e5458193e81"[silk#strict] .
istAsserted(UniversalVocabularyMt, omitArgIsa(thereExists, (1))) .
\"urn:uuid:a6d0e769-3cdd-4ae1-8039-f6227617b573"[silk#strict] .
istAsserted(BaseKB, scopingArg(thereExists, (1))) .
istAsserted(BookkeepingMt, oldConstantName(thereExists, ("ThereExists"^^_string))) .
\"urn:uuid:04aa4950-e7a1-4a59-8411-43eb377fc14a"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(transitiveViaArg, ("A #$MetaPredicate used for stating that a given predicate behaves transitively, in a specified argument-place, with respect to a given binary predicate. <code>(#$transitiveViaArg PRED BINPRED N)</code> means that the <code>N</code>th argument position of <code>PRED</code> is ''transitive'' with respect to <code>BINPRED</code>.  That is, if <code>(PRED ... ARG-N ...)</code> and <code>(BINPRED ARG-N ARG-N-PRIME)</code> hold, then so does <code>(PRED ... ARG-N-PRIME ...)</code>.  For example, (#$transitiveViaArg #$relationAllExists #$genlPreds 1) holds; thus from (#$relationAllExists #$anatomicalParts #$Mammal #$Head-AnimalBodyPart) and (#$genlPreds #$anatomicalParts #$physicalParts) it follows that (#$relationAllExists #$physicalParts #$Mammal #$Head-AnimalBodyPart). See also #$transitiveViaArgInverse."^^_string))) .
\"urn:uuid:87ba3f94-25d6-42c5-9def-31ce2b6587a7"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArg, (1), Predicate)) .
\"urn:uuid:8e919f3b-e8af-4784-97bf-7f66cc7b99fd"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArg, (3), PositiveInteger)) .
\"urn:uuid:4aae6b13-df80-4d77-904e-23565f10c797"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArg, (2), TransitiveBinaryPredicate)) .
\"urn:uuid:c93e4b6e-3a4b-44d7-9d3b-5c05eff8348e"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(transitiveViaArg, openEntryFormatInArgs)) .
\"urn:uuid:6be8cc98-d2ca-4843-8b96-1149b425f009"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(transitiveViaArg, openEntryFormatInArgs)) .
\"urn:uuid:f09ac0bb-274f-4ff6-9ecb-0ad141f7cf2c"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(transitiveViaArg, openEntryFormatInArgs)) .
\"urn:uuid:51a864d5-a222-4308-8832-b9e2d347192f"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(transitiveViaArgInverse, ("A #$MetaPredicate used for stating that a given predicate behaves transitively, in a specified argument-place, with respect to the inverse of a given binary predicate.  <code>(#$transitiveViaArgInverse PRED BINPRED N)</code> means that the <code>N</code>th argument position of <code>PRED</code> is ''transitive'' with respect to the inverse of <code>BINPRED</code>.  That is, if <code>(PRED</code> ... <code>ARGN</code> ...) and <code>(BINPRED ARGN-PRIME ARGN)</code> hold, then so does <code>(PRED</code> ... <code>ARGN-PRIME</code> ...).  For example,(#$transitiveViaArgInverse #$relationAllExists #$genls 2) holds; thus from (#$relationAllExists #$anatomicalParts #$Mammal #$Head-AnimalBodyPart) and (#$genls #$Horse #$Mammal) it follows that (#$relationAllExists #$anatomicalParts #$Horse #$Head-AnimalBodyPart).  See also #$transitiveViaArg."^^_string))) .
\"urn:uuid:df98a4cf-6388-4292-a9b8-852271cc86fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArgInverse, (3), PositiveInteger)) .
\"urn:uuid:ab4428e3-06cd-453d-940b-bade11fc9055"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArgInverse, (1), Predicate)) .
\"urn:uuid:c75a753a-64d5-4b28-b4d1-0d4b690c5aa4"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(transitiveViaArgInverse, (2), TransitiveBinaryPredicate)) .
\"urn:uuid:1def145f-f714-493c-9091-2134d5b48567"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(transitiveViaArgInverse, openEntryFormatInArgs)) .
\"urn:uuid:2b0116b4-becd-4ccd-aed5-68bb0e78da70"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(transitiveViaArgInverse, openEntryFormatInArgs)) .
\"urn:uuid:d758b16d-faf1-4615-810f-eb51fe7ae315"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(transitiveViaArgInverse, openEntryFormatInArgs)) .
\"urn:uuid:a8b98802-5462-49cf-9047-3156567febe8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(trueRule, ("(#$trueRule TEMPLATE FORMULA) states that FORMULA is both true and an instantiation of the rule template TEMPLATE."^^_string))) .
\"urn:uuid:bb3ae1f5-4d42-4c52-8635-073a3227c1ef"[silk#strict] .
istAsserted(UniversalVocabularyImplementationMt, canonicalizerDirectiveForArg(trueRule, (2), LeaveSomeTermsAtEL)) .
\"urn:uuid:0637348d-5ed3-4688-b1db-7ec223552923"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(trueRule, (1), RuleTemplate)) .
istAsserted(EnglishParaphraseMt, genFormat(trueRule, ("~a is true, and ~a is an instantiation of the rule template ~a"^^_string), [(2), (2), (1)])) .
\"urn:uuid:eca57474-7572-4fe9-ade1-53d4fc174769"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(trueRule, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:cc0ab8b0-1474-4096-a321-66980899ccc1"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(trueRule, (2))) .
\"urn:uuid:f577dc99-e942-46f7-91f8-0d13afd06f71"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(trueSentence, ("A #$KBDependentRelation (q.v.) and specialization of #$consistent (q.v.) that is used to state that a given CycL sentence is true.  <code>(#$trueSentence SENT)</code> means that <code>SENT</code> is true.\n<p>\n#$trueSentence is a non-assertible predicate (see  #$notAssertible).  But this puts no real limitation on the expressive power of the Cyc system since one can assert that <code>SENT</code> is true by simply asserting <code>SENT</code> itself.  \n<p>\nMost occurrences of the expression '#$trueSentence' in CycL assertions have been added by the canonicalizer, so that certain nested sentences (or variables occurring in argument-positions intended for sentences) can receive special handling during canonicalization or inference. See the accompanying #$cyclistNotes for details."^^_string))) .
\"urn:uuid:925a0074-9793-4455-8972-8d2ef640914d"[silk#strict] .
istAsserted(BaseKB, notAssertible(trueSentence)) .
istAsserted(BookkeepingMt, oldConstantName(trueSentence, ("trueFormula"^^_string))) .
\"urn:uuid:8155dbff-6ab0-4528-8dc2-dfc52187f02d"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(trueSentence, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:aeebbf79-23ff-4bab-89cb-f4cfbe996487"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(trueSentence, (1))) .
\"urn:uuid:35e81104-a5d2-4e32-98f0-a4fc0429d078"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(trueSubL, ("<code>(#$trueSubL SUBL)</code> states that the SubL expression <code>SUBL</code> evaluates to a value other than NIL.  This predicate allows for a procedural test for programmatic 'truth' in the implementation language to be reflected as a CycL test for logical truth in the logical language.  For example, <code>(#$trueSubL (#$ExpandSubLFn () (integerp 42)))</code> states that the SubL expression <code>(integerp 42)</code> evaluates to something other than NIL.  See #$ExpandSubLFn for a way to denote SubL within CycL.  See also #$evaluate and #$EvaluateSubLFn, and #$performSubL."^^_string))) .
\"urn:uuid:c5cf7f91-daa3-48e4-842d-625cef7bc47d"[silk#strict] .
istAsserted(BaseKB, notAssertible(trueSubL)) .
\"urn:uuid:a1ffa715-e729-4f47-8380-772f9f424cdd"[silk#strict] .
istAsserted(BaseKB, backchainForbidden(trueSubL)) .
\"urn:uuid:770ff250-1a4f-42ba-b9b3-56f4a04f327c"[silk#strict] .
istAsserted(BaseKB, evaluationDefn(trueSubL, SubLSymbolFn(("CYC-TRUE-SUBL"^^_string)))) .
\"urn:uuid:5f1a7076-fe14-4be5-b692-52d0dcef7e3f"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(trueSubL, (1))) .
\"urn:uuid:efd5ab79-de7b-482d-bb81-270a864ef379"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(unitMultiplicationFactor, ("A ternary #$MetaFunction predicate that relates two interconvertible #$UnitOfMeasures (q.v.) to the real number by which the larger unit is a multiple of the smaller.  <code>(#$unitMultiplicationFactor SMALLUNIT BIGUNIT N)</code> means that there are <code>N SMALLUNIT</code>s in one <code>BIGUNIT</code>.  In other words, to convert from a measure <code>BIGUNIT</code>s to a measure in <code>SMALLUNIT</code>s, multiply by <code>N</code>.\n<p>\nFor example, (#$unitMultiplicationFactor #$Inch #$Foot-UnitOfMeasure 12) entails that, when converting from feet to inches, one multiplies the number of feet by twelve.\n<p>\nNote that <code>SMALLUNIT</code> and <code>BIGUNIT</code> must be instances of the same #$InterconvertibleUnitType (q.v.), and that <code>N</code> must be greater than or equal to 1.\n<p>\nSee also #$QuantityConversionFn."^^_string))) .
\"urn:uuid:3abf7352-ab20-42c4-aeaa-8c857141ec4f"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(unitMultiplicationFactor, (2), UnitOfMeasure)) .
\"urn:uuid:d5a71fc6-f380-498a-a1b4-9c562989e919"[silk#strict] .
istAsserted(UniversalVocabularyMt, argIsa(unitMultiplicationFactor, (1), UnitOfMeasure)) .
\"urn:uuid:d6b8b2b3-0e0e-45f6-91cd-f0427d1ed1ed"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg2Format(unitMultiplicationFactor, singleEntryFormatInArgs)) .
\"urn:uuid:016d31c1-7e02-4be3-b117-d91da292877f"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg3Format(unitMultiplicationFactor, singleEntryFormatInArgs)) .
\"urn:uuid:ca58d132-0337-4d49-bdc6-d53908387293"[silk#strict] .
istAsserted(UniversalVocabularyMt, arg1Format(unitMultiplicationFactor, singleEntryFormatInArgs)) .
\"urn:uuid:04904da5-8059-40b1-b0e4-b49edcc029f5"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(unitMultiplicationFactor, (3))) .
\"urn:uuid:781f3d7a-1427-4c71-89fb-9482dbd235d5"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(unitMultiplicationFactor, (2))) .
\"urn:uuid:fc1bf746-e20e-459a-9db3-4cbf91def93b"[silk#strict] .
istAsserted(BaseKB, singleEntryFormatInArgs(unitMultiplicationFactor, (1))) .
\"urn:uuid:245a47ef-2095-4327-a8ea-b9a24cc6d36b"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(unitMultiplicationFactor, (2))) .
\"urn:uuid:575fedf8-6d90-45d0-9df2-0fb4574f418d"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(unitMultiplicationFactor, (1))) .
\"urn:uuid:4a8ab023-0fd6-4583-a939-dc766038f253"[silk#strict] .
istAsserted(UniversalVocabularyMt, singleEntryFormatInArgs(unitMultiplicationFactor, (3))) .
\"urn:uuid:94e04782-421d-423f-9ba4-f897ff007ee5"[silk#strict] .
istAsserted(UniversalVocabularyMt, completeExtentDecidable(unknownSentence)) .
\"urn:uuid:2ce05a4f-8bd6-4d95-949d-1653e18250f8"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(unknownSentence, ("A unary #$KBDependentRelation (q.v.) that takes instances of #$CycLSentence as arguments.  <code>(#$unknownSentence SENTENCE)</code> means that <code>SENTENCE</code> is not currently  ''known'' by the Cyc system to be true.  More precisely, the inference engine cannot prove <code>SENTENCE</code> <i>using only removal</i> (see #$CycRemovalModule) from the current state of the knowledge base.  <code>SENTENCE</code> might actually be known to be false (see the specialization #$contradictorySentence), or its truth-value might be simply unknown in the present sense.  \n<p>\nNote that, as a KB dependent relation, #$unknownSentence is #$notAssertible (q.v.)."^^_string))) .
\"urn:uuid:685cd857-d1b7-447f-8985-7f7ca4514682"[silk#strict] .
istAsserted(BaseKB, notAssertible(unknownSentence)) .
istAsserted(BookkeepingMt, oldConstantName(unknownSentence, ("unknownFormula"^^_string))) .
\"urn:uuid:89e22a71-4cff-4c62-a3e1-087508f8065d"[silk#strict] .
istAsserted(UniversalVocabularyMt, backchainForbidden(unknownSentence)) .
\"urn:uuid:72716fa4-ebdf-4865-832e-d2e0f35755fb"[silk#strict] .
istAsserted(CoreCycLImplementationMt, backchainForbidden(unknownSentence)) .
\"urn:uuid:5d3cbe08-458b-4f7e-aba3-01289f252ea8"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(unknownSentence, (1), CycLSentence)) .
\"urn:uuid:28516120-b049-485a-b766-3d09d0a8fed4"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(unknownSentence, (1))) .
\"urn:uuid:fa9f530e-7ee7-47e1-bfbe-610b83ee113e"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(unknownSentence, knownSentence)) .
\"urn:uuid:afb688c2-d19e-4b90-ad9b-1fc93903c859"[silk#strict] .
istAsserted(UniversalVocabularyMt, negationPreds(unknownSentence, trueSentence)) .
\"urn:uuid:126d5096-c8c3-463e-a8ed-6c798f139133"[silk#strict] .
istAsserted(BaseKB, negationPreds(unknownSentence, knownSentence)) .
\"urn:uuid:f8ecd744-7236-48e5-8dfc-af0f9aa9e5fe"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(xor, (2))) .
\"urn:uuid:0841c6a3-545d-46e2-9c35-604da2eed3d5"[silk#strict] .
istAsserted(UniversalVocabularyMt, quotedArgument(xor, (1))) .
\"urn:uuid:5bbcd797-086c-44ed-aa20-365afcd1e94f"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(xor, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:9572bd7e-5abb-48a1-96ab-16e870181a74"[silk#strict] .
istAsserted(BaseKB, argQuotedIsa(xor, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:00c116a9-41d9-46ce-857e-245224d8bd2b"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(xor, (1), 'CycLSentence-Assertible')) .
\"urn:uuid:033cf2e5-cd05-45ba-b88d-4f65e90acff1"[silk#strict] .
istAsserted(UniversalVocabularyMt, argQuotedIsa(xor, (2), 'CycLSentence-Assertible')) .
\"urn:uuid:f0fa99c2-2fb1-40c8-808c-57a6ecfa736b"[silk#strict] .
istAsserted(UniversalVocabularyMt, comment(xor, ("The #$LogicalConnective that represents exclusive-or in #$CycL. Unlike #$or, which is a #$VariableArityRelation, #$xor takes two arguments, which must be instances of #$ELSentence-Assertible. (#$xor P Q) means  one but not both of P and Q is true. (An EL formula that mentions \n  #$xor is translated during canonicalization into an equivalent, less compact, formula that mentions #$or, #$and, and #$not)."^^_string))) .
istAsserted(EnglishParaphraseMt, genFormat(xor, ("either ~a or ~a (but not both)"^^_string), TheEmptyList)) .
\"urn:uuid:7f84c69c-f842-4417-8bdf-e91b43e47b1f"[silk#strict] .
istAsserted(BaseKB, ruleTemplateDirection(CollectionRuleTemplateFn(ArgIsaPredicate), 'Forward-AssertionDirection')) .
\"urn:uuid:9f160f97-02f3-4a6d-bb78-2555a0cb7bdb"[silk#strict] .
forwardSentence(arg1Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (1), ?COL)) .
\"urn:uuid:58ba0278-ab9d-413f-9988-732abc6543d9"[silk#strict] .
forwardSentence(argIsa(?RELN, (1), ?COL)) :- removalSentence(arg1Isa(?RELN, ?COL)) .
\"urn:uuid:b0e5c175-b7dc-4217-8365-3c6b29e66430"[silk#strict] .
forwardSentence(arg2Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (2), ?COL)) .
\"urn:uuid:63650e72-3d2c-4a3d-8dcb-5beb81966b26"[silk#strict] .
forwardSentence(argIsa(?RELN, (2), ?COL)) :- removalSentence(arg2Isa(?RELN, ?COL)) .
\"urn:uuid:45313e57-5e3c-4354-a00e-19d48c4d4872"[silk#strict] .
forwardSentence(arg5Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (5), ?COL)) .
\"urn:uuid:86ffc75f-6bb1-4df1-9cb7-1103ec628af3"[silk#strict] .
forwardSentence(argIsa(?RELN, (5), ?COL)) :- removalSentence(arg5Isa(?RELN, ?COL)) .
\"urn:uuid:0073521a-378f-48a9-b54f-6b8d6fcd92c2"[silk#strict] .
forwardSentence(arg4Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (4), ?COL)) .
\"urn:uuid:5a5e5fea-4833-455a-91ce-7de69ae61ddb"[silk#strict] .
forwardSentence(argIsa(?RELN, (4), ?COL)) :- removalSentence(arg4Isa(?RELN, ?COL)) .
\"urn:uuid:dbae8d13-1b6d-436f-939b-d41f91d7ed15"[silk#strict] .
forwardSentence(arg3Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (3), ?COL)) .
\"urn:uuid:a6e251bb-619f-4ef8-9cc7-5ad290d0c503"[silk#strict] .
forwardSentence(argIsa(?RELN, (3), ?COL)) :- removalSentence(arg3Isa(?RELN, ?COL)) .
\"urn:uuid:96106299-39da-4caa-9df9-fb97ab2ce086"[silk#strict] .
forwardSentence(arg6Isa(?RELN, ?COL)) :- removalSentence(argIsa(?RELN, (6), ?COL)) .
\"urn:uuid:ee643237-4044-4956-a547-31b7bfa16aed"[silk#strict] .
forwardSentence(argIsa(?RELN, (6), ?COL)) :- removalSentence(arg6Isa(?RELN, ?COL)) .
\"urn:uuid:0d0b6348-8273-4704-9b37-16a4b27fc4d7"[silk#strict] .
istAsserted(UniversalVocabularyMt, ruleTemplateDirection(CollectionRuleTemplateFn(HypotheticalContext), 'Forward-AssertionDirection')) .
\"urn:uuid:acc9175e-9a30-46a5-9236-72caa87ae15b"[silk#strict] .
forwardSentence(backchainForbidden(?PRED)) :- removalSentence(completeExtentDecidable(?PRED)) .
\"urn:uuid:8a9980c4-2443-4d45-8762-56a6fe1a8811"[silk#strict] .
forwardSentence(relationAllExists(?PRED, ?COL1, ?COL2)) :- removalSentence(arity(?PRED, (2))) and removalSentence(requiredArg1Pred(?COL1, ?PRED)) and removalSentence('interArgIsa1-2'(?PRED, ?COL1, ?COL2)) .
\"urn:uuid:34795492-009e-42b5-ac6b-845abc2be918"[silk#strict] .
forwardSentence(arg4SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (4), ?COL)) .
\"urn:uuid:d5047aab-944b-4c6d-9098-1014ba955de9"[silk#strict] .
forwardSentence(arity(?REL, (1))) :- removalSentence(isa(?REL, UnaryRelation)) .
\"urn:uuid:3b20e8ff-8894-49a5-a045-f1c7b612b5ba"[silk#strict] .
forwardSentence(defnSufficient(?SET_TYPE, SubLSymbolFn(("CYC-SET-OF-TYPE-SUFFICIENT"^^_string)))) :- removalSentence(instanceElementType(?SET_TYPE, ?XCOL)) .
\"urn:uuid:843da82b-5057-43db-adf4-b143364ab29d"[silk#strict] .
forwardSentence(collectionBackchainEncouraged(?PRED)) :- removalSentence(collectionBackchainRequired(?PRED)) .
\"urn:uuid:80b45294-84dc-42ec-9987-4534adef50bc"[silk#strict] .
forwardSentence(isa(?NAT, ?COL)) :- removalSentence(natFunction(?NAT, ?FUNC)) and removalSentence(resultIsaArg(?FUNC, ?N)) and removalSentence(natArgument(?NAT, ?N, ?COL)) .
\"urn:uuid:ac6d55f4-a6e4-4697-955d-cd771b42df2d"[silk#strict] .
forwardSentence(resultIsa(?FUNC, Collection)) :- removalSentence(isa(?FUNC, CollectionDenotingFunction)) .
\"urn:uuid:1b6f0106-36ad-4621-9382-eb822b8b377d"[silk#strict] .
forwardSentence(arg6SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (6), ?COL)) .
\"urn:uuid:a7f2cd7e-a11e-4748-b14a-3a236add3a52"[silk#strict] .
forwardSentence(collectionIsaBackchainEncouraged(?PRED)) :- removalSentence(collectionIsaBackchainRequired(?PRED)) .
\"urn:uuid:a910f30d-ab19-4946-8cbf-b982ef7fca42"[silk#strict] .
forwardSentence(multiplicationUnits(?PERFN, ?UOM2, ?UOM1)) :- removalSentence(termOfUnit(?PERFN, PerFn(?UOM1, ?UOM2))) .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-DISJOINTWITH"^^_string)))) :- removalSentence(different(disjointWith, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, disjointWith)) .
\"urn:uuid:96b13abe-b40f-414d-a33b-c49737cc6414"[silk#strict] .
forwardSentence(quotedIsa(?NAT, ?COL)) :- removalSentence(natFunction(?NAT, ?FUNCTION)) and removalSentence(resultQuotedIsa(?FUNCTION, ?COL)) .
\"urn:uuid:a4c0a2bd-6244-4c9c-bbb2-f67de84d55bf"[silk#strict] .
forwardSentence(arity(?REL, (2))) :- removalSentence(isa(?REL, BinaryRelation)) .
\"urn:uuid:a272f853-676c-4c1c-ab65-a1cd92400bba"[silk#strict] .
forwardSentence(arg1SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (1), ?COL)) .
\"urn:uuid:bb8259ed-4a58-4d90-a1b6-0e325efde29c"[silk#strict] .
forwardSentence(transitiveViaArg(?PRED, genls, (3))) :- removalSentence(isa(?PRED, ArgGenlTernaryPredicate)) .
\"urn:uuid:f80d332e-0e84-412e-8ff3-0f587ab045b2"[silk#strict] .
forwardSentence(isa(?NART, ?COL)) :- removalSentence(assertedSentence(isa(?ARG, ?COL))) and removalSentence(natFunction(?NART, ?FUNC)) and removalSentence(resultIsaArgIsa(?FUNC, ?INT)) and removalSentence(natArgument(?NART, ?INT, ?ARG)) .
\"urn:uuid:33fc27f4-3474-4175-928c-5f5a27f87124"[silk#strict] .
forwardSentence(negationInverse(?PRED, ?PRED)) :- removalSentence(isa(?PRED, AsymmetricBinaryPredicate)) .
\"urn:uuid:114a0138-d4b4-4fa6-a6ff-3c0c097b0803"[silk#strict] .
forwardSentence(transitiveViaArg(?PRED, genls, (3))) :- removalSentence(isa(?PRED, ArgIsaTernaryPredicate)) .
\"urn:uuid:4f7239a6-c0ad-4773-8c66-96cc306dbec9"[silk#strict] .
forwardSentence(genls(?NAT, ?COL)) :- removalSentence(natFunction(?NAT, ?FUNC)) and removalSentence(resultGenlArg(?FUNC, ?N)) and removalSentence(natArgument(?NAT, ?N, ?COL)) .
\"urn:uuid:f8d86e08-1393-436c-9991-d731aa921230"[silk#strict] .
forwardSentence(fanOutArg(?SPEC, ?ARG_NUM)) :- removalSentence(genlPreds(?SPEC, ?GENL)) and removalSentence(fanOutArg(?GENL, ?ARG_NUM)) .
\"urn:uuid:25c08c35-a5d1-4763-9c8f-2057be1d8009"[silk#strict] .
forwardSentence(arg3QuotedIsa(?QUANT, 'CycLSentence-Assertible')) :- removalSentence(isa(?QUANT, 'ExistentialQuantifier-Bounded')) .
\"urn:uuid:ccf97543-ecfc-4f0a-bae8-5aa7243501b4"[silk#strict] .
forwardSentence(decontextualizedPredicate(?SPEC)) :- removalSentence(decontextualizedPredicate(?PRED)) and removalSentence(genlPreds(?SPEC, ?PRED)) .
\"urn:uuid:88fb9c74-001c-4c75-8ce6-0ae82dde8360"[silk#strict] .
forwardSentence(argsQuotedIsa(?CONNECT, 'CycLSentence-Assertible')) :- removalSentence(isa(?CONNECT, LogicalConnective)) and removalSentence(isa(?CONNECT, VariableArityRelation)) .
\"urn:uuid:cb543274-1664-4736-b26b-654381fd49e4"[silk#strict] .
forwardSentence(arg3SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (3), ?COL)) .
\"urn:uuid:a0303663-70a4-4bed-9b2f-48401c54c83d"[silk#strict] .
forwardSentence(genls(?NAT, ?DEP_COL)) :- removalSentence(natFunction(?NAT, ?FUNC)) and removalSentence(genls(?COL, ?INDEP_COL)) and removalSentence(natArgument(?NAT, ?ARG, ?COL)) and removalSentence(interArgResultGenl(?FUNC, ?ARG, ?INDEP_COL, ?DEP_COL)) .
\"urn:uuid:d67730f5-8739-49da-826e-74ea80fcde40"[silk#strict] .
forwardSentence(arity(?REL, (3))) :- removalSentence(isa(?REL, TernaryRelation)) .
forwardSentence(argIsa(?RELN, ?N, ?COL)) :- removalSentence('genls-SpecDenotesGenlInstances'(?Q_COL, ?COL)) and removalSentence(argQuotedIsa(?RELN, ?N, ?Q_COL)) .
\"urn:uuid:104752fd-18ce-4d69-b9cf-6b8b263f4b47"[silk#strict] .
forwardSentence(quotedArgument(?PRED, ?N)) :- removalSentence(argQuotedIsa(?PRED, ?N, ?XCOL)) .
\"urn:uuid:441cd882-5511-4dbe-a3c0-ed1d2e08c611"[silk#strict] .
forwardSentence(unitMultiplicationFactor(?PERFN_1, ?PERFN, ?FACTOR1)) :- removalSentence(unitMultiplicationFactor(?UNIT_ONE, ?UNIT_TWO, ?FACTOR1)) and removalSentence(termOfUnit(?PERFN_1, PerFn(?UNIT_ONE, ?UNIT_THREE))) and removalSentence(termOfUnit(?PERFN, PerFn(?UNIT_TWO, ?UNIT_THREE))) .
\"urn:uuid:8feff4ce-c3b1-4f79-a055-58face3f20f3"[silk#strict] .
forwardSentence(genls(?NAT, ?COL)) :- removalSentence(natFunction(?NAT, ?FUNCTION)) and removalSentence(resultGenl(?FUNCTION, ?COL)) .
\"urn:uuid:a29a26a6-5b26-42bb-af8e-1cccd2a09207"[silk#strict] .
forwardSentence(arg5SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (5), ?COL)) .
\"urn:uuid:e60cd486-48a4-4c5f-8609-4ce9a67c3eb2"[silk#strict] .
forwardSentence(collectionGenlsBackchainEncouraged(?PRED)) :- removalSentence(collectionGenlsBackchainRequired(?PRED)) .
\"urn:uuid:70edbe7b-ae02-47f5-90b2-91090bc1660e"[silk#strict] .
forwardSentence(evaluateAtEL(?FUNC)) :- removalSentence(evaluateImmediately(?FUNC)) .
\"urn:uuid:f6336047-cfa1-470a-87f3-f23c1d1e21fe"[silk#strict] .
forwardSentence(arity(?REL, (4))) :- removalSentence(isa(?REL, QuaternaryRelation)) .
\"urn:uuid:e1a08a12-8119-4b61-9f9d-26747a097823"[silk#strict] .
forwardSentence(expansion(?INVERSE, ?SLOT(MetaVariableFn(("ARG2"^^_string)), MetaVariableFn(("ARG1"^^_string))))) :- removalSentence(elInverse(?SLOT, ?INVERSE)) .
\"urn:uuid:1e6e7c42-955e-4129-969c-c22eaddadbec"[silk#strict] .
forwardSentence(predicateConventionMt(?SPEC, ?MT)) :- removalSentence(decontextualizedPredicate(?PRED)) and removalSentence(different(?PRED, ?SPEC)) and removalSentence(genlInverse(?SPEC, ?PRED)) and removalSentence(predicateConventionMt(?PRED, ?MT)) .
\"urn:uuid:3adf561f-4b77-457c-8ca1-b9d13407e5fd"[silk#strict] .
forwardSentence(genlMt(?MIC, BaseKB)) :- removalSentence(isa(?MIC, Microtheory)) .
\"urn:uuid:33381f80-ba38-411e-acf9-f7c1f10dbbeb"[silk#strict] .
forwardSentence(isa(?FUNCTION, CollectionDenotingFunction)) :- removalSentence(genls(?COLTYPE, Collection)) and removalSentence(resultIsa(?FUNCTION, ?COLTYPE)) .
\"urn:uuid:58888e53-35ec-43fe-8234-41dd6fa2e46d"[silk#strict] .
forwardSentence(isa(?NAT, ?DEP_COL)) :- removalSentence(natFunction(?NAT, ?FUNC)) and removalSentence(isa(?TERM, ?INDEP_COL)) and removalSentence(natArgument(?NAT, ?ARG, ?TERM)) and removalSentence(interArgResultIsa(?FUNC, ?ARG, ?INDEP_COL, ?DEP_COL)) .
\"urn:uuid:21e104c7-27b9-4372-8490-ffc2686cc907"[silk#strict] .
forwardSentence(afterRemoving(?PRED, SubLSymbolFn(("REMOVE-DEPENDENT-TERM"^^_string)))) :- removalSentence(genlPreds(?PRED, termDependsOn)) .
\"urn:uuid:86cbb156-6576-4937-a097-77f5ed847846"[silk#strict] .
forwardSentence(unitMultiplicationFactor(?PERFN_1, ?PERFN, ?FACTOR1)) :- removalSentence(unitMultiplicationFactor(?UNIT_TWO, ?UNIT_THREE, ?FACTOR1)) and removalSentence(termOfUnit(?PERFN_1, PerFn(?UNIT_ONE, ?UNIT_THREE))) and removalSentence(termOfUnit(?PERFN, PerFn(?UNIT_ONE, ?UNIT_TWO))) .
\"urn:uuid:6413df78-37bc-4254-bd91-f4c241f5855c"[silk#strict] .
forwardSentence(?ARG_N_QUOTED_ISA(?CONNECT, 'CycLSentence-Assertible')) :- removalSentence(isa(?CONNECT, FixedArityRelation)) and removalSentence(isa(?CONNECT, LogicalConnective)) and removalSentence(isa(?ARG_N_QUOTED_ISA, ArgQuotedIsaBinaryPredicate)) and removalSentence(arity(?CONNECT, ?ARITY)) and removalSentence(constrainsArg(?ARG_N_QUOTED_ISA, ?N)) and removalSentence(integerBetween((1), ?N, ?ARITY)) .
\"urn:uuid:e4ff4884-ad74-45c0-a8b2-e3b8a565879c"[silk#strict] .
forwardSentence(isa(?NAT, ?COL)) :- removalSentence(natFunction(?NAT, ?FUNCTION)) and removalSentence(resultIsa(?FUNCTION, ?COL)) .
\"urn:uuid:a4969eda-3129-40f2-a293-26ddc6fb1c27"[silk#strict] .
forwardSentence(arg2SometimesIsa(?RELN, ?COL)) :- removalSentence(argSometimesIsa(?RELN, (2), ?COL)) .
\"urn:uuid:f19cf3d5-8d70-4767-91a0-da08dd857ef6"[silk#strict] .
forwardSentence(predicateConventionMt(?SPEC, ?MT)) :- removalSentence(decontextualizedPredicate(?PRED)) and removalSentence(predicateConventionMt(?PRED, ?MT)) and removalSentence(genlPreds(?SPEC, ?PRED)) .
\"urn:uuid:aedb1ccf-48cc-49ff-a43c-b28371294dc5"[silk#strict] .
forwardSentence(arity(?REL, (5))) :- removalSentence(isa(?REL, QuintaryRelation)) .
\"urn:uuid:b5f23477-da79-4958-a815-abf1e0f568da"[silk#strict] .
forwardSentence(arg2QuotedIsa(?QUANT, CycLVariable)) :- removalSentence(isa(?QUANT, 'ExistentialQuantifier-Bounded')) .
\"urn:uuid:dccbb318-5d4e-4b39-86cb-b7283d53c38d"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (3), ?COL)) :- removalSentence(arg3SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:d8b6b74b-2dc0-409e-aa22-d1580eee8648"[silk#strict] .
forwardSentence(arg1Genl(greaterThanOrEqualTo, ?ARGGENL)) :- removalSentence(arg2Genl(lessThanOrEqualTo, ?ARGGENL)) .
\"urn:uuid:16eca49f-0aad-45ff-a3c9-b44a689dee01"[silk#strict] .
forwardSentence(defnSufficient(?WEEKDAY, SubLSymbolFn(("CYC-DAY-OF-WEEK-DEFN"^^_string)))) :- removalSentence(isa(?WEEKDAY, DayOfWeekType)) .
\"urn:uuid:700dd6c2-e443-4dd6-981b-b3061cadfbaf"[silk#strict] .
forwardSentence('interArgIsa3-4'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (3), ?IND_COL, (4), ?DEP_COL)) .
\"urn:uuid:5d9264fd-2e37-440d-a810-5ac41515db62"[silk#strict] .
forwardSentence(decontextualizedPredicate(?SPEC)) :- removalSentence(decontextualizedPredicate(?PRED)) and removalSentence(different(?PRED, ?SPEC)) and removalSentence(genlInverse(?SPEC, ?PRED)) .
\"urn:uuid:af514245-89d4-472d-b12a-cd1a10db5dd8"[silk#strict] .
forwardSentence(arg6Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (6), ?COL)) .
\"urn:uuid:81e639b5-a23e-4347-8648-7f329134d298"[silk#strict] .
forwardSentence(afterAdding(?SPEC_INVERSE, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLMT"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, genlMt)) .
\"urn:uuid:4999eeae-daf8-4ec8-83c9-b6919eb7cd3c"[silk#strict] .
forwardSentence(arg2Isa(greaterThan, ?ARGISA)) :- removalSentence(arg1Isa(lessThan, ?ARGISA)) .
\"urn:uuid:19a113ea-6221-4e24-9470-460da31d8fb3"[silk#strict] .
forwardSentence(afterAdding(?EQUALITY_PRED, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) :- removalSentence(genlPreds(?EQUALITY_PRED, equals)) .
\"urn:uuid:667ab242-cdd7-43c4-8961-aa9c28e20f74"[silk#strict] .
forwardSentence(afterAdding(?PRED, SubLSymbolFn(("INTER-ARG-ISA-AFTER-ADDING"^^_string)))) :- removalSentence(isa(?PRED, InterArgIsaPredicate)) .
\"urn:uuid:0e4bb6b5-58a9-47ce-b9c6-bd66425a0fbd"[silk#strict] .
forwardSentence('interArgIsa2-1'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (2), ?IND_COL, (1), ?DEP_COL)) .
\"urn:uuid:4253a140-6a87-4374-9541-adf213cd3a2d"[silk#strict] .
forwardSentence(decontextualizedCollection(?ANECT)) :- removalSentence(isa(?ANECT, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:360ecc43-62ba-459a-a9dd-6ecd44ef8054"[silk#strict] .
forwardSentence(arg1QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (1), ?COL)) .
\"urn:uuid:5d9dcfa1-1311-4c11-a4ab-f61e47eb7434"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-NEGATIONINVERSE"^^_string)))) :- removalSentence(different(negationInverse, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, negationInverse)) .
\"urn:uuid:7f06ea53-4397-493b-93a2-2b41f53398cb"[silk#strict] .
forwardSentence('interArgIsa4-2'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (4), ?IND_COL, (2), ?DEP_COL)) .
\"urn:uuid:0d2cc9ec-edbc-4316-9ee4-539c6f92c775"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (3), ?COL)) :- removalSentence(arg3QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:4725d27b-28ff-484b-8e03-59258fde42d7"[silk#strict] .
forwardSentence(argGenl(?RELN, (4), ?COL)) :- removalSentence(arg4Genl(?RELN, ?COL)) .
\"urn:uuid:0790f547-3563-4e32-92f3-db227ac950e4"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (5), ?IND_COL, (3), ?DEP_COL)) :- removalSentence('interArgIsa5-3'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:ec971ab6-c5a3-465f-a27c-1e4277c96fc6"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (1), ?IND_COL, (2), ?DEP_COL)) :- removalSentence('interArgIsa1-2'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:2b4e14a5-ba10-4e5f-8216-178c0fe22853"[silk#strict] .
forwardSentence(silk#qualifies(CycAssertionFn((8876)))) :- removalSentence(admittedSentence(isa(?A, ?B))) .
\"urn:uuid:e8190cff-140e-4edb-b3ad-f989e335c8b9"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (4), ?IND_COL, (3), ?DEP_COL)) :- removalSentence('interArgIsa4-3'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:700ef2dc-1b18-4332-ba12-d08962b54ed4"[silk#strict] .
forwardSentence(arg2Genl(greaterThanOrEqualTo, ?ARGGENL)) :- removalSentence(arg1Genl(lessThanOrEqualTo, ?ARGGENL)) .
\"urn:uuid:92c34c78-8d32-4f9c-9062-689730ffcf7b"[silk#strict] .
forwardSentence(arg6QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (6), ?COL)) .
\"urn:uuid:b2d2cec9-af9a-41f3-8130-b5010762eb9c"[silk#strict] .
forwardSentence('interArgIsa1-5'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (1), ?IND_COL, (5), ?DEP_COL)) .
\"urn:uuid:cec739d8-4595-41a8-bb1f-3c632d113bda"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (4), ?IND_COL, (2), ?DEP_COL)) :- removalSentence('interArgIsa4-2'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:b3d32263-5f6f-4cc0-8073-24e4c698633c"[silk#strict] .
forwardSentence(arg3Format(?SPECPRED, SingleEntry)) :- removalSentence(arg3Format(?GENLPRED, SingleEntry)) and removalSentence(different(?GENLPRED, ?SPECPRED)) and removalSentence(genlPreds(?SPECPRED, ?GENLPRED)) .
\"urn:uuid:1cecfd86-fc5c-466a-88b6-c3d4776a7277"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-GENLMT"^^_string)))) :- removalSentence(different(genlMt, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, genlMt)) .
\"urn:uuid:146fc823-21a7-4abc-b992-d3bbcbb33443"[silk#strict] .
forwardSentence('interArgIsa5-3'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (5), ?IND_COL, (3), ?DEP_COL)) .
\"urn:uuid:b538d823-50df-42e4-9b4b-08393919cf43"[silk#strict] .
forwardSentence(highlyRelevantTerm(?TERM)) :- removalSentence(hypotheticalTerm(?TERM)) .
\"urn:uuid:6d2b1294-be35-4fb9-88b3-4ce787fcb048"[silk#strict] .
forwardSentence(completelyDecidableCollection(?COL)) :- removalSentence(completeExtentDecidableForValueInArg(isa, ?COL, (2))) .
\"urn:uuid:681f808f-fc87-4fc7-88a5-8235b113c166"[silk#strict] .
forwardSentence(highlyRelevantAssertion(?ASSERTION)) :- removalSentence(knownAntecedentRule(?ASSERTION)) .
\"urn:uuid:a5b9d8c1-0da7-40c9-9aec-2a584c6b8178"[silk#strict] .
forwardSentence(afterRemoving(?SPEC_INVERSE, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, genls)) .
\"urn:uuid:47412344-68f3-4bd1-bba1-1535d8530aab"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (2), ?IND_COL, (5), ?DEP_COL)) :- removalSentence('interArgIsa2-5'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:4ddf6bed-9e85-4de1-84b4-12c153ca7ecb"[silk#strict] .
forwardSentence(genlInverse(?PRED, ?PRED)) :- removalSentence(isa(?PRED, SymmetricBinaryPredicate)) .
\"urn:uuid:9c318a8a-3477-42fe-a2d8-2890a13e6b3e"[silk#strict] .
forwardSentence('interArgIsa4-3'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (4), ?IND_COL, (3), ?DEP_COL)) .
\"urn:uuid:39a2d3eb-3eda-4fd3-a21f-8a72280ac5ca"[silk#strict] .
forwardSentence(arg3QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (3), ?COL)) .
\"urn:uuid:876d8524-5175-4f94-9789-e547f55742b5"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (5), ?COL)) :- removalSentence(arg5SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:9990fac2-7eaa-4f8d-9a03-d11f407f4342"[silk#strict] .
forwardSentence(arg2Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (2), ?COL)) .
\"urn:uuid:70cc4623-5339-4d81-b161-4418bf424593"[silk#strict] .
forwardSentence('interArgIsa3-1'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (3), ?IND_COL, (1), ?DEP_COL)) .
\"urn:uuid:085a3972-0ec6-497e-8fb9-2b1c02367de5"[silk#strict] .
forwardSentence(afterAdding(?SPEC_INVERSE, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLPREDS"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, genlPreds)) .
\"urn:uuid:348fa67b-830e-4c78-9856-c7294839075f"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (5), ?COL)) :- removalSentence(arg5QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:8adebd1c-b4c3-4f59-919b-109c46e495f1"[silk#strict] .
forwardSentence(arg2Isa(?INVERSE, ?COL)) :- removalSentence(elInverse(?PRED, ?INVERSE)) and removalSentence(arg1Isa(?PRED, ?COL)) .
\"urn:uuid:453af7c3-2859-4fdc-9bf4-4b8804e2f19d"[silk#strict] .
forwardSentence(arg4Format(?SPECPRED, SingleEntry)) :- removalSentence(arg4Format(?GENLPRED, SingleEntry)) and removalSentence(different(?GENLPRED, ?SPECPRED)) and removalSentence(genlPreds(?SPECPRED, ?GENLPRED)) .
\"urn:uuid:457a0fa4-99d5-4123-8a50-438ffc84ce78"[silk#strict] .
forwardSentence(argsGenl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (0), ?COL)) .
\"urn:uuid:6e81de6a-acfb-4c70-abcd-211b8870c736"[silk#strict] .
forwardSentence(predicateConventionMt(?SPEC_PRED, UniversalVocabularyMt)) :- removalSentence(decontextualizedPredicate(?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, genlMt)) .
\"urn:uuid:c8f4f989-1b68-44ea-b8c9-b9416fd14aa1"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-ISA"^^_string)))) :- removalSentence(different(isa, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, isa)) .
\"urn:uuid:1407a788-115b-4c05-a9ae-46a716ae4c0b"[silk#strict] .
forwardSentence(arg2Isa(lessThan, ?ARGISA)) :- removalSentence(arg1Isa(greaterThan, ?ARGISA)) .
\"urn:uuid:c1526ccf-271b-4fe3-a5a7-cf5bde577e33"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (3), ?IND_COL, (2), ?DEP_COL)) :- removalSentence('interArgIsa3-2'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:176f22ea-6d41-4806-95b8-e62318e5639a"[silk#strict] .
forwardSentence(silk#qualifies(CycAssertionFn((8865)))) :- removalSentence(admittedArgument(?B, (1), natFunction)) and removalSentence(admittedArgument(?A, (2), natFunction)) .
\"urn:uuid:2c69cfad-5aff-4b8b-8ae3-33d5fa725f0e"[silk#strict] .
forwardSentence(arg1Genl(lessThanOrEqualTo, ?ARGGENL)) :- removalSentence(arg2Genl(greaterThanOrEqualTo, ?ARGGENL)) .
\"urn:uuid:ba9dcfdc-6651-4cac-bf17-1df4365f5da0"[silk#strict] .
forwardSentence(afterRemoving(?SPEC_PRED, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) :- removalSentence(genlPreds(?SPEC_PRED, genls)) .
\"urn:uuid:88533074-2088-454d-a515-c6f1a065908b"[silk#strict] .
forwardSentence(silk#qualifies(CycAssertionFn((8930)))) :- removalSentence(admittedSentence('equalStrings-CaseInsensitive'(?A, ?B))) .
\"urn:uuid:7957bb04-d9c5-42e4-90cb-db612746d20d"[silk#strict] .
forwardSentence(argGenl(?RELN, (3), ?COL)) :- removalSentence(arg3Genl(?RELN, ?COL)) .
\"urn:uuid:0933de8b-2227-4164-a12d-e26c68e11ea2"[silk#strict] .
forwardSentence(decontextualizedCollection(?SPEC)) :- removalSentence(genls(?SPEC, LogicalConnective)) .
\"urn:uuid:6ffa8e9f-8a58-47c7-b248-65e2a4e07a84"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (1))) and removalSentence(arg1Genl(?FUNC, ?COL)) .
\"urn:uuid:52ffe5ff-bd79-42b5-a292-e10129ba9426"[silk#strict] .
forwardSentence(transitiveViaArg(?PRED, genls, (2))) :- removalSentence(isa(?PRED, ArgIsaBinaryPredicate)) .
\"urn:uuid:8718510e-edab-4488-89e1-64e755f72a7c"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-GENLPREDS"^^_string)))) :- removalSentence(different(genlPreds, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, genlPreds)) .
\"urn:uuid:16c08575-db1b-46c7-b48d-b5e3bc873692"[silk#strict] .
forwardSentence(afterRemoving(?PRED, SubLSymbolFn(("REMOVE-TVA-CACHE-KEY"^^_string)))) :- removalSentence(afterAdding(?PRED, SubLSymbolFn(("ADD-TVA-CACHE-KEY"^^_string)))) .
\"urn:uuid:1178db7d-7eb2-4226-adef-463140353892"[silk#strict] .
forwardSentence('interArgIsa5-2'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (5), ?IND_COL, (2), ?DEP_COL)) .
\"urn:uuid:8f2edaa4-c2ca-4cd8-ae18-bdf0153884c3"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (1), ?IND_COL, (3), ?DEP_COL)) :- removalSentence('interArgIsa1-3'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:42221a3b-30f5-4474-9897-c42f29cdea70"[silk#strict] .
forwardSentence(definingMt(?PRED, BaseKB)) :- removalSentence(isa(?PRED, InferenceRelatedBookkeepingPredicate)) .
\"urn:uuid:e26b6ed9-7d66-4f2d-b69d-d8fc979ead47"[silk#strict] .
forwardSentence('interArgIsa2-5'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (2), ?IND_COL, (5), ?DEP_COL)) .
\"urn:uuid:7bba7e3c-686d-4fed-9e1d-fab8de5d7195"[silk#strict] .
forwardSentence(arg4Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (4), ?COL)) .
\"urn:uuid:847906cf-9afa-4b93-b82e-35f259c71cd3"[silk#strict] .
forwardSentence('interArgIsa2-1'(?PRED, ?COL, ?COL)) :- removalSentence(isa(?PRED, SymmetricBinaryPredicate)) and removalSentence('interArgIsa1-2'(?PRED, ?COL, ?COL)) .
\"urn:uuid:0eee3d0b-c36c-4144-a4ff-bcc15a4d8107"[silk#strict] .
forwardSentence(arg2Format(?SPECPRED, SingleEntry)) :- removalSentence(arg2Format(?GENLPRED, SingleEntry)) and removalSentence(different(?GENLPRED, ?SPECPRED)) and removalSentence(genlPreds(?SPECPRED, ?GENLPRED)) .
\"urn:uuid:079f1a67-429e-46db-9986-8753073bd993"[silk#strict] .
forwardSentence(resultQuotedIsa(?FUNC, IndeterminateTerm)) :- removalSentence(isa(?FUNC, IndeterminateTermDenotingFunction)) .
\"urn:uuid:d99de091-d36e-496a-bc3a-267ad1fad760"[silk#strict] .
forwardSentence('interArgIsa1-2'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (1), ?IND_COL, (2), ?DEP_COL)) .
\"urn:uuid:8f4836a7-d689-4beb-8f9d-26021f603564"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (3), ?IND_COL, (1), ?DEP_COL)) :- removalSentence('interArgIsa3-1'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:be3351a7-43a4-4b06-b1f2-d4579a935473"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (2), ?COL)) :- removalSentence(arg2QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:bbc7b4ec-9e0b-48a9-ac92-83db66585806"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (1), ?IND_COL, (5), ?DEP_COL)) :- removalSentence('interArgIsa1-5'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:73832dd8-8eb7-4cc6-bf8e-7003d4cd800b"[silk#strict] .
forwardSentence('interArgIsa3-2'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (3), ?IND_COL, (2), ?DEP_COL)) .
\"urn:uuid:52ee9b9c-dba0-4f3b-bc0b-bb7d1753c452"[silk#strict] .
forwardSentence(arg1Genl(greaterThan, ?ARGGENL)) :- removalSentence(arg2Genl(lessThan, ?ARGGENL)) .
\"urn:uuid:c8dfb903-d9da-4dc3-9b9c-c3d9c282030e"[silk#strict] .
forwardSentence(argGenl(?RELN, (1), ?COL)) :- removalSentence(arg1Genl(?RELN, ?COL)) .
\"urn:uuid:3e22c9d5-6a99-4082-8367-4c98d05a11fb"[silk#strict] .
forwardSentence(afterAdding(?SPEC_INVERSE, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLINVERSE"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, genlInverse)) .
\"urn:uuid:5a77732d-34ae-4c77-93a4-cf50a5298b3e"[silk#strict] .
forwardSentence(_cancelCycAssertionFn((8907))) :- removalSentence(isa(?CONNECT, ExceptionPredicate)) .
\"urn:uuid:b84bc9ed-1625-45a5-8474-cc18e4d39db1"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (2), ?COL)) :- removalSentence(arg2SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:3f5a4035-ed66-4849-a2a2-f97afc012fc0"[silk#strict] .
forwardSentence(arg2Genl(lessThanOrEqualTo, ?ARGGENL)) :- removalSentence(arg1Genl(greaterThanOrEqualTo, ?ARGGENL)) .
\"urn:uuid:2aa38c04-e03b-473c-abd9-eace4debad31"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (5), ?IND_COL, (4), ?DEP_COL)) :- removalSentence('interArgIsa5-4'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:5be3263c-ff5f-4466-8a11-ce64f21a0d77"[silk#strict] .
forwardSentence(afterRemoving(?PRED, SubLSymbolFn(("INTER-ARG-FORMAT-AFTER-REMOVING"^^_string)))) :- removalSentence(isa(?PRED, InterArgFormatPredicate)) .
\"urn:uuid:353e841f-98f4-4dcb-a6c3-480a94faf123"[silk#strict] .
forwardSentence(resultIsa(?FUNCTION, ?COL)) :- removalSentence(evaluationResultQuotedIsa(?FUNCTION, ?Q_COL)) and removalSentence('genls-SpecDenotesGenlInstances'(?Q_COL, ?COL)) .
\"urn:uuid:028d258d-5197-4d22-8fc7-77d673ebc96c"[silk#strict] .
forwardSentence(argGenl(?RELN, (6), ?COL)) :- removalSentence(arg6Genl(?RELN, ?COL)) .
\"urn:uuid:20514898-9eaa-425c-bf13-623d39e0a489"[silk#strict] .
forwardSentence('interArgIsa1-3'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (1), ?IND_COL, (3), ?DEP_COL)) .
\"urn:uuid:b75d022f-b0be-469f-8b1b-ffceddcc881d"[silk#strict] .
forwardSentence(argGenl(?RELN, (2), ?COL)) :- removalSentence(arg2Genl(?RELN, ?COL)) .
\"urn:uuid:a184c04a-4fbf-4db6-9132-dd885d92063c"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (2), ?IND_COL, (1), ?DEP_COL)) :- removalSentence('interArgIsa2-1'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:172c910d-71b5-48b1-8c5d-e1e353c6f03a"[silk#strict] .
forwardSentence(followingValue(?SUB, ?LATER)) :- removalSentence(quantitySubsumes(?SUPER, ?SUB)) and removalSentence(followingValue(?SUPER, ?LATER)) .
\"urn:uuid:461f10ee-8e06-4186-97da-dbe1a635376d"[silk#strict] .
forwardSentence(arg1Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (1), ?COL)) .
\"urn:uuid:3075014c-86ee-4d9b-8937-280299eb7da4"[silk#strict] .
forwardSentence(collectionConventionMt(?ANECT, UniversalVocabularyMt)) :- removalSentence(isa(?ANECT, AtemporalNecessarilyEssentialCollectionType)) .
\"urn:uuid:3091804d-31df-464e-9981-28c9609dad98"[silk#strict] .
forwardSentence(arg5QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (5), ?COL)) .
\"urn:uuid:ce7e10c1-88f9-417d-b5db-5d6cd53f5d58"[silk#strict] .
forwardSentence(arg2Genl(greaterThan, ?ARGGENL)) :- removalSentence(arg1Genl(lessThan, ?ARGGENL)) .
\"urn:uuid:4a3236e2-555f-4126-8e08-42aa20e25eb6"[silk#strict] .
forwardSentence('interArgIsa4-5'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (4), ?IND_COL, (5), ?DEP_COL)) .
\"urn:uuid:77a05f6d-9e55-48dc-aab5-6b7d584f0534"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (3))) and removalSentence(arg3Genl(?FUNC, ?COL)) .
\"urn:uuid:43ece622-3323-4fdf-b5a0-2ac177deb355"[silk#strict] .
forwardSentence(arg2Genl(?INVERSE, ?COL)) :- removalSentence(elInverse(?PRED, ?INVERSE)) and removalSentence(arg1Genl(?PRED, ?COL)) .
\"urn:uuid:d6b397ce-be25-498a-96fb-fabcd897950a"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (4))) and removalSentence(arg4Genl(?FUNC, ?COL)) .
\"urn:uuid:3baa0128-c705-45fb-9903-f80a1de0b035"[silk#strict] .
forwardSentence(overlappingExternalConcept(?COL, ?SOURCE, ?STRING)) :- removalSentence(extConceptOverlapsColAndReln(?COL, ?RELN, ?SOURCE, ?STRING)) .
\"urn:uuid:1701ef44-d9c3-4e8c-91fc-4a179d8ffa6a"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (3), ?IND_COL, (4), ?DEP_COL)) :- removalSentence('interArgIsa3-4'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:f1354195-37e6-4022-8972-cb4fa0bd30f5"[silk#strict] .
forwardSentence(afterAdding(?SPEC_INVERSE, SubLSymbolFn(("PROPAGATE-INVERSE-TO-ISA"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, isa)) .
\"urn:uuid:062101f1-5997-4d8c-b300-bbdd90b7eb79"[silk#strict] .
forwardSentence(arg2Isa(greaterThanOrEqualTo, ?ARGISA)) :- removalSentence(arg1Isa(lessThanOrEqualTo, ?ARGISA)) .
\"urn:uuid:34753f4a-3d4f-44f6-85be-5be56ea34802"[silk#strict] .
forwardSentence(multiplicationUnits(?PERFN_1, ?PERFN_2, ?PERFN)) :- removalSentence(termOfUnit(?PERFN_1, PerFn(?UNIT2, ?UNIT3))) and removalSentence(termOfUnit(?PERFN_2, PerFn(?UNIT1, ?UNIT2))) and removalSentence(termOfUnit(?PERFN, PerFn(?UNIT1, ?UNIT3))) .
\"urn:uuid:b2496ff2-ba36-426b-9525-609347f237f8"[silk#strict] .
forwardSentence(arityMax(?UNIT, (2))) :- removalSentence(isa(?UNIT, UnitOfMeasure)) .
\"urn:uuid:b9d1a1bc-61a8-4f65-92a6-07c0ef003b14"[silk#strict] .
forwardSentence(argGenl(?RELN, (0), ?COL)) :- removalSentence(argsGenl(?RELN, ?COL)) .
\"urn:uuid:ad5c8341-ded9-4f09-bc3e-dca61181d5d5"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-GENLINVERSE"^^_string)))) :- removalSentence(different(genlInverse, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, genlInverse)) .
\"urn:uuid:895c131e-9a93-4acf-8f72-17744a16ac31"[silk#strict] .
forwardSentence(afterRemoving(?EQUALITY_PRED, SubLSymbolFn(("DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE"^^_string)))) :- removalSentence(genlPreds(?EQUALITY_PRED, equals)) .
\"urn:uuid:119d26f3-46a0-4dc7-b569-21737a2a0849"[silk#strict] .
forwardSentence(transitiveViaArgInverse(?PRED, quantitySubsumes, (3))) :- removalSentence(isa(?PRED, ArgGenlQuantityTernaryPredicate)) .
\"urn:uuid:a63602a3-4bb8-4d89-848e-306066769e15"[silk#strict] .
forwardSentence(afterAdding(?PRED, SubLSymbolFn(("ADD-TVA-CACHE-KEY"^^_string)))) :- removalSentence(afterRemoving(?PRED, SubLSymbolFn(("REMOVE-TVA-CACHE-KEY"^^_string)))) .
\"urn:uuid:02c7ddec-f1b3-4e36-af60-1a7cea9fbf04"[silk#strict] .
forwardSentence(afterAdding(?X, SubLSymbolFn(("CLEAR-WFF-CONSTRAINT-DEPENDENT-CACHES"^^_string)))) :- removalSentence(isa(?X, WFFConstraintPredicate)) .
\"urn:uuid:fa6481f0-ebaf-49b8-8f10-95bce7be9d0c"[silk#strict] .
forwardSentence(ephemeralTerm(?TERM)) :- removalSentence(hypotheticalTerm(?TERM)) .
\"urn:uuid:0d65ecc0-b045-49c1-92af-48be03a477ac"[silk#strict] .
forwardSentence('interArgIsa2-4'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (2), ?IND_COL, (4), ?DEP_COL)) .
\"urn:uuid:e092b913-9468-4ea3-b8f6-84e99506863a"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (4), ?COL)) :- removalSentence(arg4SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:e3e9e07c-c548-4988-9390-8e0f959a9016"[silk#strict] .
forwardSentence(arg5Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (5), ?COL)) .
\"urn:uuid:3c1bec00-0a0c-4a5c-b564-f9f4f478799b"[silk#strict] .
forwardSentence(resultIsa(?FN, ?COLL)) :- removalSentence(interArgResultIsa(?FN, ?XNUM, Thing, ?COLL)) .
\"urn:uuid:d9cd4f4e-d8e7-40aa-af82-0790479411ed"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (4), ?COL)) :- removalSentence(arg4QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:db00ecd4-c9fa-41fa-b8a5-15fa3b980d05"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (5), ?IND_COL, (1), ?DEP_COL)) :- removalSentence('interArgIsa5-1'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:5032582e-dfa2-41db-b958-bb1b7fd1a6dc"[silk#strict] .
forwardSentence(_cancelCycAssertionFn((8842))) :- removalSentence(omitArgIsa(?RELN, ?N)) .
\"urn:uuid:daa3b6fa-82b0-41d3-91fa-b0e30f4ada23"[silk#strict] .
forwardSentence(arg2QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (2), ?COL)) .
\"urn:uuid:16fe3f6e-7e30-4d96-9de5-e75e161d5a38"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (5))) and removalSentence(arg5Genl(?FUNC, ?COL)) .
\"urn:uuid:87769b87-c33b-4c8f-9a38-35c659b27de5"[silk#strict] .
forwardSentence(genls(?TYPE, ?THING)) :- removalSentence(genlPreds(?ISA_PRED, isa)) and removalSentence(relationAllInstance(?ISA_PRED, ?TYPE, ?THING)) .
\"urn:uuid:35fa10cd-d996-4254-9a69-308ac2286def"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (2))) and removalSentence(arg2Genl(?FUNC, ?COL)) .
\"urn:uuid:0aa1a368-280b-468a-a403-4d1e1cfd0913"[silk#strict] .
forwardSentence(arg1Isa(?INVERSE, ?COL)) :- removalSentence(elInverse(?PRED, ?INVERSE)) and removalSentence(arg2Isa(?PRED, ?COL)) .
\"urn:uuid:2a1e52ba-a0b8-4660-8b37-09204c966411"[silk#strict] .
forwardSentence('interArgIsa5-1'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (5), ?IND_COL, (1), ?DEP_COL)) .
\"urn:uuid:b812dc3f-b783-4525-a72e-c97c8c227d99"[silk#strict] .
forwardSentence(afterAdding(?PRED, SubLSymbolFn(("INTER-ARG-FORMAT-AFTER-ADDING"^^_string)))) :- removalSentence(isa(?PRED, InterArgFormatPredicate)) .
\"urn:uuid:894a61e9-7815-496f-a217-4e320124be4a"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (4), ?IND_COL, (1), ?DEP_COL)) :- removalSentence('interArgIsa4-1'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:9e8a381f-bc7f-4510-99d0-f3964b350794"[silk#strict] .
forwardSentence(resultIsa(?FUNC, ?COL)) :- removalSentence(resultIsaArg(?FUNC, (6))) and removalSentence(arg6Genl(?FUNC, ?COL)) .
\"urn:uuid:4138eba5-919a-47cc-b451-c38ea0ec4bdc"[silk#strict] .
forwardSentence(silk#qualifies(CycAssertionFn((8790)))) :- removalSentence(assertiveWFFEnabled()) and removalSentence(different(?ARGN, ?COL)) and removalSentence(not(assertedMoreSpecifically(genls(?ARGN, ?COL)))) and removalSentence(strongestAssertedSentence(argGenl(?PRED, ?N, ?COL))) .
\"urn:uuid:51d0795d-b98e-4399-bf24-f0496754a87b"[silk#strict] .
forwardSentence('interArgIsa3-5'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (3), ?IND_COL, (5), ?DEP_COL)) .
\"urn:uuid:5c6bde2d-6cae-4f7b-97b0-60dc3ebe9042"[silk#strict] .
forwardSentence(quotedIsa(?TERM, IndeterminateTerm)) :- removalSentence(hypotheticalTerm(?TERM)) .
\"urn:uuid:b118e3df-aa3b-403b-94cd-709eb8a21b1a"[silk#strict] .
forwardSentence(transitiveViaArgInverse(?PRED, quantitySubsumes, (2))) :- removalSentence(isa(?PRED, ArgGenlQuantityBinaryPredicate)) .
\"urn:uuid:f74ec5ad-f1c7-4e67-af2a-e7934b59f7f1"[silk#strict] .
forwardSentence(multiplicationUnits(?X, ?Y, ?UNITPRODUCTFN)) :- removalSentence(termOfUnit(?UNITPRODUCTFN, UnitProductFn(?X, ?Y))) .
\"urn:uuid:6c3a97ac-054d-4705-9b33-cd38444d624c"[silk#strict] .
forwardSentence(minQuantValue(?SCALAR, ?VALUE)) :- removalSentence(pointQuantValue(?SCALAR, ?VALUE)) .
\"urn:uuid:616a52b9-6524-4afc-ba6c-c721d89dac2b"[silk#strict] .
forwardSentence(completelyEnumerableCollection(?COL)) :- removalSentence(completeExtentEnumerableForValueInArg(isa, ?COL, (2))) .
\"urn:uuid:d6468750-5b3a-4dd2-834c-a36d03577121"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (2), ?IND_COL, (4), ?DEP_COL)) :- removalSentence('interArgIsa2-4'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:9d5d2f00-f109-4474-9b7a-2cd31ec6fc6c"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (6), ?COL)) :- removalSentence(arg6SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:5882e00a-b242-4b96-910d-8c32fb14217b"[silk#strict] .
forwardSentence(arityMin(?UNIT, (1))) :- removalSentence(isa(?UNIT, UnitOfMeasure)) .
\"urn:uuid:5826cf78-ecb1-4890-b56f-223131f1ef07"[silk#strict] .
forwardSentence(afterAdding(?SPEC_INVERSE, SubLSymbolFn(("PROPAGATE-INVERSE-TO-GENLS"^^_string)))) :- removalSentence(genlInverse(?SPEC_INVERSE, genls)) .
\"urn:uuid:905298d4-4c9c-4de4-b29e-814d576deb36"[silk#strict] .
forwardSentence('interArgIsa2-3'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (2), ?IND_COL, (3), ?DEP_COL)) .
\"urn:uuid:1586c36f-3dd9-40a6-989e-6e74a9d66e77"[silk#strict] .
forwardSentence(arg1Format(?SPECPRED, SingleEntry)) :- removalSentence(arg1Format(?GENLPRED, SingleEntry)) and removalSentence(different(?GENLPRED, ?SPECPRED)) and removalSentence(genlPreds(?SPECPRED, ?GENLPRED)) .
\"urn:uuid:287673d6-f1e7-49bb-808b-c98a8a119932"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (2), ?IND_COL, (3), ?DEP_COL)) :- removalSentence('interArgIsa2-3'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:d1dffa07-0889-4721-9097-7b40a90b6d90"[silk#strict] .
forwardSentence(arg1Genl(lessThan, ?ARGGENL)) :- removalSentence(arg2Genl(greaterThan, ?ARGGENL)) .
\"urn:uuid:fd4614b3-5d16-44eb-8906-1b703e298c89"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-NEGATIONPREDS"^^_string)))) :- removalSentence(different(negationPreds, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, negationPreds)) .
\"urn:uuid:a054fa9a-391f-4961-9c95-6e24feee2ec0"[silk#strict] .
forwardSentence(afterRemoving(?PRED, SubLSymbolFn(("INTER-ARG-ISA-AFTER-REMOVING"^^_string)))) :- removalSentence(isa(?PRED, InterArgIsaPredicate)) .
\"urn:uuid:ba7d154b-3f16-4798-9360-d9df388d9bd1"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (1), ?COL)) :- removalSentence(arg1QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:77f0755a-028b-4223-92e4-722eb5d93c1a"[silk#strict] .
forwardSentence(afterRemoving(?PRED, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) :- removalSentence(afterAdding(?PRED, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:1e2b4123-ac43-4441-a606-82b1281facba"[silk#strict] .
forwardSentence(arg2Isa(lessThanOrEqualTo, ?ARGISA)) :- removalSentence(arg1Isa(greaterThanOrEqualTo, ?ARGISA)) .
\"urn:uuid:282a6e55-ea7e-4885-bb52-3ddb559b75cd"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (1), ?IND_COL, (4), ?DEP_COL)) :- removalSentence('interArgIsa1-4'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:7d99ea65-9edd-4ee5-bb28-4dbece6fb956"[silk#strict] .
forwardSentence(argSometimesIsa(?RELN, (1), ?COL)) :- removalSentence(arg1SometimesIsa(?RELN, ?COL)) .
\"urn:uuid:16f14c19-1fbb-4d5a-a1b8-a4b7d20bbce0"[silk#strict] .
forwardSentence(arg3Genl(?RELN, ?COL)) :- removalSentence(argGenl(?RELN, (3), ?COL)) .
\"urn:uuid:9c587429-dbd2-4f07-9bcf-fbdb57cabaf0"[silk#strict] .
forwardSentence(overlappingExternalConcept(?RELN, ?SOURCE, ?STRING)) :- removalSentence(extConceptOverlapsColAndReln(?COL, ?RELN, ?SOURCE, ?STRING)) .
\"urn:uuid:5aac4bd7-d2a3-4c1a-abaa-35c3209a8afd"[silk#strict] .
forwardSentence(arg4QuotedIsa(?RELN, ?COL)) :- removalSentence(argQuotedIsa(?RELN, (4), ?COL)) .
\"urn:uuid:bf8e574e-77f9-4c31-9cc2-99db16751796"[silk#strict] .
forwardSentence('interArgIsa4-1'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (4), ?IND_COL, (1), ?DEP_COL)) .
\"urn:uuid:03e81d8b-880e-4ad8-bcb9-6818ecfd3261"[silk#strict] .
forwardSentence('interArgIsa1-4'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (1), ?IND_COL, (4), ?DEP_COL)) .
\"urn:uuid:fb941f18-0437-4441-90a0-fabe1613b91a"[silk#strict] .
forwardSentence(argQuotedIsa(?RELN, (6), ?COL)) :- removalSentence(arg6QuotedIsa(?RELN, ?COL)) .
\"urn:uuid:75ff1f9a-40cd-40a1-9b00-fe5ce32ca446"[silk#strict] .
forwardSentence(decontextualizedCollection(?SPEC)) :- removalSentence(genls(?SPEC, Quantifier)) .
\"urn:uuid:693841e8-df4d-49a9-8b41-c99369444b55"[silk#strict] .
forwardSentence(transitiveViaArg(?PRED, genls, (2))) :- removalSentence(isa(?PRED, ArgGenlBinaryPredicate)) .
\"urn:uuid:a6dc3372-67d2-4530-83c1-72a3590a12ac"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (3), ?IND_COL, (5), ?DEP_COL)) :- removalSentence('interArgIsa3-5'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:0d443afa-67f4-4469-9557-afc68f7bcd50"[silk#strict] .
forwardSentence(afterAdding(?SPEC_PRED, SubLSymbolFn(("PROPAGATE-TO-GENLS"^^_string)))) :- removalSentence(different(genls, ?SPEC_PRED)) and removalSentence(genlPreds(?SPEC_PRED, genls)) .
\"urn:uuid:0f4c45e6-21fb-43d2-99b0-7ae980232b26"[silk#strict] .
forwardSentence(arg2Genl(lessThan, ?ARGGENL)) :- removalSentence(arg1Genl(greaterThan, ?ARGGENL)) .
\"urn:uuid:e74da5a6-f6fc-40c7-88d6-ce314fe5794b"[silk#strict] .
forwardSentence(relationExistsAll(?PRED, ?COL_1, ?COL_2)) :- removalSentence(requiredArg2Pred(?COL_2, ?PRED)) and removalSentence('interArgIsa2-1'(?PRED, ?COL_2, ?COL_1)) .
\"urn:uuid:a80fd8da-f9f8-42e7-8894-18da2202f816"[silk#strict] .
forwardSentence(isa(?TERM, UnknownScalarInterval)) :- removalSentence(hypotheticalTerm(?TERM)) and removalSentence(isa(?TERM, ScalarInterval)) .
\"urn:uuid:a4d987a3-41b5-4d23-acde-367eb1653ed6"[silk#strict] .
forwardSentence(afterAdding(?PRED, SubLSymbolFn(("ADD-TVA-CACHE-VALUE"^^_string)))) :- removalSentence(afterRemoving(?PRED, SubLSymbolFn(("REMOVE-TVA-CACHE-VALUE"^^_string)))) .
\"urn:uuid:a4d84d9e-2ac9-467c-9a3c-4c67e00031c8"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (5), ?IND_COL, (2), ?DEP_COL)) :- removalSentence('interArgIsa5-2'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:4cfabfb6-80e8-4701-a652-5dc0e528e063"[silk#strict] .
forwardSentence(interArgIsa(?CONSTRAINED_PRED, (4), ?IND_COL, (5), ?DEP_COL)) :- removalSentence('interArgIsa4-5'(?CONSTRAINED_PRED, ?IND_COL, ?DEP_COL)) .
\"urn:uuid:658b6e8a-bb09-431b-bd43-8d3aea57bd2d"[silk#strict] .
forwardSentence('interArgIsa1-2'(?PRED, ?COL, ?COL)) :- removalSentence(isa(?PRED, SymmetricBinaryPredicate)) and removalSentence('interArgIsa2-1'(?PRED, ?COL, ?COL)) .
\"urn:uuid:5758cb21-93ae-4b4e-90d4-2ed2a46f3a67"[silk#strict] .
forwardSentence(silk#qualifies(CycAssertionFn((8824)))) :- removalSentence(admittedSentence(genls(?A, ?B))) .
\"urn:uuid:c67ff40e-93d2-4875-a5b0-f73e1471894b"[silk#strict] .
forwardSentence(argGenl(?RELN, (5), ?COL)) :- removalSentence(arg5Genl(?RELN, ?COL)) .
\"urn:uuid:0f920603-34b3-454f-acca-fc34b2623d5a"[silk#strict] .
forwardSentence(maxQuantValue(?SCALAR, ?VALUE)) :- removalSentence(pointQuantValue(?SCALAR, ?VALUE)) .
\"urn:uuid:d2dac89b-5133-4c06-b060-272f93c32915"[silk#strict] .
forwardSentence('interArgIsa5-4'(?PRED, ?IND_COL, ?DEP_COL)) :- removalSentence(interArgIsa(?PRED, (5), ?IND_COL, (4), ?DEP_COL)) .
\"urn:uuid:4618ad41-55c2-4916-bfd8-f8e8940b2a6c"[silk#strict] .
forwardSentence(arg1Genl(?INVERSE, ?COL)) :- removalSentence(elInverse(?PRED, ?INVERSE)) and removalSentence(arg2Genl(?PRED, ?COL)) .
\"urn:uuid:e1537b35-7f93-4359-9e93-363c320deffa"[silk#strict] .
istAsserted(BaseKB, salientAssertions(ReflexiveBinaryPredicate, CycAssertionFn((8733)))) .
\"urn:uuid:cf0eb4d5-6063-4a64-89f4-bf5a65e813be"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BaseKB, BaseKB)) .
\"urn:uuid:a6fada71-d72d-4364-a615-e97bdd274e5e"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(BookkeepingMt, BaseKB)) .
\"urn:uuid:d472fce2-74ab-4757-b278-5fe226a60cac"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLImplementationMt, BaseKB)) .
\"urn:uuid:b7818518-7d33-4c93-93d6-034ab34a6515"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(CoreCycLMt, BaseKB)) .
\"urn:uuid:56435084-d4b1-4675-a64e-9d84e4b45366"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt('CurrentWorldDataCollectorMt-NonHomocentric', BaseKB)) .
\"urn:uuid:9d7901e3-dcf5-46df-91ee-b4ddd22848ec"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(EnglishParaphraseMt, BaseKB)) .
\"urn:uuid:b420f90b-a3a2-4f2a-9778-705ec73a3bd4"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(LogicalTruthImplementationMt, BaseKB)) .
\"urn:uuid:b7204d27-d444-4195-a9df-d8bef1208399"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(LogicalTruthMt, BaseKB)) .
\"urn:uuid:75762cac-36a1-4653-b9d2-b4c34927950f"[silk#strict] .
istAsserted(UniversalVocabularyMt, genlMt(TemporaryEnglishParaphraseMt, BaseKB)) .
\"urn:uuid:8741959f-a6d8-4cc8-ac22-5661b2e86ec5"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argAndRestIsa, CycAssertionFn((8734)))) .
\"urn:uuid:f4a4162e-d2e1-43da-a3ed-0beffd578dd3"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argAndRestGenl, CycAssertionFn((8736)))) .
\"urn:uuid:7748a311-efa6-4996-8cde-c309e10837aa"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationAllExistsMin, CycAssertionFn((8737)))) .
\"urn:uuid:58dbf047-39dd-4ea5-8cb2-72afc52e9a3f"[silk#strict] .
istAsserted(BaseKB, salientAssertions(Thing, CycAssertionFn((8739)))) .
\"urn:uuid:b3f6e930-fa48-4a5f-9848-1dc88591b384"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa1-2', CycAssertionFn((8743)))) .
\"urn:uuid:a2264cc9-0f8c-438f-9568-134f3d489e1a"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationPreds, CycAssertionFn((8745)))) .
\"urn:uuid:be6c0a46-cdf5-45b2-9bef-e9f75e3cb614"[silk#strict] .
istAsserted(BaseKB, salientAssertions(AsymmetricBinaryPredicate, CycAssertionFn((8748)))) .
\"urn:uuid:f5f00357-ee31-434f-a62c-575e917555bd"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationAll, CycAssertionFn((8750)))) .
\"urn:uuid:e8cd2bbc-2d9b-4b7b-9559-5522f500e8c2"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8751)))) .
\"urn:uuid:f51fdc19-4e50-46e3-93b1-e03df30c8204"[silk#strict] .
istAsserted(BaseKB, salientAssertions(defaultReformulationDirectionInModeForPred, CycAssertionFn((8754)))) .
\"urn:uuid:fc885987-564b-431b-88f4-b5fbf10cc869"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationExistsInstanceFn, CycAssertionFn((8755)))) .
\"urn:uuid:ddea815e-1d77-45e6-82da-4abdec166ee7"[silk#strict] .
istAsserted(UniversalVocabularyMt, constraint(CycAssertionFn((8756)))) .
\"urn:uuid:59a68030-a2cc-4a52-b59a-2b716508f46a"[silk#strict] .
istAsserted(UniversalVocabularyMt, salientAssertions(sentenceTruth, CycAssertionFn((8757)))) .
\"urn:uuid:e90147d6-7abb-4e52-8d43-c84c3ef8df82"[silk#strict] .
istAsserted(BaseKB, salientAssertions(nearestGenlMt, CycAssertionFn((8758)))) .
\"urn:uuid:300fd43d-ab7b-44af-904b-c6bef4431ef5"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationInstanceExistsFn, CycAssertionFn((8759)))) .
\"urn:uuid:c8773017-a57d-4460-8d3a-045bf74a1ca4"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgGenl1-2', CycAssertionFn((8760)))) .
\"urn:uuid:5b64ead8-709e-4751-998a-f9532b726bcd"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationAllExistsCount, CycAssertionFn((8761)))) .
\"urn:uuid:25ccdbd2-67ad-4781-9130-a28ca3bf3a2f"[silk#strict] .
istAsserted(BaseKB, salientAssertions(UnitOfMeasure, CycAssertionFn((8762)))) .
\"urn:uuid:b776fdc6-100b-46d7-b102-8bc76326a601"[silk#strict] .
istAsserted(BaseKB, salientAssertions(PerFn, CycAssertionFn((8764)))) .
\"urn:uuid:d02067e4-e14e-4876-9fbb-3ef7f745a274"[silk#strict] .
istAsserted(BaseKB, salientAssertions(isa, CycAssertionFn((8765)))) .
\"urn:uuid:f51f9fe2-62ca-4c74-aaee-05add85d4547"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genls, CycAssertionFn((8765)))) .
\"urn:uuid:fd7dcb27-4e99-4a0c-9d12-6b56b6c8c7f4"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa3-1', CycAssertionFn((8768)))) .
\"urn:uuid:93e8bb2c-6348-4cd1-ac56-1fdcbe0cbde0"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8769)))) .
\"urn:uuid:afee8d86-709c-4f87-89b0-55eb3ee333cf"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationInverse, CycAssertionFn((8770)))) .
\"urn:uuid:d84b6b98-4f9f-46c1-9266-2c437e894dd1"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argQuotedIsa, CycAssertionFn((8771)))) .
\"urn:uuid:676315a6-4d21-452a-b648-1ca0d04359c6"[silk#strict] .
istAsserted(UniversalVocabularyMt, assertiveWFFRule(CycAssertionFn((8771)))) .
\"urn:uuid:379865aa-5259-4aad-a9b5-e88cf5aecb7d"[silk#strict] .
istAsserted(BaseKB, salientAssertions(coExtensional, CycAssertionFn((8773)))) .
\"urn:uuid:055108c0-0ef7-45b3-9964-4644d5a19301"[silk#strict] .
istAsserted(UniversalVocabularyMt, constraint(CycAssertionFn((8774)))) .
\"urn:uuid:bf1def0e-1b70-43d0-9a55-83c2c1780f79"[silk#strict] .
istAsserted(UniversalVocabularyMt, salientAssertions(backchainForbiddenWhenUnboundInArg, CycAssertionFn((9799)))) .
\"urn:uuid:14cd1e0f-acce-41a6-8f24-20425c3ef339"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationPreds, CycAssertionFn((8775)))) .
\"urn:uuid:dd220ace-eebf-4e7c-ba5d-100986396409"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationExistsMinAll, CycAssertionFn((8776)))) .
\"urn:uuid:ce88846f-8e89-4fcd-a5ae-c950e4c7dc56"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationInstanceExists, CycAssertionFn((8777)))) .
\"urn:uuid:3fc18203-d7e4-4a26-9e83-bf00e86c9344"[silk#strict] .
istAsserted(UniversalVocabularyMt, salientAssertions(CollectionDenotingFunction, CycAssertionFn((8778)))) .
\"urn:uuid:945e9f34-cc30-4ee3-938a-599d24a9e348"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlPreds, CycAssertionFn((8779)))) .
\"urn:uuid:c1370efa-33b5-49be-9e19-1df69d529c8f"[silk#strict] .
istAsserted(BaseKB, salientAssertions(disjointWith, CycAssertionFn((8782)))) .
\"urn:uuid:3a80ad51-f5dc-40ad-9268-e11c65fec7be"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlInverse, CycAssertionFn((8783)))) .
\"urn:uuid:be0c6a99-5d6e-4348-82c6-4b85eab18464"[silk#strict] .
istAsserted(BaseKB, salientAssertions(BinaryFunction, CycAssertionFn((8787)))) .
\"urn:uuid:06f26a32-4cb5-4d87-a990-1910e6db99e6"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa4-1', CycAssertionFn((8788)))) .
\"urn:uuid:75add20a-675e-4e4e-8fe3-791db745ce1d"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argGenl, CycAssertionFn((8790)))) .
\"urn:uuid:86156d65-dd67-4be5-a7da-0eec72f8f5ad"[silk#strict] .
istAsserted(UniversalVocabularyMt, assertiveWFFRule(CycAssertionFn((8790)))) .
\"urn:uuid:b6230afd-ec60-4406-90d4-09a8f8c8c888"[silk#strict] .
istAsserted(BaseKB, salientAssertions(quotedIsa, CycAssertionFn((8791)))) .
\"urn:uuid:0c963215-dda1-4c71-866e-61b1f9a2917c"[silk#strict] .
istAsserted(UniversalVocabularyMt, salientAssertions(sentenceTruth, CycAssertionFn((8792)))) .
\"urn:uuid:4a24d1f5-3fc0-4e1b-ac0d-ec3695749bb2"[silk#strict] .
istAsserted(BaseKB, salientAssertions(ReflexiveBinaryPredicate, CycAssertionFn((8793)))) .
\"urn:uuid:d58f4e5b-5345-49bf-b64e-738739cb5dbf"[silk#strict] .
istAsserted(BaseKB, salientAssertions(UnitOfMeasure, CycAssertionFn((8794)))) .
\"urn:uuid:9de22c7e-b33e-41a9-86b5-e87e41c0fbb7"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationInstanceAll, CycAssertionFn((8797)))) .
\"urn:uuid:d79071e9-722c-43e6-ae3c-1a9b0e29d961"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlPreds, CycAssertionFn((8802)))) .
\"urn:uuid:bb9b327d-6d04-4099-83aa-76615ef100ed"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8804)))) .
\"urn:uuid:143f6510-2b24-404a-b735-870a90d6a14a"[silk#strict] .
istAsserted(BaseKB, salientAssertions(AsymmetricBinaryPredicate, CycAssertionFn((8805)))) .
\"urn:uuid:e031633c-9d8a-420c-98da-a8c8c5ed72aa"[silk#strict] .
istAsserted(BaseKB, salientAssertions(TheEmptySet, CycAssertionFn((8807)))) .
\"urn:uuid:0b5849d4-5b06-4a07-8266-378e2b81523b"[silk#strict] .
istAsserted(BaseKB, salientAssertions(disjointWith, CycAssertionFn((8808)))) .
\"urn:uuid:59d588d6-1ed1-4859-9322-4a6b6f22fa19"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationInstanceExistsFn, CycAssertionFn((8809)))) .
\"urn:uuid:7d0a701c-b9f8-4e67-bbfe-8bb004ab166a"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa5-4', CycAssertionFn((8810)))) .
\"urn:uuid:c0b46b5b-97da-4cbf-936d-8845479b463b"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa5-3', CycAssertionFn((8811)))) .
\"urn:uuid:59e61553-11ac-4dd6-b1c4-f95928b9e654"[silk#strict] .
istAsserted(BaseKB, salientAssertions(performSubL, CycAssertionFn((8813)))) .
\"urn:uuid:ad6b5c9d-2d4d-4665-92ae-5c48c09be889"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationInstanceAll, CycAssertionFn((8815)))) .
\"urn:uuid:42fc4e51-0339-42c8-b110-45e1aaf43490"[silk#strict] .
istAsserted(BaseKB, salientAssertions(sentenceDesignationArgnum, CycAssertionFn((8816)))) .
\"urn:uuid:17a17e18-ec4b-481a-b251-9244b54f8b26"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationPreds, CycAssertionFn((8817)))) .
\"urn:uuid:5ea77fab-6944-465d-ae01-3d887a6418f9"[silk#strict] .
istAsserted(BaseKB, comment(CycAssertionFn((8820)), ("All microtheories currently must be known to be a microtheory in the #$BaseKB."^^_string))) .
\"urn:uuid:8c3e01a0-7bae-4cfd-bfea-b4074f386aae"[silk#strict] .
istAsserted(BaseKB, salientAssertions(coExtensional, CycAssertionFn((8822)))) .
\"urn:uuid:a725b430-21a5-4802-8d75-061018bc1fa3"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa2-3', CycAssertionFn((8823)))) .
\"urn:uuid:35c7010e-bfa2-489f-af30-2d8f970a9fd7"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlPreds, CycAssertionFn((8825)))) .
\"urn:uuid:388c5e04-edd9-4f73-9712-a8bfd61719d5"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa2-1', CycAssertionFn((8826)))) .
\"urn:uuid:2f30b880-f213-4290-a211-6ad0b20ae69b"[silk#strict] .
istAsserted(BaseKB, salientAssertions(microtheoryDesignationArgnum, CycAssertionFn((8827)))) .
\"urn:uuid:454de7ae-b79a-4938-a176-62be69879afe"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa4-3', CycAssertionFn((8829)))) .
\"urn:uuid:68df17c0-1262-4ba1-a210-9dc5c007cfb0"[silk#strict] .
istAsserted(BaseKB, salientAssertions(LogicalConnective, CycAssertionFn((8830)))) .
\"urn:uuid:58eafab8-880b-45b8-a163-bfad7be5e95b"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa3-2', CycAssertionFn((8831)))) .
\"urn:uuid:a3dd1161-ce8d-4afa-955b-d7801b20b141"[silk#strict] .
istAsserted(BaseKB, salientAssertions(different, CycAssertionFn((8832)))) .
\"urn:uuid:7b71d2d6-e63b-4a22-8f02-0f2795f3a8d9"[silk#strict] .
istAsserted(BaseKB, salientAssertions(equals, CycAssertionFn((8832)))) .
\"urn:uuid:0ccdb100-5417-434b-86c3-7521704b13bd"[silk#strict] .
istAsserted(BaseKB, salientAssertions(conceptuallyRelated, CycAssertionFn((8833)))) .
\"urn:uuid:1171136b-b83a-49e4-9227-f069c9628397"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationAllExistsMax, CycAssertionFn((8834)))) .
\"urn:uuid:3ca8ffb8-ef32-412b-b0d2-5f7e5343834e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(nearestGenls, CycAssertionFn((8836)))) .
\"urn:uuid:9a71e912-e78b-4f1d-a3c0-7e662c1c7384"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgResultGenl, CycAssertionFn((8838)))) .
\"urn:uuid:7d88aa84-9d2e-4343-82bc-550cebfbb640"[silk#strict] .
istAsserted(BaseKB, salientAssertions(conceptuallyRelated, CycAssertionFn((8839)))) .
\"urn:uuid:a74498b3-dbbe-41ca-86c6-080dc488519b"[silk#strict] .
istAsserted(BaseKB, salientAssertions(DisjointCollectionType, CycAssertionFn((8841)))) .
\"urn:uuid:88e153b2-bb83-4137-bb40-e708550d5cb2"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8843)))) .
\"urn:uuid:d0491741-7bdc-48c6-9405-989f313c6a2c"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa3-5', CycAssertionFn((8844)))) .
\"urn:uuid:24dcf41c-db82-4f34-9f77-be705ce192ed"[silk#strict] .
istAsserted(BaseKB, salientAssertions(SiblingDisjointCollectionType, CycAssertionFn((8845)))) .
\"urn:uuid:381eac59-be20-49b6-910f-9aab8fd7a88c"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8846)))) .
\"urn:uuid:c1464e21-5c70-4cf4-8dde-ab9ad5a71348"[silk#strict] .
istAsserted(BaseKB, exampleAssertions(constraint, CycAssertionFn((9851)))) .
\"urn:uuid:881c8436-ccb6-4505-8a32-10dea22c7a8e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(UnitProductFn, CycAssertionFn((8848)))) .
\"urn:uuid:236b6c60-0d4e-40af-99e0-9dcded29ee4b"[silk#strict] .
istAsserted(UniversalVocabularyMt, constraint(CycAssertionFn((8849)))) .
\"urn:uuid:42d1eb10-a1bf-4f7f-9369-f3aaa26bd819"[silk#strict] .
istAsserted(BaseKB, salientAssertions(trueSubL, CycAssertionFn((8850)))) .
\"urn:uuid:b5398569-a021-4adc-818f-1e74a52b4244"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgResultIsaReln, CycAssertionFn((8852)))) .
\"urn:uuid:2abf61cb-9d7c-49db-8065-548a8ec883e6"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8853)))) .
\"urn:uuid:a20ff65f-4641-4c32-bac8-19927d1084dd"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlPreds, CycAssertionFn((8855)))) .
\"urn:uuid:280f327d-747d-49fe-84e3-883b00164960"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationExistsAllFn, CycAssertionFn((8856)))) .
\"urn:uuid:2c87707d-c6aa-471e-91e7-39b29097910a"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationExistsCountAll, CycAssertionFn((8857)))) .
\"urn:uuid:e932fc6c-107a-438c-8a12-ccbfc0bf3f04"[silk#strict] .
istAsserted(BaseKB, salientAssertions(AsymmetricBinaryPredicate, CycAssertionFn((8858)))) .
\"urn:uuid:0db48c8d-4614-4539-8bf8-0174b6e05bc6"[silk#strict] .
istAsserted(BaseKB, salientAssertions(differentSymbols, CycAssertionFn((8860)))) .
\"urn:uuid:88dda52a-a8ea-4711-a05e-c6392243cb88"[silk#strict] .
istAsserted(BaseKB, salientAssertions(nearestGenlPreds, CycAssertionFn((8862)))) .
\"urn:uuid:39ff1b92-7ff2-424f-8c45-64588768a893"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationExistsInstanceFn, CycAssertionFn((8863)))) .
\"urn:uuid:1de08583-be60-4963-b0d4-b77bbe8bcc21"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgIsa, CycAssertionFn((8864)))) .
\"urn:uuid:e230d7fd-4865-400e-a99e-cca991660a14"[silk#strict] .
istAsserted(UniversalVocabularyMt, assertiveWFFRule(CycAssertionFn((8864)))) .
\"urn:uuid:54eeac5f-290d-4cb0-897d-1e7bdb3b241e"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa2-4', CycAssertionFn((8867)))) .
\"urn:uuid:9cd36c8c-f724-4af1-bbbb-7ee79700429b"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationAllInstance, CycAssertionFn((8868)))) .
\"urn:uuid:43e4255a-8bd7-4285-acd8-daaa200d2b9e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argIsa, CycAssertionFn((8869)))) .
\"urn:uuid:6e1613ed-1982-44df-8e94-234853c5b127"[silk#strict] .
istAsserted(UniversalVocabularyMt, assertiveWFFRule(CycAssertionFn((8869)))) .
\"urn:uuid:1e805ad3-29d9-4e6c-a044-c9f980c1eaad"[silk#strict] .
istAsserted(BaseKB, salientAssertions(genlPreds, CycAssertionFn((8870)))) .
\"urn:uuid:69f12f7d-1361-408b-951a-cd3f06352aac"[silk#strict] .
istAsserted(BaseKB, salientAssertions(argN, CycAssertionFn((8871)))) .
\"urn:uuid:608f80ac-e5c6-42cd-b689-13273904d827"[silk#strict] .
istAsserted(BaseKB, salientAssertions(QuintaryFunction, CycAssertionFn((8873)))) .
\"urn:uuid:440324e7-9a0c-4f8e-9961-7804fe36dc4a"[silk#strict] .
istAsserted(BaseKB, salientAssertions(QuasiQuote, CycAssertionFn((8874)))) .
\"urn:uuid:acd5a6af-320c-4465-af68-5877be6ea9c3"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationPreds, CycAssertionFn((8875)))) .
\"urn:uuid:7f9ffda2-2db0-43a2-90ae-9094ee963d3c"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationAllExistsFn, CycAssertionFn((8877)))) .
\"urn:uuid:c25fa61e-0f65-434f-8d33-8e89e64edd0e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(istAsserted, CycAssertionFn((8878)))) .
\"urn:uuid:ecadb67d-d0a0-4c5d-a695-ea2398f1b285"[silk#strict] .
istAsserted(BaseKB, salientAssertions(AntiTransitiveBinaryPredicate, CycAssertionFn((8880)))) .
\"urn:uuid:0c59e8b6-8f4c-416f-89b4-afbea55c406b"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa5-1', CycAssertionFn((8881)))) .
\"urn:uuid:25cd1fec-39ae-465a-838f-bde6f06431c3"[silk#strict] .
istAsserted(BaseKB, salientAssertions(holdsIn, CycAssertionFn((8884)))) .
\"urn:uuid:2cdcc6d2-9026-4710-8f54-ff05b90bf8dd"[silk#strict] .
istAsserted(BaseKB, salientAssertions(resultGenl, CycAssertionFn((8885)))) .
\"urn:uuid:8ccafa78-94ae-4a55-8f71-d0a78c0fe526"[silk#strict] .
istAsserted(BaseKB, _cancelCycAssertionFn((8888))) .
\"urn:uuid:6a3a73b8-4c95-43bd-873e-0592cf70aed9"[silk#strict] .
istAsserted(BaseKB, _cancelCycAssertionFn((8888))) .
\"urn:uuid:7689a8fe-e1c9-4523-a011-c2d6b8cfa6c4"[silk#strict] .
istAsserted(BaseKB, _cancelCycAssertionFn((8888))) .
\"urn:uuid:feace4b3-f275-4825-abe8-946057d25c61"[silk#strict] .
istAsserted(BaseKB, _cancelCycAssertionFn((8888))) .
\"urn:uuid:eb374c34-259f-451a-82af-7b0b5f141a6c"[silk#strict] .
istAsserted(BaseKB, salientAssertions(operatorFormulas, CycAssertionFn((8889)))) .
\"urn:uuid:9890c72c-cbe9-406f-9f22-259144a66c0b"[silk#strict] .
istAsserted(BaseKB, salientAssertions(sentenceImplies, CycAssertionFn((8890)))) .
\"urn:uuid:413102ba-b5ca-4b81-a161-4cd6f789bd34"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa1-4', CycAssertionFn((8891)))) .
\"urn:uuid:5b9be9d2-7910-494b-b912-fee25fb59a81"[silk#strict] .
istAsserted(BaseKB, salientAssertions(SymmetricBinaryPredicate, CycAssertionFn((8892)))) .
\"urn:uuid:bf0142a7-13de-43fb-919b-99c261b19013"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgDifferent, CycAssertionFn((8894)))) .
\"urn:uuid:564d790e-1cf1-4900-9cf6-e6fe475f9ce6"[silk#strict] .
istAsserted(BaseKB, salientAssertions(natFunction, CycAssertionFn((8895)))) .
\"urn:uuid:36d0afb7-6787-4d9f-82c0-c9e467146b4a"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa4-2', CycAssertionFn((8897)))) .
\"urn:uuid:7d014790-8dec-49a2-8d68-f92b0d23cfe1"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgResultGenlReln, CycAssertionFn((8898)))) .
\"urn:uuid:fd1dd188-18a9-4475-ba4c-fade19df6c37"[silk#strict] .
istAsserted(BaseKB, salientAssertions(interArgResultIsa, CycAssertionFn((8900)))) .
\"urn:uuid:c85721b7-bbf2-498c-9e64-2e6f52ffb080"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8901)))) .
\"urn:uuid:7d3e8108-ec84-428a-a318-6657fddf643f"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationExistsAllFn, CycAssertionFn((8903)))) .
\"urn:uuid:8663c68b-b4cd-4eaf-af6c-605fc78f62f7"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa5-2', CycAssertionFn((8905)))) .
\"urn:uuid:5dabe6ce-7480-48e9-b1bd-6234b03fe12d"[silk#strict] .
istAsserted(BaseKB, salientAssertions(quotedIsa, CycAssertionFn((8906)))) .
\"urn:uuid:1b02d794-e9b7-4c71-ab91-02f9bbbab994"[silk#strict] .
istAsserted(BaseKB, salientAssertions(LogicalConnective, CycAssertionFn((8907)))) .
\"urn:uuid:6ccb72b5-7542-42d0-b03e-8555711f1e2e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(AntiSymmetricBinaryPredicate, CycAssertionFn((8909)))) .
\"urn:uuid:4c02425a-6ad7-4af3-9576-ac0a7fb31586"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8909)))) .
\"urn:uuid:ad2b54fb-8219-480a-af14-a85a727f2089"[silk#strict] .
istAsserted(BaseKB, salientAssertions(TernaryRelation, CycAssertionFn((8910)))) .
\"urn:uuid:8ee3b1c8-0c48-4b31-a045-fa060dccdd5d"[silk#strict] .
istAsserted(BaseKB, salientAssertions(negationPreds, CycAssertionFn((8911)))) .
\"urn:uuid:82c14ac2-d53e-42f4-9730-b996fa0023b1"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa2-5', CycAssertionFn((8912)))) .
\"urn:uuid:b60f5011-b5e3-4de9-aaab-37eade167b5a"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa4-5', CycAssertionFn((8914)))) .
\"urn:uuid:7573f423-c740-4d9f-a2bb-fdd5ad4bf9b0"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationExistsInstance, CycAssertionFn((8916)))) .
\"urn:uuid:b82358cf-95da-4aa3-8b98-e74a3fd1fcc5"[silk#strict] .
istAsserted(BaseKB, salientAssertions(natArgumentsEqual, CycAssertionFn((8917)))) .
\"urn:uuid:8ac153d3-3255-4cb5-99a2-eb96a0f048ef"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8918)))) .
\"urn:uuid:801f5a29-3ae4-42be-a9d3-4188797fb10f"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa1-5', CycAssertionFn((8919)))) .
\"urn:uuid:418f98b9-0f25-47c8-8628-ef5c6a8ad208"[silk#strict] .
istAsserted(BaseKB, salientAssertions(natArgument, CycAssertionFn((8921)))) .
\"urn:uuid:42243ca4-e8d7-479c-9054-a62a9df05868"[silk#strict] .
istAsserted(BaseKB, salientAssertions(relationExistsMaxAll, CycAssertionFn((8923)))) .
\"urn:uuid:41fb30cf-35fb-4c24-9cc8-037536934a0e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(unitMultiplicationFactor, CycAssertionFn((8924)))) .
\"urn:uuid:b7a026bb-fee6-4dbb-97a1-60bedcb88655"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa3-4', CycAssertionFn((8925)))) .
\"urn:uuid:56bc3f1f-f123-4189-9418-b55a1a4762f6"[silk#strict] .
istAsserted(BaseKB, salientAssertions(QuaternaryRelation, CycAssertionFn((8927)))) .
\"urn:uuid:399aec39-ced2-4a4b-ac8c-69e63afa093e"[silk#strict] .
istAsserted(BaseKB, salientAssertions(RelationAllExistsFn, CycAssertionFn((8928)))) .
\"urn:uuid:05113df5-a4f8-41c7-b44d-186b49e59db7"[silk#strict] .
istAsserted(BaseKB, salientAssertions(CommutativeRelation, CycAssertionFn((8929)))) .
\"urn:uuid:ddf0ca34-b0ed-4c82-9bb2-f0aac8204bb9"[silk#strict] .
istAsserted(BaseKB, constraint(CycAssertionFn((8931)))) .
\"urn:uuid:fcf8abc3-e4bb-487b-ba14-ee9804f5cef2"[silk#strict] .
istAsserted(BaseKB, salientAssertions('interArgIsa1-3', CycAssertionFn((8935)))) .
\"urn:uuid:d59a550e-5e28-4de1-8a54-519530d668e1"[silk#strict] .
istAsserted(BaseKB, salientAssertions(resultIsa, CycAssertionFn((8936)))) .
\"urn:uuid:ee925f5a-be9e-4f18-8717-92d2fa792229"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertibleMt(EverythingPSC)) .
\"urn:uuid:9d4bc8c8-cb62-4a24-b152-bbc91f9cbb19"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertibleMt(InferencePSC)) .
\"urn:uuid:0e48decc-58cd-4d6e-92c9-3364689be913"[silk#strict] .
istAsserted(UniversalVocabularyMt, notAssertibleMt(LogicalTruthMt)) .

